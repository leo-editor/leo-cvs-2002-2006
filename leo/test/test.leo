<?xml version="1.0" encoding="UTF-8"?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="1998" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="54" left="228" height="835" width="981"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences allow_rich_text="0">
</preferences>
<find_panel_settings>
	<find_string></find_string>
	<change_string></change_string>
</find_panel_settings>
<vnodes>
<v t="T1"><vh>Distribution checklist</vh></v>
<v t="T2"><vh>Distribution scripts</vh></v>
<v t="T3"><vh>Notes</vh>
<v t="T4"><vh>Quote from Alex Martelli</vh></v>
<v t="T5"><vh>Singleton sequences</vh></v>
<v t="T6"><vh>How to get screenshots</vh></v>
</v>
<v t="T7"><vh>Previous tests</vh>
<v t="T8"><vh> Colorizer tests</vh>
<v t="T9"><vh>(colorizing bug)</vh>
<v t="T10"><vh>report</vh></v>
<v t="T11"><vh>@file c:\prog\test\Enroll SerNum.c</vh>
<v t="T12"><vh>&lt;&lt; Defines &gt;&gt;</vh></v>
<v t="T13"><vh>&lt;&lt; Head &gt;&gt;</vh></v>
</v>
</v>
<v t="T14"><vh>(Fixed syntax coloring bugs when language/comments change)</vh>
<v t="T15"><vh>Test</vh></v>
</v>
<v t="T16"><vh>(html syntax coloring)</vh>
<v t="T17"><vh>test</vh></v>
</v>
<v t="T18"><vh>(Incremental Syntax Coloring)</vh>
<v t="T19"><vh> Tests</vh>
<v t="T20"><vh> Long text for tests</vh></v>
<v t="T21"><vh>Dave Hein</vh>
<v t="T22"><vh>Test</vh></v>
</v>
<v t="T23"><vh>Dave Hein2</vh>
<v t="T24"><vh>NewHeadline</vh></v>
</v>
<v t="T25"><vh>Long test</vh></v>
<v t="T26"><vh>problems</vh></v>
</v>
</v>
<v t="T27"><vh>php test</vh></v>
<v t="T28"><vh>tests</vh></v>
<v t="T29"><vh>wiki tests</vh>
<v t="T30"><vh>test 1</vh></v>
<v t="T31"><vh>test 2</vh></v>
<v t="T32"><vh>test 3</vh></v>
</v>
</v>
<v t="T33"><vh>@encoding test</vh>
<v t="T34"><vh>@file c:\prog\test\encodingTest.txt</vh>
<v t="T35"><vh>Umlaut in headline ë</vh></v>
</v>
</v>
<v t="T36"><vh>@file c:\prog\test\tab_test.txt</vh></v>
<v t="T37"><vh>@image Icons/Leoapp.GIF</vh></v>
<v t="T38"><vh>@url file:///C:/prog/test/sortText.leo</vh></v>
<v t="T39"><vh>Actionscript keywords</vh></v>
<v t="T40"><vh>alloc tests</vh></v>
<v t="T41"><vh>Assignment tests</vh></v>
<v t="T42"><vh>clone tests</vh>
<v t="T43" a="C"><vh>A</vh>
<v t="T44" a="C"><vh>B</vh>
<v t="T45" a="C"><vh>C</vh>
<v t="T46"><vh>D</vh></v>
</v>
<v t="T45" a="C"><vh>C</vh>
<v t="T46"><vh>D</vh></v>
</v>
</v>
<v t="T44" a="C"><vh>B</vh>
<v t="T45" a="C"><vh>C</vh>
<v t="T46"><vh>D</vh></v>
</v>
<v t="T45" a="C"><vh>C</vh>
<v t="T46"><vh>D</vh></v>
</v>
</v>
</v>
<v t="T47" a="C"><vh>New root</vh>
<v t="T43" a="C"><vh>A</vh>
<v t="T44" a="C"><vh>B</vh>
<v t="T45" a="C"><vh>C</vh>
<v t="T46"><vh>D</vh></v>
</v>
<v t="T45" a="C"><vh>C</vh>
<v t="T46"><vh>D</vh></v>
</v>
</v>
<v t="T44" a="C"><vh>B</vh>
<v t="T45" a="C"><vh>C</vh>
<v t="T46"><vh>D</vh></v>
</v>
<v t="T45" a="C"><vh>C</vh>
<v t="T46"><vh>D</vh></v>
</v>
</v>
</v>
</v>
<v t="T47" a="C"><vh>New root</vh>
<v t="T43" a="C"><vh>A</vh>
<v t="T44" a="C"><vh>B</vh>
<v t="T45" a="C"><vh>C</vh>
<v t="T46"><vh>D</vh></v>
</v>
<v t="T45" a="C"><vh>C</vh>
<v t="T46"><vh>D</vh></v>
</v>
</v>
<v t="T44" a="C"><vh>B</vh>
<v t="T45" a="C"><vh>C</vh>
<v t="T46"><vh>D</vh></v>
</v>
<v t="T45" a="C"><vh>C</vh>
<v t="T46"><vh>D</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="T48"><vh>Copy/Clones test</vh>
<v t="T49" a="C"><vh>a Å</vh>
<v t="T50" a="C"><vh>b</vh>
<v t="T51"><vh>c</vh></v>
</v>
<v t="T50" a="C"><vh>b</vh>
<v t="T51"><vh>c</vh></v>
</v>
</v>
<v t="T49" a="C"><vh>a Å</vh>
<v t="T50" a="C"><vh>b</vh>
<v t="T51"><vh>c</vh></v>
</v>
<v t="T50" a="C"><vh>b</vh>
<v t="T51"><vh>c</vh></v>
</v>
</v>
</v>
<v t="T52"><vh>Dialog tests</vh>
<v t="T53"><vh>Test askOk</vh></v>
<v t="T54"><vh>Test aboutLeo</vh></v>
<v t="T55"><vh>Test askLeoID</vh></v>
<v t="T56"><vh>Test askOkCancelNumber</vh></v>
<v t="T57"><vh>Test askOkCancel</vh></v>
<v t="T58"><vh>Test askYesNo</vh></v>
<v t="T59"><vh>Test askYesNoCancel</vh></v>
</v>
<v t="T60"><vh>Go to line number test</vh>
<v t="T61"><vh>@file c:\prog\test\goToLineNumber.txt</vh>
<v t="T62"><vh>__init__</vh></v>
<v t="T63"><vh>__init__</vh></v>
</v>
</v>
<v t="T64"><vh>Icon bar</vh>
<v t="T65"><vh>add some buttons</vh></v>
<v t="T66"><vh>add all gif files</vh></v>
<v t="T67"><vh>clear</vh></v>
<v t="T68"><vh>hide</vh></v>
<v t="T69"><vh>configure</vh></v>
<v t="T70"><vh>show (puts at bottom)</vh></v>
</v>
<v t="T71"><vh>Ignore</vh>
<v t="T72"><vh>@lineending and @encoding tests</vh></v>
<v t="T73"><vh>@file test.py</vh>
<v t="T74"><vh>Outer</vh>
<v t="T75"><vh>A2</vh></v>
<v t="T76"><vh>B</vh></v>
</v>
</v>
<v t="T77"><vh>Check clones links</vh></v>
</v>
<v t="T78"><vh>Leo Unit Tests</vh></v>
<v t="T79"><vh>Line break problems</vh>
<v t="T80"><vh>Error</vh>
<v t="T81"><vh>@nosentinelsfile c:\prog\test\lineBreakError.txt</vh>
<v t="T82"><vh>functions</vh>
<v t="T83"><vh>objects</vh>
<v t="T84" a="M"><vh>class shape</vh>
<v t="T85"><vh>&lt;&lt; class shape declarations &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
</v>
</v>
<v t="T86"><vh>New import</vh></v>
<v t="T87"><vh>Overriding core classes</vh></v>
<v t="T88"><vh>Read @file nodes</vh>
<v t="T89"><vh>@file c:\prog\test\atFileTest.txt</vh>
<v t="T90"><vh>Node 1</vh></v>
</v>
</v>
<v t="T91"><vh>Rebol keywords (- ? ~ ! recognized as a part of a keyword)</vh></v>
<v t="T92"><vh>reformatParagraph test</vh></v>
<v t="T93"><vh>Spell test </vh>
<v t="T94"><vh>node two</vh></v>
<v t="T95"><vh>node two no misspellings</vh></v>
</v>
<v t="T96"><vh>Status line</vh>
<v t="T97"><vh>put message</vh></v>
<v t="T98"><vh>clear</vh></v>
<v t="T99"><vh>tab width tests</vh>
<v t="T100"><vh>2</vh></v>
<v t="T101"><vh>4</vh></v>
<v t="T102"><vh>6</vh></v>
<v t="T103"><vh>8</vh></v>
</v>
</v>
<v t="T104"><vh>Test of recent sections &amp; clones</vh>
<v t="T105" a="C"><vh>&lt;&lt; section a &gt;&gt;</vh></v>
<v t="T106" a="C"><vh>hyper link test</vh>
<v t="T105" a="C"><vh>&lt;&lt; section a &gt;&gt;</vh></v>
<v t="T107"><vh>&lt;&lt; section b &gt;&gt;</vh></v>
</v>
<v t="T106" a="C"><vh>hyper link test</vh>
<v t="T105" a="C"><vh>&lt;&lt; section a &gt;&gt;</vh></v>
<v t="T107"><vh>&lt;&lt; section b &gt;&gt;</vh></v>
</v>
</v>
<v t="T108"><vh>timeit (in 2.3b1)</vh></v>
<v t="T109"><vh>Trailing newline in body</vh></v>
<v t="T110"><vh>Undo replace tests</vh>
<v t="T111" a="CE"><vh>B</vh>
<v t="T112"><vh>C</vh></v>
<v t="T113"><vh>C2</vh></v>
</v>
<v t="T114" a="CE"><vh>A</vh>
<v t="T111" a="CE"><vh>B</vh>
<v t="T112"><vh>C</vh></v>
<v t="T113"><vh>C2</vh></v>
</v>
</v>
<v t="T114" a="CE"><vh>A</vh>
<v t="T111" a="CE"><vh>B</vh>
<v t="T112"><vh>C</vh></v>
<v t="T113"><vh>C2</vh></v>
</v>
</v>
</v>
<v t="T115"><vh>Undo typing tests</vh></v>
<v t="T116"><vh>Use xml.sax</vh></v>
<v t="T117"><vh>v.__repr__ and v.__str___</vh></v>
<v t="T118"><vh>Write Missing @file nodes test</vh>
<v t="T119"><vh>@file ../test/missing_test.txt</vh></v>
</v>
<v t="T120"><vh>wx Leo</vh></v>
</v>
<v t="T121" a="E"><vh>wrap test</vh>
<v t="T122" a="E"><vh>@file c:\prog\test\wrap_test.txt</vh>
<v t="T123"><vh>wrap node</vh></v>
<v t="T124"><vh>nowrap node</vh></v>
</v>
</v>
<v t="T125" a="E" tnodeList="125"><vh>4.0 Test files</vh>
<v t="T126" a="E"><vh>Script to compare 3.x and 4.x derived files</vh></v>
<v t="T127" a="EV"><vh>Test Files...</vh>
<v t="T128" a="C"><vh>&lt;&lt; ref &gt;&gt; (cloned)</vh></v>
<v t="T129" tnodeList="129,128,130,132,133,135,128"><vh>@file c:\prog\test\gnxText.txt</vh>
<v t="T128" a="C"><vh>&lt;&lt; ref &gt;&gt; (cloned)</vh></v>
<v t="T130"><vh>&lt;&lt; ref2 &gt;&gt;</vh></v>
<v t="T131" a="E"><vh>Organizer node</vh>
<v t="T132" a="E"><vh>node 1</vh>
<v t="T133"><vh>&lt;&lt; indented ref &gt;&gt;</vh></v>
</v>
<v t="T134"><vh>empty node</vh></v>
</v>
<v t="T135"><vh>Node 2</vh></v>
</v>
<v t="T136" tnodeList="136,137,138,139,140,141,142,143,144,145"><vh>@file c:\prog\test\leo.py </vh>
<v t="T137"><vh>&lt;&lt; Import pychecker &gt;&gt;</vh></v>
<v t="T138"><vh>runMainLoop</vh></v>
<v t="T139" a="E"><vh>run &amp; allies</vh>
<v t="T140"><vh>createTkRoot</vh>
<v t="T141"><vh>&lt;&lt; set the icon image &gt;&gt;</vh></v>
</v>
<v t="T142"><vh>createAppObject</vh></v>
<v t="T143"><vh>createFrame (leo.py)</vh></v>
<v t="T144"><vh>initSherlock</vh></v>
</v>
<v t="T145"><vh>profile</vh></v>
</v>
<v t="T146" tnodeList="146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168"><vh>@file c:\prog\test\leoApp.py</vh>
<v t="T147"><vh>app.__init__</vh>
<v t="T148"><vh>&lt;&lt; define global constants &gt;&gt;</vh></v>
<v t="T149"><vh>&lt;&lt; define global data structures &gt;&gt;</vh></v>
</v>
<v t="T150"><vh>app.closeLeoWindow</vh></v>
<v t="T151"><vh>app.destroyAllGlobalWindows</vh></v>
<v t="T152"><vh>app.destroyAllOpenWithFiles</vh></v>
<v t="T153"><vh>app.destroyAllWindowObjects</vh>
<v t="T154"><vh>&lt;&lt; clear all vnodes and tnodes in the tree&gt;&gt;</vh></v>
</v>
<v t="T155"><vh>app.destroyOpenWithFilesForFrame</vh></v>
<v t="T156"><vh>app.destroyOpenWithFileWithDict</vh></v>
<v t="T157"><vh>app.destroyWindow</vh></v>
<v t="T158"><vh>app.finishCreate</vh>
<v t="T159"><vh>&lt;&lt; return false if not v2.1 or above &gt;&gt;</vh></v>
<v t="T160"><vh>&lt;&lt; set loadDir &gt;&gt;</vh></v>
<v t="T161"><vh>&lt;&lt; set the default Leo icon &gt;&gt;</vh>
<v t="T162"><vh>&lt;&lt; set v834 if version is 8.3.4 or greater &gt;&gt;</vh></v>
</v>
<v t="T163"><vh>&lt;&lt; set app.tkEncoding &gt;&gt;</vh></v>
</v>
<v t="T164"><vh>app.finishQuit</vh></v>
<v t="T165"><vh>app.get/setRealMenuName &amp; setRealMenuNamesFromTable</vh></v>
<v t="T166"><vh>app.onQuit</vh></v>
<v t="T167"><vh>app.setLog, lockLog, unlocklog</vh></v>
<v t="T168"><vh>app.writeWaitingLog</vh></v>
</v>
<v t="T169" tnodeList="169,170,172,173,175,176,177,178,179,180,181,182,180,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,210,211,212,213,216,218,219,220,221,222,223,214,215,217,224,225,228,229,227,226,230,231,209,233,234,235,236,237,238,239,240,241,242,243,245,246,247,248,250,251,252,257,258,259,254,253,255,256,260,261,262,263,264,265,266,267,268,271,272,273,274,275,276,277,278,279,280,281,282,283,273,284,276,285,286,287,288,289,290,291,292,293,294,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,318,316,317,319,320,321,322,323,324,325,326,327,328,330,331,332,333,334,335"><vh>@file c:\prog\test\leoAtFile.py </vh>
<v t="T170"><vh>&lt;&lt; atFile constants &gt;&gt;</vh></v>
<v t="T171"><vh>Birth &amp; death</vh>
<v t="T172" a="E"><vh>atFile.__init__&amp; initIvars</vh>
<v t="T173"><vh>&lt;&lt; init atFile ivars &gt;&gt;</vh></v>
</v>
</v>
<v t="T174" a="E"><vh>Top level</vh>
<v t="T175"><vh>atFile.readAll</vh></v>
<v t="T176" a="E"><vh>atFile.read</vh>
<v t="T177"><vh>&lt;&lt; set self.targetFileName &gt;&gt;</vh></v>
<v t="T178"><vh>&lt;&lt; open file &gt;&gt;</vh>
<v t="T179"><vh>&lt;&lt; warn on read-only file &gt;&gt;</vh></v>
</v>
<v t="T180"><vh>&lt;&lt; Scan the file buffer  &gt;&gt;</vh></v>
<v t="T181"><vh>&lt;&lt; Bump mStructureErrors if any vnodes are unvisited &gt;&gt;</vh></v>
<v t="T182"><vh>&lt;&lt; quickly delete root's tree and body text &gt;&gt;</vh></v>
</v>
</v>
<v t="T183"><vh>Reading</vh>
<v t="T184"><vh>completeFirstDirectives (Dave Hein)</vh></v>
<v t="T185"><vh>completeLastDirectives (Dave Hein)</vh></v>
<v t="T186"><vh>createNthChild (3.0)</vh>
<v t="T187"><vh>&lt;&lt; check the headlines &gt;&gt;</vh></v>
</v>
<v t="T188"><vh>handleLinesFollowingSentinel</vh>
<v t="T189"><vh>&lt;&lt; remove the comment delims from s &gt;&gt;</vh></v>
</v>
<v t="T190"><vh>readLine</vh></v>
<v t="T191"><vh>readLinesToNextSentinel</vh></v>
<v t="T192"><vh>scanDoc</vh>
<v t="T193"><vh>&lt;&lt; Skip the opening sentinel &gt;&gt;</vh></v>
<v t="T194"><vh>&lt;&lt; Skip an opening block delim &gt;&gt;</vh></v>
<v t="T195"><vh>&lt;&lt; set kind, nextLine &gt;&gt;</vh></v>
<v t="T196"><vh>&lt;&lt; Skip the leading stuff &gt;&gt;</vh></v>
<v t="T197"><vh>&lt;&lt; Append s to out &gt;&gt;</vh></v>
<v t="T198"><vh>&lt;&lt; Remove a closing block delim from out &gt;&gt;</vh></v>
</v>
<v t="T199"><vh>scanHeader</vh>
<v t="T200"><vh>&lt;&lt; skip any non @+leo lines &gt;&gt;</vh></v>
<v t="T201"><vh>&lt;&lt; make sure we have @+leo &gt;&gt;</vh></v>
<v t="T202"><vh>&lt;&lt; read optional version param &gt;&gt;</vh></v>
<v t="T203"><vh>&lt;&lt; read optional encoding param &gt;&gt;</vh></v>
<v t="T204"><vh>&lt;&lt; set the closing comment delim &gt;&gt;</vh></v>
</v>
<v t="T205"><vh>scanText</vh>
<v t="T206"><vh>&lt;&lt; put the next line into s &gt;&gt;</vh></v>
<v t="T207"><vh>&lt;&lt; set kind, nextKind &gt;&gt;</vh></v>
<v t="T208"><vh>&lt;&lt; Set lineIndent, linep and leading_ws &gt;&gt;</vh></v>
<v t="T209"><vh>&lt;&lt; handle unexpected end of text &gt;&gt;</vh></v>
<v t="T210"><vh>&lt;&lt; handle the line in s &gt;&gt;</vh>
<v t="T211"><vh>&lt;&lt; append non-sentinel line &gt;&gt;</vh></v>
<v t="T212"><vh>&lt;&lt; handle common sentinels &gt;&gt;</vh>
<v t="T213"><vh>&lt;&lt; handle an ending sentinel &gt;&gt;</vh></v>
<v t="T214"><vh>&lt;&lt; scan old ref &gt;&gt; (3.0)</vh></v>
<v t="T215"><vh>&lt;&lt; scan @+at &gt;&gt;</vh></v>
<v t="T216"><vh>&lt;&lt; scan @+body &gt;&gt;</vh></v>
<v t="T217"><vh>&lt;&lt; scan @+doc &gt;&gt;</vh></v>
<v t="T218"><vh>&lt;&lt; scan @+node &gt;&gt;</vh>
<v t="T219"><vh>&lt;&lt; Set childIndex &gt;&gt;</vh></v>
<v t="T220"><vh>&lt;&lt; Set cloneIndex &gt;&gt;</vh></v>
<v t="T221"><vh>&lt;&lt; Set headline and ref &gt;&gt;</vh></v>
<v t="T222"><vh>&lt;&lt; Check the filename in the sentinel &gt;&gt;</vh></v>
<v t="T223"><vh>&lt;&lt; look for sentinels that may follow a reference &gt;&gt;</vh></v>
</v>
<v t="T224"><vh>&lt;&lt; scan @+others &gt;&gt;</vh></v>
</v>
<v t="T225"><vh>&lt;&lt; handle rare sentinels &gt;&gt;</vh>
<v t="T226"><vh>&lt;&lt; scan @+leo &gt;&gt;</vh></v>
<v t="T227"><vh>&lt;&lt; scan @@ &gt;&gt;</vh></v>
<v t="T228"><vh>&lt;&lt; scan @comment &gt;&gt;</vh></v>
<v t="T229"><vh>&lt;&lt; scan @delims &gt;&gt;</vh></v>
<v t="T230"><vh>&lt;&lt; scan @verbatim &gt;&gt;</vh></v>
</v>
<v t="T231"><vh>&lt;&lt; warn about unknown sentinel &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T232"><vh>Sentinels</vh>
<v t="T233"><vh>nodeSentinelText</vh>
<v t="T234"><vh>&lt;&lt; remove comment delims from h if necessary &gt;&gt;</vh></v>
</v>
<v t="T235"><vh>putCloseNodeSentinel</vh></v>
<v t="T236"><vh>putCloseSentinels</vh></v>
<v t="T237"><vh>putOpenLeoSentinel</vh></v>
<v t="T238"><vh>putOpenNodeSentinel</vh></v>
<v t="T239"><vh>putOpenSentinels</vh></v>
<v t="T240"><vh>putSentinel (applies cweb hack)</vh></v>
<v t="T241"><vh>sentinelKind</vh></v>
<v t="T242"><vh>sentinelName</vh></v>
<v t="T243"><vh>skipSentinelStart</vh></v>
</v>
<v t="T244"><vh>Testing</vh>
<v t="T245"><vh>scanAll</vh></v>
<v t="T246"><vh>scanFile</vh>
<v t="T247"><vh>&lt;&lt; open file &gt;&gt;</vh></v>
<v t="T248"><vh>&lt;&lt; Scan the file buffer  &gt;&gt;</vh></v>
</v>
</v>
<v t="T249"><vh>Utilites</vh>
<v t="T250"><vh>atFile.scanAllDirectives (calls writeError on errors)</vh>
<v t="T251"><vh>&lt;&lt; Set ivars &gt;&gt;</vh></v>
<v t="T252"><vh>&lt;&lt; Set path from @file node &gt;&gt;</vh></v>
<v t="T253"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="T254"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="T255"><vh>&lt;&lt; Test for @header and @noheader &gt;&gt;</vh></v>
<v t="T256"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="T257"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="T258"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
<v t="T259"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
<v t="T260"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="T261"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="T262"><vh>&lt;&lt; Set current directory &gt;&gt;</vh></v>
<v t="T263"><vh>&lt;&lt; Set comment Strings from delims &gt;&gt;</vh></v>
</v>
<v t="T264"><vh>directiveKind</vh></v>
<v t="T265"><vh>error</vh></v>
<v t="T266"><vh>readError</vh></v>
<v t="T267"><vh>skipIndent</vh></v>
<v t="T268"><vh>writeError</vh></v>
</v>
<v t="T269"><vh>Writing</vh>
<v t="T270"><vh>Top level</vh>
<v t="T271"><vh>atFile.rawWrite</vh>
<v t="T272"><vh>&lt;&lt; write root's tree &gt;&gt;</vh>
<v t="T273" a="C"><vh>&lt;&lt; put all @first lines in root &gt;&gt;</vh></v>
<v t="T274"><vh>&lt;&lt; put optional @comment sentinel lines &gt;&gt;</vh></v>
<v t="T275"><vh>&lt;&lt; Write v's node &gt;&gt;</vh></v>
<v t="T276" a="C"><vh>&lt;&lt; put all @last lines in root &gt;&gt;</vh></v>
</v>
</v>
<v t="T277"><vh>atFile.silentWrite</vh>
<v t="T278"><vh>&lt;&lt; Write v's headline if it starts with @@ &gt;&gt;</vh></v>
<v t="T279"><vh>&lt;&lt; Write v's body &gt;&gt;</vh></v>
</v>
<v t="T280"><vh>atFile.write</vh>
<v t="T281"><vh>&lt;&lt; initialize &gt;&gt;</vh></v>
<v t="T282"><vh>&lt;&lt; open the file; return on error &gt;&gt;</vh></v>
<v t="T283"><vh>&lt;&lt; write then entire @file tree &gt;&gt;</vh>
<v t="T273" a="C"><vh>&lt;&lt; put all @first lines in root &gt;&gt;</vh></v>
<v t="T284"><vh>&lt;&lt; write the derived file&gt;&gt;</vh></v>
<v t="T276" a="C"><vh>&lt;&lt; put all @last lines in root &gt;&gt;</vh></v>
</v>
<v t="T285"><vh>&lt;&lt; Warn about @ignored and orphans  &gt;&gt;</vh></v>
<v t="T286"><vh>&lt;&lt; finish writing &gt;&gt;</vh></v>
</v>
<v t="T287"><vh>atFile.writeAll</vh>
<v t="T288"><vh>&lt;&lt; Clear all orphan bits &gt;&gt;</vh></v>
<v t="T289"><vh>&lt;&lt; handle v's tree &gt;&gt;</vh></v>
<v t="T290"><vh>&lt;&lt; say the command is finished &gt;&gt;</vh></v>
</v>
<v t="T291"><vh>atFile.writeMissing</vh>
<v t="T292"><vh>&lt;&lt; set missing if the file does not exist &gt;&gt;</vh></v>
<v t="T293"><vh>&lt;&lt; create self.outputFile &gt;&gt;</vh></v>
<v t="T294"><vh>&lt;&lt; write the @file node &gt;&gt;</vh></v>
</v>
<v t="T295"><vh>Top level write helpers</vh>
<v t="T296"><vh>atFile.closeWriteFile</vh></v>
<v t="T297"><vh>atFile.handleWriteException</vh></v>
<v t="T298"><vh>atFile.openWriteFile</vh></v>
<v t="T299"><vh>atFile.putInitialComment</vh></v>
<v t="T300"><vh>atFile.replaceTargetFileIfDifferent</vh>
<v t="T301"><vh>&lt;&lt; delete the output file &gt;&gt;</vh></v>
<v t="T302"><vh>&lt;&lt; replace the target file with the output file &gt;&gt;</vh></v>
<v t="T303"><vh>&lt;&lt; rename the output file to be the target file &gt;&gt;</vh></v>
</v>
<v t="T304"><vh>atFile.outputStringWithLineEndings</vh></v>
</v>
</v>
<v t="T305"><vh>putBodyPart</vh>
<v t="T306"><vh>&lt;&lt; put code/doc parts and sentinels &gt;&gt;</vh>
<v t="T307"><vh>&lt;&lt; initialize lookingForFirst/Last &amp; initialLastDirective &gt;&gt;</vh></v>
<v t="T308"><vh>&lt;&lt; set lookingForFirst/Last &amp; initialLastDirective &gt;&gt;</vh></v>
<v t="T309"><vh>&lt;&lt; handle misc directives &gt;&gt;</vh></v>
<v t="T310"><vh>&lt;&lt; put out the last directives, if any &gt;&gt;</vh></v>
</v>
</v>
<v t="T311"><vh>putDoc</vh></v>
<v t="T312"><vh>putDocPart</vh>
<v t="T313"><vh>&lt;&lt; copy words, splitting the line if needed &gt;&gt;</vh></v>
</v>
<v t="T314"><vh>putCodePart &amp; allies</vh>
<v t="T315"><vh>&lt;&lt; handle the start of a line &gt;&gt;</vh>
<v t="T316"><vh>&lt;&lt; handle @others &gt;&gt;</vh></v>
<v t="T317"><vh>&lt;&lt; handle @raw &gt;&gt;</vh></v>
<v t="T318"><vh>&lt;&lt; handle @end_raw &gt;&gt;</vh></v>
<v t="T319"><vh>&lt;&lt; put @verbatim sentinel if necessary &gt;&gt;</vh></v>
</v>
<v t="T320"><vh>&lt;&lt; put the line &gt;&gt;</vh>
<v t="T321"><vh>&lt;&lt; put possible section reference &gt;&gt;</vh></v>
</v>
<v t="T322"><vh>inAtOthers</vh></v>
<v t="T323"><vh>isSectionName</vh></v>
<v t="T324"><vh>putAtOthers</vh></v>
<v t="T325"><vh>putAtOthersChild</vh></v>
<v t="T326"><vh>putRef</vh>
<v t="T327"><vh>&lt;&lt; Generate the expansion of the reference &gt;&gt;</vh>
<v t="T328"><vh>&lt;&lt; Add @verbatimAfterRef sentinel if required &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T329"><vh>Utils</vh>
<v t="T330"><vh>putBuffered</vh></v>
<v t="T331"><vh>os, onl, etc. (leoAtFile)</vh></v>
<v t="T332"><vh>putDirective  (handles @delims)</vh>
<v t="T333"><vh>&lt;&lt; handle @delims &gt;&gt;</vh></v>
</v>
<v t="T334"><vh>putEmptyDirective (Dave Hein)</vh></v>
<v t="T335"><vh>putIndent</vh></v>
</v>
</v>
</v>
<v t="T336" tnodeList="336,337,338,339"><vh>@file c:\prog\test\leoColor.py</vh>
<v t="T337"><vh>&lt;&lt; define leo keywords &gt;&gt;</vh></v>
<v t="T338"><vh>&lt;&lt; define colorizer constants &gt;&gt;</vh></v>
<v t="T339"><vh>&lt;&lt; define color panel data &gt;&gt;</vh></v>
<v t="T340"><vh>class leoColorPanel</vh>
<v t="T341"><vh>colorPanel.__init__</vh></v>
<v t="T342"><vh>run</vh>
<v t="T343"><vh>&lt;&lt; create color panel &gt;&gt;</vh></v>
</v>
<v t="T344"><vh>showColorPicker</vh></v>
<v t="T345"><vh>showColorName</vh></v>
<v t="T346"><vh>colorPanel.onOk, onCancel, onRevert</vh></v>
<v t="T347"><vh>update</vh></v>
</v>
<v t="T348"><vh>class leoColorNamePanel</vh>
<v t="T349"><vh>namePanel.__init__</vh></v>
<v t="T350"><vh>getSelection</vh></v>
<v t="T351"><vh>run</vh>
<v t="T352"><vh>&lt;&lt; create color name panel &gt;&gt;</vh></v>
</v>
<v t="T353"><vh>onOk, onCancel, onRevert, OnApply</vh></v>
<v t="T354"><vh>select</vh></v>
</v>
<v t="T355"><vh>class colorizer</vh>
<v t="T356"><vh>&lt;&lt; define colorizer keywords &gt;&gt;</vh>
<v t="T357"><vh>&lt;&lt; actionscript keywords &gt;&gt;</vh></v>
<v t="T358"><vh>&lt;&lt; c keywords &gt;&gt;</vh></v>
<v t="T359"><vh>&lt;&lt; html keywords &gt;&gt;</vh></v>
<v t="T360"><vh>&lt;&lt; java keywords &gt;&gt;</vh></v>
<v t="T361"><vh>&lt;&lt; latex keywords &gt;&gt;</vh></v>
<v t="T362"><vh>&lt;&lt; pascal keywords &gt;&gt;</vh></v>
<v t="T363"><vh>&lt;&lt; perl keywords &gt;&gt;</vh></v>
<v t="T364"><vh>&lt;&lt; python keywords &gt;&gt;</vh></v>
<v t="T365"><vh>&lt;&lt; tcl/tk keywords &gt;&gt;</vh></v>
<v t="T366"><vh>&lt;&lt; php keywords &gt;&gt;</vh></v>
<v t="T367"><vh>&lt;&lt; rebol keywords &gt;&gt;</vh></v>
</v>
<v t="T368"><vh>color.__init__</vh>
<v t="T369"><vh>&lt;&lt; ivars for communication between colorAllDirectives and its allies &gt;&gt;</vh></v>
<v t="T370"><vh>&lt;&lt; define dispatch dicts &gt;&gt;</vh></v>
<v t="T371"><vh>&lt;&lt; define fonts and data for wiki tags &gt;&gt;</vh></v>
</v>
<v t="T372"><vh>color.callbacks...</vh>
<v t="T373"><vh>OnHyperLinkControlClick</vh></v>
<v t="T374"><vh>OnHyperLinkEnter</vh></v>
<v t="T375"><vh>OnHyperLinkLeave</vh></v>
</v>
<v t="T376"><vh>colorize &amp; recolor_range</vh></v>
<v t="T377"><vh>colorizeAnyLanguage &amp; allies</vh>
<v t="T378"><vh>&lt;&lt; initialize ivars &amp; tags &gt;&gt; colorizeAnyLanguage</vh>
<v t="T379"><vh>&lt;&lt; configure tags &gt;&gt;</vh></v>
<v t="T380"><vh>&lt;&lt; configure language-specific settings &gt;&gt;</vh></v>
</v>
<v t="T381"><vh>&lt;&lt; all state ivars match &gt;&gt;</vh></v>
<v t="T382"><vh>&lt;&lt; incrementally color the text &gt;&gt;</vh>
<v t="T383"><vh>&lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;</vh></v>
<v t="T384"><vh>&lt;&lt; clear leading_lines if middle lines involve @color or @recolor  &gt;&gt;</vh></v>
<v t="T385"><vh>&lt;&lt; initialize new states &gt;&gt;</vh></v>
<v t="T386"><vh>&lt;&lt; colorize until the states match &gt;&gt;</vh></v>
</v>
<v t="T387"><vh>&lt;&lt; non-incrementally color the text &gt;&gt;</vh></v>
<v t="T388"><vh>&lt;&lt; update state ivars &gt;&gt;</vh></v>
<v t="T389"><vh>&lt;&lt; set state ivars to "unknown" &gt;&gt;</vh></v>
<v t="T390"><vh>&lt;&lt; completely recolor in two passes &gt;&gt;</vh>
<v t="T391"><vh>&lt;&lt; kludge: insert a blank in s for every image in the line &gt;&gt;</vh></v>
</v>
</v>
<v t="T392"><vh>colorizeLine &amp; allies</vh>
<v t="T393"><vh>continueBlockComment</vh></v>
<v t="T394"><vh>continueSingle/DoubleString</vh></v>
<v t="T395"><vh>continueDocPart</vh>
<v t="T396"><vh>&lt;&lt; handle cweb doc part &gt;&gt;</vh></v>
<v t="T397"><vh>&lt;&lt; handle noweb doc part &gt;&gt;</vh></v>
</v>
<v t="T398"><vh>continueNocolor</vh></v>
<v t="T399"><vh>continueSingle/DoublePythonString</vh></v>
<v t="T400"><vh>doAtKeyword: NOT for cweb keywords</vh></v>
<v t="T401"><vh>doLatexLine</vh></v>
<v t="T402"><vh>doNormalState</vh>
<v t="T403"><vh>Valid regardless of latex mode</vh>
<v t="T404"><vh>&lt;&lt; handle possible  keyword &gt;&gt;</vh>
<v t="T405"><vh>&lt;&lt; handle possible latex keyword &gt;&gt;</vh></v>
<v t="T406"><vh>&lt;&lt; handle possible html keyword &gt;&gt;</vh></v>
<v t="T407"><vh>&lt;&lt; handle general keyword &gt;&gt;</vh></v>
</v>
<v t="T408"><vh>&lt;&lt; handle at keyword &gt;&gt;</vh>
<v t="T409"><vh>&lt;&lt; Handle cweb control word &gt;&gt;</vh></v>
<v t="T410"><vh>&lt;&lt; handle cweb ref or def &gt;&gt;</vh></v>
</v>
<v t="T411"><vh>&lt;&lt; handle single-line comment &gt;&gt;</vh></v>
<v t="T412"><vh>&lt;&lt; start block comment &gt;&gt;</vh></v>
<v t="T413"><vh>&lt;&lt; handle latex line &gt;&gt;</vh></v>
</v>
<v t="T414"><vh>Vaid only in latex mode</vh>
<v t="T415"><vh>&lt;&lt; handle latex normal character &gt;&gt;</vh></v>
</v>
<v t="T416"><vh>Valid when not in latex_mode</vh>
<v t="T417"><vh>&lt;&lt; handle string &gt;&gt;</vh></v>
<v t="T418"><vh>&lt;&lt; handle C preprocessor line &gt;&gt;</vh></v>
<v t="T419"><vh>&lt;&lt; handle special php keywords &gt;&gt;</vh></v>
<v t="T420"><vh>&lt;&lt; handle blank &gt;&gt;</vh></v>
<v t="T421"><vh>&lt;&lt; handle tab &gt;&gt;</vh></v>
<v t="T422"><vh>&lt;&lt; handle normal character &gt;&gt;</vh></v>
</v>
</v>
<v t="T423"><vh>doNowebSecRef</vh>
<v t="T424"><vh>&lt;&lt; set the hyperlink &gt;&gt;</vh></v>
</v>
<v t="T425"><vh>removeAllTags &amp; removeTagsFromLines</vh></v>
</v>
<v t="T426"><vh>scanColorDirectives</vh>
<v t="T427"><vh>&lt;&lt; Test for @comment or @language &gt;&gt;</vh></v>
<v t="T428"><vh>&lt;&lt; Test for @root, @root-doc or @root-code &gt;&gt;</vh></v>
</v>
<v t="T429"><vh>color.schedule</vh></v>
<v t="T430"><vh>getCwebWord</vh></v>
<v t="T431"><vh>removeAllImages</vh></v>
<v t="T432"><vh>updateSyntaxColorer</vh></v>
<v t="T433"><vh>useSyntaxColoring</vh></v>
<v t="T434"><vh>Utils</vh>
<v t="T435"><vh>index &amp; tag</vh></v>
<v t="T436"><vh>setFirstLineState</vh></v>
<v t="T437"><vh>skip_id</vh></v>
<v t="T438"><vh>skip_python_string</vh></v>
<v t="T439"><vh>skip_string</vh></v>
</v>
</v>
</v>
<v t="T440" tnodeList="440,442,443,444,445,446,448,449,450,452,453,454,455,456,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,506,507,508,509,510,511,512,513,514,516,517,518,520,521,522,523,524,525,526,528,529,530,531,532,533,534,536,537,538,539,540,541,542,543,544,545,546,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,566,567,568,569,570,571,572,573,574,575"><vh>@file c:\prog\test\leoCommands.py</vh>
<v t="T441" a="E"><vh>Birth &amp; death</vh>
<v t="T442"><vh>c.__init__ &amp; initIvars</vh>
<v t="T443"><vh>&lt;&lt; initialize ivars &gt;&gt;</vh></v>
</v>
<v t="T444"><vh>c.__repr__ &amp; __str__</vh></v>
</v>
<v t="T445"><vh>c.setIvarsFromFind</vh></v>
<v t="T446"><vh>c.setIvarsFromPrefs</vh></v>
<v t="T447"><vh>Cut &amp; Paste Outlines</vh>
<v t="T448"><vh>cutOutline</vh></v>
<v t="T449"><vh>copyOutline</vh></v>
<v t="T450"><vh>pasteOutline</vh></v>
</v>
<v t="T451"><vh>Drawing Utilities</vh>
<v t="T452"><vh>beginUpdate</vh></v>
<v t="T453"><vh>bringToFront</vh></v>
<v t="T454"><vh>endUpdate</vh></v>
<v t="T455"><vh>recolor</vh></v>
<v t="T456"><vh>redraw &amp; repaint</vh></v>
</v>
<v t="T457"><vh>Edit Body Text</vh>
<v t="T458"><vh>convertAllBlanks</vh></v>
<v t="T459"><vh>convertAllTabs</vh></v>
<v t="T460"><vh>convertBlanks</vh></v>
<v t="T461"><vh>convertTabs</vh></v>
<v t="T462"><vh>createLastChildNode</vh></v>
<v t="T463"><vh>dedentBody</vh></v>
<v t="T464"><vh>extract</vh>
<v t="T465"><vh>&lt;&lt; Set headline for extract &gt;&gt;</vh></v>
</v>
<v t="T466"><vh>extractSection</vh>
<v t="T467"><vh>&lt;&lt; Set headline for extractSection &gt;&gt;</vh></v>
</v>
<v t="T468"><vh>extractSectionNames</vh>
<v t="T469"><vh>&lt;&lt; Find the next section name &gt;&gt;</vh></v>
</v>
<v t="T470"><vh>getBodyLines</vh></v>
<v t="T471"><vh>getBodySelection</vh></v>
<v t="T472"><vh>indentBody</vh></v>
<v t="T473"><vh>reformatParagraph</vh>
<v t="T474"><vh>&lt;&lt; Set the new insert at the start of the next paragraph &gt;&gt;</vh></v>
</v>
<v t="T475"><vh>updateBodyPane (handles undo)</vh></v>
</v>
<v t="T476"><vh>Enabling Menu Items (Commands)</vh>
<v t="T477"><vh>canContractAllHeadlines</vh></v>
<v t="T478"><vh>canContractAllSubheads</vh></v>
<v t="T479"><vh>canContractParent</vh></v>
<v t="T480"><vh>canContractSubheads</vh></v>
<v t="T481"><vh>canCutOutline &amp; canDeleteHeadline</vh></v>
<v t="T482"><vh>canDemote</vh></v>
<v t="T483"><vh>canExpandAllHeadlines</vh></v>
<v t="T484"><vh>canExpandAllSubheads</vh></v>
<v t="T485"><vh>canExpandSubheads</vh></v>
<v t="T486"><vh>canExtract, canExtractSection &amp; canExtractSectionNames</vh></v>
<v t="T487"><vh>canFindMatchingBracket</vh></v>
<v t="T488"><vh>canGoToNextDirtyHeadline</vh></v>
<v t="T489"><vh>canGoToNextMarkedHeadline</vh></v>
<v t="T490"><vh>canMarkChangedHeadline</vh></v>
<v t="T491"><vh>canMarkChangedRoots</vh></v>
<v t="T492"><vh>canMoveOutlineDown</vh></v>
<v t="T493"><vh>canMoveOutlineLeft</vh></v>
<v t="T494"><vh>canMoveOutlineRight</vh></v>
<v t="T495"><vh>canMoveOutlineUp</vh></v>
<v t="T496"><vh>canPasteOutline</vh></v>
<v t="T497"><vh>canPromote</vh></v>
<v t="T498"><vh>canRevert</vh></v>
<v t="T499"><vh>canSelect....</vh></v>
<v t="T500"><vh>canShiftBodyLeft/Right</vh></v>
<v t="T501"><vh>canSortChildren, canSortSiblings</vh></v>
<v t="T502"><vh>canUndo &amp; canRedo</vh></v>
<v t="T503"><vh>canUnmarkAll</vh></v>
</v>
<v t="T504"><vh>Expand &amp; Contract</vh>
<v t="T505"><vh>Commands</vh>
<v t="T506"><vh>contractAllHeadlines</vh></v>
<v t="T507"><vh>contractNode</vh></v>
<v t="T508"><vh>contractParent</vh></v>
<v t="T509"><vh>expandAllHeadlines</vh></v>
<v t="T510"><vh>expandAllSubheads</vh></v>
<v t="T511"><vh>expandLevel1..9</vh></v>
<v t="T512"><vh>expandNextLevel</vh></v>
<v t="T513"><vh>expandNode</vh></v>
<v t="T514"><vh>expandPrevLevel</vh></v>
</v>
<v t="T515"><vh>Utilities</vh>
<v t="T516"><vh>contractSubtree</vh></v>
<v t="T517"><vh>expandSubtree</vh></v>
<v t="T518"><vh>expandToLevel</vh></v>
</v>
</v>
<v t="T519"><vh>Getters &amp; Setters</vh>
<v t="T520"><vh>c.currentVnode</vh></v>
<v t="T521"><vh>clearAllMarked</vh></v>
<v t="T522"><vh>clearAllVisited</vh></v>
<v t="T523"><vh>fileName</vh></v>
<v t="T524"><vh>isChanged</vh></v>
<v t="T525"><vh>rootVnode</vh></v>
<v t="T526"><vh>setChanged</vh></v>
</v>
<v t="T527"><vh>Insert, Delete &amp; Clone (Commands)</vh>
<v t="T528"><vh>c.checkMoveWithParentWithWarning</vh></v>
<v t="T529"><vh>c.deleteHeadline</vh></v>
<v t="T530"><vh>c.insertHeadline</vh></v>
<v t="T531"><vh>c.clone</vh></v>
<v t="T532"><vh>initAllCloneBits (changed in 4.0)</vh></v>
<v t="T533"><vh>c.initJoinedClonedBits (changed in 3.11.1)</vh></v>
<v t="T534"><vh>validateOutline</vh></v>
</v>
<v t="T535"><vh>Mark &amp; Unmark &amp; goto</vh>
<v t="T536"><vh>goToNextDirtyHeadline</vh></v>
<v t="T537"><vh>goToNextMarkedHeadline</vh></v>
<v t="T538"><vh>goToNextClone</vh></v>
<v t="T539"><vh>markChangedHeadlines</vh></v>
<v t="T540"><vh>markChangedRoots</vh></v>
<v t="T541"><vh>markAllAtFileNodesDirty</vh></v>
<v t="T542"><vh>markAtFileNodesDirty</vh></v>
<v t="T543"><vh>markClones</vh></v>
<v t="T544"><vh>markHeadline</vh></v>
<v t="T545"><vh>markSubheads</vh></v>
<v t="T546"><vh>unmarkAll</vh></v>
</v>
<v t="T547"><vh>Moving, Dragging, Promote, Demote, Sort (commands)</vh>
<v t="T548"><vh>c.dragAfter</vh></v>
<v t="T549"><vh>c.dragCloneToNthChildOf (changed in 3.11.1)</vh></v>
<v t="T550"><vh>c.dragToNthChildOf</vh></v>
<v t="T551"><vh>c.sortChildren, sortSiblings</vh>
<v t="T552"><vh>&lt;&lt; Set the undo info for sortChildren &gt;&gt;</vh></v>
<v t="T553"><vh>&lt;&lt; Set the undo info for sortSiblings &gt;&gt;</vh></v>
</v>
<v t="T554"><vh>c.sortTopLevel</vh>
<v t="T555"><vh>&lt;&lt; Set the undo info for sortTopLevel &gt;&gt;</vh></v>
</v>
<v t="T556"><vh>demote</vh></v>
<v t="T557"><vh>moveOutlineDown</vh>
<v t="T558"><vh>&lt;&lt; Move v down &gt;&gt;</vh></v>
</v>
<v t="T559"><vh>moveOutlineLeft</vh></v>
<v t="T560"><vh>moveOutlineRight</vh></v>
<v t="T561"><vh>moveOutlineUp</vh>
<v t="T562"><vh>&lt;&lt; Move v up &gt;&gt;</vh></v>
</v>
<v t="T563"><vh>promote</vh></v>
<v t="T564"><vh>c.dragCloneAfter (changed in 3.11.1)</vh></v>
</v>
<v t="T565"><vh>Selecting &amp; Updating (commands)</vh>
<v t="T566"><vh>editVnode (calls tree.editLabel)</vh></v>
<v t="T567"><vh>endEditing (calls tree.endEditLabel)</vh></v>
<v t="T568"><vh>selectThreadBack</vh></v>
<v t="T569"><vh>selectThreadNext</vh></v>
<v t="T570"><vh>selectVisBack</vh></v>
<v t="T571"><vh>selectVisNext</vh></v>
<v t="T572"><vh>c.selectVnode (calls tree.select)</vh></v>
<v t="T573"><vh>selectVnodeWithEditing</vh></v>
</v>
<v t="T574"><vh>Syntax coloring interface</vh>
<v t="T575"><vh>updateSyntaxColorer</vh></v>
</v>
</v>
<v t="T576" tnodeList="576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,613,614,615,616"><vh>@file c:\prog\test\leoCompare.py</vh>
<v t="T577"><vh>choose</vh></v>
<v t="T578"><vh>go</vh></v>
<v t="T579"><vh>class leoCompare</vh>
<v t="T580"><vh>compare.__init__</vh></v>
<v t="T581"><vh>compare_directories (entry)</vh></v>
<v t="T582"><vh>compare_files (entry)</vh></v>
<v t="T583"><vh>compare_lines</vh></v>
<v t="T584"><vh>compare_open_files</vh>
<v t="T585"><vh>&lt;&lt; handle opening lines &gt;&gt;</vh></v>
<v t="T586"><vh>&lt;&lt; ignore blank lines and/or sentinels &gt;&gt;</vh></v>
<v t="T587"><vh>&lt;&lt; print matches and/or mismatches &gt;&gt;</vh></v>
<v t="T588"><vh>&lt;&lt; warn if mismatch limit reached &gt;&gt;</vh></v>
<v t="T589"><vh>&lt;&lt; handle reporting after at least one eof is seen &gt;&gt;</vh></v>
</v>
<v t="T590"><vh>filecmp</vh></v>
<v t="T591"><vh>utils...</vh>
<v t="T592"><vh>doOpen</vh></v>
<v t="T593"><vh>dump</vh></v>
<v t="T594"><vh>dumpToEndOfFile</vh></v>
<v t="T595"><vh>isLeoHeader &amp; isSentinel</vh></v>
<v t="T596"><vh>openOutputFile (compare)</vh></v>
<v t="T597"><vh>show</vh></v>
<v t="T598"><vh>showIvars</vh></v>
</v>
</v>
<v t="T599"><vh>class leoComparePanel</vh>
<v t="T600"><vh>browser</vh></v>
<v t="T601"><vh>comparePanel.__init__</vh></v>
<v t="T602"><vh>finishCreate</vh></v>
<v t="T603"><vh>run</vh>
<v t="T604"><vh>&lt;&lt; create the organizer frames &gt;&gt;</vh></v>
<v t="T605"><vh>&lt;&lt; create the browser rows &gt;&gt;</vh></v>
<v t="T606"><vh>&lt;&lt; create the extension row &gt;&gt;</vh></v>
<v t="T607"><vh>&lt;&lt; create the whitespace options frame &gt;&gt;</vh></v>
<v t="T608"><vh>&lt;&lt; create the print options frame &gt;&gt;</vh></v>
<v t="T609"><vh>&lt;&lt; create the compare buttons &gt;&gt;</vh></v>
</v>
<v t="T610"><vh>show</vh></v>
<v t="T611"><vh>setIvarsFromWidgets</vh></v>
<v t="T612"><vh>Event handlers...</vh>
<v t="T613"><vh>onBrowse...</vh></v>
<v t="T614"><vh>onClose</vh></v>
<v t="T615"><vh>onCompare...</vh></v>
<v t="T616"><vh>onPrintMatchedLines</vh></v>
</v>
</v>
</v>
<v t="T617" tnodeList="617,618,619,620,621,622,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646"><vh>@file c:\prog\test\leoConfig.py</vh>
<v t="T618"><vh>&lt;&lt; define defaultsDict &gt;&gt;</vh></v>
<v t="T619"><vh>config.__init__</vh>
<v t="T620"><vh>&lt;&lt; get the default font &gt;&gt;</vh></v>
<v t="T621"><vh>&lt;&lt; initialize constant ivars, lists &amp; dicts &gt;&gt; (leoConfig)</vh></v>
<v t="T622"><vh>&lt;&lt; initialize ivars that may be set by config options &gt;&gt;</vh></v>
</v>
<v t="T623"><vh>getters/setters</vh>
<v t="T624"><vh>get...FromDict &amp; setDict</vh></v>
<v t="T625"><vh>get/setColors</vh></v>
<v t="T626"><vh>get/setComparePref</vh></v>
<v t="T627"><vh>get/setFindPref</vh></v>
<v t="T628"><vh>get/setPref</vh></v>
<v t="T629"><vh>get/setRecentFiles</vh></v>
<v t="T630"><vh>get/setWindowPrefs</vh></v>
<v t="T631"><vh>config.getFontFromParams</vh></v>
<v t="T632"><vh>getShortcut</vh></v>
<v t="T633"><vh>init/Boolean/ConfigParam</vh></v>
<v t="T634"><vh>setCommandsFindIvars</vh></v>
<v t="T635"><vh>setCommandsIvars</vh>
<v t="T636"><vh>&lt;&lt; set prefs ivars &gt;&gt;</vh></v>
</v>
<v t="T637"><vh>setConfigFindIvars</vh></v>
<v t="T638"><vh>setConfigIvars</vh></v>
</v>
<v t="T639"><vh>open</vh>
<v t="T640"><vh>&lt;&lt; get config options &gt;&gt;</vh></v>
<v t="T641"><vh>&lt;&lt; get recent files &gt;&gt;</vh></v>
<v t="T642"><vh>&lt;&lt; convert find/change options to unicode &gt;&gt;</vh></v>
<v t="T643"><vh>&lt;&lt; print options &gt;&gt;</vh></v>
</v>
<v t="T644"><vh>update (config)</vh>
<v t="T645"><vh>&lt;&lt; write recent files section &gt;&gt;</vh></v>
</v>
<v t="T646"><vh>update_section</vh></v>
</v>
<v t="T647" tnodeList="647"><vh>@file c:\prog\test\leoDialog.py</vh>
<v t="T648"><vh>class leoDialog</vh>
<v t="T649"><vh>__init__ (leoDialog)</vh></v>
<v t="T650"><vh>cancelButton, noButton, okButton, yesButton</vh></v>
<v t="T651"><vh>center</vh></v>
<v t="T652"><vh>createButtons</vh></v>
<v t="T653"><vh>createMessageFrame</vh></v>
<v t="T654"><vh>createTopFrame</vh></v>
<v t="T655"><vh>run</vh></v>
</v>
<v t="T656"><vh>class aboutLeo</vh>
<v t="T657"><vh>aboutLeo.__init__</vh></v>
<v t="T658"><vh>aboutLeo.createFrame</vh></v>
<v t="T659"><vh>onAboutLeoEmail</vh></v>
<v t="T660"><vh>onAboutLeoUrl</vh></v>
<v t="T661"><vh>setArrowCursor, setDefaultCursor</vh></v>
</v>
<v t="T662"><vh>class askOkCancelNumber</vh>
<v t="T663"><vh>askOKCancelNumber.__init__</vh></v>
<v t="T664"><vh>askOKCancelNumber.createFrame</vh></v>
<v t="T665"><vh>askOKCancelNumber.okButton, cancelButton</vh></v>
<v t="T666"><vh>askOKCancelNumber.onKey</vh>
<v t="T667"><vh>&lt;&lt; eliminate non-numbers &gt;&gt;</vh></v>
</v>
</v>
<v t="T668"><vh>class askOk</vh>
<v t="T669"><vh>askOk.__init__</vh></v>
<v t="T670"><vh>askOk.onKey</vh></v>
</v>
<v t="T671"><vh>class askOkCancel</vh>
<v t="T672"><vh>askOkCancel.__init__</vh></v>
<v t="T673"><vh>askOkCancel.onKey</vh></v>
</v>
<v t="T674"><vh>class askYesNo</vh>
<v t="T675"><vh>askYesNo.__init__</vh></v>
<v t="T676"><vh>askYesNo.onKey</vh></v>
</v>
<v t="T677"><vh>class askYesNoCancel</vh>
<v t="T678"><vh>askYesNoCancel.__init__</vh></v>
<v t="T679"><vh>askYesNoCancel.onKey</vh></v>
<v t="T680"><vh>askYesNoCancel.noButton &amp; yesButton</vh></v>
</v>
<v t="T681"><vh>class listboxDialog</vh>
<v t="T682"><vh>listboxDialog.__init__</vh></v>
<v t="T683"><vh>addStdButtons</vh></v>
<v t="T684"><vh>createFrame</vh></v>
<v t="T685"><vh>destroy</vh></v>
<v t="T686"><vh>hide</vh></v>
<v t="T687"><vh>fillbox</vh></v>
<v t="T688"><vh>go</vh></v>
</v>
</v>
<v t="T689" tnodeList="689,690,692,693,694,695,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,718,717,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,732,734,735,737,738,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,778,779"><vh>@file c:\prog\test\leoFileCommands.py</vh>
<v t="T690"><vh>leoFileCommands._init_</vh></v>
<v t="T691" a="E"><vh>Reading</vh>
<v t="T692"><vh>createVnode</vh></v>
<v t="T693"><vh>finishPaste</vh>
<v t="T694"><vh>&lt;&lt; Create join lists of all pasted vnodes &gt;&gt;</vh></v>
<v t="T695"><vh>&lt;&lt; Recompute clone bits for pasted vnodes &gt;&gt;</vh></v>
</v>
<v t="T696" a="E"><vh>get routines</vh>
<v t="T697"><vh>get &amp; match (basic)(leoFileCommands)</vh>
<v t="T698"><vh>get routines</vh></v>
<v t="T699"><vh>match routines</vh></v>
</v>
<v t="T700"><vh>getClipboardHeader</vh></v>
<v t="T701"><vh>getCloneWindows</vh></v>
<v t="T702"><vh>getEscapedString</vh></v>
<v t="T703"><vh>getFindPanelSettings</vh>
<v t="T704"><vh>&lt;&lt; Set defaults of all flags &gt;&gt;</vh></v>
</v>
<v t="T705"><vh>getGlobals (changed for 4.0)</vh></v>
<v t="T706"><vh>getLeoFile (calls setAllJoinLinks, initAllCloneBits)</vh>
<v t="T707"><vh>&lt;&lt; warn on read-only files &gt;&gt;</vh></v>
<v t="T708"><vh>&lt;&lt; scan all the xml elements &gt;&gt;</vh></v>
<v t="T709"><vh>&lt;&lt; raise an alert &gt;&gt;</vh></v>
</v>
<v t="T710"><vh>getLeoHeader</vh></v>
<v t="T711"><vh>getLeoOutline (from clipboard)</vh></v>
<v t="T712"><vh>getPosition</vh></v>
<v t="T713"><vh>getPrefs</vh>
<v t="T714"><vh>&lt;&lt; check for syntax coloring prefs &gt;&gt; (getPrefs)</vh></v>
</v>
<v t="T715"><vh>getSize</vh></v>
<v t="T716"><vh>getTnode</vh>
<v t="T717"><vh>&lt;&lt; handle read from file &gt;&gt;</vh></v>
<v t="T718"><vh>&lt;&lt; handle read from clipboard &gt;&gt;</vh></v>
</v>
<v t="T719"><vh>getTnodes</vh></v>
<v t="T720"><vh>getVnode</vh>
<v t="T721"><vh>&lt;&lt; Handle vnode attribute bits  &gt;&gt;</vh></v>
<v t="T722"><vh>&lt;&lt; Set the remembered status bits &gt;&gt;</vh></v>
</v>
<v t="T723"><vh>getTnodeList (4.0)</vh></v>
<v t="T724"><vh>getVnodes</vh></v>
<v t="T725"><vh>getXmlStylesheetTag</vh></v>
<v t="T726"><vh>getXmlVersionTag</vh></v>
<v t="T727"><vh>skipWs</vh></v>
<v t="T728"><vh>skipWsAndNl</vh></v>
</v>
<v t="T729"><vh>newTnode</vh></v>
<v t="T730"><vh>readAtFileNodes</vh></v>
<v t="T731"><vh>fileCommands.readOutlineOnly</vh>
<v t="T732" a="C"><vh>&lt;&lt; Set the default directory &gt;&gt;</vh></v>
</v>
<v t="T733"><vh>fileCommands.open</vh>
<v t="T732" a="C"><vh>&lt;&lt; Set the default directory &gt;&gt;</vh></v>
</v>
<v t="T734"><vh>fileCommands.setAllJoinLinks</vh></v>
<v t="T735"><vh>xmlUnescape</vh></v>
</v>
<v t="T736"><vh>Writing</vh>
<v t="T737"><vh>assignFileIndices</vh></v>
<v t="T738"><vh>compactFileIndices</vh></v>
<v t="T739"><vh>put routines</vh>
<v t="T740"><vh>putClipboardHeader</vh>
<v t="T741"><vh>&lt;&lt; count the number of tnodes &gt;&gt;</vh></v>
</v>
<v t="T742"><vh>put (basic)(leoFileCommands)</vh></v>
<v t="T743"><vh>putEscapedString</vh></v>
<v t="T744"><vh>putFindSettings</vh>
<v t="T745"><vh>&lt;&lt; put find settings that may exist in leoConfig.txt &gt;&gt;</vh></v>
</v>
<v t="T746"><vh>putGlobals (changed for 4.0)</vh>
<v t="T747"><vh>&lt;&lt; put the body/outline ratio &gt;&gt;</vh></v>
<v t="T748"><vh>&lt;&lt; put the position of this frame &gt;&gt;</vh></v>
<v t="T749"><vh>&lt;&lt; put the position of the log window &gt;&gt;</vh></v>
</v>
<v t="T750"><vh>putHeader</vh></v>
<v t="T751"><vh>putLeoOutline (to clipboard)</vh></v>
<v t="T752"><vh>putPrefs</vh>
<v t="T753"><vh>&lt;&lt; put prefs that may exist in leoConfig.txt &gt;&gt; (putPrefs)</vh>
<v t="T754"><vh>&lt;&lt; put default directory &gt;&gt;</vh></v>
</v>
</v>
<v t="T755"><vh>putProlog</vh>
<v t="T756"><vh>&lt;&lt; Put the &lt;?xml...?&gt; line &gt;&gt;</vh></v>
<v t="T757"><vh>&lt;&lt; Put the optional &lt;?xml-stylesheet...?&gt; line &gt;&gt;</vh></v>
</v>
<v t="T758"><vh>putPostlog</vh></v>
<v t="T759"><vh>putTnodes</vh>
<v t="T760"><vh>&lt;&lt; write only those tnodes that were referenced &gt;&gt;</vh></v>
</v>
<v t="T761"><vh>putTnode</vh></v>
<v t="T762"><vh>putVnodes</vh></v>
<v t="T763"><vh>putVnode</vh>
<v t="T764"><vh>&lt;&lt; Put tnode index if this vnode has body text &gt;&gt;</vh></v>
<v t="T765"><vh>&lt;&lt; Put attribute bits &gt;&gt;</vh></v>
<v t="T766"><vh>&lt;&lt; write the head text &gt;&gt;</vh></v>
</v>
</v>
<v t="T767"><vh>save</vh></v>
<v t="T768"><vh>saveAs</vh></v>
<v t="T769"><vh>saveTo</vh></v>
<v t="T770"><vh>setDefaultDirectoryForNewFiles</vh></v>
<v t="T771"><vh>xmlEscape</vh></v>
<v t="T772"><vh>writeAtFileNodes</vh></v>
<v t="T773"><vh>writeDirtyAtFileNodes</vh></v>
<v t="T774"><vh>writeMissingAtFileNodes</vh></v>
<v t="T775"><vh>writeOutlineOnly</vh></v>
<v t="T776"><vh>write_LEO_file</vh>
<v t="T777"><vh>&lt;&lt; create backup file &gt;&gt;</vh></v>
<v t="T778"><vh>&lt;&lt; delete backup file &gt;&gt;</vh></v>
<v t="T779"><vh>&lt;&lt; erase filename and rename backupName to fileName &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T780" tnodeList="780,781"><vh>@file c:\prog\test\leoFind.py</vh>
<v t="T781"><vh>&lt;&lt; Theory of operation of find/change &gt;&gt;</vh></v>
<v t="T782"><vh>class leoFindBase</vh>
<v t="T783"><vh>findBase.__init__</vh></v>
<v t="T784"><vh>onCloseWindow</vh></v>
<v t="T785"><vh>resetWrap</vh></v>
<v t="T786"><vh>OnReturnKey (no longer used)</vh></v>
</v>
<v t="T787"><vh>class leoFind</vh>
<v t="T788"><vh>find.__init__ (creates find panel)</vh>
<v t="T789"><vh>&lt;&lt; Initialize the leoFind ivars &gt;&gt;</vh></v>
</v>
<v t="T790"><vh>find.createFrame</vh>
<v t="T791"><vh>&lt;&lt; Create four columns of radio and checkboxes &gt;&gt;</vh></v>
<v t="T792"><vh>&lt;&lt; Create the Find and Change panes &gt;&gt;</vh></v>
<v t="T793"><vh>&lt;&lt; Create two rows of buttons &gt;&gt;</vh></v>
</v>
<v t="T794"><vh>find.init</vh>
<v t="T795"><vh>&lt;&lt; set widgets &gt;&gt;</vh></v>
</v>
<v t="T796"><vh>find.set_ivars</vh></v>
<v t="T797"><vh>Top Level Commands</vh>
<v t="T798"><vh>changeButton</vh></v>
<v t="T799"><vh>changeAllButton</vh></v>
<v t="T800"><vh>changeThenFindButton</vh></v>
<v t="T801"><vh>findButton</vh></v>
<v t="T802"><vh>findAllButton</vh></v>
<v t="T803"><vh>changeCommand</vh></v>
<v t="T804"><vh>changeThenFindCommandd</vh></v>
<v t="T805"><vh>findNextCommand</vh></v>
<v t="T806"><vh>fndPreviousCommand</vh></v>
<v t="T807"><vh>setup_button</vh></v>
<v t="T808"><vh>setup_command</vh></v>
</v>
<v t="T809"><vh>Utilities</vh>
<v t="T810"><vh>batchChange</vh>
<v t="T811"><vh>&lt;&lt; set the undo head params &gt;&gt;</vh></v>
<v t="T812"><vh>&lt;&lt; set the undo body typing params &gt;&gt;</vh></v>
</v>
<v t="T813"><vh>change</vh></v>
<v t="T814"><vh>changeAll</vh></v>
<v t="T815"><vh>changeSelection</vh></v>
<v t="T816"><vh>changeThenFind</vh></v>
<v t="T817"><vh>findAll</vh></v>
<v t="T818"><vh>findNext</vh></v>
<v t="T819"><vh>findNextMatch</vh></v>
<v t="T820"><vh>selectNextVnode</vh></v>
<v t="T821"><vh>search</vh>
<v t="T822"><vh>&lt;&lt; search again after getting stuck going backward &gt;&gt;</vh></v>
<v t="T823"><vh>&lt;&lt; return if we are passed the wrap point &gt;&gt;</vh></v>
<v t="T824"><vh>&lt;&lt; test for whole word match &gt;&gt;</vh></v>
</v>
<v t="T825"><vh>Initializing &amp; finalizing &amp; selecting</vh>
<v t="T826"><vh>checkArgs</vh></v>
<v t="T827"><vh>initBatchCommands</vh></v>
<v t="T828"><vh>initBatchText &amp; initNextText</vh></v>
<v t="T829"><vh>initInHeadline</vh></v>
<v t="T830"><vh>initInteractiveCommands</vh></v>
<v t="T831"><vh>printLine</vh></v>
<v t="T832"><vh>restore</vh></v>
<v t="T833"><vh>save</vh></v>
<v t="T834"><vh>showSuccess</vh></v>
</v>
</v>
</v>
</v>
<v t="T835" tnodeList="835,837,838,839,840,841,842,843,845,846,847,848,849,851,852,854,855,856,857,858,859,860,861,862,863,864"><vh>@file c:\prog\test\leoFontPanel.py</vh>
<v t="T836"><vh>Birth &amp; Death</vh>
<v t="T837"><vh>fontPanel.__init__</vh></v>
<v t="T838"><vh>create_outer</vh>
<v t="T839"><vh>&lt;&lt; create the organizer frames &gt;&gt;</vh></v>
<v t="T840"><vh>&lt;&lt; create the font pane &gt;&gt;</vh></v>
<v t="T841"><vh>&lt;&lt; create the checkboxes &gt;&gt;</vh></v>
<v t="T842"><vh>&lt;&lt; create the buttons &gt;&gt;</vh></v>
</v>
<v t="T843"><vh>finishCreate</vh></v>
</v>
<v t="T844"><vh>Buttons</vh>
<v t="T845"><vh>onApply</vh></v>
<v t="T846"><vh>onCancel</vh></v>
<v t="T847"><vh>onOk</vh>
<v t="T848"><vh>&lt;&lt; update the configuration settings &gt;&gt;</vh></v>
</v>
<v t="T849"><vh>onRevert</vh></v>
</v>
<v t="T850"><vh>Events</vh>
<v t="T851"><vh>selectFont</vh></v>
<v t="T852"><vh>onSizeEntryKey</vh></v>
</v>
<v t="T853"><vh>Helpers</vh>
<v t="T854"><vh>getActiveFont</vh></v>
<v t="T855"><vh>getFontSettings</vh></v>
<v t="T856"><vh>getImpliedFont</vh></v>
<v t="T857"><vh>hide</vh></v>
<v t="T858"><vh>revertIvars</vh></v>
<v t="T859"><vh>run</vh></v>
<v t="T860"><vh>setRevertVars</vh></v>
<v t="T861"><vh>showSettings</vh></v>
<v t="T862"><vh>update</vh>
<v t="T863"><vh>&lt;&lt; insert the new text in the size box &gt;&gt;</vh></v>
<v t="T864"><vh>&lt;&lt; set the fonts in all panes &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T865" a="M" tnodeList="865,867,868,869,870,871,872,873,874,875,876,877,878,879,881,882,883,884,885,886,887,888,889,890,891,893,894,895,896,897,898,899,900,901,902,904,905,906,907,908,909,910,911,912,914,918,915,916,917,919,920,927,928,929,930,931,932,933,934,921,922,923,924,925,926,935,936,937,938,939,940,941,942,943,944,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,970,971,972,974,975,976,977,978,979,981,982,983,985,986,987,989,990,991,992,993,994,995,996,997,998,999,1002,1003,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1042,1043,1044,1045,1047,1048,1049,1050,1051,1054,1055,1056,1057,1058,1059,1060,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099,1100,1101,1102,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149,1150,1151,1152,1153,1154,1155,1156,1157"><vh>@file c:\prog\test\leoFrame.py</vh>
<v t="T866"><vh>Birth &amp; Death</vh>
<v t="T867"><vh>f.__init__</vh>
<v t="T868"><vh>&lt;&lt; set the LeoFrame ivars &gt;&gt;</vh></v>
<v t="T869"><vh>&lt;&lt; create the first tree node &gt;&gt;</vh></v>
</v>
<v t="T870"><vh>f.__repr__</vh></v>
<v t="T871"><vh>f.setWindowTitle</vh></v>
<v t="T872"><vh>f.createLeoFrame</vh>
<v t="T873"><vh>&lt;&lt; create both splitters &gt;&gt;</vh></v>
<v t="T874"><vh>&lt;&lt; create the body pane &gt;&gt;</vh></v>
<v t="T875"><vh>&lt;&lt; create the tree pane &gt;&gt;</vh></v>
<v t="T876"><vh>&lt;&lt; create the log pane &gt;&gt;</vh></v>
</v>
<v t="T877"><vh>frame.destroyAllPanels</vh></v>
<v t="T878"><vh>frame.promptForSave</vh>
<v t="T879"><vh>&lt;&lt; Put up a file save dialog to set mFileName &gt;&gt;</vh></v>
</v>
</v>
<v t="T880"><vh>Configuration</vh>
<v t="T881"><vh>f.configureBar</vh></v>
<v t="T882"><vh>f.configureBarsFromConfig</vh></v>
<v t="T883"><vh>f.reconfigureFromConfig</vh></v>
<v t="T884"><vh>f.setBodyFontFromConfig</vh></v>
<v t="T885"><vh>f.setInitialWindowGeometry</vh></v>
<v t="T886"><vh>f.setLogFontFromConfig</vh></v>
<v t="T887"><vh>f.setTabWidth</vh></v>
<v t="T888"><vh>f.setTreeColorsFromConfig</vh></v>
<v t="T889"><vh>f.setWrap</vh></v>
<v t="T890"><vh>reconfigurePanes (use config bar_width)</vh></v>
</v>
<v t="T891"><vh>Scrolling callbacks (frame)</vh></v>
<v t="T892"><vh>Event handlers (Frame)</vh>
<v t="T893"><vh>frame.OnCloseLeoEvent</vh></v>
<v t="T894"><vh>frame.OnControlKeyUp/Down</vh></v>
<v t="T895"><vh>frame.OnVisibility</vh></v>
<v t="T896"><vh>OnActivateBody</vh></v>
<v t="T897"><vh>OnActivateLeoEvent, OnDeactivateLeoEvent</vh></v>
<v t="T898"><vh>OnActivateLog</vh></v>
<v t="T899"><vh>OnActivateTree</vh></v>
<v t="T900"><vh>OnBodyClick, OnBodyRClick (Events)</vh></v>
<v t="T901"><vh>OnBodyDoubleClick (Events)</vh></v>
<v t="T902"><vh>OnMouseWheel (Tomaz Ficko)</vh></v>
</v>
<v t="T903"><vh>Icon area: convenience routines</vh>
<v t="T904"><vh>createIconBar</vh></v>
<v t="T905"><vh>hideIconBar</vh></v>
<v t="T906"><vh>clearIconBar</vh></v>
<v t="T907"><vh>showIconBar</vh></v>
<v t="T908"><vh>addIconButton</vh>
<v t="T909"><vh>&lt;&lt; create a picture &gt;&gt;</vh></v>
</v>
</v>
<v t="T910"><vh>f.longFileName &amp; shortFileName</vh></v>
<v t="T911"><vh>f.put, putnl</vh></v>
<v t="T912"><vh>f.getFocus</vh></v>
<v t="T913"><vh> Menus</vh>
<v t="T914"><vh>canonicalizeShortcut</vh>
<v t="T915"><vh>&lt;&lt; canonicalize the last field &gt;&gt;</vh>
<v t="T916"><vh>&lt;&lt; define dict of Tk bind names &gt;&gt;</vh></v>
<v t="T917"><vh>&lt;&lt; define dict of special names &gt;&gt;</vh></v>
</v>
<v t="T918"><vh>&lt;&lt; set the last field, preserving case &gt;&gt;</vh></v>
<v t="T919"><vh>&lt;&lt; synthesize the shortcuts from the information &gt;&gt;</vh></v>
</v>
<v t="T920"><vh>createMenuBar</vh>
<v t="T921"><vh>&lt;&lt; create the edit menu &gt;&gt;</vh>
<v t="T922"><vh>&lt;&lt; create the first top-level edit entries &gt;&gt;</vh></v>
<v t="T923"><vh>&lt;&lt; create the edit body submenu &gt;&gt;</vh></v>
<v t="T924"><vh>&lt;&lt; create the edit headline submenu &gt;&gt;</vh></v>
<v t="T925"><vh>&lt;&lt; create the find submenu &gt;&gt;</vh></v>
<v t="T926"><vh>&lt;&lt; create the last top-level edit entries &gt;&gt;</vh></v>
</v>
<v t="T927"><vh>&lt;&lt; create the file menu &gt;&gt;</vh>
<v t="T928"><vh>&lt;&lt; create the top-level file entries &gt;&gt;</vh></v>
<v t="T929"><vh>&lt;&lt; create the recent files submenu &gt;&gt;</vh></v>
<v t="T930"><vh>&lt;&lt; create the read/write submenu &gt;&gt;</vh></v>
<v t="T931"><vh>&lt;&lt; create the tangle submenu &gt;&gt;</vh></v>
<v t="T932"><vh>&lt;&lt; create the untangle submenu &gt;&gt;</vh></v>
<v t="T933"><vh>&lt;&lt; create the import submenu &gt;&gt;</vh></v>
<v t="T934"><vh>&lt;&lt; create the export submenu &gt;&gt;</vh></v>
</v>
<v t="T935"><vh>&lt;&lt; create the outline menu &gt;&gt;</vh>
<v t="T936"><vh>&lt;&lt; create top-level outline menu &gt;&gt;</vh></v>
<v t="T937"><vh>&lt;&lt; create expand/contract submenu &gt;&gt;</vh></v>
<v t="T938"><vh>&lt;&lt; create move submenu &gt;&gt;</vh></v>
<v t="T939"><vh>&lt;&lt; create mark submenu &gt;&gt;</vh></v>
<v t="T940"><vh>&lt;&lt; create goto submenu &gt;&gt;</vh></v>
</v>
<v t="T941"><vh>&lt;&lt; create the window menu &gt;&gt;</vh></v>
<v t="T942"><vh>&lt;&lt; create the help menu &gt;&gt;</vh></v>
</v>
<v t="T943"><vh>frame.doCommand</vh></v>
<v t="T944"><vh>get/set/destroyMenu</vh></v>
<v t="T945"><vh>Menu Command Handlers</vh>
<v t="T946"><vh>File Menu</vh>
<v t="T947"><vh>top level</vh>
<v t="T948"><vh>OnNew</vh></v>
<v t="T949"><vh>frame.OnOpen</vh>
<v t="T950"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="T951"><vh>frame.OnOpenWith and allies</vh>
<v t="T952"><vh>&lt;&lt; set ext based on the present language &gt;&gt;</vh></v>
<v t="T953"><vh>&lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt;</vh>
<v t="T954"><vh>&lt;&lt;set dict and path if a temp file already refers to v.t &gt;&gt;</vh></v>
<v t="T955"><vh>&lt;&lt; create or recreate temp file as needed &gt;&gt;</vh>
<v t="T956"><vh>&lt;&lt; Raise dialog about conflict and set result &gt;&gt;</vh></v>
</v>
</v>
<v t="T957"><vh>&lt;&lt; execute a command to open path in external editor &gt;&gt;</vh></v>
<v t="T958"><vh>frame.createOpenWithTempFile</vh>
<v t="T959"><vh>&lt;&lt; remove previous entry from a.openWithFiles if it exists &gt;&gt;</vh></v>
</v>
<v t="T960"><vh>frame.openWithTempFilePath</vh></v>
</v>
<v t="T961"><vh>frame.OpenWithFileName</vh></v>
<v t="T962"><vh>frame.OnClose</vh></v>
<v t="T963"><vh>OnSave</vh></v>
<v t="T964"><vh>OnSaveAs</vh></v>
<v t="T965"><vh>OnSaveTo</vh></v>
<v t="T966"><vh>frame.OnRevert</vh></v>
<v t="T967"><vh>frame.OnQuit</vh></v>
<v t="T968"><vh>frame.updateRecentFiles</vh></v>
</v>
<v t="T969"><vh>Recent Files submenu &amp; allies</vh>
<v t="T970"><vh>frame.OnOpenRecentFile</vh>
<v t="T971"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="T972"><vh>createRecentFilesMenuItems</vh></v>
</v>
<v t="T973"><vh>Read/Write submenu</vh>
<v t="T974"><vh>fileCommands.OnReadOutlineOnly</vh></v>
<v t="T975"><vh>OnReadAtFileNodes</vh></v>
<v t="T976"><vh>OnWriteDirtyAtFileNodes</vh></v>
<v t="T977"><vh>OnWriteMissingAtFileNodes</vh></v>
<v t="T978"><vh>OnWriteOutlineOnly</vh></v>
<v t="T979"><vh>OnWriteAtFileNodes</vh></v>
</v>
<v t="T980"><vh>Tangle submenu</vh>
<v t="T981"><vh>OnTangleAll</vh></v>
<v t="T982"><vh>OnTangleMarked</vh></v>
<v t="T983"><vh>OnTangle</vh></v>
</v>
<v t="T984"><vh>Untangle submenu</vh>
<v t="T985"><vh>OnUntangleAll</vh></v>
<v t="T986"><vh>OnUntangleMarked</vh></v>
<v t="T987"><vh>OnUntangle</vh></v>
</v>
<v t="T988"><vh>Import&amp;Export submenu</vh>
<v t="T989"><vh>OnExportHeadlines</vh></v>
<v t="T990"><vh>OnFlattenOutline</vh></v>
<v t="T991"><vh>OnImportAtRoot</vh></v>
<v t="T992"><vh>OnImportAtFile</vh></v>
<v t="T993"><vh>OnImportCWEBFiles</vh></v>
<v t="T994"><vh>OnImportFlattenedOutline</vh></v>
<v t="T995"><vh>OnImportNowebFiles</vh></v>
<v t="T996"><vh>OnOutlineToCWEB</vh></v>
<v t="T997"><vh>OnOutlineToNoweb</vh></v>
<v t="T998"><vh>OnRemoveSentinels</vh></v>
<v t="T999"><vh>OnWeave</vh></v>
</v>
</v>
<v t="T1000"><vh>Edit Menu (change to handle log pane too)</vh>
<v t="T1001"><vh>Edit top level</vh>
<v t="T1002"><vh>OnUndo</vh></v>
<v t="T1003"><vh>OnRedo</vh></v>
<v t="T1004"><vh>Cut/Copy/Paste body text</vh>
<v t="T1005"><vh>frame.OnCut, OnCutFrom Menu</vh></v>
<v t="T1006"><vh>frame.OnCopy, OnCopyFromMenu</vh></v>
<v t="T1007"><vh>frame.OnPaste, OnPasteNode, OnPasteFromMenu</vh></v>
</v>
<v t="T1008"><vh>OnDelete</vh></v>
<v t="T1009"><vh>OnExecuteScript</vh></v>
<v t="T1010"><vh>OnGoToLineNumber &amp; allies</vh>
<v t="T1011"><vh>&lt;&lt; set root to the nearest @file, @silentfile or @rawfile ancestor node &gt;&gt;</vh></v>
<v t="T1012"><vh>&lt;&lt; read the file into lines &gt;&gt;</vh></v>
<v t="T1013"><vh>&lt;&lt; get n, the line number, from a dialog &gt;&gt;</vh></v>
<v t="T1014"><vh>&lt;&lt; count outline lines, setting v,n2,found &gt;&gt;</vh></v>
<v t="T1015"><vh>&lt;&lt; set v to the node given by vnodeName and childIndex &gt;&gt;</vh></v>
<v t="T1016"><vh>&lt;&lt; select v and make it visible &gt;&gt;</vh></v>
<v t="T1017"><vh>&lt;&lt; put the cursor on line n2 of the body text &gt;&gt;</vh></v>
<v t="T1018"><vh>convertLineToVnodeNameIndexLine</vh>
<v t="T1019"><vh>&lt;&lt; set delim, leoLine from the @+leo line &gt;&gt;</vh></v>
<v t="T1020"><vh>&lt;&lt; scan back to  @+node, setting offset,nodeSentinelLine &gt;&gt;</vh>
<v t="T1021"><vh>&lt;&lt; handle delim while scanning backward &gt;&gt;</vh></v>
</v>
<v t="T1022"><vh>&lt;&lt; set vnodeName and childIndex from s &gt;&gt;</vh></v>
</v>
<v t="T1023"><vh>skipToMatchingNodeSentinel</vh></v>
</v>
<v t="T1024"><vh>OnSelectAll</vh></v>
<v t="T1025"><vh>OnFontPanel</vh></v>
<v t="T1026"><vh>OnColorPanel</vh></v>
<v t="T1027"><vh>OnViewAllCharacters</vh></v>
<v t="T1028"><vh>OnPreferences</vh></v>
</v>
<v t="T1029"><vh>Edit Body submenu</vh>
<v t="T1030"><vh>OnConvertBlanks &amp; OnConvertAllBlanks</vh></v>
<v t="T1031"><vh>OnConvertTabs &amp; OnConvertAllTabs</vh></v>
<v t="T1032"><vh>OnDedent</vh></v>
<v t="T1033"><vh>OnExtract</vh></v>
<v t="T1034"><vh>OnExtractNames</vh></v>
<v t="T1035"><vh>OnExtractSection</vh></v>
<v t="T1036"><vh>OnFindMatchingBracket</vh>
<v t="T1037"><vh>findMatchingBracket</vh></v>
</v>
<v t="T1038"><vh>OnIndent</vh></v>
<v t="T1039"><vh>OnInsertBody/HeadlineTime &amp; allies</vh>
<v t="T1040"><vh>getTime</vh></v>
</v>
</v>
<v t="T1041"><vh>Edit Headline submenu</vh>
<v t="T1042"><vh>OnEditHeadline</vh></v>
<v t="T1043"><vh>OnEndEditHeadline</vh></v>
<v t="T1044"><vh>OnAbortEditHeadline</vh></v>
<v t="T1045"><vh>OnToggleAngleBrackets</vh></v>
</v>
<v t="T1046"><vh>Find submenu (frame methods)</vh>
<v t="T1047"><vh>OnFindPanel</vh></v>
<v t="T1048"><vh>OnFindNext</vh></v>
<v t="T1049"><vh>OnFindPrevious</vh></v>
<v t="T1050"><vh>OnReplace</vh></v>
<v t="T1051"><vh>OnReplaceThenFind</vh></v>
</v>
</v>
<v t="T1052"><vh>Outline Menu</vh>
<v t="T1053"><vh>top level</vh>
<v t="T1054"><vh>OnCutNode</vh></v>
<v t="T1055"><vh>OnCopyNode</vh></v>
<v t="T1056"><vh>OnPasteNodee</vh></v>
<v t="T1057"><vh>OnDeleteNode</vh></v>
<v t="T1058"><vh>OnInsertNode</vh></v>
<v t="T1059"><vh>OnCloneNode</vh></v>
<v t="T1060"><vh>OnSortChildren, OnSortSiblings</vh></v>
</v>
<v t="T1061"><vh>Expand/Contract</vh>
<v t="T1062"><vh>No longer used</vh>
<v t="T1063"><vh>OnContractChildren (no longer used)</vh></v>
<v t="T1064"><vh>OnContractAllChildren (no longer used)</vh></v>
<v t="T1065"><vh>OnExpandAllChildren (no longer used)</vh></v>
<v t="T1066"><vh>OnExpandChildren (no longer used)</vh></v>
</v>
<v t="T1067"><vh>OnContractAll</vh></v>
<v t="T1068"><vh>OnContractNode</vh></v>
<v t="T1069"><vh>OnContractParent</vh></v>
<v t="T1070"><vh>OnExpandAll</vh></v>
<v t="T1071"><vh>OnExpandNextLevel</vh></v>
<v t="T1072"><vh>OnExpandNode</vh></v>
<v t="T1073"><vh>OnExpandPrevLevel</vh></v>
<v t="T1074"><vh>OnExpandToLevel1..9</vh></v>
</v>
<v t="T1075"><vh>Move/Select</vh>
<v t="T1076"><vh>OnMoveDownwn</vh></v>
<v t="T1077"><vh>OnMoveLeft</vh></v>
<v t="T1078"><vh>OnMoveRight</vh></v>
<v t="T1079"><vh>OnMoveUp</vh></v>
<v t="T1080"><vh>OnPromote</vh></v>
<v t="T1081"><vh>OnDemote</vh></v>
<v t="T1082"><vh>OnGoPrevVisible</vh></v>
<v t="T1083"><vh>OnGoNextVisible</vh></v>
<v t="T1084"><vh>OnGoBack</vh></v>
<v t="T1085"><vh>OnGoNext</vh></v>
</v>
<v t="T1086"><vh>Mark/Goto</vh>
<v t="T1087"><vh>OnGoPrevVisitedNode</vh></v>
<v t="T1088"><vh>OnGoNextVisitedNode</vh></v>
<v t="T1089"><vh>OnGoToFirstNode</vh></v>
<v t="T1090"><vh>OnGoToLastNode</vh></v>
<v t="T1091"><vh>OnGoToNextChanged</vh></v>
<v t="T1092"><vh>OnGoToNextClone</vh></v>
<v t="T1093"><vh>OnGoToNextMarked</vh></v>
<v t="T1094"><vh>OnGoToNextSibling</vh></v>
<v t="T1095"><vh>OnGoToParent</vh></v>
<v t="T1096"><vh>OnGoToPrevSibling</vh></v>
<v t="T1097"><vh>OnMark</vh></v>
<v t="T1098"><vh>OnMarkChangedItems</vh></v>
<v t="T1099"><vh>OnMarkChangedRoots</vh></v>
<v t="T1100"><vh>OnMarkClones</vh></v>
<v t="T1101"><vh>OnMarkSubheads</vh></v>
<v t="T1102"><vh>OnUnmarkAll</vh></v>
</v>
</v>
<v t="T1103"><vh>Window Menu</vh>
<v t="T1104"><vh>OnEqualSizedPanes</vh></v>
<v t="T1105"><vh>OnToggleActivePane</vh></v>
<v t="T1106"><vh>OnToggleSplitDirection</vh></v>
<v t="T1107"><vh>OnCascade</vh></v>
<v t="T1108"><vh>OnMinimizeAll</vh></v>
<v t="T1109"><vh>OnHideLogWindow</vh></v>
<v t="T1110"><vh>OnOpenCompareWindow</vh></v>
<v t="T1111"><vh>OnOpenPythonWindow (Dave Hein)</vh>
<v t="T1112"><vh>&lt;&lt; open idle in Linux &gt;&gt;</vh></v>
<v t="T1113"><vh>&lt;&lt; open idle in Windows &gt;&gt;</vh></v>
<v t="T1114"><vh>leoPyShellMain</vh></v>
</v>
</v>
<v t="T1115"><vh>Help Menu</vh>
<v t="T1116"><vh>OnAbout (version number &amp; date)</vh></v>
<v t="T1117"><vh>OnLeoDocumentation</vh></v>
<v t="T1118"><vh>OnLeoHome</vh></v>
<v t="T1119"><vh>OnLeoHelp</vh>
<v t="T1120"><vh>showProgressBar</vh>
<v t="T1121"><vh>&lt;&lt; create the scale widget &gt;&gt;</vh></v>
</v>
</v>
<v t="T1122"><vh>OnLeoTutorial (version number)</vh></v>
<v t="T1123"><vh>OnLeoConfig, OnApplyConfig</vh></v>
</v>
</v>
<v t="T1124"><vh>Menu Convenience Routines</vh>
<v t="T1125"><vh>createMenuEntries</vh>
<v t="T1126"><vh>&lt;&lt; set name to the label for doCommand &gt;&gt;</vh></v>
<v t="T1127"><vh>&lt;&lt; set accel to the shortcut for name &gt;&gt;</vh></v>
<v t="T1128"><vh>&lt;&lt; set bind_shortcut and menu_shortcut using accel &gt;&gt;</vh></v>
<v t="T1129"><vh>&lt;&lt; define callback function &gt;&gt;</vh></v>
<v t="T1130"><vh>&lt;&lt; set realLabel, amp_index and menu_shortcut &gt;&gt;</vh></v>
<v t="T1131"><vh>&lt;&lt; handle bind_shorcut &gt;&gt;</vh></v>
</v>
<v t="T1132"><vh>createMenuItemsFromTable</vh></v>
<v t="T1133"><vh>createNewMenu</vh></v>
<v t="T1134"><vh>createOpenWithMenuFromTable</vh></v>
<v t="T1135"><vh>deleteMenu</vh></v>
<v t="T1136"><vh>deleteMenuItem</vh></v>
<v t="T1137"><vh>setRealMenuNamesFromTable</vh></v>
</v>
<v t="T1138"><vh>Menu enablers (Frame)</vh>
<v t="T1139"><vh>frame.OnMenuClick (enables and disables all menu items)</vh></v>
<v t="T1140"><vh>hasSelection</vh></v>
<v t="T1141"><vh>updateFileMenu</vh></v>
<v t="T1142"><vh>updateEditMenu</vh></v>
<v t="T1143"><vh>updateOutlineMenu</vh></v>
</v>
</v>
<v t="T1144"><vh>Splitter stuff</vh>
<v t="T1145"><vh>resizePanesToRatio</vh></v>
<v t="T1146"><vh>bindBar</vh></v>
<v t="T1147"><vh>createLeoSplitter</vh></v>
<v t="T1148"><vh>divideAnySplitter</vh></v>
<v t="T1149"><vh>divideLeoSplitter</vh></v>
<v t="T1150"><vh>initialRatios</vh></v>
<v t="T1151"><vh>onDrag...</vh></v>
<v t="T1152"><vh>placeSplitter</vh></v>
</v>
<v t="T1153"><vh>Status line: convenience routines</vh>
<v t="T1154"><vh>createStatusLine</vh></v>
<v t="T1155"><vh>clearStatusLine</vh></v>
<v t="T1156"><vh>putStatusLine</vh></v>
<v t="T1157"><vh>updateStatusRowCol()</vh></v>
</v>
</v>
<v t="T1158" tnodeList="1158,1159"><vh>@file c:\prog\test\leoGlobals.py</vh>
<v t="T1159"><vh>&lt;&lt; define general constants &gt;&gt;</vh></v>
<v t="T1160"><vh>Checking Leo Files...</vh>
<v t="T1161"><vh>createTopologyList</vh></v>
<v t="T1162"><vh>checkClones2Links</vh>
<v t="T1163"><vh>&lt;&lt; clear statistics &gt;&gt;</vh></v>
<v t="T1164"><vh>&lt;&lt; print statistics &gt;&gt;</vh></v>
<v t="T1165"><vh>&lt;&lt; handle each item in v's join list &gt;&gt;</vh></v>
</v>
</v>
<v t="T1166"><vh>CheckVersion (Dave Hein)</vh></v>
<v t="T1167"><vh>class Bunch</vh></v>
<v t="T1168"><vh>Commands, Dialogs, Directives, &amp; Menus...</vh>
<v t="T1169"><vh>Dialog utils...</vh>
<v t="T1170"><vh>attachLeoIcon &amp; allies</vh>
<v t="T1171"><vh>createLeoIcon</vh></v>
<v t="T1172"><vh>onVisibility</vh></v>
</v>
<v t="T1173"><vh>get_window_info</vh></v>
<v t="T1174"><vh>center_dialog</vh></v>
<v t="T1175"><vh>create_labeled_frame</vh></v>
</v>
<v t="T1176"><vh>Directive utils...</vh>
<v t="T1177"><vh>@language and @comment directives (leoUtils)</vh>
<v t="T1178"><vh>set_delims_from_language</vh></v>
<v t="T1179"><vh>set_delims_from_string</vh></v>
<v t="T1180"><vh>set_language</vh></v>
</v>
<v t="T1181"><vh>findReference</vh></v>
<v t="T1182"><vh>get_directives_dict &amp; globalDirectiveList</vh>
<v t="T1183"><vh>&lt;&lt; set dict for @ directives &gt;&gt;</vh></v>
<v t="T1184"><vh>&lt;&lt; set dict["root"] for noweb * chunks &gt;&gt;</vh></v>
</v>
<v t="T1185"><vh>getOutputNewline</vh></v>
<v t="T1186"><vh>scanAtEncodingDirective</vh></v>
<v t="T1187"><vh>scanAtLineendingDirective</vh></v>
<v t="T1188"><vh>scanAtPagewidthDirective</vh></v>
<v t="T1189"><vh>scanAtTabwidthDirective</vh></v>
<v t="T1190"><vh>scanDirectives (utils)</vh>
<v t="T1191"><vh>&lt;&lt; Set local vars &gt;&gt;</vh></v>
<v t="T1192"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="T1193"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="T1194"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="T1195"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="T1196"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="T1197"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
</v>
<v t="T1198"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="T1199"><vh>&lt;&lt; Test for @wrap and @nowrap &gt;&gt;</vh></v>
</v>
</v>
<v t="T1200"><vh>Menus...</vh>
<v t="T1201"><vh>canonicalizeMenuName &amp; cononicalizeTranslatedMenuName</vh></v>
<v t="T1202"><vh>enableMenu &amp; disableMenu &amp; setMenuLabel</vh></v>
</v>
<v t="T1203"><vh>openWithFileName (leoGlobals)</vh></v>
<v t="T1204"><vh>wrap_lines</vh>
<v t="T1205"><vh>&lt;&lt; place blank and word on the present line &gt;&gt;</vh></v>
<v t="T1206"><vh>&lt;&lt; place word on a new line &gt;&gt;</vh></v>
</v>
</v>
<v t="T1207"><vh>Debugging, Dumping, Timing, Tracing &amp; Sherlock</vh>
<v t="T1208"><vh>Files &amp; Directories...</vh>
<v t="T1209"><vh>create_temp_name</vh></v>
<v t="T1210"><vh>ensure_extension</vh></v>
<v t="T1211"><vh>getBaseDirectory</vh></v>
<v t="T1212"><vh>makeAllNonExistentDirectories</vh></v>
<v t="T1213"><vh>readlineForceUnixNewline (Steven P. Schaefer)</vh></v>
<v t="T1214"><vh>redirecting stderr and stdout</vh>
<v t="T1215"><vh>&lt;&lt; redirectClass methods &gt;&gt;</vh></v>
<v t="T1216"><vh>&lt;&lt; define convenience methods for redirecting streams &gt;&gt;</vh></v>
<v t="T1217"><vh>&lt;&lt; test code &gt;&gt;</vh></v>
</v>
<v t="T1218"><vh>sanitize_filename</vh></v>
<v t="T1219"><vh>shortFileName</vh></v>
<v t="T1220"><vh>update_file_if_changed</vh></v>
<v t="T1221"><vh>utils_rename</vh></v>
</v>
<v t="T1222"><vh>Sherlock...</vh>
<v t="T1223"><vh>init_sherlock</vh></v>
<v t="T1224"><vh>get_Sherlock_args</vh></v>
<v t="T1225"><vh>init_trace</vh></v>
<v t="T1226"><vh>trace</vh></v>
<v t="T1227"><vh>trace_tag</vh></v>
</v>
<v t="T1228"><vh>Statistics</vh>
<v t="T1229"><vh>clear_stats</vh></v>
<v t="T1230"><vh>print_stats</vh></v>
<v t="T1231"><vh>stat</vh></v>
</v>
<v t="T1232"><vh>Timing</vh></v>
<v t="T1233"><vh>alert</vh></v>
<v t="T1234"><vh>angleBrackets &amp; virtual_event_name</vh></v>
<v t="T1235"><vh>callerName</vh></v>
<v t="T1236"><vh>dump</vh></v>
<v t="T1237"><vh>es_error</vh></v>
<v t="T1238"><vh>es_event_exception</vh></v>
<v t="T1239"><vh>es_exception</vh></v>
<v t="T1240"><vh>file/module/plugin_date</vh></v>
<v t="T1241"><vh>funcToMethod</vh></v>
<v t="T1242"><vh>get_line &amp; get_line_after</vh></v>
<v t="T1243"><vh>pause</vh></v>
<v t="T1244"><vh>printBindings</vh></v>
<v t="T1245"><vh>printGlobals</vh></v>
<v t="T1246"><vh>printLeoModules</vh></v>
</v>
<v t="T1247"><vh>executeScript</vh></v>
<v t="T1248"><vh>Focus (leoGlobals)</vh>
<v t="T1249"><vh>get_focus</vh></v>
<v t="T1250"><vh>set_focus</vh></v>
<v t="T1251"><vh>force_focus</vh></v>
</v>
<v t="T1252"><vh>Garbage Collection</vh>
<v t="T1253"><vh>clearAllIvars</vh></v>
<v t="T1254"><vh>collectGarbage</vh>
<v t="T1255"><vh>&lt;&lt; make a list of the new objects &gt;&gt;</vh></v>
</v>
<v t="T1256"><vh>printGc</vh></v>
<v t="T1257"><vh>printGcRefs</vh></v>
</v>
<v t="T1258"><vh>Hooks &amp; plugins</vh>
<v t="T1259"><vh>enableIdleTimeHook, disableIdleTimeHook, idleTimeHookHandler</vh></v>
<v t="T1260"><vh>doHook</vh></v>
<v t="T1261"><vh>plugin_signon</vh></v>
</v>
<v t="T1262"><vh>importFromPath</vh></v>
<v t="T1263"><vh>Lists...</vh>
<v t="T1264"><vh>appendToList</vh></v>
<v t="T1265"><vh>flattenList</vh></v>
<v t="T1266"><vh>listToString</vh></v>
</v>
<v t="T1267"><vh>makeDict</vh></v>
<v t="T1268"><vh>Most common functions</vh>
<v t="T1269"><vh>app, setApp</vh></v>
<v t="T1270"><vh>choose</vh></v>
<v t="T1271"><vh>es, enl, ecnl</vh></v>
<v t="T1272"><vh>top</vh></v>
<v t="T1273"><vh>trace is defined below</vh></v>
<v t="T1274"><vh>windows</vh></v>
</v>
<v t="T1275"><vh>Scanning, selection &amp; whitespace...</vh>
<v t="T1276" a="C"><vh>getindex</vh></v>
<v t="T1277"><vh>scanAtFileOptions</vh>
<v t="T1278"><vh>&lt;&lt; scan another @file option &gt;&gt;</vh></v>
</v>
<v t="T1279"><vh>scanAtRootOptions</vh>
<v t="T1280"><vh>&lt;&lt; scan another @root option &gt;&gt;</vh></v>
</v>
<v t="T1281"><vh>scanError</vh></v>
<v t="T1282"><vh>scanf</vh></v>
<v t="T1283"><vh>Scanners: calling scanError</vh>
<v t="T1284"><vh>skip_block_comment</vh></v>
<v t="T1285"><vh>skip_braces</vh></v>
<v t="T1286"><vh>skip_php_braces (Dave Hein)</vh></v>
<v t="T1287"><vh>skip_parens</vh></v>
<v t="T1288"><vh>skip_pascal_begin_end</vh></v>
<v t="T1289"><vh>skip_pascal_block_comment</vh></v>
<v t="T1290"><vh>skip_pascal_string : called by tangle</vh></v>
<v t="T1291"><vh>skip_heredoc_string : called by php import (Dave Hein)</vh></v>
<v t="T1292"><vh>skip_pp_directive</vh></v>
<v t="T1293"><vh>skip_pp_if</vh></v>
<v t="T1294"><vh>skip_pp_part</vh></v>
<v t="T1295"><vh>skip_python_string</vh></v>
<v t="T1296"><vh>skip_string : called by tangle</vh></v>
<v t="T1297"><vh>skip_to_semicolon</vh></v>
<v t="T1298"><vh>skip_typedef</vh></v>
</v>
<v t="T1299"><vh>Scanners: no error messages</vh>
<v t="T1300"><vh>escaped</vh></v>
<v t="T1301"><vh>find_line_start</vh></v>
<v t="T1302"><vh>find_on_line</vh></v>
<v t="T1303"><vh>is_c_id</vh></v>
<v t="T1304"><vh>is_nl</vh></v>
<v t="T1305"><vh>is_special</vh></v>
<v t="T1306"><vh>is_ws &amp; is_ws_or_nl</vh></v>
<v t="T1307"><vh>match</vh></v>
<v t="T1308"><vh>match_c_word</vh></v>
<v t="T1309"><vh>match_ignoring_case</vh></v>
<v t="T1310"><vh>match_word</vh></v>
<v t="T1311"><vh>skip_blank_lines</vh></v>
<v t="T1312"><vh>skip_c_id</vh></v>
<v t="T1313"><vh>skip_line, skip_to_end_of_line</vh></v>
<v t="T1314"><vh>skip_long</vh></v>
<v t="T1315"><vh>skip_matching_delims</vh></v>
<v t="T1316"><vh>skip_nl</vh></v>
<v t="T1317"><vh>skip_non_ws</vh></v>
<v t="T1318"><vh>skip_pascal_braces</vh></v>
<v t="T1319"><vh>skip_to_char</vh></v>
<v t="T1320"><vh>skip_ws, skip_ws_and_nl</vh></v>
</v>
<v t="T1321"><vh>Tk.Text selection (utils)</vh>
<v t="T1322"><vh>bound_paragraph</vh></v>
<v t="T1276" a="C"><vh>getindex</vh></v>
<v t="T1323"><vh>getSelectedText</vh></v>
<v t="T1324"><vh>getTextSelection</vh></v>
<v t="T1325"><vh>setTextSelection</vh></v>
</v>
<v t="T1326"><vh>Whitespace...</vh>
<v t="T1327"><vh>computeLeadingWhitespace</vh></v>
<v t="T1328"><vh>computeWidth</vh></v>
<v t="T1329"><vh>get_leading_ws</vh></v>
<v t="T1330"><vh>optimizeLeadingWhitespace</vh></v>
<v t="T1331"><vh>removeLeadingWhitespace</vh></v>
<v t="T1332"><vh>removeTrailingWs</vh></v>
<v t="T1333"><vh>skip_leading_ws</vh></v>
<v t="T1334"><vh>skip_leading_ws_with_indent</vh></v>
</v>
</v>
<v t="T1335"><vh>Unicode utils...</vh>
<v t="T1336"><vh>isValidEncoding</vh></v>
<v t="T1337"><vh>reportBadChars</vh></v>
<v t="T1338"><vh>toUnicode &amp; toEncodedString</vh></v>
<v t="T1339"><vh>getpreferredencoding from 2.3a2</vh>
<v t="T1340"><vh>&lt;&lt; define getpreferredencoding using _locale &gt;&gt;</vh></v>
<v t="T1341"><vh>&lt;&lt; define getpreferredencoding for *nix &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T1342" tnodeList="1342,1344,1345,1343,1347,1348,1349,1350,1352,1353,1354,1355,1356,1357,1358,1359,1360,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1374,1375,1376,1377,1380,1381,1382,1383,1384,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1400,1399,1401,1402,1403,1404,1405,1414,1415,1416,1417,1406,1407,1408,1409,1410,1411,1412,1413,1418,1419,1420,1426,1427,1428,1429,1421,1422,1423,1424,1425,1418,1430,1431,1434,1435,1436,1432,1437,1433,1418,1439,1440,1441,1442,1443,1444,1443,1444,1445,1446,1447,1447,1448,1449,1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476"><vh>@file c:\prog\test\leoImport.py</vh>
<v t="T1343"><vh>import.__init__</vh></v>
<v t="T1344"><vh>&lt;&lt; scripts &gt;&gt;</vh>
<v t="T1345"><vh>importFiles</vh></v>
</v>
<v t="T1346"><vh>Import</vh>
<v t="T1347"><vh>createOutline</vh>
<v t="T1348"><vh>&lt;&lt; Read file into s &gt;&gt;</vh></v>
</v>
<v t="T1349"><vh>importFilesCommand</vh>
<v t="T1350"><vh>&lt;&lt; Create a parent for two files having a common prefix &gt;&gt;</vh></v>
</v>
<v t="T1351"><vh>importFlattenedOutline &amp; allies</vh>
<v t="T1352"><vh>convertMoreString/StringsToOutlineAfter</vh>
<v t="T1353"><vh>&lt;&lt; Link a new vnode v into the outline &gt;&gt;</vh></v>
<v t="T1354"><vh>&lt;&lt; Set the headline string, skipping over the leader &gt;&gt;</vh></v>
<v t="T1355"><vh>&lt;&lt; Count the number of following body lines &gt;&gt;</vh></v>
<v t="T1356"><vh>&lt;&lt; Add the lines to the body text of v &gt;&gt;</vh></v>
</v>
<v t="T1357"><vh>importFlattenedOutline</vh>
<v t="T1358"><vh>&lt;&lt; Read the file into array &gt;&gt;</vh></v>
</v>
<v t="T1359"><vh>moreHeadlineLevel</vh></v>
<v t="T1360"><vh>stringIs/stringsAreValidMoreFile</vh></v>
</v>
<v t="T1361"><vh>importWebCommand &amp; allies</vh>
<v t="T1362"><vh>createOutlineFromWeb</vh></v>
<v t="T1363"><vh>importWebCommand</vh></v>
<v t="T1364"><vh>findFunctionDef</vh></v>
<v t="T1365"><vh>scanBodyForHeadline</vh>
<v t="T1366"><vh>&lt;&lt; scan cweb body for headline &gt;&gt;</vh></v>
<v t="T1367"><vh>&lt;&lt; scan noweb body for headline &gt;&gt;</vh></v>
</v>
<v t="T1368"><vh>scanWebFile (handles limbo)</vh>
<v t="T1369"><vh>&lt;&lt; Create a symbol table of all section names &gt;&gt;</vh></v>
<v t="T1370"><vh>&lt;&lt; Create nodes for limbo text and the root section &gt;&gt;</vh></v>
<v t="T1371"><vh>&lt;&lt; Create a node for the next module &gt;&gt;</vh>
<v t="T1372"><vh>&lt;&lt; Handle cweb @d, @f, @c and @p directives &gt;&gt;</vh></v>
</v>
</v>
<v t="T1373"><vh>Symbol table</vh>
<v t="T1374"><vh>cstCanonicalize</vh></v>
<v t="T1375"><vh>cstDump</vh></v>
<v t="T1376"><vh>cstEnter</vh></v>
<v t="T1377"><vh>cstLookup</vh></v>
</v>
</v>
<v t="T1378"><vh>Scanners for createOutline</vh>
<v t="T1379"><vh>Python scanners</vh>
<v t="T1380"><vh>scanPythonClass</vh>
<v t="T1381"><vh>&lt;&lt; set classname and headline, or return i &gt;&gt;</vh></v>
<v t="T1382"><vh>&lt;&lt; create class_vnode  &gt;&gt;</vh></v>
<v t="T1383"><vh>&lt;&lt; create nodes for all defs of the class &gt;&gt;</vh>
<v t="T1384"><vh>&lt;&lt; create parent_vnode &gt;&gt;</vh></v>
</v>
</v>
<v t="T1385"><vh>scanPythonDef</vh>
<v t="T1386"><vh>&lt;&lt; set headline or return i &gt;&gt;</vh></v>
<v t="T1387"><vh>&lt;&lt; skip the Python def &gt;&gt;</vh></v>
<v t="T1388"><vh>&lt;&lt; Create def node &gt;&gt;</vh></v>
</v>
<v t="T1389"><vh>scanPythonDecls</vh>
<v t="T1390"><vh>&lt;&lt; break on def or class &gt;&gt;</vh></v>
<v t="T1391"><vh>&lt;&lt; Create a child node for declarations &gt;&gt;</vh></v>
</v>
<v t="T1392"><vh>scanPythonText</vh>
<v t="T1393"><vh>&lt;&lt; handle possible Python function or class &gt;&gt;</vh></v>
<v t="T1394"><vh>&lt;&lt; Append a reference to the methods of this file &gt;&gt;</vh></v>
<v t="T1395"><vh>&lt;&lt; Append any unused python text to the parent's body text &gt;&gt;</vh></v>
</v>
</v>
<v t="T1396"><vh>scanPHPText (Dave Hein)</vh>
<v t="T1397"><vh>&lt;&lt; Append file if not pure PHP &gt;&gt;</vh></v>
<v t="T1398"><vh>&lt;&lt; define scanPHPText vars &gt;&gt;</vh></v>
<v t="T1399"><vh>&lt;&lt; handle possible heredoc string &gt;&gt;</vh></v>
<v t="T1400"><vh>&lt;&lt; handle possible PHP comments &gt;&gt;</vh></v>
<v t="T1401"><vh>&lt;&lt; handle possible class or function &gt;&gt;</vh></v>
<v t="T1402"><vh>&lt;&lt; handle end of class &gt;&gt;</vh></v>
<v t="T1403"><vh>&lt;&lt; Append any unused text to the parent's body text &gt;&gt;</vh></v>
</v>
<v t="T1404"><vh>scanCText</vh>
<v t="T1405"><vh>&lt;&lt; define scanCText vars &gt;&gt;</vh></v>
<v t="T1406"><vh>&lt;&lt; handle # sign &gt;&gt;</vh>
<v t="T1407"><vh>&lt;&lt; create a child node for all #include statements &gt;&gt;</vh></v>
</v>
<v t="T1408"><vh>&lt;&lt; handle open curly bracket in C &gt;&gt; (scans function)</vh>
<v t="T1409"><vh>&lt;&lt; create a declaration node &gt;&gt;</vh></v>
<v t="T1410"><vh>&lt;&lt; append C function/method reference to parent node &gt;&gt;</vh></v>
</v>
<v t="T1411"><vh>&lt;&lt; handle id, class, typedef, struct, union, namespace &gt;&gt;</vh>
<v t="T1412"><vh>&lt;&lt; create children for the namespace &gt;&gt;</vh></v>
<v t="T1413"><vh>&lt;&lt; test for operator keyword &gt;&gt;</vh></v>
</v>
<v t="T1414"><vh>&lt;&lt; handle possible C comments &gt;&gt;</vh></v>
<v t="T1415"><vh>&lt;&lt; handle equal sign in C&gt;&gt;</vh></v>
<v t="T1416"><vh>&lt;&lt; handle open paren in C &gt;&gt;</vh></v>
<v t="T1417"><vh>&lt;&lt; handle semicolon in C &gt;&gt;</vh></v>
<v t="T1418" a="C"><vh>&lt;&lt; Append any unused text to the parent's body text &gt;&gt;</vh></v>
</v>
<v t="T1419"><vh>scanJavaText</vh>
<v t="T1420"><vh>&lt;&lt; define scanJavaText vars &gt;&gt;</vh></v>
<v t="T1421"><vh>&lt;&lt; handle open curly bracket in Java &gt;&gt;</vh>
<v t="T1422"><vh>&lt;&lt; create a Java declaration node &gt;&gt;</vh></v>
<v t="T1423"><vh>&lt;&lt; append Java method reference to parent node &gt;&gt;</vh></v>
<v t="T1424"><vh>&lt;&lt; recursively scan the text &gt;&gt;</vh></v>
</v>
<v t="T1425"><vh>&lt;&lt; skip and remember the Java id &gt;&gt;</vh></v>
<v t="T1426"><vh>&lt;&lt; handle possible Java comments &gt;&gt;</vh></v>
<v t="T1427"><vh>&lt;&lt; handle equal sign in Java &gt;&gt;</vh></v>
<v t="T1428"><vh>&lt;&lt; handle open paren in Java &gt;&gt;</vh></v>
<v t="T1429"><vh>&lt;&lt; handle semicolon in Java &gt;&gt;</vh></v>
<v t="T1418" a="C"><vh>&lt;&lt; Append any unused text to the parent's body text &gt;&gt;</vh></v>
</v>
<v t="T1430"><vh>scanPascalText</vh>
<v t="T1431"><vh>&lt;&lt; handle possible Pascal function &gt;&gt;</vh>
<v t="T1432"><vh>&lt;&lt; create a child node for leading declarations &gt;&gt;</vh></v>
<v t="T1433"><vh>&lt;&lt; create a child node for the function &gt;&gt;</vh></v>
<v t="T1434"><vh>&lt;&lt; remember the function name, or continue &gt;&gt;</vh></v>
<v t="T1435"><vh>&lt;&lt; skip the function definition, or continue &gt;&gt;</vh>
<v t="T1436"><vh>&lt;&lt; skip past the semicolon &gt;&gt;</vh></v>
</v>
<v t="T1437"><vh>&lt;&lt; append noweb method reference to the parent node &gt;&gt;</vh></v>
</v>
<v t="T1418" a="C"><vh>&lt;&lt; Append any unused text to the parent's body text &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T1438"><vh>Export</vh>
<v t="T1439"><vh>convertCodePartToWeb</vh>
<v t="T1440"><vh>&lt;&lt; put v's headline ref in head_ref&gt;&gt;</vh></v>
<v t="T1441"><vh>&lt;&lt; put name following @root or @file in file_name &gt;&gt;</vh>
<v t="T1442"><vh>&lt;&lt; Set file_name &gt;&gt;</vh></v>
</v>
<v t="T1443"><vh>&lt;&lt; append ref to file_name &gt;&gt;</vh></v>
<v t="T1444"><vh>&lt;&lt; append head_ref &gt;&gt;</vh></v>
</v>
<v t="T1445"><vh>convertDocPartToWeb (handle @ %def)</vh></v>
<v t="T1446"><vh>convertVnodeToWeb</vh>
<v t="T1447"><vh>&lt;&lt; Supply a missing doc part &gt;&gt;</vh></v>
</v>
<v t="T1448"><vh>copyPart</vh></v>
<v t="T1449"><vh>exportHeadlines</vh></v>
<v t="T1450"><vh>flattenOutline</vh></v>
<v t="T1451"><vh>outlineToWeb</vh></v>
<v t="T1452"><vh>removeSentinelsCommand</vh>
<v t="T1453"><vh>&lt;&lt; Read file into s &gt;&gt;</vh></v>
<v t="T1454"><vh>&lt;&lt; set delims from the header line &gt;&gt;</vh></v>
<v t="T1455"><vh>&lt;&lt; Write s into newFileName &gt;&gt;</vh></v>
</v>
<v t="T1456"><vh>removeSentinelLines</vh>
<v t="T1457"><vh>&lt;&lt; handle possible sentinel &gt;&gt;</vh></v>
</v>
<v t="T1458"><vh>weave</vh>
<v t="T1459"><vh>&lt;&lt; open filename to f, or return &gt;&gt;</vh></v>
<v t="T1460"><vh>&lt;&lt; write the context of v to f &gt;&gt;</vh></v>
</v>
</v>
<v t="T1461"><vh>Utilities</vh>
<v t="T1462"><vh>createHeadline</vh></v>
<v t="T1463"><vh>error</vh></v>
<v t="T1464"><vh>getLeadingIndent</vh></v>
<v t="T1465"><vh>isDocStart and isModuleStart</vh></v>
<v t="T1466"><vh>massageBody</vh></v>
<v t="T1467"><vh>massageComment</vh></v>
<v t="T1468"><vh>massageWebBody</vh>
<v t="T1469"><vh>&lt;&lt; Remove most newlines from @space and @* sections &gt;&gt;</vh></v>
<v t="T1470"><vh>&lt;&lt; Replace abbreviated names with full names &gt;&gt;</vh></v>
</v>
<v t="T1471"><vh>setEncoding</vh></v>
<v t="T1472"><vh>skipLeadingComments</vh>
<v t="T1473"><vh>&lt;&lt; scan for C-style comments &gt;&gt;</vh></v>
<v t="T1474"><vh>&lt;&lt; scan for Pascal comments &gt;&gt;</vh></v>
<v t="T1475"><vh>&lt;&lt; scan for Python comments &gt;&gt;</vh></v>
</v>
<v t="T1476"><vh>undentBody</vh></v>
</v>
</v>
<v t="T1477" tnodeList="1477,1479,1478"><vh>@file c:\prog\test\leoNodes.py</vh>
<v t="T1478"><vh>&lt;&lt; About clones &gt;&gt;</vh></v>
<v t="T1479"><vh>&lt;&lt; About the vnode and tnode classes &gt;&gt;</vh></v>
<v t="T1480"><vh>class tnode</vh>
<v t="T1481"><vh>&lt;&lt; tnode constants &gt;&gt;</vh></v>
<v t="T1482"><vh>t.__init__</vh></v>
<v t="T1483"><vh>Getters</vh>
<v t="T1484"><vh>hasBody</vh></v>
<v t="T1485"><vh>loadBodyPaneFromTnode</vh></v>
<v t="T1486"><vh>Status bits</vh>
<v t="T1487"><vh>isDirty</vh></v>
<v t="T1488"><vh>isRichTextBit</vh></v>
<v t="T1489"><vh>isVisited</vh></v>
</v>
</v>
<v t="T1490" a="E"><vh>Setters</vh>
<v t="T1491"><vh>Setting body text</vh>
<v t="T1492"><vh>saveBodyPaneToTnode</vh></v>
<v t="T1493"><vh>setTnodeText</vh></v>
<v t="T1494"><vh>setSelection</vh></v>
</v>
<v t="T1495"><vh>Status bits</vh>
<v t="T1496"><vh>clearDirty</vh></v>
<v t="T1497"><vh>clearRichTextBit</vh></v>
<v t="T1498"><vh>clearVisited</vh></v>
<v t="T1499"><vh>setDirty</vh></v>
<v t="T1500"><vh>setRichTextBit</vh></v>
<v t="T1501"><vh>setVisited</vh></v>
</v>
<v t="T1502"><vh>setCloneIndex</vh></v>
<v t="T1503"><vh>setFileIndex</vh></v>
</v>
</v>
<v t="T1504" a="E"><vh>class vnode</vh>
<v t="T1505"><vh>&lt;&lt; vnode constants &gt;&gt;  ### Warning: changes meaning of visitedBit</vh></v>
<v t="T1506"><vh>Birth &amp; death</vh>
<v t="T1507"><vh>v.__cmp__ (not used)</vh></v>
<v t="T1508"><vh>v.__init__</vh>
<v t="T1509"><vh>&lt;&lt; initialize vnode data members &gt;&gt;</vh></v>
</v>
<v t="T1510"><vh>v.__repr__ &amp; v.__str__</vh></v>
</v>
<v t="T1511"><vh>v.Callbacks (handles event hooks)</vh>
<v t="T1512"><vh>OnBoxClick</vh></v>
<v t="T1513"><vh>OnDrag</vh></v>
<v t="T1514"><vh>v.OnEndDrag</vh></v>
<v t="T1515"><vh>v.OnHeadlineClick &amp; OnHeadlineRightClick</vh></v>
<v t="T1516"><vh>OnHeadlineKey</vh></v>
<v t="T1517"><vh>OnHyperLinkControlClick</vh></v>
<v t="T1518"><vh>OnHyperLinkEnter</vh></v>
<v t="T1519"><vh>OnHyperLinkLeave</vh></v>
<v t="T1520"><vh>OnIconClick &amp; OnIconRightClick</vh></v>
<v t="T1521"><vh>OnIconDoubleClick</vh></v>
</v>
<v t="T1522" a="E"><vh>Comparisons (vnode)</vh>
<v t="T1523"><vh>afterHeadlineMatch</vh></v>
<v t="T1524"><vh>at/../NodeName</vh></v>
<v t="T1525"><vh>isAt/../Node</vh></v>
<v t="T1526"><vh>isAnyAtFileNode &amp; isAnyAtFileNodeName</vh></v>
<v t="T1527"><vh>isAtIgnoreNode</vh></v>
<v t="T1528"><vh>isAtOthersNode</vh></v>
<v t="T1529"><vh>matchHeadline</vh></v>
</v>
<v t="T1530"><vh>File Conversion (vnode)</vh>
<v t="T1531"><vh>convertTreeToString</vh></v>
<v t="T1532"><vh>moreHead</vh></v>
<v t="T1533"><vh>v.moreBody</vh></v>
</v>
<v t="T1534"><vh>Getters</vh>
<v t="T1535"><vh>Children</vh>
<v t="T1536"><vh>childIndex</vh></v>
<v t="T1537"><vh>firstChild</vh></v>
<v t="T1538"><vh>hasChildren</vh></v>
<v t="T1539"><vh>lastChild</vh></v>
<v t="T1540"><vh>nthChild</vh></v>
<v t="T1541"><vh>numberOfChildren (n)</vh></v>
</v>
<v t="T1542"><vh>Status Bits</vh>
<v t="T1543"><vh>isCloned</vh></v>
<v t="T1544"><vh>isDirty</vh></v>
<v t="T1545"><vh>isExpanded</vh></v>
<v t="T1546"><vh>isMarked</vh></v>
<v t="T1547"><vh>isOrphan</vh></v>
<v t="T1548"><vh>isSelected</vh></v>
<v t="T1549"><vh>isTopBitSet</vh></v>
<v t="T1550"><vh>isVisible</vh></v>
<v t="T1551"><vh>isVisited</vh></v>
<v t="T1552"><vh>status</vh></v>
</v>
<v t="T1553"><vh>bodyString</vh></v>
<v t="T1554"><vh>currentVnode (vnode)</vh></v>
<v t="T1555"><vh>edit_text</vh></v>
<v t="T1556"><vh>findRoot</vh></v>
<v t="T1557"><vh>headString &amp; cleanHeadString</vh></v>
<v t="T1558"><vh>isAncestorOf</vh></v>
<v t="T1559"><vh>isRoot</vh></v>
<v t="T1560"><vh>v.exists</vh></v>
</v>
<v t="T1561"><vh>Setters</vh>
<v t="T1562" a="E"><vh>Head and body text</vh>
<v t="T1563"><vh>appendStringToBody</vh></v>
<v t="T1564"><vh>setBodyStringOrPane &amp; setBodyTextOrPane</vh></v>
<v t="T1565"><vh>setHeadString &amp; initHeadString</vh></v>
<v t="T1566"><vh>setHeadStringOrHeadline</vh></v>
</v>
<v t="T1567"><vh>computeIcon &amp; setIcon</vh></v>
<v t="T1568"><vh>Status bits</vh>
<v t="T1569"><vh>clearAllVisited</vh></v>
<v t="T1570"><vh>clearAllVisitedInTree</vh></v>
<v t="T1571"><vh>clearClonedBit</vh></v>
<v t="T1572"><vh>clearDirty &amp; clearDirtyJoined (redundant code)</vh></v>
<v t="T1573"><vh>clearMarked</vh></v>
<v t="T1574"><vh>clearOrphan</vh></v>
<v t="T1575"><vh>clearVisited</vh></v>
<v t="T1576"><vh>clearVisitedInTree</vh></v>
<v t="T1577"><vh>contract &amp; expand &amp; initExpandedBit</vh></v>
<v t="T1578"><vh>initStatus</vh></v>
<v t="T1579"><vh>setAncestorsOfClonedNodesInTreeDirty</vh></v>
<v t="T1580"><vh>setAncestorAtFileNodeDirty</vh></v>
<v t="T1581"><vh>setClonedBit &amp; initClonedBit</vh></v>
<v t="T1582"><vh>setDirty, setDirtyDeleted &amp; initDirtyBit (redundant code)</vh></v>
<v t="T1583"><vh>setMarked &amp; initMarkedBit</vh></v>
<v t="T1584"><vh>setOrphan</vh></v>
<v t="T1585"><vh>setSelected (vnode, new)</vh></v>
<v t="T1586"><vh>setVisited</vh></v>
</v>
<v t="T1587"><vh>setSelection</vh></v>
<v t="T1588"><vh>setT</vh></v>
<v t="T1589"><vh>trimTrailingLines</vh></v>
</v>
<v t="T1590"><vh>Tree Traversal (vnode)</vh>
<v t="T1591"><vh>back</vh></v>
<v t="T1592"><vh>lastNode</vh></v>
<v t="T1593"><vh>level</vh></v>
<v t="T1594"><vh>next</vh></v>
<v t="T1595"><vh>nodeAfterTree</vh></v>
<v t="T1596"><vh>parent</vh></v>
<v t="T1597"><vh>threadBack</vh></v>
<v t="T1598"><vh>threadNext</vh></v>
<v t="T1599"><vh>visBack</vh></v>
<v t="T1600"><vh>visNext</vh></v>
</v>
<v t="T1601"><vh>Moving, Inserting, Deleting, Cloning, Sorting (vnode)</vh>
<v t="T1602"><vh>Entry Points (vnode)</vh>
<v t="T1603"><vh>doDelete</vh></v>
<v t="T1604"><vh>insertAfter</vh></v>
<v t="T1605"><vh>insertAsLastChild</vh></v>
<v t="T1606"><vh>insertAsNthChild</vh></v>
<v t="T1607"><vh>moveToRoot</vh></v>
<v t="T1608"><vh>restoreOutlineFromDVnodes (test)</vh></v>
<v t="T1609"><vh>v.clone</vh></v>
<v t="T1610"><vh>v.linkAfter</vh></v>
<v t="T1611"><vh>v.linkAsNthChild</vh></v>
<v t="T1612"><vh>v.linkAsRoot</vh></v>
<v t="T1613"><vh>v.moveAfter</vh></v>
<v t="T1614"><vh>v.moveToNthChildOf</vh></v>
<v t="T1615"><vh>v.sortChildren</vh></v>
</v>
<v t="T1616"><vh>Helper functions</vh>
<v t="T1617"><vh>v.addTreeToJoinLists (new in 3.12 beta 2)</vh></v>
<v t="T1618"><vh>v.cloneTree</vh></v>
<v t="T1619"><vh>v.copyCloneBitsTo</vh></v>
<v t="T1620"><vh>v.copyTree</vh></v>
<v t="T1621"><vh>v.copyTreeWithNewTnodes (new after 3.11.1) (not used at present)</vh></v>
<v t="T1622"><vh>v.createDependents</vh></v>
<v t="T1623"><vh>v.destroyDependents</vh></v>
<v t="T1624"><vh>v.destroyTree (does nothing!)(Called only from destroy dependents)</vh></v>
<v t="T1625"><vh>v.invalidOutline</vh></v>
<v t="T1626"><vh>v.joinNodeTo (rewritten for 4.0)</vh></v>
<v t="T1627"><vh>v.joinTreeTo</vh></v>
<v t="T1628"><vh>v.shouldBeClone</vh></v>
<v t="T1629"><vh>v.unjoinTree</vh></v>
<v t="T1630"><vh>v.unlink</vh></v>
<v t="T1631"><vh>validateOutlineWithParent</vh>
<v t="T1632"><vh>&lt;&lt; validate parent ivar &gt;&gt;</vh></v>
<v t="T1633"><vh>&lt;&lt; validate childIndex ivar &gt;&gt;</vh></v>
<v t="T1634"><vh>&lt;&lt; validate x ivar &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="T1635" tnodeList="1635"><vh>@file c:\prog\test\leoPlugins.py</vh>
<v t="T1636"><vh>loadHandlers</vh></v>
<v t="T1637"><vh>doHandlersForTag</vh></v>
<v t="T1638"><vh>registerHandler</vh></v>
<v t="T1639"><vh>registerExclusiveHandler</vh></v>
<v t="T1640"><vh>funcToMethod</vh></v>
</v>
<v t="T1641" tnodeList="1641,1642,1643,1644,1645,1646,1647,1648,1649,1650,1652,1653,1654,1655,1656,1656"><vh>@file c:\prog\test\leoPrefs.py</vh>
<v t="T1642"><vh>prefs.__init__</vh>
<v t="T1643"><vh>&lt;&lt; Set ivars &gt;&gt;</vh></v>
<v t="T1644"><vh>&lt;&lt; Create the Global Options frame &gt;&gt;</vh></v>
<v t="T1645"><vh>&lt;&lt; Create the Tangle Options frame &gt;&gt;</vh></v>
<v t="T1646"><vh>&lt;&lt; Create the Target Language frame &gt;&gt;</vh></v>
<v t="T1647"><vh>&lt;&lt; Create the Ok, Cancel &amp; Revert buttons &gt;&gt;</vh></v>
</v>
<v t="T1648"><vh>prefs.init</vh>
<v t="T1649"><vh>&lt;&lt; remember values for revert &gt;&gt;</vh></v>
<v t="T1650"><vh>&lt;&lt; set widgets &gt;&gt;</vh></v>
</v>
<v t="T1651"><vh>Event handlers</vh>
<v t="T1652"><vh>prefs.set_ivars &amp; idle_set_ivars &amp; print_ivars</vh>
<v t="T1653"><vh>&lt;&lt; update ivars &gt;&gt;</vh></v>
</v>
<v t="T1654"><vh>set_lang</vh></v>
<v t="T1655"><vh>prefs.onOK, onCancel, onRevert</vh>
<v t="T1656"><vh>&lt;&lt; restore options &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T1657" tnodeList="1657,1658,1659"><vh>@file c:\prog\test\leoTangle.py</vh>
<v t="T1658"><vh>&lt;&lt; About Tangle and Untangle &gt;&gt;</vh></v>
<v t="T1659"><vh>&lt;&lt; constants &amp; synonyms &gt;&gt;</vh></v>
<v t="T1660"><vh>node classes</vh>
<v t="T1661"><vh>class tst_node</vh>
<v t="T1662"><vh>tst_node.__init__</vh></v>
<v t="T1663"><vh>tst_node.__repr__</vh></v>
</v>
<v t="T1664"><vh>class part_node</vh>
<v t="T1665"><vh>part_node.__init__</vh></v>
<v t="T1666"><vh>part_node.__repr__</vh></v>
</v>
<v t="T1667"><vh>class ust_node</vh>
<v t="T1668"><vh>ust_node.__init__</vh></v>
<v t="T1669"><vh>ust_node.__repr__</vh></v>
</v>
<v t="T1670"><vh>class def_node</vh>
<v t="T1671"><vh>def_node.__init__</vh></v>
<v t="T1672"><vh>def_node.__repr__</vh></v>
</v>
<v t="T1673"><vh>class root_attributes (Stephen P. Schaefer)</vh>
<v t="T1674"><vh>root_attributes.__init__</vh>
<v t="T1675"><vh>&lt;&lt; trace the state &gt;&gt;</vh></v>
</v>
<v t="T1676"><vh>root_attributes.__repr__</vh></v>
</v>
</v>
<v t="T1677"><vh>class tangleCommands methods</vh>
<v t="T1678"><vh>tangle.__init__</vh></v>
<v t="T1679"><vh>tangle.init_ivars &amp; init_directive_ivars</vh>
<v t="T1680"><vh>&lt;&lt; init tangle ivars &gt;&gt;</vh></v>
<v t="T1681"><vh>&lt;&lt; init untangle ivars &gt;&gt;</vh></v>
<v t="T1682"><vh>&lt;&lt; init directive ivars &gt;&gt; (tangle)</vh></v>
</v>
<v t="T1683"><vh>top level</vh>
<v t="T1684"><vh>cleanup</vh>
<v t="T1685"><vh>&lt;&lt; call tangle_done.run() or untangle_done.run() &gt;&gt;</vh></v>
</v>
<v t="T1686"><vh>initTangleCommand</vh></v>
<v t="T1687"><vh>initUntangleCommand</vh></v>
<v t="T1688"><vh>tangle</vh></v>
<v t="T1689"><vh>tangleAll</vh></v>
<v t="T1690"><vh>tangleMarked</vh></v>
<v t="T1691"><vh>tanglePass1</vh></v>
<v t="T1692"><vh>tanglePass2</vh></v>
<v t="T1693"><vh>tangleTree (calls cleanup)</vh></v>
<v t="T1694"><vh>untangle</vh></v>
<v t="T1695"><vh>untangleAll</vh></v>
<v t="T1696"><vh>untangleMarked</vh></v>
<v t="T1697"><vh>untangleRoot (calls cleanup)</vh>
<v t="T1698"><vh>&lt;&lt; return if @silent or unknown language &gt;&gt;</vh></v>
<v t="T1699"><vh>&lt;&lt; Set path &amp; root_name to the file specified in the @root directive &gt;&gt;</vh></v>
<v t="T1700"><vh>&lt;&lt; Read the file into file_buf  &gt;&gt;</vh></v>
<v t="T1701"><vh>&lt;&lt; Pass 2:  Untangle the outline using the UST and a newly-created TST &gt;&gt;</vh></v>
</v>
<v t="T1702"><vh>untangleTree</vh>
<v t="T1703"><vh>&lt;&lt; set end to the next root in the unit &gt;&gt;</vh></v>
</v>
</v>
<v t="T1704"><vh>tangle</vh>
<v t="T1705"><vh>Pass 1</vh>
<v t="T1706"><vh>handle_newline</vh></v>
<v t="T1707"><vh>skip_body</vh>
<v t="T1708"><vh>The interface between tangle and untangle</vh>
<v t="T1709"><vh>&lt;&lt; Define a section containing only an @doc part &gt;&gt;</vh></v>
<v t="T1710"><vh>&lt;&lt; Define a section for a leading code part &gt;&gt;</vh></v>
<v t="T1711"><vh>&lt;&lt; Scan and define a section definition &gt;&gt;</vh></v>
<v t="T1712"><vh>&lt;&lt; Scan and define an @code defininition &gt;&gt;</vh></v>
<v t="T1713"><vh>&lt;&lt; Scan and define a root section &gt;&gt;</vh></v>
</v>
</v>
<v t="T1714"><vh>skip_code</vh>
<v t="T1715"><vh>&lt;&lt; skip a noweb code section &gt;&gt;</vh>
<v t="T1716"><vh>&lt;&lt; handle possible noweb section reference &gt;&gt;</vh></v>
</v>
<v t="T1717"><vh>&lt;&lt; skip a CWEB code section &gt;&gt;</vh>
<v t="T1718"><vh>&lt;&lt; handle CWEB control code &gt;&gt;</vh></v>
</v>
</v>
<v t="T1719"><vh>skip_doc</vh></v>
<v t="T1720"><vh>skip_headline</vh></v>
</v>
<v t="T1721"><vh>Pass 2</vh>
<v t="T1722"><vh>oblank, oblanks, os, otab, otabs (Tangle)</vh></v>
<v t="T1723"><vh>tangle.put_all_roots</vh>
<v t="T1724"><vh>&lt;&lt;Get root specific attributes&gt;&gt;</vh></v>
<v t="T1725"><vh>&lt;&lt;Put @first lines&gt;&gt;</vh></v>
<v t="T1726"><vh>&lt;&lt;Write a banner at the start of the output file&gt;&gt;</vh></v>
<v t="T1727"><vh>&lt;&lt; Erase the temporary file &gt;&gt;</vh></v>
</v>
<v t="T1728"><vh>put_code</vh>
<v t="T1729"><vh>&lt;&lt;put possible section reference &gt;&gt;</vh></v>
<v t="T1730"><vh>&lt;&lt; handle 2-character CWEB control codes &gt;&gt;</vh></v>
<v t="T1731"><vh>&lt;&lt; handle noweb @ &lt; &lt; convention &gt;&gt;</vh></v>
</v>
<v t="T1732"><vh>put_doc</vh>
<v t="T1733"><vh>&lt;&lt;put the doc part&gt;&gt;</vh>
<v t="T1734"><vh>&lt;&lt;output or skip whitespace or newlines&gt;&gt;</vh></v>
<v t="T1735"><vh>&lt;&lt;compute the width of the next word&gt;&gt;</vh></v>
<v t="T1736"><vh>&lt;&lt;output next word&gt;&gt;</vh></v>
</v>
</v>
<v t="T1737"><vh>put_leading_ws</vh></v>
<v t="T1738"><vh>put_newline</vh>
<v t="T1739"><vh>&lt;&lt; Output leading white space except for blank lines &gt;&gt;</vh></v>
</v>
<v t="T1740"><vh>put_part_node</vh></v>
<v t="T1741"><vh>put_section</vh>
<v t="T1742"><vh>&lt;&lt; Calculate the new value of tangle_indent &gt;&gt;</vh></v>
<v t="T1743"><vh>&lt;&lt; Set 'newline_flag' if the line ends with the reference &gt;&gt;</vh></v>
<v t="T1744"><vh>&lt;&lt;put all parts of the section definition&gt;&gt;</vh>
<v t="T1745"><vh>&lt;&lt; Put the section name in a comment &gt;&gt;</vh>
<v t="T1746"><vh>&lt;&lt; put ( n of m ) &gt;&gt;</vh></v>
</v>
<v t="T1747"><vh>&lt;&lt; Put the ending comment &gt;&gt;</vh></v>
</v>
<v t="T1748"><vh>&lt;&lt;Put a comment about the undefined section&gt;&gt;</vh></v>
</v>
<v t="T1749"><vh>section_check</vh></v>
</v>
</v>
<v t="T1750"><vh>tst</vh>
<v t="T1751"><vh>st_check</vh></v>
<v t="T1752"><vh>st_dump</vh></v>
<v t="T1753"><vh>st_dump_node</vh></v>
<v t="T1754"><vh>st_enter</vh>
<v t="T1755"><vh>&lt;&lt;check for duplicate code definitions &gt;&gt;</vh></v>
<v t="T1756"><vh>&lt;&lt;remember root node attributes&gt;&gt;</vh></v>
</v>
<v t="T1757"><vh>st_enter_root_name</vh></v>
<v t="T1758"><vh>st_enter_section_name</vh></v>
<v t="T1759"><vh>st_lookup</vh></v>
</v>
<v t="T1760"><vh>ust</vh>
<v t="T1761"><vh>ust_dump</vh></v>
<v t="T1762"><vh>ust_enter</vh>
<v t="T1763"><vh>&lt;&lt; remove blank lines from the start and end of the text &gt;&gt;</vh></v>
</v>
<v t="T1764"><vh>ust_lookup</vh></v>
<v t="T1765"><vh>ust_warn_about_orphans</vh></v>
</v>
<v t="T1766"><vh>untangle</vh>
<v t="T1767"><vh>compare_comments</vh>
<v t="T1768" a="C"><vh>&lt;&lt; Check both parts for @ comment conventions &gt;&gt;</vh></v>
</v>
<v t="T1769"><vh>massage_block_comment (no longer used)</vh></v>
<v t="T1770"><vh>forgiving_compare</vh>
<v t="T1771"><vh>&lt;&lt; Define forgiving_compare vars &gt;&gt;</vh></v>
<v t="T1768" a="C"><vh>&lt;&lt; Check both parts for @ comment conventions &gt;&gt;</vh></v>
<v t="T1772"><vh>&lt;&lt; Compare non-critical newlines &gt;&gt;</vh></v>
<v t="T1773"><vh>&lt;&lt; Compare non-critical whitespace &gt;&gt;</vh></v>
<v t="T1774"><vh>&lt;&lt; Compare possible preprocessor directives &gt;&gt;</vh>
<v t="T1775" a="C"><vh>&lt;&lt; Compare single characters &gt;&gt;</vh></v>
<v t="T1776"><vh>&lt;&lt; Compare preprocessor directives &gt;&gt;</vh></v>
</v>
<v t="T1777"><vh>&lt;&lt; Compare possible strings &gt;&gt;</vh>
<v t="T1775" a="C"><vh>&lt;&lt; Compare single characters &gt;&gt;</vh></v>
<v t="T1778"><vh>&lt;&lt; Compare C strings &gt;&gt;</vh></v>
<v t="T1779"><vh>&lt;&lt; Compare Pascal strings &gt;&gt;</vh></v>
</v>
<v t="T1780"><vh>&lt;&lt; Compare possible section references &gt;&gt;</vh></v>
<v t="T1781"><vh>&lt;&lt; Compare comments or single characters &gt;&gt;</vh>
<v t="T1775" a="C"><vh>&lt;&lt; Compare single characters &gt;&gt;</vh></v>
</v>
<v t="T1782"><vh>&lt;&lt; Make sure both parts have ended &gt;&gt;</vh></v>
<v t="T1783"><vh>&lt;&lt; Trace the mismatch &gt;&gt;</vh></v>
</v>
<v t="T1784"><vh>mismatch</vh></v>
<v t="T1785"><vh>scan_derived_file (pass 1)</vh>
<v t="T1786"><vh>&lt;&lt; set the private global matching vars &gt;&gt;</vh></v>
<v t="T1787"><vh>&lt;&lt; Skip the header line output by tangle &gt;&gt;</vh></v>
<v t="T1788"><vh>&lt;&lt; handle the start of a new line &gt;&gt;</vh></v>
<v t="T1789"><vh>&lt;&lt; handle a sentinel line &gt;&gt;</vh>
<v t="T1790"><vh>&lt;&lt; terminate the previous part of this section if it exists &gt;&gt;</vh></v>
</v>
<v t="T1791"><vh>&lt;&lt; copy the entire line &gt;&gt;</vh></v>
<v t="T1792"><vh>&lt;&lt; copy a string &gt;&gt;</vh></v>
<v t="T1793"><vh>&lt;&lt; copy a multi-line comment &gt;&gt;</vh></v>
<v t="T1794"><vh>&lt;&lt; copy an alternate multi-line comment &gt;&gt;</vh></v>
<v t="T1795"><vh>&lt;&lt; end all open sections &gt;&gt;</vh></v>
</v>
<v t="T1796"><vh>update_def (pass 2)</vh>
<v t="T1797"><vh>&lt;&lt; Remove leading blank lines and comments from ucode &gt;&gt;</vh></v>
</v>
<v t="T1798"><vh>update_current_vnode</vh></v>
</v>
<v t="T1799"><vh>utility methods</vh>
<v t="T1800"><vh>compare_section_names</vh></v>
<v t="T1801"><vh>copy</vh></v>
<v t="T1802"><vh>error, pathError, warning</vh></v>
<v t="T1803"><vh>is_end_of_directive</vh></v>
<v t="T1804"><vh>is_end_of_string</vh></v>
<v t="T1805"><vh>is_escaped</vh></v>
<v t="T1806"><vh>is_section_name</vh></v>
<v t="T1807"><vh>is_sentinel_line &amp; is_sentinel_line_with_data</vh>
<v t="T1808"><vh>&lt;&lt; Initialize the return values  &gt;&gt;</vh></v>
<v t="T1809"><vh>&lt;&lt; Make sure the line starts with start_sentinel &gt;&gt;</vh></v>
<v t="T1810"><vh>&lt;&lt; Set end_flag if we have -- end -- &gt;&gt;</vh></v>
<v t="T1811"><vh>&lt;&lt; Make sure we have a section reference &gt;&gt;</vh></v>
<v t="T1812"><vh>&lt;&lt; Set part and of if they exist &gt;&gt;</vh></v>
<v t="T1813"><vh>&lt;&lt; Set nl_flag to false if !newline exists &gt;&gt;</vh></v>
<v t="T1814"><vh>&lt;&lt; Make sure the line ends with end_sentinel &gt;&gt;</vh></v>
</v>
<v t="T1815"><vh>push_new_def_node</vh></v>
<v t="T1816"><vh>scan_short_val</vh></v>
<v t="T1817"><vh>setRootFromHeadline</vh></v>
<v t="T1818"><vh>setRootFromText</vh></v>
<v t="T1819"><vh>skip_CWEB_section_name</vh></v>
<v t="T1820"><vh>skip_noweb_section_name</vh></v>
<v t="T1821"><vh>skip_section_name</vh></v>
<v t="T1822"><vh>standardize_name</vh></v>
<v t="T1823"><vh>tangle.scanAllDirectives</vh>
<v t="T1824"><vh>&lt;&lt; Collect @first attributes &gt;&gt;</vh></v>
<v t="T1825"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="T1826"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="T1827"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="T1828"><vh>&lt;&lt; Test for print modes directives &gt;&gt;</vh></v>
<v t="T1829"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="T1830"><vh>&lt;&lt; compute dir and relative_path from s[k:] &gt;&gt;</vh></v>
<v t="T1831"><vh>&lt;&lt; handle absolute @path &gt;&gt;</vh></v>
</v>
<v t="T1832"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="T1833"><vh>&lt;&lt; Test for @root &gt;&gt;</vh></v>
<v t="T1834"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="T1835"><vh>&lt;&lt; Test for @header and @noheader &gt;&gt;</vh></v>
<v t="T1836"><vh>&lt;&lt; Set self.tangle_directory &gt;&gt;</vh>
<v t="T1837"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
</v>
<v t="T1838"><vh>token_type</vh>
<v t="T1839"><vh>&lt;&lt; set token_type in noweb mode &gt;&gt;</vh></v>
<v t="T1840"><vh>&lt;&lt; set token_type for CWEB mode &gt;&gt;</vh></v>
<v t="T1841"><vh>&lt;&lt; set kind for directive &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="T1842" tnodeList="1842,1843,1844,1845,1847,1848,1849,1851,1852,1853,1854,1856,1857,1858,1859,1860,1861,1862,1863,1864,1865,1866,1867,1868,1869,1870,1871,1872,1873,1874,1875,1876,1877,1878,1879,1880,1881,1882,1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899,1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,1921,1922,1923,1925,1926,1927,1928,1929,1930,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,1942,1943,1944,1945,1946,1947,1948,1949,1950"><vh>@file c:\prog\test\leoTree.py</vh>
<v t="T1843"><vh>&lt;&lt; about the tree classes &gt;&gt;</vh></v>
<v t="T1844"><vh>&lt;&lt; About drawing and events &gt;&gt;</vh></v>
<v t="T1845"><vh>&lt;&lt; drawing constants &gt;&gt;</vh></v>
<v t="T1846"><vh>Birth &amp; death</vh>
<v t="T1847"><vh>tree.__init__</vh></v>
<v t="T1848"><vh>tree.deleteBindings</vh></v>
<v t="T1849"><vh>tree.deleteWidgets</vh></v>
</v>
<v t="T1850"><vh>Drawing</vh>
<v t="T1851"><vh>About drawing and updating</vh></v>
<v t="T1852"><vh>beginUpdate</vh></v>
<v t="T1853"><vh>drawBox (tag_bind)</vh></v>
<v t="T1854"><vh>drawIcon (tag_bind)</vh></v>
<v t="T1855"><vh>Drawing routines (tree)...</vh>
<v t="T1856"><vh>redraw</vh></v>
<v t="T1857"><vh>force_redraw</vh></v>
<v t="T1858"><vh>redraw_now</vh></v>
<v t="T1859"><vh>idle_redraw</vh></v>
<v t="T1860"><vh>idle_second_redraw</vh></v>
</v>
<v t="T1861"><vh>drawNode &amp; force_draw_node</vh></v>
<v t="T1862"><vh>drawText (bind)</vh>
<v t="T1863"><vh>&lt;&lt; configure the text depending on state &gt;&gt;</vh></v>
</v>
<v t="T1864"><vh>drawTree</vh>
<v t="T1865"><vh>&lt;&lt; draw vertical line &gt;&gt;</vh></v>
</v>
<v t="T1866"><vh>endUpdate</vh></v>
<v t="T1867"><vh>headWidth</vh></v>
<v t="T1868"><vh>inVisibleArea &amp; inExpandedVisibleArea</vh></v>
<v t="T1869"><vh>lastVisible</vh></v>
<v t="T1870"><vh>setLineHeight</vh></v>
<v t="T1871"><vh>tree.getFont,setFont,setFontFromConfig</vh></v>
<v t="T1872"><vh>tree.getIconImage</vh></v>
<v t="T1873"><vh>tree.idle_scrollTo</vh></v>
<v t="T1874"><vh>tree.numberOfVisibleNodes</vh></v>
<v t="T1875"><vh>tree.recolor, recolor_now, recolor_range</vh></v>
<v t="T1876"><vh>tree.yoffset</vh></v>
</v>
<v t="T1877"><vh>Event handers (tree)</vh>
<v t="T1878"><vh>OnActivate</vh>
<v t="T1879"><vh>&lt;&lt; activate this window &gt;&gt;</vh></v>
</v>
<v t="T1880"><vh>OnBoxClick</vh></v>
<v t="T1881"><vh>tree.OnDeactivate (caused double-click problem)</vh></v>
<v t="T1882"><vh>tree.findVnodeWithIconId</vh></v>
<v t="T1883"><vh>body key handlers (tree)</vh>
<v t="T1884"><vh>idle_body_key</vh>
<v t="T1885"><vh>&lt;&lt; set s to the widget text &gt;&gt;</vh></v>
<v t="T1886"><vh>&lt;&lt; return if nothing has changed &gt;&gt;</vh></v>
<v t="T1887"><vh>&lt;&lt; set removeTrailing &gt;&gt;</vh></v>
<v t="T1888"><vh>&lt;&lt; Do auto indent &gt;&gt; (David McNab)</vh></v>
<v t="T1889"><vh>&lt;&lt; convert tab to blanks &gt;&gt;</vh></v>
<v t="T1890"><vh>&lt;&lt; set s to widget text, removing trailing newlines if necessary &gt;&gt;</vh></v>
<v t="T1891"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="T1892"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
</v>
<v t="T1893"><vh>onBodyChanged</vh></v>
<v t="T1894"><vh>OnBodyKey</vh></v>
<v t="T1895"><vh>onBodyWillChange</vh></v>
</v>
<v t="T1896"><vh>tree.OnContinueDrag</vh>
<v t="T1897"><vh>&lt;&lt; continue dragging &gt;&gt;</vh>
<v t="T1898"><vh>&lt;&lt; scroll the canvas as needed &gt;&gt;</vh></v>
</v>
</v>
<v t="T1899"><vh>tree.OnCtontrolT</vh></v>
<v t="T1900"><vh>tree.OnDrag</vh></v>
<v t="T1901"><vh>tree.OnEndDrag</vh>
<v t="T1902"><vh>&lt;&lt; set vdrag, childFlag &gt;&gt;</vh></v>
</v>
<v t="T1903"><vh>headline key handlers (tree)</vh>
<v t="T1904"><vh>onHeadChanged</vh></v>
<v t="T1905"><vh>OnHeadlineKey</vh></v>
<v t="T1906"><vh>idle_head_key</vh>
<v t="T1907"><vh>&lt;&lt; set s to the widget text &gt;&gt;</vh></v>
<v t="T1908"><vh>&lt;&lt; set head to vnode text &gt;&gt;</vh></v>
<v t="T1909"><vh>&lt;&lt; update v and all nodes joined to v &gt;&gt;</vh></v>
<v t="T1910"><vh>&lt;&lt; reconfigure v and all nodes joined to v &gt;&gt;</vh></v>
<v t="T1911"><vh>&lt;&lt; update the screen &gt;&gt;</vh></v>
</v>
</v>
<v t="T1912"><vh>tree.OnIconClick &amp; OnIconRightClick</vh></v>
<v t="T1913"><vh>tree.OnIconDoubleClick (@url)</vh>
<v t="T1914"><vh>&lt;&lt; stop the url after any whitespace  &gt;&gt;</vh></v>
<v t="T1915"><vh>&lt;&lt; check the url; return if bad &gt;&gt;</vh></v>
<v t="T1916"><vh>&lt;&lt; pass the url to the web browser &gt;&gt;</vh></v>
</v>
<v t="T1917"><vh>tree.OnPopup &amp; allies</vh>
<v t="T1918"><vh>OnPopupFocusLost</vh></v>
<v t="T1919"><vh>createPopupMenu</vh>
<v t="T1920"><vh>&lt;&lt; Create the menu table &gt;&gt;</vh></v>
</v>
<v t="T1921"><vh>enablePopupMenuItems</vh>
<v t="T1922"><vh>&lt;&lt; set isAtRoot and isAtFile if v's tree contains @root or @file nodes &gt;&gt;</vh></v>
</v>
<v t="T1923"><vh>showPopupMenu</vh></v>
</v>
</v>
<v t="T1924"><vh>Incremental drawing</vh>
<v t="T1925"><vh>allocateNodes</vh></v>
<v t="T1926"><vh>allocateNodesBeforeScrolling</vh></v>
<v t="T1927"><vh>updateNode</vh></v>
<v t="T1928"><vh>setVisibleAreaToFullCanvas</vh></v>
<v t="T1929"><vh>setVisibleArea</vh></v>
<v t="T1930"><vh>tree.updateTree</vh></v>
</v>
<v t="T1931"><vh>Selecting &amp; editing (tree)</vh>
<v t="T1932"><vh>abortEditLabelCommand</vh></v>
<v t="T1933"><vh>dimEditLabel, undimEditLabel</vh></v>
<v t="T1934"><vh>editLabel</vh></v>
<v t="T1935"><vh>endEditLabel &amp; endEditLabelCommand</vh></v>
<v t="T1936"><vh>tree.expandAllAncestors</vh></v>
<v t="T1937"><vh>tree.scanForTabWidth</vh>
<v t="T1938"><vh>&lt;&lt; set w and break on @tabwidth &gt;&gt;</vh></v>
</v>
<v t="T1939"><vh>tree.select</vh>
<v t="T1940"><vh>&lt;&lt; define vars and stop editing &gt;&gt;</vh></v>
<v t="T1941"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="T1942"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="T1943"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="T1944"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="T1945"><vh>&lt;&lt; set the current node and redraw &gt;&gt;</vh></v>
</v>
<v t="T1946"><vh>tree.set...LabelState</vh>
<v t="T1947"><vh>&lt;&lt; set editing headline colors &gt;&gt;</vh></v>
<v t="T1948"><vh>&lt;&lt; set selected, disabled headline colors &gt;&gt;</vh></v>
<v t="T1949"><vh>&lt;&lt; set unselected headline colors &gt;&gt;</vh></v>
</v>
</v>
<v t="T1950"><vh>tree.moveUpDown</vh></v>
</v>
<v t="T1951" tnodeList="1951,1952,1953,1954,1955,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1971,1970,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1983,1982,1984,1985,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998"><vh>@file c:\prog\test\leoUndo.py</vh>
<v t="T1952"><vh>&lt;&lt; How Leo implements unlimited undo &gt;&gt;</vh></v>
<v t="T1953"><vh>&lt;&lt; Define optional ivars &gt;&gt;</vh></v>
<v t="T1954"><vh>undo.__init__ &amp; clearIvars</vh>
<v t="T1955"><vh>clearIvars</vh></v>
</v>
<v t="T1956"><vh>State routines...</vh>
<v t="T1957"><vh>clearUndoState</vh></v>
<v t="T1958"><vh>canRedo &amp; canUndo</vh></v>
<v t="T1959"><vh>enableMenuItems</vh></v>
<v t="T1960"><vh>getBead, peekBead, setBead</vh></v>
<v t="T1961"><vh>redoMenuName, undoMenuName</vh></v>
<v t="T1962"><vh>setRedoType, setUndoType</vh></v>
<v t="T1963"><vh>setUndoParams</vh></v>
<v t="T1964"><vh>setUndoTypingParams</vh>
<v t="T1965"><vh>&lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;</vh></v>
<v t="T1966"><vh>&lt;&lt; save undo text info &gt;&gt;</vh></v>
</v>
<v t="T1967"><vh>setUndoTypes</vh></v>
</v>
<v t="T1968"><vh>u.redo</vh>
<v t="T1969"><vh>&lt;&lt; redo clone cases &gt;&gt;</vh></v>
<v t="T1970"><vh>&lt;&lt; redo delete cases &gt;&gt;</vh></v>
<v t="T1971"><vh>&lt;&lt; redo insert cases &gt;&gt;</vh></v>
<v t="T1972"><vh>&lt;&lt; redo move &amp; drag cases &gt;&gt;</vh></v>
<v t="T1973"><vh>&lt;&lt; redo promote and demote cases &gt;&gt;</vh></v>
<v t="T1974"><vh>&lt;&lt; redo replace cases &gt;&gt;</vh></v>
<v t="T1975"><vh>&lt;&lt; redo sort cases &gt;&gt;</vh></v>
<v t="T1976"><vh>&lt;&lt; redo typing cases &gt;&gt;</vh></v>
</v>
<v t="T1977"><vh>u.undo</vh>
<v t="T1978"><vh>&lt;&lt; undo clone cases &gt;&gt;</vh></v>
<v t="T1979"><vh>&lt;&lt; undo delete cases &gt;&gt;</vh></v>
<v t="T1980"><vh>&lt;&lt; undo insert cases &gt;&gt;</vh></v>
<v t="T1981"><vh>&lt;&lt; undo move  &amp; drag cases &gt;&gt;</vh></v>
<v t="T1982"><vh>&lt;&lt; undo replace cases &gt;&gt;</vh></v>
<v t="T1983"><vh>&lt;&lt; undo promote and demote cases &gt;&gt;</vh></v>
<v t="T1984"><vh>&lt;&lt; undo sort cases &gt;&gt;</vh></v>
<v t="T1985"><vh>&lt;&lt; undo typing cases &gt;&gt;</vh></v>
</v>
<v t="T1986"><vh>Undo helpers</vh>
<v t="T1987"><vh>findSharedVnode</vh></v>
<v t="T1988"><vh>undoDemote</vh></v>
<v t="T1989"><vh>undoPromote</vh></v>
<v t="T1990"><vh>undoReplace</vh></v>
<v t="T1991"><vh>undoRedoText</vh>
<v t="T1992"><vh>&lt;&lt; Incrementally update the Tk.Text widget &gt;&gt;</vh></v>
<v t="T1993"><vh>&lt;&lt; Compute the result using v's body text &gt;&gt;</vh></v>
<v t="T1994"><vh>&lt;&lt; Get textResult from the Tk.Text widget &gt;&gt;</vh></v>
<v t="T1995"><vh>&lt;&lt; print mismatch trace &gt;&gt;</vh></v>
</v>
<v t="T1996"><vh>undoSortChildren</vh></v>
<v t="T1997"><vh>undoSortSiblings</vh></v>
<v t="T1998"><vh>undoSortTopLevel</vh></v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="T1">@color

# **** Run this from test.leo ****

# Run pychecker from idle.
if 1:
	import pychecker.checker
	import leo
@nocolor
Documentation
	- Update readme.txt
	- Update LeoDocs.leo
	- Update web site.
Version numbers
	- Update version number in Help menu.
	- Update version number in setup.py (@ignore'd!!)
@color

if 1: # Save all files and tangle leoConfig.leo
	from leoGlobals import importFromPath
	preSetup = importFromPath("preSetup","c:\prog\leoCvs\leo")
	preSetup.setup()

if 1: # Replace config settings and create .zip file.
	import os
	os.system(r"c:\python22\python c:\prog\leoCvs\leo\setup.py sdist --formats=zip")

@nocolor
Create and test leosetup.exe.
	- Create leosetup.exe by right-clicking leo.nsi and choosing "compile with NSI (bz2)"
	- Test created leosetup.exe file.
	- test the files created in c:\program files\leo
Create Release on SourceForge
Uploads
    - Upload leodocs.zip
	- Upload leosetup.exe
	- Upload leo-x-y.zip
	- Upload sbook.chm if it has been changed.
Announcements
	- Announce to SourceForge itself. USE ANNOUNCEMENT FORMAT, not readme format.
	- Announce to Leo's SourceForce site.
	- Announce to comp.lang.python
	- Announce to comp.programming.literate</t>
<t tx="T2">@color

# These scripts are now intended to be run only from here.

if 1: # Save all files and tangle leoConfig.leo
	from leoGlobals import importFromPath
	preSetup = importFromPath("preSetup","c:\prog\leoCvs\leo")
	preSetup.setup()

if 1: # Replace config settings and create .zip file.
	import os
	os.system(r"c:\python22\python c:\prog\leoCvs\leo\setup.py sdist --formats=zip")</t>
<t tx="T3"></t>
<t tx="T4">@nocolor

Personally, I nominate timeit.py as THE outstanding enhancement of Python 2.3
-- I love many of the others (the performance improvement in particular), but
timeit.py is the one I find myself using all of the time -- seems to provide an
innocuous way for programmers' typical obsession with performance and
micro-optimization to discharge itself harmlessly, cleansing their souls to
choose idioms on the basis of clarity, maintainability and readability, as of
course SHOULD be done :-)</t>
<t tx="T5"># Empty tuples are constructed by an empty pair of parentheses.
# tuple with one item is constructed by following a value with a comma.
# Examples:

# empty = ()
# singleton = 'hello',    # &lt;-- note trailing comma

s = "abc",

for i in s:
	print `i`
	
s = {"x":1, "y":2},

for i in s:
	print `i`</t>
<t tx="T6">import ImageGrab,os # requires PIL 1.1.3 or later

path = os.path.join(app().loadDir,"../","test","screenshot.gif")

ImageGrab.grab().save(path)
</t>
<t tx="T7">@ignore</t>
<t tx="T8"></t>
<t tx="T9"></t>
<t tx="T10">@nocolor

Read and respond to this message at: 
http://sourceforge.net/forum/message.php?msg_id=1719215
By: nobody

Ok, it seems to be in the code I copied in. I tried it with a second Node, and
don't have the trouble.

Console Mode gives the following:

Traceback (most recent call last):
File "d:\language\literate programming\Leo\leoColor.py", line 830,
in colorizeAnyLanguage
    i,state = func(s,i,n)

File "d:\language\literate programming\Leo\leoColor.py", line 934,
in continueBlockComment
    j = string.find(s,self.block_comment_end,i)

File "D:\LANGUAGE\PYTHON\lib\string.py", line 174, in find
    return s.find(*args)

TypeError: expected a character buffer object

The line, "#define WIPEOUT 0 /* " seems to be the problem child -- if I move
the start-of-comment marker to the next line, the error message goes away; however,
the lines between the '/*' and '*/' are NOT comment-colored...

--Rich
</t>
<t tx="T11">@language c
@comment /* */
@path .
@ignore

&lt;&lt; Defines &gt;&gt;
&lt;&lt; Head &gt;&gt;</t>
<t tx="T12">@
@c

#define WIPEOUT 0 /* 
                   * Causes database card number &amp; flags to be set to zero. 
                   * This is so I don't need an infinite supply of cards!
                   */
// Not colored (because of @language /* */)
#include "equ.h"
#include "cmn.h"
#include "ramdef.h"
#include "eeprom.h"
#include &lt;hpc_ram.h&gt;
#include &lt;rlydef.h&gt;</t>
<t tx="T13"></t>
<t tx="T14">@ Enabling or disabling @language or @comment now recolors entire text.</t>
<t tx="T15">@language c
 @comment /* */

/* comment */
# test</t>
<t tx="T16">@language html
@
To do:

done: use self.tag routine everywhere.
done: convert index to be a method.
done: create self.line_index ivar.  Use it in self.index().
done: remove n param from most routines, especially calls to self.add_tag!
done: complete test of syntax coloring.

- add @language html when importing html file.
</t>
<t tx="T17">@color
@ignore
&lt;HTML&gt;
&lt;!-- Author: Edward K. Ream, edream@tds.net --&gt;
&lt;HEAD&gt;
  &lt;META NAME="GENERATOR" CONTENT="Microsoft FrontPage 4.0"&gt;
  &lt;TITLE&gt; Leo's Home Page &lt;/TITLE&gt;
  &lt;META NAME="description" CONTENT="This page describes Leo.
Leo adds powerful outlines to the noweb and CWEB literate programming languages."&gt;
  &lt;META NAME="keywords" CONTENT="LEO, LITERATE PROGRAMMING, OUTLINES, CWEB,
NOWEB, OUTLINES, EDWARD K. REAM, DONALD E. KNUTH, SILVIO LEVY, OPEN SOFTWARE"&gt;
&lt;/HEAD&gt;
&lt;!-- Last Modified: May 12, 2002 --&gt;
&lt;BODY BGCOLOR="#fffbdc"&gt;

&lt;H1 ALIGN=CENTER&gt;&lt;a NAME="top"&gt;&lt;/a&gt;&lt;IMG SRC="Blank.gif" width=
"32" height="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;IMG SRC="leo.gif" 
WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;a href="leo_TOC.html#top"&gt;&lt;IMG SRC=
"arrow_rt.gif" WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;/a&gt; &amp;nbsp;&lt;/H1&gt;

&lt;H1 ALIGN=CENTER&gt; Leo's Home Page&lt;/H1&gt;

&lt;p align="center"&gt;&lt;a href="http://www.python.org/"&gt;&lt;img border="0" src="PythonPowered.gif" width="110" height="44"&gt; &lt;/a&gt; &lt;A HREF="http://sourceforge.net/"&gt;&lt;IMG SRC="http://sourceforge.net/sflogo.php?group_id=3458&amp;type=1" NATURALSIZEFLAG="0" ALT="SourceForge Logo"&gt;&lt;/A&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;
&lt;A HREF="http://sourceforge.net/project/?group_id=3458"&gt;Leo at SourceForge&lt;/A&gt;&amp;nbsp;&amp;nbsp;
&lt;a href="icons.html"&gt;&lt;img border="0" src="LeoCodeGray.gif" width="77" height="42"&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;
&lt;a href="icons.html"&gt;&lt;img border="0" src="LeoProse.gif" width="81" height="42"&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;

&lt;H3&gt;&lt;A NAME="anchor127554"&gt;&lt;/A&gt;Summary&lt;/H3&gt;

&lt;UL&gt;
  &lt;LI&gt;Leo is a &lt;i&gt; programmer's editor&lt;/i&gt;  and a flexible &lt;i&gt;browser&lt;/i&gt; for
    projects, programs, classes or data. Leo clarifies design, coding, debugging, testing
  and maintenance.
  &lt;LI&gt;Leo is an &lt;i&gt;outlining editor&lt;/i&gt;. Outlines clarify the big picture while
    providing unlimited space for details.
  &lt;LI&gt;Leo
    is a &lt;a HREF="http://www.literateprogramming.com/"&gt;&lt;i&gt;literate
    programming&lt;/i&gt;&lt;/a&gt; tool, compatible with &lt;A HREF="http://www.eecs.harvard.edu/~nr/noweb/"&gt;noweb&lt;/A&gt;
    and &lt;a HREF="http://www-cs-faculty.stanford.edu/~knuth/cweb.html"&gt;CWEB&lt;/a&gt;.
    Leo enhances any text-based
programming language, from assembly language and C to Java, Python and XML.
  &lt;LI&gt;Leo is also a &lt;i&gt;data organizer&lt;/i&gt;. A single Leo outline can generate complex
    data spanning many different files.&amp;nbsp; Leo has been used to manage web sites.
  &lt;LI&gt;Leo is a &lt;i&gt; project manager&lt;/i&gt;. Leo provides multiple views
of a project within a single outline. Leo naturally represents tasks that remain
    up-to-date.
  &lt;LI&gt;Leo is fully &lt;i&gt; scriptable&lt;/i&gt; using &lt;A HREF="http://www.python.org/"&gt;Python&lt;/A&gt;
  and saves its files in &lt;A HREF="http://www.w3.org/XML/"&gt;XML&lt;/A&gt; format.
  &lt;LI&gt;Leo is &lt;i&gt;portable&lt;/i&gt;.&amp;nbsp; Leo.py is 100% pure Python and will run on
    any platform supporting &lt;A HREF="http://www.python.org/"&gt;Python&lt;/A&gt;
    and &lt;a href="http://tcl.activestate.com/"&gt;Tk/tcl&lt;/a&gt;, including Windows,
    Linux and MacOS X.&amp;nbsp; Leo.exe runs on any Windows platform.
  &lt;LI&gt;Leo is &lt;a href="http://www.opensource.org/"&gt; &lt;i&gt; Open Software&lt;/i&gt;&lt;/a&gt;, distributed under
    the &lt;a href="http://www.python.org/doc/Copyright.html"&gt; Python License&lt;/a&gt;.
&lt;/UL&gt;

&lt;H3&gt;More Information and downloads&lt;/H3&gt;

&lt;ul&gt;
  &lt;LI&gt;An excellent &lt;a href="http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm"&gt;online
    tutorial&lt;/a&gt; and &lt;A HREF="http://www.jserv.com/jk_orr/xml/leo.htm"&gt;Leo resource
  page&lt;/A&gt;, both written by &lt;a href="http://www.jserv.com/jk_orr"&gt;Joe Orr&lt;/a&gt;.
  &lt;LI&gt;My brother's &lt;a href="SpeedReam.html"&gt;slashdot
    article about Leo&lt;/a&gt;, the best description about why Leo is special.
  &lt;LI&gt;&lt;A HREF="testimonials.html#anchor104391"&gt;What people are saying about Leo&lt;/A&gt;
  &lt;LI&gt;&lt;A HREF="leo_TOC.html#anchor964914"&gt;Complete users guide&lt;/A&gt;
    and
    &lt;A HREF="intro.html#anchor887874"&gt;tutorial introduction&lt;/A&gt;  with
  screen shots.
  &lt;li&gt;&lt;a href="FAQ.html"&gt;FAQ&lt;/a&gt; and &lt;a href="http://sourceforge.net/forum/?group_id=3458"&gt;help and discussion
    forums&lt;/a&gt;, preferable to &lt;A HREF="mailto:edream@tds.net"&gt;email&lt;/A&gt; so others may join
    in.&lt;/li&gt;
  &lt;li&gt;&lt;a href="icons.html"&gt;Icons&lt;/a&gt; for bragging about Leo.&lt;/li&gt;
&lt;/ul&gt;

&lt;a href="http://sourceforge.net/project/showfiles.php?group_id=3458"&gt;Download
    Leo&lt;/a&gt; from &lt;A HREF="http://sourceforge.net/project/?group_id=3458"&gt;Leo's SourceForge
site&lt;/A&gt;.

&lt;P ALIGN=left&gt;Leo's author is &lt;A HREF="http://personalpages.tds.net/~edream/index.html"&gt;Edward
  K. Ream&lt;/A&gt; email: &lt;A HREF="mailto:edream@tds.net"&gt;edream@tds.net&lt;/A&gt; voice: (608) 231-0766

&lt;HR ALIGN=LEFT&gt;

&lt;p align="center"&gt;

&lt;IMG SRC="Blank.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="34" height="34"&gt;&lt;IMG SRC="leo.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="32" height="32"&gt;&lt;a HREF="leo_TOC.html"&gt;&lt;IMG SRC="arrow_rt.gif" WIDTH="32"
HEIGHT="32" ALIGN="left" NATURALSIZEFLAG="3"&gt;

&lt;/BODY&gt;
&lt;/HTML&gt;
</t>
<t tx="T18">@ignore

@

We need both incremental and full syntax coloring...

We must do a _full_ recoloring when selecting any node, even for two cloned nodes, because the nodes may have different contexts.

Furthermore, at present undo must always do a full recoloring because setBodyStringOrPane just replaces the old text with the new, and that destroys all the coloring tags.  The only possible solution would be to do an "incremental update" in setBodyStringOrPane.  It would also be good to do that in tree.select.

The present code _is_ faster than the old code because it avoids redundant drawing.</t>
<t tx="T19"></t>
<t tx="T20"># This creates a free-floating copy of v's tree for undo.
# The copied trees must use different tnodes than the original.

def copyTree(self,root):

    c = self
    # Create the root vnode.
    result = v = leoNodes.vnode(c,root.t)
        # Copy the headline and icon values v.copyNode(root,v)
        # Copy the rest of tree.
        v.copyTree(root,v)
    # Replace all tnodes in v by copies.
    assert(v.nodeAfterTree() == None)
    while v:
        v.t = leoNodes.tnode(0, v.t.bodyString)
        v = v.threadNext()
    return result
    
# This creates a free-floating copy of v's tree for undo.
# The copied trees must use different tnodes than the original.

def copyTree(self,root):

    c = self
    # Create the root vnode.
    result = v = leoNodes.vnode(c,root.t)

	# Copy the headline and icon values
    v.copyNode(root,v)
    # Copy the rest of tree.
        v.copyTree(root,v)
    # Replace all tnodes in v by copies.
    assert(v.nodeAfterTree() == None)
    while v:
        v.t = leoNodes.tnode(0, v.t.bodyString)
        v = v.threadNext()
    return result</t>
<t tx="T21">@language c</t>
<t tx="T22">@
This is just a test
@c
aprocedure(
	a,
	b )
	{
	printf( "Hello, world\n" );
	return 0;
}

"/* testing */"
@#
bprocedure(
	a,
	b )
	{
	printf( "Hello, world\n" );
	return 0;
}

@#
cprocedure(
	a,
	b )
	{
	printf( "Hello, world\n" );
	return 0;
}

@#
dprocedure(
	a,
	b )
	{
	printf( "Hello, world\n" );
	return 0;
}

@#
int main()
{
  return 0
}</t>
<t tx="T23">Here's another issue

Create a @file node[snip]

You should see the &lt;!-- test --&gt; in 'red' (comment color).

Now backspace over 'html' in the language directive and type 'xml'.  

The bug is that XML is not a valid Leo language but the comment is still 'red'.
If you go to another node and come back it changes back to black type.  Now
change the language back to 'html'.  It doesn't recolorize and the comment remains
black.

This is a nit, really.
</t>
<t tx="T24">@language html
&lt;? xml version="1.0"&gt;
&lt;!-- test --&gt;
&lt;project name="Converter" default="dist"&gt;
&lt;/project&gt;</t>
<t tx="T25">def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:		
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()


</t>
<t tx="T26">"""python
string"""d

'this\
is</t>
<t tx="T27">@language php
@ doc
@c

and or
array
array()
this is a test.
__CLASS__
&lt;?php and or array() ?&gt;
</t>
<t tx="T28">@ignore
@ doc
@c
@language c
	@others

abc
for # comment
# pp
@q comment @&gt; after
// comment
&lt;!-- comment --&gt; after
/* java comment */
{ pascal comment }
% latex comment
xor php keyword
fblocked tcl keyword
synchronized java keyword
\acute latex keyword
alarm perl keyword

# Python single-line comment
// C single-line comment
xx /* C block comment */ yy
xxx """ triple string """ zzz
a 'string' b
c "string" d
// C keywords
switch, case
</t>
<t tx="T29">@markup wiki</t>
<t tx="T30">@language python

""" {picture file=../Icons/Leoapp.GIF}this """ # Problems with correct indexing following a graphic.

""" {picture file=../Icons/Leoapp.GIF}this """ # two copies work.

abc

""" {picture file=../Icons/Leodoc.GIF} """ # xyz


""" continued
string"""

@ ''ab'' __xxx__ ''wx'' __xyz__
@c

# /* ''ab'' __xxx__ ''wx'' __xyz__ */

# Test

""" ''' """ ''' """'''  # Leo handles the common cases correctly.

''' ''ab'' __xxx__ ''wx'' __xyz__ ''' # No wiki markup in ''' strings.

""" ''ab'' __xxx__ ''wx'' __xyz__ """

# ''ab'' __xxx__ ''wx'' __xyz__

""" ''y'' """

""" text~~#ff00ff:some text~~more text""

and if

from leoGlobals import * ; print app().loadDir</t>
<t tx="T31">""" continued
string"""

@ ''ab'' __xxx__ ''wx'' __xyz__  __''bolditalic''__ and ''__italicbold__''
@c

# /* ''ab'' __xxx__ ''wx'' __xyz__ */

__abc__ 

# Test

""" ''' """ ''' """'''  # Leo handles the __b__ common cases correctly.

''' ''ab'' __xxx__ ''wx'' __xyz__ ''' # No wiki markup in ''' strings.

""" ''ab'' __xxx__ ''wx'' __xyz__ """

# ''ab'' __xxx__ ''wx'' __xyz__

""" ''y'' """

""" text~~#ee00ff:some text~~more text"""



and if

from leoGlobals import * ; print app().loadDir
</t>
<t tx="T32">""" text~~red:some text~~more text"""

""" text~~#ee0ff:some text~~more text"""</t>
<t tx="T33">@encoding iso-8859-1</t>
<t tx="T34">@others

This is an umlaute ë</t>
<t tx="T35"></t>
<t tx="T36">----*---*---*---*---*---*
	.	.	.	.	.	
                        
.   ..  ... ....    .   
        .   ..</t>
<t tx="T37"></t>
<t tx="T38"></t>
<t tx="T39">@language actionscript

break
call, continue
delete, do
else
false, for, function
goto
if, in
new, null
return
true, typeof
undefined
var, void, while, with
#include
catch, constructor
prototype
this, try
_parent, _root, __proto__
// Jeeze hasn't anyone ever heard of namespaces??
ASnative, abs, acos, appendChild, asfunction, asin, atan, atan2, attachMovie, attachSound, attributes
BACKSPACE
CAPSLOCK, CONTROL, ceil, charAt, charCodeAt, childNodes, chr, cloneNode, close, concat, connect, cos, createElement, createTextNode
DELETEKEY, DOWN, docTypeDecl, duplicateMovieClip
END, ENTER, ESCAPE, enterFrame, entry, equal, eval, evaluate, exp
firstChild, floor, fromCharCode, fscommand, getAscii
getBeginIndex, getBounds, getBytesLoaded, getBytesTotal, getCaretIndex, getCode, getDate, getDay, getEndIndex, getFocus, getFullYear, getHours, getMilliseconds, getMinutes, getMonth, getPan, getProperty, getRGB, getSeconds, getTime, getTimer, getTimezoneOffset, getTransform, getURL, getUTCDate, getUTCDay, getUTCFullYear, getUTCHours, getUTCMilliseconds, getUTCMinutes, getUTCMonth, getUTCSeconds, getVersion, getVolume, getYear, globalToLocal, gotoAndPlay, gotoAndStop
HOME, haschildNodes, hide, hitTest
INSERT, Infinity, ifFrameLoaded, ignoreWhite, indexOf, insertBefore, int, isDown, isFinite, isNaN, isToggled
join
keycode, keyDown, keyUp
LEFT, LN10, LN2, LOG10E, LOG2E, lastChild, lastIndexOf, length, load, loaded, loadMovie, loadMovieNum, loadVariables, loadVariablesNum, localToGlobal, log
MAX_VALUE, MIN_VALUE, max, maxscroll, mbchr, mblength, mbord, mbsubstring, min, 
NEGATIVE_INFINITY, NaN, newline, nextFrame, nextScene, nextSibling, nodeName, nodeType, nodeValue
on, onClipEvent, onClose, onConnect, onData, onLoad, onXML, ord
PGDN, PGUP, PI, POSITIVE_INFINITY, parentNode, parseFloat, parseInt, parseXML, play, pop, pow, press, prevFrame, previousSibling, prevScene, print, printAsBitmap, printAsBitmapNum, printNum, push
RIGHT, random, release, removeMovieClip, removeNode, reverse, round
SPACE, SQRT1_2, SQRT2, scroll, send, sendAndLoad, set, setDate, setFocus, setFullYear, setHours, setMilliseconds, setMinutes, setMonth, setPan, setProperty, setRGB, setSeconds, setSelection, setTime, setTransform, setUTCDate, setUTCFullYear, setUTCHours, setUTCMilliseconds, setUTCMinutes, setUTCMonth, setUTCSeconds, setVolume, setYear, shift, show, sin, slice, sort, start, startDrag, status, stop, stopAllSounds, stopDrag, substr, substring, swapDepths, splice, split, sqrt
TAB, tan, targetPath, tellTarget, toggleHighQuality, toLowerCase, toString, toUpperCase, trace
UP, UTC, unescape, unloadMovie, unLoadMovieNum, unshift, updateAfterEvent
valueOf
xmlDecl, _alpha
_currentframe
_droptarget
_focusrect, _framesloaded
_height, _highquality
_name
_quality
_rotation
_soundbuftime
_target, _totalframes
_url
_visible
_width
_x, _xmouse, _xscale
_y, _ymouse, _yscale
and, add, eq, ge, gt, le, lt, ne, not, or, Array, Boolean, Color, Date, Key, Math, MovieClip, Mouse, Number, Object, Selection, Sound, String, XML, XMLSocket</t>
<t tx="T40">import gc,Tkinter

# gc.set_debug(gc.DEBUG_STATS)

lastObjectCount = 0

def printGarbage(s):
	global lastObjectCount
	n  = len(gc.garbage)
	n2 = len(gc.get_objects())
	fmt = "%8s garbage: %d, objects:%+6d =%6d"
	print fmt % (s,n,n2-lastObjectCount,n2)
	lastObjectCount = n2

gc.collect()
printGarbage("start 1")
# Create a canvas widget for experimentation.
top = Tkinter.Tk()
frame = Tkinter.Frame(top) ; frame.pack()
canvas = Tkinter.Canvas(frame) ; canvas.pack()
# Allocate and (try to) deallocate widgets in the canvas.
x,y = 10,10
printGarbage("start 2")
for i in xrange(5):
	t = Tkinter.Text(canvas)
	canvas.create_window(x,y,window=t)
	y += 40
	printGarbage(" loop 1")
	t.destroy()
	canvas.delete("all")
	gc.collect() # Nuts...
	printGarbage(" loop 2")
# See when objects are really freed.
top.destroy()
printGarbage("end 1") # Huh ???
gc.collect()
printGarbage("end 2")
top = frame = canvas = None
gc.collect()
printGarbage("end 3")</t>
<t tx="T41"># The output of this is 5 5 6
# This shows that o2 is merely an alias for o.

class obj:
	def __init__(self,n):
		self.n = n

o = obj(5) ; print o.n,
o2  = o    ; print o2.n,
o.n = 6    ; print o2.n</t>
<t tx="T42"># The following corrupts the outline: extract section (in B), undo.
</t>
<t tx="T43"></t>
<t tx="T44"># The following used to corrupt the outline: extract section, undo.

&lt;&lt; test &gt;&gt;
line 1
line 2

after
</t>
<t tx="T45"></t>
<t tx="T46"></t>
<t tx="T47"></t>
<t tx="T48"></t>
<t tx="T49"></t>
<t tx="T50"></t>
<t tx="T51"></t>
<t tx="T52"></t>
<t tx="T53">from leoGlobals import *
import leoDialog

if 1: # passed
	print leoDialog.askOk(
		"My Test Dialog",
		"Please hit return to test this dialog.",
		text="whoopee",
		resizeable=false).run(modal=true)
	
if 1: # passed
	message = "leo.py requires Python 2.1 or higher"
	print leoDialog.askOk("Python version error",message=message,text="Exit").run(modal=true)
	
if 1: # passed
	fileName = "xyzzy"
	print leoDialog.askOk("Read-only ouline",
		"Warning: the outline: " + fileName + " is read-only.").run(modal=true)</t>
<t tx="T54">from leoGlobals import *
import leoDialog

ver = "version 3.14159 "
build = "-3.8" 
version = "leo.py 4.0 alpha 2, Build " + build + ", June 13, 2003\n\n"
copyright = (
	"Copyright 1999-2003 by Edward K. Ream\n" +
	"All Rights Reserved\n" +
	"Leo is distributed under the Python License")
url = "http://webpages.charter.net/edreamleo/front.html"
email = "edreamleo@charter.net"

leoDialog.aboutLeo(version,copyright,url,email).run(modal=false)</t>
<t tx="T55">import leoDialog

print leoDialog.askLeoID().run(modal=1)</t>
<t tx="T56">import leoDialog

print leoDialog.askOkCancelNumber("Enter Line Number","Line number:").run(modal=1)
</t>
<t tx="T57">import leoDialog

print leoDialog.askOkCancel("Proceed?",
	"Read @file Nodes is not undoable.\nProceed?").run(modal=1)</t>
<t tx="T58">import leoDialog

if 1: # passed
	message = "Replace changed outline with external changes?"
	print leoDialog.askYesNo("Conflict!",message).run(modal=1)
	
if 1: # passed
	print leoDialog.askYesNo("Revert",
		"Revert to previous version of xyzzy?").run(modal=1)
		
if 1: # passed
	print leoDialog.askYesNo(
		"Download Tutorial?",
		"Download tutorial (sbooks.chm) from SourceForge?").run(modal=1)</t>
<t tx="T59">import leoDialog

if 1: # passed
	print leoDialog.askYesNoCancel("Confirm",
		'Save changes to xyzzy before crashing?').run(modal=1)
		
if 1: # passed
	message = (
		"Conflicting changes in outline and temp file\n\n" +
		"Do you want to use the code in the outline or the temp file?\n\n")
	
	print leoDialog.askYesNoCancel(
		"Conflict!", message,
		yesMessage = "Outline",
		noMessage = "File",
		defaultButton = "Cancel").run(modal=1)</t>
<t tx="T60"></t>
<t tx="T61">@others</t>
<t tx="T62">def __init__ (self):
	
	pass # line 9</t>
<t tx="T63">def __init__ (self):
	
	pass # line 16</t>
<t tx="T64"></t>
<t tx="T65">from leoGlobals import *

top().frame.addIconButton(imagefile="../Icons/Leoapp.gif")

top().frame.addIconButton(text="hi")

top().frame.addIconButton(imagefile="../Icons/Leodoc.gif")</t>
<t tx="T66">from leoGlobals import *
import glob,os

f = top().frame

pattern = "c:/prog/leoCVS/leo/Icons/*.gif"
files = glob.glob(pattern)
files.sort()

f.clearIconBar()
for file in files:
	f.addIconButton(imagefile=file,bg="lightBlue")</t>
<t tx="T67">from leoGlobals import *

top().frame.clearIconBar()</t>
<t tx="T68">from leoGlobals import *

top().frame.hideIconBar()</t>
<t tx="T69">from leoGlobals import *

top().frame.iconFrame.configure(height="15m")</t>
<t tx="T70">from leoGlobals import *

top().frame.showIconBar()</t>
<t tx="T71">@ignore</t>
<t tx="T72">@lineending nl         (the default, Linux)
@lineending cr         (Mac)
@lineending crlf       (Windows)
@lineending lf          (same as nl, not recommended)
@lineending platform (same as platform value for output_newline setting in leoConfig.txt)

@encoding utf-8</t>
<t tx="T73"># Test file for cut/paste operations.

@others</t>
<t tx="T74"></t>
<t tx="T75">node A Text</t>
<t tx="T76">node B text</t>
<t tx="T77">from leoGlobals import *

checkClones2Links(verbose=true)</t>
<t tx="T78">import unittest
import leoTest
reload(leoTest)

colorSuite = unittest.makeSuite(leoTest.colorTests)

if 1:
	suite = colorSuite
else:
	suite = unittest.TestSuite()
	suite.addTest(leoTest.colorTests("testC"))
	# suite.addTest(leoTest.colorSuite)

runner = unittest.TextTestRunner()
runner.run(suite)</t>
<t tx="T79"></t>
<t tx="T80">@ EKR: the doc string in class shape is improperly indented.
@c

@language Python
@tabwidth -4</t>
<t tx="T81">@first #!/usr/bin/python

@others
</t>
<t tx="T82">@others
</t>
<t tx="T83">@others
</t>
<t tx="T84">class shape(object):
  	&lt;&lt; class shape declarations &gt;&gt;
  	# after decls</t>
<t tx="T85">"""Parent class of all shapes."""
pass
</t>
<t tx="T86"># This shows that Python programs _could_ use .xpy files (xml files containing Leo/Python code).

from leoGlobals import *
import imp
import sys

old_import = __import__ # Get the global function

def leo_import(name,old_import,globals=None, locals=None, fromlist=None):
	try:
		mod = sys.modules.get(name)
		if mod:
			es("Leo import: module exists: " + name, color="blue")
		else:
			mod = old_import(name,globals,locals,fromlist)
			es("Leo import: " + name,color="blue")
	except ImportError:
		es("Leo import: not found: " + name,color="blue")
		mod = None
	return mod
		
m = leo_import("leoTest",__import__)
es(m,color="red")</t>
<t tx="T87">import leoFrame
print "%d leoFrame instances" % leoFrame.LeoFrame.instances</t>
<t tx="T88">@ignore</t>
<t tx="T89">@nocolor
This is a test file
@others</t>
<t tx="T90">Node one text.  changed 2.</t>
<t tx="T91">@language rebol

; a comment
about abs absolute add alert alias all alter and and~ any append arccosine arcsine arctangent array ask at  
back bind boot-prefs break browse build-port build-tag  
call caret-to-offset catch center-face change change-dir charset checksum choose clean-path clear clear-fields close comment complement compose compress confirm continue-post context copy cosine create-request crypt cvs-date cvs-version  
debase decode-cgi decode-url decompress deflag-face dehex delete demo desktop detab dh-compute-key dh-generate-key dh-make-key difference dirize disarm dispatch divide do do-boot do-events do-face do-face-alt does dsa-generate-key dsa-make-key dsa-make-signature dsa-verify-signature  
echo editor either else emailer enbase entab exclude exit exp extract 
fifth find find-key-face find-window flag-face first flash focus for forall foreach forever form forskip fourth free func function  
get get-modes get-net-info get-style  
halt has head help hide hide-popup  
if import-email in inform input insert insert-event-func intersect 
join 
last launch launch-thru layout license list-dir load load-image load-prefs load-thru log-10 log-2 log-e loop lowercase  
make make-dir make-face max maximum maximum-of min minimum minimum-of mold multiply  
negate net-error next not now  
offset-to-caret open open-events or or~ 
parse parse-email-addrs parse-header parse-header-date parse-xml path-thru pick poke power prin print probe protect protect-system  
q query quit  
random read read-io read-net read-thru reboot recycle reduce reform rejoin remainder remold remove remove-event-func rename repeat repend replace request request-color request-date request-download request-file request-list request-pass request-text resend return reverse rsa-encrypt rsa-generate-key rsa-make-key 
save save-prefs save-user scroll-para second secure select send send-and-check set set-modes set-font set-net set-para set-style set-user set-user-name show show-popup sine size-text skip sort source split-path square-root stylize subtract switch  
tail tangent textinfo third throw throw-on-error to to-binary to-bitset to-block to-char to-date to-decimal to-email to-event to-file to-get-word to-hash to-hex to-idate to-image to-integer to-issue to-list to-lit-path to-lit-word to-local-file to-logic to-money to-none to-pair to-paren to-path to-rebol-file to-refinement to-set-path to-set-word to-string to-tag to-time to-tuple to-url to-word trace trim try  
unfocus union unique uninstall unprotect unset until unview update upgrade uppercase usage use  
vbug view view-install view-prefs  
wait what what-dir while write write-io  
xor xor~  
action! any-block! any-function! any-string! any-type! any-word!  
binary! bitset! block!  
char!  
datatype! date! decimal! 
email! error! event!  
file! function!  
get-word!  
hash!  
image! integer! issue!  
library! list! lit-path! lit-word! logic!  
money!  
native! none! number!  
object! op!  
pair! paren! path! port!  
refinement! routine!  
series! set-path! set-word! string! struct! symbol!  
tag! time! tuple!  
unset! url!  
word!  
any-block? any-function? any-string? any-type? any-word?  
binary? bitset? block?  
char? connected? crypt-strength? 
datatype? date? decimal? dir?  
email? empty? equal? error? even? event? exists? exists-key?
file? flag-face? found? function?  
get-word? greater-or-equal? greater?  
hash? head?  
image? in-window? index? info? input? inside? integer? issue?  
length? lesser-or-equal? lesser? library? link-app? link? list? lit-path? lit-word? logic?  
modified? money?  
native? negative? none? not-equal? number?  
object? odd? offset? op? outside?  
pair? paren? path? port? positive?  
refinement? routine?  
same? screen-offset? script? series? set-path? set-word? size? span? strict-equal? strict-not-equal? string? struct?  
tag? tail? time? tuple? type?  
unset? url?  
value? view? 
within? word?  
zero?</t>
<t tx="T92">@language plain
@pagewidth 72
@tabwidth 2

The intent of this tool is to provide 
an aid to memorization practice.  The 
tool is directed at memorization of 
prose or poetry, not music or 
mathematics.  It would probably not 
be useful for memorization of dialog.  The 
purpose of such memorization is 
to be able to recreate a chunk of 
text in your head or on paper, and perhaps verbally.

The steps might be as follows:</t>
<t tx="T93">a b leoDialogs leoFind leoAtFile leoFileCommands leoGlobals modal end
line tooo changed 9
</t>
<t tx="T94">this is another test.

hello there jkk this is werg
		
the cht sat on the marh
the cat was sitting phew, another day. by zz z z 
two initabc
</t>
<t tx="T95">everything good.</t>
<t tx="T96"></t>
<t tx="T97">from leoGlobals import *
f = top().frame

f.clearStatusLine()

f.putStatusLine ("Hello")

for color in ("red","blue","yellow","green","orange"):
	f.putStatusLine (" %s " % (color),color=color)

f.putStatusLine(" World")</t>
<t tx="T98">from leoGlobals import *
f = top().frame

f.clearStatusLine()
</t>
<t tx="T99"></t>
<t tx="T100">@tabwidth 2

a
	b
		c	d</t>
<t tx="T101">@tabwidth 4

a
	b
		c	d</t>
<t tx="T102">@tabwidth 6

a
	b
		c	d</t>
<t tx="T103">@tabwidth 8

a
	b
		c	d</t>
<t tx="T104"></t>
<t tx="T105">This is section a.</t>
<t tx="T106">&lt;&lt; section a &gt;&gt;</t>
<t tx="T107"></t>
<t tx="T108">import timeit</t>
<t tx="T109">ab
</t>
<t tx="T110"></t>
<t tx="T111"># The following corrupts the outline: extract section, undo.

&lt;&lt; test &gt;&gt;
line 1
	line 2

	after
</t>
<t tx="T112"># The following corrupts the outline: extract section, undo.

&lt;&lt; test &gt;&gt;
line 1
	line 2

	after

</t>
<t tx="T113"></t>
<t tx="T114"></t>
<t tx="T115">test one</t>
<t tx="T116">from leoGlobals import *
import gc,os,time,leoNodes
from xml.sax import saxutils, make_parser
from xml.sax.xmlreader import InputSource

path = os.path.join(app().loadDir,"../","test","test2.leo")
# path = os.path.join(app().loadDir,"LeoPy.leo")
path = os.path.normpath(path)

verbose = true
tnodes = vnodes = 0
start = None

def clean(s): return toEncodedString(s,"ascii")

class trace_parse(saxutils.XMLGenerator):
	lastContent = None
	def startDocument(self):
		if 0: # Doesn't smooth things out.
			gc.collect() 
		global start ; start = time.clock()
		if verbose:
			print ; print ; print '*' * 30 + " dump " + '*' * 30 ; print
			trace()
	def endDocument(self):
		global start ; print "total time" + "%6.3f" % (time.clock()-start)
		if verbose: trace()
	def startElement(self,name,attrs):
		global vnodes,tnodes
		self.lastContent = None
		if verbose:
			name = clean(name).strip()
			self.lastName = name
			a = []
			keys = attrs.keys()
			keys.sort()
			for key in keys:
				a.append("%s=%s" % (key,attrs.getValue(key)))
			if name not in (("vh"),):
				print
			if a:
				print '&lt;%s %s&gt;' % (name, string.join(a,' ')),
			else:
				print '&lt;%s&gt;' % name,
			# if name in (("t"),): print
		if name == "v":
			vnodes += 1 ; v = leoNodes.vnode(top(),leoNodes.tnode())
		elif name == "t":
			tnodes += 1 ; t = leoNodes.tnode()
	def endElement(self,name):
		name = clean(name).strip()
		if verbose:
			if self.lastContent and name not in (("vh"),):
				print
			print '&lt;/%s&gt;' % name,
		self.lastName = name
	def characters(self,content):
		self.lastContent = content = content.replace('\r','')
		if verbose and content.strip():
			if self.lastName != "vh": print
			print clean(content),
	def ignorableWhitespace(self):                trace()
	def processingInstruction (self,target,data): trace()
	def skippedEntity(self,name):                 trace(name)
	def startElementNS(self,name,qname,attrs):    trace(name)
	def endElementNS(self,name,qname):            trace(name)
	
try:
	f = None
	try:
		print path
		if 1: # not needed, and it works.
			source = InputSource(path)
			# source.setEncoding(app().tkEncoding)
		else:
			source = f = open(path)
		parser = make_parser()
		parser.setContentHandler(trace_parse())
		parser.parse(source)
		print "vnodes,tnodes:",`vnodes`,`tnodes`
	except: es_exception()
finally:
	if f: f.close()</t>
<t tx="T117">from leoGlobals import *
c = top() ; v = c.currentVnode()
print v
print `v`</t>
<t tx="T118">@ignore</t>
<t tx="T119"></t>
<t tx="T120">import wxLeo
reload(wxLeo)</t>
<t tx="T121"></t>
<t tx="T122">@others</t>
<t tx="T123">@wrap

this should wrap aaaaaaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbbbbbb cccccccccccccccccc ddddddddddddddddddd eeeeeeeeeeeeeeeeeeeeee ffffffffffffffffffff</t>
<t tx="T124">@nowrap

this should NOT wrap aaaaaaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbbbbbb cccccccccccccccccc ddddddddddddddddddd eeeeeeeeeeeeeeeeeeeeee ffffffffffffffffffff</t>
<t tx="T125">@ignore
## @encoding iso-8859-1
# @comment /* */</t>
<t tx="T126">from leoGlobals import *

def compare(name):
	path1 = r"c:\prog\leoCvs\leo\src"
	path2 = r"c:\prog\test"
	f1 = open(path1 + '\\' + name)
	f2 = open(path2 + '\\' + name)
	lines1 = stripBlankAndCommentLines(f1.readlines())
	lines2 = stripBlankAndCommentLines(f2.readlines())
	f1.close() ; f2.close()
	print "%20s %4d %4d" % (name,len(lines1),len(lines2)),
	mismatches = 0 ; n1 = 0 ; n2 = 0
	while n1 &lt; len(lines1) and n2 &lt; len(lines2) and mismatches &lt; 10:
		if lines1[n1] != lines2[n2]:
			mismatches += 1
			print n1,lines1[n1] ; print n2,lines2[n2]
			if   n2+1 &lt; len(lines2) and lines1[n1] == lines2[n2+1]: n1 += 1
			elif n1+1 &lt; len(lines2) and lines2[n2] == lines1[n1+1]: n2 += 1
			else: n1 += 1 ; n2 += 1
		else: n1 += 1 ; n2 += 1
	print "mismatches:",mismatches

def stripBlankAndCommentLines(lines):
	n = 0
	while n &lt; len(lines):
		s = lines[n] ; i = skip_ws(s,0)
		if i == len(s) or match(s,i,'#') or match(s,i,'\n'):
			del lines[n]
		else: n += 1
	return lines
	
print ; print "comparing..."
if 1: # 9/19/03: all files pass
	compare("leo.py")
	compare("leoApp.py")
	compare("leoAtFile.py")
	compare("leoColor.py")
	compare("leoCommands.py")
	compare("leoCompare.py")
	compare("leoConfig.py")
	compare("leoDialog.py")
	compare("leoFileCommands.py")
	compare("leoFind.py")
	compare("leoFontPanel.py")
	compare("leoFrame.py")
	compare("leoGlobals.py")
	compare("leoImport.py")
	compare("leoNodes.py")
	compare("leoPlugins.py")
	compare("leoPrefs.py")
	compare("leoTangle.py")
	compare("leoTree.py")
	compare("leoUndo.py")
print ; print "end of compare"


	</t>
<t tx="T127">@ignore</t>
<t tx="T128">ref line 1
ref line 2</t>
<t tx="T129">@first first line1
@first first line2
@pagewidth 40
@ Class to read and write @file nodes.

This code uses readline() to get each line rather than reading the entire file into a buffer.  This is more memory efficient and saves us from having to scan for the end of each line.  The result is cleaner and faster code.  This code also accumulates body text line-by-line rather than character-by-character, a much faster way.

w012345678901234567890123456789012345678901234567890123456789

and w012345678901234567890123456789012345678901234567890123456789 in the middle.

Trailing line.
@c

# gnxText.txt  2

before
&lt;&lt; ref &gt;&gt; afterref
middle
	&lt;&lt; ref2 &gt;&gt;
after
	@others
beforref &lt;&lt; ref &gt;&gt;
after at-others
@last last line1
@last last line2
</t>
<t tx="T130">ref2 line</t>
<t tx="T131"></t>
<t tx="T132">@ Doc part
doc part line 2
@c
	indented node 1 line 1
node 2 line 2
#@ should be a verbatim line.
	&lt;&lt; indented ref &gt;&gt;
after indented ref</t>
<t tx="T133">indented ref line</t>
<t tx="T134"></t>
<t tx="T135">node 2 line 1
node 2 line 2
</t>
<t tx="T136">@first #! /usr/bin/env python
# Entry point for Leo in Python.

@language python
&lt;&lt; Import pychecker &gt;&gt;
from leoGlobals import *
import leoApp,leoFrame
import os,string,sys,Tkinter

@others

if __name__ == "__main__":
	if len(sys.argv) &gt; 1:
		if sys.platform=="win32": # Windows
			fileName = string.join(sys.argv[1:],' ')
		else:
			fileName = sys.argv[1]
		run(fileName)
	else:
		run()


</t>
<t tx="T137">@ pychecker is extremely useful, and it sometimes reports problems erroneously.  In particular, the following warnings are invalid:

in leoFrame.py and leoNodes.py: warnings about the event param not being used. pychecker doesn't understand that these routines are Tkinter callbacks.

in leoApp.py and leoGlobals.py: pychecker doesn't seem to handle globals very well.  There are spurious warnings about globals.

several files: pychecker complains about several routines being "too big", i.e., pychecker doesn't understand about literate programming.

@c

if 0: # Set to 1 for lint-like testing.  This can also be done in idle.
	try:
		import pychecker.checker
	except: pass</t>
<t tx="T138">def runMainLoop(root):
	
	"""A function that runs root.mainloop()
	
	LeoN may replace this fuction entirely."""
	
	root.mainloop()
</t>
<t tx="T139">def run(fileName=None,*args,**keywords):
	
	"""Initialize and run Leo"""

	printGc("before creating root")
	root = createTkRoot()
	printGc("after creating root")
	if not root: return
	
	app = createAppObject(root)
	printGc("after creating app")
	if not app: return
	
	# Set this ivar so LeoN may override it.
	app.runMainLoop = runMainLoop
	
	doHook("start1")
	printGc("after loading plugins")
	
	initSherlock(app,args)
	frame = createFrame(app,fileName)
	printGc("after creating frames")
	if not frame: return

	# Write queued output and redraw the screen.
	app.writeWaitingLog()

	c = frame.commands ; v = c.currentVnode()
	doHook("start2",c=c,v=v,fileName=fileName)

	frame.commands.redraw()
	set_focus(frame.commands,frame.body)

	app.runMainLoop(root)</t>
<t tx="T140">def createTkRoot ():
	
	"""Step 1 of Leo startup process:
	
	Create a hidden Tk root window and the app object"""
	
	# Create a hidden main window: this window never becomes visible!
	root = Tkinter.Tk()

	&lt;&lt; set the icon image &gt;&gt;
	root.title("Leo Main Window")
	root.withdraw()
	return root
	
</t>
<t tx="T141">if 0: # not yet
	fullname = r"c:\prog\LeoPy\Icons\box05.GIF"
	image = Tkinter.PhotoImage(file=fullname)
	trace(`image`)
	image = Tkinter.BitmapImage(image)
	trace(`image`)
	image = Tkinter.BitmapImage("stop")
	trace(`image`)
	root.iconbitmap(image)</t>
<t tx="T142">def createAppObject(root):

	# Create the application object.
	app = leoApp.LeoApp(root)
	setApp(app)
	
	# Finish the creation of the app object after app() exists.
	if not app.finishCreate(): 
		root.destroy()
		root = None

	return app</t>
<t tx="T143">def createFrame (app,fileName):
	
	"""Step 2 of Leo startup process:
		
	Create a Leo Frame."""
	
	# Try to create a frame for the file.
	if fileName:
		fileName = os.path.join(os.getcwd(),fileName)
		fileName = os.path.normpath(fileName)
		if os.path.exists(fileName):
			ok, frame = openWithFileName(fileName) # 7/13/03: the global routine.
			if ok:
				# print fileName
				return frame
	
	# Create a new frame &amp; indicate it is the startup window.
	frame = leoFrame.LeoFrame()
	frame.setInitialWindowGeometry()
	frame.startupWindow = true
	
	# Report the failure to open the file.
	if fileName:
		es("File not found: " + fileName)

	return frame</t>
<t tx="T144">def initSherlock (app,args):
	
	"""Initialize Sherlock."""
	
	# Initialze Sherlock &amp; stats.
	init_sherlock(args)
	clear_stats()</t>
<t tx="T145">@ To gather statistics, do the following in a Python window, not idle:

	import leo
	leo.profile()  (this runs leo)
	load leoDocs.leo (it is very slow)
	quit Leo.
@c

def profile ():
	
	"""Gather and print statistics about Leo"""

	import profile, pstats
	
	name = "c:/prog/test/leoProfile.txt"
	profile.run('leo.run()',name)

	p = pstats.Stats(name)
	p.strip_dirs()
	p.sort_stats('cum','file','name')
	p.print_stats()</t>
<t tx="T146">@first # -*- coding: utf-8 -*-
@language python

from leoGlobals import *
import leo,leoConfig,leoDialog,leoFind
import os,sys,Tkinter

class LeoApp:

	"""A class representing the Leo application itself.
	
	Ivars of this class are Leo's global variables."""
	
	@others
</t>
<t tx="T147">def __init__(self, root):

	# These ivars are the global vars of this program.
	self.afterHandler = None
	self.commandName = None # The name of the command being executed.
	self.config = None # The leoConfig instance.
	self.globalWindows = []
	self.hasOpenWithMenu = false # True: open with plugin has been loaded.
	self.hookError = false # true: suppress further calls to hooks.
	self.hookFunction = None # Application wide hook function.
	self.idle_imported = false # true: we have done an import idle
	self.idleTimeDelay = 100 # Delay in msec between calls to "idle time" hook.
	self.idleTimeHook = false # true: the global idleTimeHookHandler will reshedule itself.
	self.killed = false # true: we are about to destroy the root window.
	self.loadDir = None # The directory from which Leo was loaded.
	self.log = None # The LeoFrame containing the present log.
	self.logIsLocked = false # true: no changes to log are allowed.
	self.logWaiting = [] # List of messages waiting to go to a log.
	self.menuWarningsGiven = false # true: supress warnings in menu code.
	self.numberOfWindows = 0 # Number of opened windows.
	self.openWithFiles = [] # List of data used by Open With command.
	self.openWithFileNum = 0 # Used to generate temp file names for Open With command.
	self.openWithTable = None # The table passed to createOpenWithMenuFromTable.
	self.quitting = false # True if quitting.  Locks out some events.
	self.realMenuNameDict = {} # Contains translations of menu names and menu item names.
	self.root = root # The hidden main window
	self.trace_list = [] # "Sherlock" argument list for tracing().
	self.tkEncoding = "utf-8" # Set by finishCreate
	self.unicodeErrorGiven = false # true: suppres unicode tracebacks.
	self.windowList = [] # Global list of all frames.  Does not include hidden root window.

	# Global panels.  Destroyed when Leo ends.
	self.findFrame = None
	self.pythonFrame = None
	
	&lt;&lt; Define global constants &gt;&gt;
	&lt;&lt; Define global data structures &gt;&gt;</t>
<t tx="T148">self.prolog_string = "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;"

# New in leo.py 3.0
self.prolog_prefix_string = "&lt;?xml version=\"1.0\" encoding="
self.prolog_postfix_string = "?&gt;"

# leo.py 3.11
self.use_unicode = true # true: use new unicode logic.
</t>
<t tx="T149"># Internally, lower case is used for all language names.
self.language_delims_dict = {
	"actionscript" : "// /* */", #jason 2003-07-03
	"c" : "// /* */", # C, C++ or objective C.
	"cweb" : "@q@ @&gt;", # Use the "cweb hack"
	"forth" : "_\\_ _(_ _)_", # Use the "REM hack"
	"fortran" : "C",
	"fortran90" : "!",
	"html" : "&lt;!-- --&gt;",
	"java" : "// /* */",
	"latex" : "%",
	"pascal" : "// { }",
	"perl" : "#",
	"perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
	"php" : "//",
	"plain" : "#", # We must pick something.
	"python" : "#",
	"rebol" : ";", #jason 2003-07-03
	"shell" : "#",  # shell scripts
	"tcltk" : "#",
	"unknown" : "#" } # Set when @comment is seen.
	
self.language_extension_dict = {
	"actionscript" : "as", #jason 2003-07-03
	"c" : "c", 
	"cweb" : "w",
	"forth" : "forth",
	"fortran" : "f",
	"fortran90" : "f",
	"html" : "html",
	"java" : "java",
	"latex" : "latex",
	"noweb" : "nw",
	"pascal" : "p",
	"perl" : "perl",
	"perlpod" : "perl", 
	"php" : "php",
	"plain" : "txt",
	"python" : "py",
	"rebol" : "r",  #jason 2003-07-03
	"shell" : "txt",
	"tex" : "tex",
	"tcltk" : "tcl",
	"unknown" : "txt" } # Set when @comment is seen.
</t>
<t tx="T150">def closeLeoWindow (self,frame):
	
	"""Attempt to close a Leo window.
	
	Return false if the user veto's the close."""
	
	a = self ; c = frame.commands

	if c.changed:
		veto = frame.promptForSave()
		# print "veto",veto
		if veto: return false

	app().setLog(None) # no log until we reactive a window.
	
	doHook("close-frame",c=c) # This may remove frame from the window list.
	
	if frame in a.windowList:
		a.destroyWindow(frame)
	
	if a.windowList:
		# Pick a window to activate so we can set the log.
		w = a.windowList[0]
		w.top.deiconify()
		w.top.lift()
		a.setLog(w)
	else:
		a.finishQuit()

	return true # The window has been closed.
</t>
<t tx="T151">def destroyAllGlobalWindows (self):
	
	for w in self.globalWindows:
		w.top.destroy()
		
	self.globalWindows = []
	
	self.findFrame = None
	self.pythonFrame = None
		
	doHook("destroy-all-global-windows")
</t>
<t tx="T152">@ Try to remove temp files created with the Open With command.  This may fail if the files are still open.

We can't use es here because the log stream no longer exists.
@c 

def destroyAllOpenWithFiles (self):
	
	a = self

	for dict in self.openWithFiles[:]: # 7/10/03.
		a.destroyOpenWithFileWithDict(dict)
		
	# Delete the list so the gc can recycle Leo windows!
	a.openWithFiles = []</t>
<t tx="T153"># Objects must not be "destroyed" more than once; only this method calls destroy routines.

def destroyAllWindowObjects (self,frame):

	"""Clear all links to objects in a Leo window."""
	
	# print "app.destroyAllNodes", frame
	
	# Do this first.
	&lt;&lt; clear all vnodes and tnodes in the tree &gt;&gt;
	
	# Destroy all subcommanders.
	clearAllIvars(frame.commands.atFileCommands)
	clearAllIvars(frame.commands.fileCommands)
	clearAllIvars(frame.commands.importCommands)
	clearAllIvars(frame.commands.tangleCommands)
	clearAllIvars(frame.commands.undoer)
	
	# Destroy the commander.
	clearAllIvars(frame.commands)

	clearAllIvars(frame.tree.colorizer)
	clearAllIvars(frame.tree)
	
	# Finally, destroy the frame itself.
	frame.destroyAllPanels()
	clearAllIvars(frame)
	
	# Note: pointers to frame still exist in the caller!</t>
<t tx="T154"># Using a dict here is essential for adequate speed.
vList = [] ; tDict = {}

v = frame.commands.rootVnode()
while v:
	vList.append(v)
	if v.t:
		key = id(v.t)
		if not tDict.has_key(key):
			tDict[key] = v.t
	v = v.threadNext()
	
for key in tDict.keys():
	clearAllIvars(tDict[key])

for v in vList:
	clearAllIvars(v)

vList = [] ; tList = [] # Remove these references immediately.</t>
<t tx="T155">def destroyOpenWithFilesForFrame (self,frame):
	
	"""Close all "Open With" files associated with frame"""
	
	a = self
	
	# Make a copy of the list: it may change in the loop.
	openWithFiles = a.openWithFiles

	for dict in openWithFiles[:]: # 6/30/03
		c = dict.get("c")
		if c.frame == frame:
			a.destroyOpenWithFileWithDict(dict)
</t>
<t tx="T156">def destroyOpenWithFileWithDict (self,dict):
	
	a = self
	
	path = dict.get("path")
	if path and os.path.exists(path):
		try:
			os.remove(path)
			print "deleting temp file:", shortFileName(path)
		except:
			print "can not delete temp file:", path
			
	# Remove dict from the list so the gc can recycle the Leo window!
	a.openWithFiles.remove(dict)</t>
<t tx="T157">def destroyWindow (self,frame):
	
	a = self
	top = frame.top # Remember this.
		
	a.destroyOpenWithFilesForFrame(frame)
	
	# 8/27/03: Recycle only if more than one window open
	if len(a.windowList) &gt; 1:
		a.destroyAllWindowObjects(frame)

	a.windowList.remove(frame)

	top.destroy() # force the window to go away now.</t>
<t tx="T158"># Called when the gApp global has been defined.

def finishCreate(self):

	import locale,sys
	import leoNodes
	&lt;&lt; return false if not v2.1 or above &gt;&gt;
	&lt;&lt; set loadDir &gt;&gt;
	&lt;&lt; set the default Leo icon &gt;&gt;
	self.config = leoConfig.config()
	&lt;&lt; set app.tkEncoding &gt;&gt;

	# Create the global windows
	self.findFrame = leoFind.leoFind()
	self.findFrame.top.withdraw()
	self.globalWindows.append(self.findFrame)

	return true # all went well.</t>
<t tx="T159"># Python 2.1 support.

try:
	# 04-SEP-2002 DHEIN: simplify version check
	message = """
leo.py requires Python 2.1 or higher.

You may download Python 2.1 and Python 2.2 from http://python.org/download/
"""

	if not CheckVersion(sys.version, "2.1"):
		leoDialog.askOk("Python version error",message=message,text="Exit").run(modal=true)
		return false
except:
	print "exception getting version"
	import traceback
	traceback.print_exc()</t>
<t tx="T160"># loadDir should be the directory that contains leo.py

try:
	self.loadDir = os.path.dirname(leo.__file__)
	if self.loadDir in (None,""):
		self.loadDir = os.getcwd()
	self.loadDir = os.path.abspath(self.loadDir)
except:
	# Emergency defaults.  Hopefully we will never have to use them.
	if sys.platform=="win32": # Windows
		self.loadDir = "c:\\prog\\LeoPy\\"
	else: # Linux, or whatever.
		self.loadDir = "LeoPy"
	print "Setting load directory to:", self.loadDir
</t>
<t tx="T161">try: # 6/2/02: Try to set the default bitmap.
	bitmap_name = os.path.join(self.loadDir,"..","Icons","LeoApp.ico")
	bitmap = Tkinter.BitmapImage(bitmap_name)
except:
	print "exception creating bitmap"
	import traceback
	traceback.print_exc()

try:
	version = self.root.getvar("tk_patchLevel")
	# print "tcl version:", version
	&lt;&lt; set v834 if version is 8.3.4 or greater &gt;&gt;
except:
	print "exception getting version"
	import traceback
	traceback.print_exc()
	v834 = None # 6/18/02
	
if v834:
	try:
		if sys.platform=="win32": # Windows
			top.wm_iconbitmap(bitmap,default=1)
		else:
			top.wm_iconbitmap(bitmap)
	except:
		if 0: # Let's ignore this for now until I understand the issues better.
			es("exception setting bitmap")
			es_exception()</t>
<t tx="T162"># 04-SEP-2002 DHEIN: simplify version check
# 04-SEP-2002 Stephen P. Schaefer: make sure v834 is set
v834 = CheckVersion(version, "8.3.4")
</t>
<t tx="T163">@ According to Martin v. L�, getdefaultlocale() is broken, and cannot be fixed. The workaround is to copy the getpreferredencoding() function from locale.py in Python 2.3a2.  This function is now in leoGlobals.py.
@c

for (encoding,src) in (
	(self.config.tkEncoding,"config"),
	#(locale.getdefaultlocale()[1],"locale"),
	(getpreferredencoding(),"locale"),
	(sys.getdefaultencoding(),"sys"),
	("utf-8","default")):

	if isValidEncoding (encoding): # 3/22/03
		self.tkEncoding = encoding
		# print self.tkEncoding,src
		break
	elif encoding and len(encoding) &gt; 0:
		print "ignoring invalid " + src + " encoding: " + `encoding`

</t>
<t tx="T164">def finishQuit(self):
	
	self.killed = true # Disable after events.
	
	if self.afterHandler != None:
		# print "finishQuit: cancelling",self.afterHandler
		self.root.after_cancel(self.afterHandler)
		self.afterHandler = None

	# Wait until everything is quiet before really quitting.
	doHook("end1")

	self.destroyAllGlobalWindows()
	
	self.destroyAllOpenWithFiles()

	if 0: # Works in Python 2.1 and 2.2.  Leaves Python window open.
		self.root.destroy()
		
	else: # Works in Python 2.3.  Closes Python window.
		self.root.quit()</t>
<t tx="T165"># Returns the translation of a menu name or an item name.

def getRealMenuName (self,menuName):
	
	cmn = canonicalizeTranslatedMenuName(menuName)
	return self.realMenuNameDict.get(cmn,menuName)
	
def setRealMenuName (self,untrans,trans):
	
	cmn = canonicalizeTranslatedMenuName(untrans)
	self.realMenuNameDict[cmn] = trans

def setRealMenuNamesFromTable (self,table):

	for untrans,trans in table:
		self.setRealMenuName(untrans,trans)
</t>
<t tx="T166">def onQuit (self):
	
	a = self
	
	a.quitting = true
	
	while a.windowList:
		w = a.windowList[0]
		if not a.closeLeoWindow(w):
			break

	a.quitting = false # If we get here the quit has been disabled.


</t>
<t tx="T167">def setLog (self,log,tag=""):
	"""set the frame to which log messages will go"""
	
	# print "setLog:",tag,"locked:",self.logIsLocked,`log`
	if not self.logIsLocked:
		self.log = log
		
def lockLog(self):
	"""Disable changes to the log"""
	self.logIsLocked = true
	
def unlockLog(self):
	"""Enable changes to the log"""
	self.logIsLocked = false</t>
<t tx="T168">def writeWaitingLog (self):

	if self.log:
		for s,color in self.logWaiting:
			es(s,color=color,newline=0) # The caller must write the newlines.
		self.logWaiting = []
</t>
<t tx="T169">@first #line1
@first #line2

@language python

@ Class to read and write @file nodes.

This code uses readline() to get each line rather than reading the entire file into a buffer.  This is more memory efficient and saves us from having to scan for the end of each line.  The result is cleaner and faster code.  This code also accumulates body text line-by-line rather than character-by-character, a much faster way.
@c

from leoGlobals import *
import leoColor,leoNodes
import filecmp,os,os.path,time

class baseAtFile:
	"""The base class for the atFile subcommander."""
	&lt;&lt; atFile constants &gt;&gt;
	@others
	
class atFile (baseAtFile):
	"""A subcommander implementing atFile commands."""
	pass

@last #last1
@last #last2
</t>
<t tx="T170"># The kind of at_directives.
noDirective		   =  1 # not an at-directive.
delimsDirective =  2 # @delims (not used!)
docDirective	   =  3 # @doc.
atDirective		   =  4 # @&lt;space&gt; or @&lt;newline&gt;
codeDirective	  =  5 # @code
cDirective		    =  6 # @c&lt;space&gt; or @c&lt;newline&gt;
othersDirective	=  7 # at-others
miscDirective	  =  8 # All other directives
rawDirective    =  9 # @raw
endRawDirective = 10 # @end_raw

# The kind of sentinel line.
noSentinel		 = 20 # Not a sentinel
# not used   = 21
endAt			 = 22 # @-at
endBody			 = 23 # @-body
endDoc			 = 24 # @-doc
endLeo			 = 25 # @-leo
endNode			 = 26 # @-node
endOthers		  = 27 # @-others

# not used     = 40
startAt			   = 41 # @+at
startBody		    = 42 # @+body
startDoc		     = 43 # @+doc
startLeo		     = 44 # @+leo
startNode		    = 45 # @+node
startOthers		  = 46 # @+others

startComment   = 60 # @comment
startDelims		  = 61 # @delims
startDirective	= 62 # @@
startRef		     = 63 # @&lt; &lt; ... &gt; &gt; (3.0)
startVerbatim	 = 64 # @verbatim
startVerbatimAfterRef = 65 # @verbatimAfterRef (3.0)

# New in 4.0...
startAfterRef  = 70 # @afterref (4.0)
startNl        = 71 # @nl (4.0)
startNonl      = 72 # @nonl (4.0)
startWs        = 73 # @ws (4.0)</t>
<t tx="T171"></t>
<t tx="T172">def __init__(self,theCommander): 

	# trace("__init__", "atFile.__init__")
	self.commands = theCommander # The commander for the current window.
	self.fileCommands = self.commands.fileCommands

	# &lt; &lt; init the 4.x constants &gt; &gt;
	self.initIvars()

def initIvars(self):

	&lt;&lt; init atFile ivars &gt;&gt;
</t>
<t tx="T173">@ errors is the number of errors seen while reading and writing.  structureErrors are errors reported by createNthChild.  If structure errors are found we delete the outline tree and rescan.
@c
self.errors = 0
self.structureErrors = 0

@ Initialized by atFile.scanAllDirectives.  8/1/02: set all to None here.
@c
self.default_directory = None
self.page_width = None
self.tab_width  = None
self.startSentinelComment = None
self.endSentinelComment = None
self.language = None

@ The files used by the output routines.  When tangling, we first write to a temporary output file.  After tangling is temporary file.  Otherwise we delete the old target file and rename the temporary file to be the target file.
@c
self.shortFileName = "" # short version of file name used for messages.
self.targetFileName = u"" # EKR 1/21/03: now a unicode string
self.outputFileName = u"" # EKR 1/21/03: now a unicode string
self.outputFile = None # The temporary output file.

@ The indentation used when outputting section references or at-others sections.  We add the indentation of the line containing the at-node directive and restore the old value when the
expansion is complete.
@c
self.indent = 0  # The unit of indentation is spaces, not tabs.

# The root of tree being written.
self.root = None

# Ivars used to suppress newlines between sentinels.
self.suppress_newlines = true # true: enable suppression of newlines.
self.newline_pending = false # true: newline is pending on read or write.

# Support of output_newline option
self.output_newline = getOutputNewline()

# Support of @raw
self.raw = false # true: in @raw mode
self.sentinels = true # true: output sentinels while expanding refs.

# Enables tracing (debugging only).
self.trace = false

# The encoding used to convert from unicode to a byte stream.
self.encoding = app().config.default_derived_file_encoding

# New for 4.0
self.using_gnx = false # true: present derived file uses gnxs.</t>
<t tx="T174"></t>
<t tx="T175">@ This method scans all vnodes, calling read for every @file node found.  v should point to the root of the entire tree on entry.

Bug fix: 9/19/01 This routine clears all orphan status bits, so we must set the dirty bit of orphan @file nodes to force the writing of those nodes on saves.  If we didn't do this, a _second_ save of the .leo file would effectively wipe out bad @file nodes!

10/19/01: With the "new" Leo2 there are no such problems, and setting the dirty bit here is still correct.
@c

def readAll(self,root,partialFlag=false):

	c = self.commands
	c.endEditing() # Capture the current headline.
	anyRead = false
	self.initIvars()
	v = root
	if partialFlag: after = v.nodeAfterTree()
	else: after = None
	while v and v != after:
		if v.isAtIgnoreNode():
			v = v.nodeAfterTree()
		elif v.isAtFileNode() or v.isAtRawFileNode():
			anyRead = true
			if partialFlag:
				# We are forcing the read.
				self.read(v)
			else:
				# if v is an orphan, we don't expect to see a derived file,
				# and we shall read a derived file if it exists.
				wasOrphan = v.isOrphan()
				ok = self.read(v)
				if wasOrphan and not ok:
					# Remind the user to fix the problem.
					v.setDirty()
					c.setChanged(true)
			v = v.nodeAfterTree()
		else: v = v.threadNext()
	# Clear all orphan bits.
	v = root
	while v:
		v.clearOrphan()
		v = v.threadNext()
		
	if partialFlag and not anyRead:
		es("no @file nodes in the selected tree")</t>
<t tx="T176">@ This is the entry point to the read code.  The root vnode should be an @file node.  If doErrorRecoveryFlag is false we are doing an update.  In that case it would be very unwise to do any error recovery which might clear clone links.  If doErrorRecoveryFlag is true and there are structure errors during the first pass we delete root's children and its body text, then rescan.  All other errors indicate potentially serious problems with sentinels.

The caller has enclosed this code in beginUpdate/endUpdate.
@c
def read(self,root,importFileName=None):

	# trace("old read")
	c = self.commands
	&lt;&lt; set self.targetFileName &gt;&gt;
	self.root = root ; self.raw = false
	self.errors = self.structureErrors = 0
	&lt;&lt; open file &gt;&gt;
	if self.errors &gt; 0: return 0
	es("reading: " + root.headString())
	&lt;&lt; Scan the file buffer &gt;&gt;
	&lt;&lt; Bump mStructureErrors if any vnodes are unvisited &gt;&gt;
	if self.structureErrors &gt; 0:
		self.readError("-- Rereading file.  Clone links into this file will be lost.") ;
		self.errors = 0
		&lt;&lt; quickly delete root's tree and body text &gt;&gt;
		file.seek(0)
		&lt;&lt; Scan the file buffer &gt;&gt;
	file.close()
	if self.errors &gt; 0:
		# A serious error has occured that has not been corrected.
		self.readError("----- File may have damaged sentinels!")
		root.unjoinTree();
	else: root.clearDirty()
	return self.errors == 0
</t>
<t tx="T177">if root.isAtFileNode():
	self.targetFileName = root.atFileNodeName()
else:
	self.targetFileName = root.atRawFileNodeName()</t>
<t tx="T178">self.scanAllDirectives(root) # 1/30/02

if not self.targetFileName or len(self.targetFileName) == 0:
	self.readError("Missing file name.  Restoring @file tree from .leo file.")
else:
	# print self.default_directory, self.targetFileName
	fn = os.path.join(self.default_directory, self.targetFileName)
	fn = os.path.normpath(fn)
	fn = toUnicode(fn,"ascii")
	
	try:
		file = open(fn,'r')
		if file:
			&lt;&lt; warn on read-only file &gt;&gt;
	except:
		self.readError("Can not open: " + '"@file ' + fn + '"')</t>
<t tx="T179">try:
	read_only = not os.access(fn,os.W_OK)
	if read_only:
		es("read only: " + fn,color="red")
except:
	pass # os.access() may not exist on all platforms.
</t>
<t tx="T180">firstLines = self.scanHeader(file)

# Reading 4.0 files is not ready yet.
if self.using_gnx:
	es("Reading 4.0 files not ready yet")
	return false
	
self.indent = 0
self.root_seen = false
out = []
	
root.clearVisitedInTree() # Clear the list of nodes for orphans logic.
lastLines = self.scanText(file,root,out,atFile.endLeo)

# 18-SEP-2002 DTHEIN: update the bodyString directly, because
# out no longer holds body text of node.
if root.t.hasBody:
	bodyLines = root.t.bodyString.split('\n')
	self.completeFirstDirectives(bodyLines,firstLines)
	self.completeLastDirectives(bodyLines,lastLines)
	bodyText = '\n'.join(bodyLines)
	bodyText = bodyText.replace('\r', '')
	root.t.setTnodeText(bodyText)
</t>
<t tx="T181">@ createNthNode marks all nodes in the derived file as visited.  Any unvisited nodes are either dummies or nodes that don't exist in the derived file.
@c

next = root.nodeAfterTree()
v = root.threadNext()
while v and v != next:
	if not v.isVisited():
		if 0: # CVS produces to many errors for this to be useful.
			es("unvisited node: " + v.headString())
		self.structureErrors += 1
	v = v.threadNext()
</t>
<t tx="T182">@ Calling v.doDelete is _way_ too slow here because it repeatedly calls c.initAllCloneBits.
@c

child = root.firstChild()
while child:
	next = child.next()
	# The guts of doDelete
	child.destroyDependents()
	child.unjoinTree()
	child.unlink()
	child = next
c.selectVnode(root)

root.setBodyStringOrPane("")</t>
<t tx="T183"></t>
<t tx="T184"># 14-SEP-2002 DTHEIN: added for use by atFile.read()

# this function scans the lines in the list 'out' for @first directives
# and appends the corresponding line from 'firstLines' to each @first 
# directive found.  NOTE: the @first directives must be the very first
# lines in 'out'.
def completeFirstDirectives(self,out,firstLines):

	tag = "@first"
	foundAtFirstYet = 0
	outRange = range(len(out))
	j = 0
	for k in outRange:
		# skip leading whitespace lines
		if (not foundAtFirstYet) and (len(out[k].strip()) == 0): continue
		# quit if something other than @first directive
		i = 0
		if not match(out[k],i,tag): break;
		foundAtFirstYet = 1
		# quit if no leading lines to apply
		if j &gt;= len(firstLines): break
		# make the new @first directive
		#18-SEP-2002 DTHEIN: remove trailing newlines because they are inserted later
		# 21-SEP-2002 DTHEIN: no trailing whitespace on empty @first directive
		leadingLine = " " + firstLines[j]
		out[k] = tag + leadingLine.rstrip() ; j += 1
</t>
<t tx="T185"># 14-SEP-2002 DTHEIN: added for use by atFile.read()

# this function scans the lines in the list 'out' for @last directives
# and appends the corresponding line from 'lastLines' to each @last 
# directive found.  NOTE: the @last directives must be the very last
# lines in 'out'.
def completeLastDirectives(self,out,lastLines):

	tag = "@last"
	foundAtLastYet = 0
	outRange = range(-1,-len(out),-1)
	j = -1
	for k in outRange:
		# skip trailing whitespace lines
		if (not foundAtLastYet) and (len(out[k].strip()) == 0): continue
		# quit if something other than @last directive
		i = 0
		if not match(out[k],i,tag): break;
		foundAtLastYet = 1
		# quit if no trailing lines to apply
		if j &lt; -len(lastLines): break
		# make the new @last directive
		#18-SEP-2002 DTHEIN: remove trailing newlines because they are inserted later
		# 21-SEP-2002 DTHEIN: no trailing whitespace on empty @last directive
		trailingLine = " " + lastLines[j]
		out[k] = tag + trailingLine.rstrip() ; j -= 1
</t>
<t tx="T186">@ Sections appear in the derived file in reference order, not tree order.  Therefore, when we insert the nth child of the parent there is no guarantee that the previous n-1 children have already been inserted. And it won't work just to insert the nth child as the last child if there aren't n-1 previous siblings.  For example, if we insert the third child followed by the second child followed by the first child the second and third children will be out of order.

To ensure that nodes are placed in the correct location we create "dummy" children as needed as placeholders.  In the example above, we would insert two dummy children when inserting the third child.  When inserting the other two children we replace the previously inserted dummy child with the actual children.

vnode child indices are zero-based.  Here we use 1-based indices.

With the "mirroring" scheme it is a structure error if we ever have to create dummy vnodes.  Such structure errors cause a second pass to be made, with an empty root.  This second pass will generate other structure errors, which are ignored.
@c
def createNthChild(self,n,parent,headline):

	assert(n &gt; 0)

	# Create any needed dummy children.
	dummies = n - parent.numberOfChildren() - 1
	if dummies &gt; 0:
		if 0: # CVS produces to many errors for this to be useful.
			es("dummy created")
		self.structureErrors += 1
	while dummies &gt; 0:
		dummies -= 1
		dummy = parent.insertAsLastChild(leoNodes.tnode())
		# The user should never see this headline.
		dummy.initHeadString("Dummy")

	if n &lt;= parent.numberOfChildren():
		&lt;&lt; check the headlines &gt;&gt;
	else:
		# This is using a dummy; we should already have bumped structureErrors.
		result = parent.insertAsLastChild(leoNodes.tnode())
	result.initHeadString(headline)
	
	result.setVisited() # Suppress all other errors for this node.
	return result</t>
<t tx="T187"># 1/24/03: A kludgy fix to the problem of headlines containing comment delims.

result = parent.nthChild(n-1)
resulthead = result.headString()

if headline.strip() != resulthead.strip():
	start = self.startSentinelComment
	end = self.endSentinelComment
	if end and len(end) &gt; 0:
		# 1/25/03: The kludgy fix.
		# Compare the headlines without the delims.
		h1 =   headline.replace(start,"").replace(end,"")
		h2 = resulthead.replace(start,"").replace(end,"")
		if h1.strip() == h2.strip():
			# 1/25/03: Another kludge: use the headline from the outline, not the derived file.
			headline = resulthead
		else:
			self.structureErrors += 1
	else:
		self.structureErrors += 1
</t>
<t tx="T188">def handleLinesFollowingSentinel (self,lines,sentinel,comments = true):
	
	"""convert lines following a sentinel to a single line"""
	
	m = " following" + sentinel + " sentinel"
	start = self.startSentinelComment
	end   = self.endSentinelComment
	
	if len(lines) == 1: # The expected case.
		s = lines[0]
	elif len(lines) == 5:
		self.readError("potential cvs conflict" + m)
		s = lines[1]
		es("using " + s)
	else:
		self.readError("unexpected lines" + m)
		es(len(lines), " lines" + m)
		s = "bad " + sentinel
		if comments: s = start + ' ' + s

	if comments:
		&lt;&lt; remove the comment delims from s &gt;&gt;
		
	# Undo the cweb hack: undouble @ signs if the opening comment delim ends in '@'.
	if start[-1:] == '@':
		s = s.replace('@@','@')

	return s</t>
<t tx="T189"># Remove the starting comment and the blank.
# 5/1/03: The starting comment now looks like a sentinel, to warn users from changing it.
comment = start + '@ '
if match(s,0,comment):
	s = s[len(comment):]
else:
	self.readError("expecting comment" + m)

# Remove the trailing comment.
if len(end) == 0:
	s = string.strip(s[:-1])
else:
	k = s.rfind(end)
	s = string.strip(s[:k]) # works even if k == -1</t>
<t tx="T190">def readLine (self,file):
	"""Reads one line from file using the present encoding"""
	
	s = readlineForceUnixNewline(file)
	u = toUnicode(s,self.encoding)
	return u

</t>
<t tx="T191"># We expect only a single line, and more may exist if cvs detects a conflict.
# We accept the first line even if it looks like a sentinel.
# 5/1/03: The starting comment now looks like a sentinel, to warn users from changing it.

def readLinesToNextSentinel (self,file):
	
	"""	read lines following multiline sentinels"""
	
	lines = []
	start = self.startSentinelComment + '@ '
	nextLine = self.readLine(file)
	while nextLine and len(nextLine) &gt; 0:
		if len(lines) == 0:
			lines.append(nextLine)
			nextLine = self.readLine(file)
		else:
			# 5/1/03: looser test then calling sentinelKind.
			s = nextLine ; i = skip_ws(s,0)
			if match(s,i,start):
				lines.append(nextLine)
				nextLine = self.readLine(file)
			else: break

	return nextLine,lines</t>
<t tx="T192"># Scans the doc part and appends the text out.
# s,i point to the present line on entry.

def scanDoc(self,file,s,i,out,kind):

	endKind = choose(kind == atFile.startDoc, atFile.endDoc, atFile.endAt)
	single = len(self.endSentinelComment) == 0
	&lt;&lt; Skip the opening sentinel &gt;&gt;
	&lt;&lt; Skip an opening block delim &gt;&gt;
	nextLine = None ; kind = atFile.noSentinel
	while len(s) &gt; 0:
		&lt;&lt; set kind, nextLine &gt;&gt;
		if kind == endKind: break
		&lt;&lt; Skip the leading stuff &gt;&gt;
		&lt;&lt; Append s to out &gt;&gt;
		if nextLine:
			s = nextLine ; nextLine = None
		else: s = self.readLine(file)
	if kind != endKind:
		self.readError("Missing " + self.sentinelName(endKind) + " sentinel")
	&lt;&lt; Remove a closing block delim from out &gt;&gt;</t>
<t tx="T193">assert(match(s,i,choose(kind == atFile.startDoc, "+doc", "+at")))

out.append(choose(kind == atFile.startDoc, "@doc", "@"))
s = self.readLine(file)
</t>
<t tx="T194">if not single:
	j = skip_ws(s,0)
	if match(s,j,self.startSentinelComment):
		s = self.readLine(file)</t>
<t tx="T195">@ For non-sentinel lines we look ahead to see whether the next line is a sentinel.
@c

assert(nextLine==None)

kind = self.sentinelKind(s)

if kind == atFile.noSentinel:
	j = skip_ws(s,0)
	blankLine = s[j] == '\n'
	nextLine = self.readLine(file)
	nextKind = self.sentinelKind(nextLine)
	if blankLine and nextKind == endKind:
		kind = endKind # stop the scan now
</t>
<t tx="T196"># Point i to the start of the real line.

if single: # Skip the opening comment delim and a blank.
	i = skip_ws(s,0)
	if match(s,i,self.startSentinelComment):
		i += len(self.startSentinelComment)
		if match(s,i," "): i += 1
else:
	i = self.skipIndent(s,0, self.indent)
</t>
<t tx="T197"># Append the line with a newline if it is real

line = s[i:-1] # remove newline for rstrip.

if line == line.rstrip():
	# no trailing whitespace: the newline is real.
	out.append(line + '\n')
else:
	# trailing whitespace: the newline is not real.
	out.append(line)
</t>
<t tx="T198"># This code will typically only be executed for HTML files.

if not single:

	delim = self.endSentinelComment
	n = len(delim)
	
	# Remove delim and possible a leading newline.
	s = string.join(out,"")
	s = s.rstrip()
	if s[-n:] == delim:
		s = s[:-n]
	if s[-1] == '\n':
		s = s[:-1]
		
	# Rewrite out in place.
	del out[:]
	out.append(s)
</t>
<t tx="T199">@ This method sets self.startSentinelComment and self.endSentinelComment based on the first @+leo sentinel line of the file.  We can not call sentinelKind here because that depends on the comment delimiters we set here.  @first lines are written "verbatim", so nothing more needs to be done!

7/8/02: Leading whitespace is now significant here before the @+leo.  This is part of the "REM hack".  We do this so that sentinelKind need not skip whitespace following self.startSentinelComment.  This is correct: we want to be as restrictive as possible about what is recognized as a sentinel.  This minimizes false matches.

14-SEP-2002 DTHEIN:  Queue up the lines before the @+leo.  These will be used to add as parameters to the @first directives, if any.  Empty lines are ignored (because empty @first directives are ignored). NOTE: the function now returns a list of the lines before @+leo.
@c
def scanHeader(self,file):

	valid = true
	tag = "@+leo" ; version_tag = "-ver="
	encoding_tag = "-encoding="
	&lt;&lt; skip any non @+leo lines &gt;&gt;
	&lt;&lt; make sure we have @+leo &gt;&gt;
	&lt;&lt; read optional version param &gt;&gt;
	&lt;&lt; read optional encoding param &gt;&gt;
	&lt;&lt; set the closing comment delim &gt;&gt;
	if not valid:
		self.readError("Bad @+leo sentinel in " + self.targetFileName)
	return firstLines</t>
<t tx="T200">firstLines = [] # The lines before @+leo.
s = self.readLine(file)
while len(s) &gt; 0:
	j = s.find(tag)
	if j != -1: break
	firstLines.append(s) # Queue the line
	s = self.readLine(file)
n = len(s)
valid = n &gt; 0
# s contains the tag
i = j = skip_ws(s,0)
# The opening comment delim is the initial non-whitespace.
# 7/8/02: The opening comment delim is the initial non-tag
while i &lt; n and not match(s,i,tag) and not is_nl(s,i):
	i += 1
if j &lt; i:
	self.startSentinelComment = s[j:i]
else: valid = false</t>
<t tx="T201">if 0:# 7/8/02: make leading whitespace significant.
	i = skip_ws(s,i)

if match(s,i,tag):
	i += len(tag)
else: valid = false</t>
<t tx="T202">self.using_gnx = match(s,i,version_tag)

if self.using_gnx:
	trace("reading gnx file",self.targetFileName)
	i += len(version_tag)
	# Skip to the next minus sign or end-of-line
	j = i
	while i &lt; len(s) and not is_nl(s,i) and s[i] != '-':
		i += 1
	if j &lt; i:
		version = s[j:i]
	else:
		valid = false

	
</t>
<t tx="T203"># 1/20/03: EKR: Read optional encoding param, e.g., -encoding=utf-8,

# Set the default encoding
self.encoding = app().config.default_derived_file_encoding

if match(s,i,encoding_tag):
	i += len(encoding_tag)
	# Skip to the next comma
	j = i
	while i &lt; len(s) and not is_nl(s,i) and s[i] not in (',','.'):
		i += 1
	if match(s,i,',') or match(s,i,'.'):
		encoding = s[j:i]
		i += 1
		# print "@+leo-encoding=",encoding
		if isValidEncoding(encoding):
			self.encoding = encoding
		else:
			es("bad encoding in derived file:",encoding)
	else:
		valid = false
</t>
<t tx="T204"># The closing comment delim is the trailing non-whitespace.
i = j = skip_ws(s,i)
while i &lt; n and not is_ws(s[i]) and not is_nl(s,i):
	i += 1
self.endSentinelComment = s[j:i]</t>
<t tx="T205">@ This method is the read code.

scanText reads lines from the file until the given ending sentinel is found, and warns if any other ending sentinel is found instead.  It calls itself recursively to handle most nested sentinels.

@c
def scanText (self,file,v,out,endSentinelKind,nextLine=None):

	a = app() ; c = self.commands ; config = a.config
	lastLines = [] # The lines after @-leo
	lineIndent = 0 ; linep = 0 # Changed only for sentinels.
	while 1:
		&lt;&lt; put the next line into s &gt;&gt;
		&lt;&lt; set kind, nextKind &gt;&gt;
		if kind != atFile.noSentinel:
			&lt;&lt; set lineIndent, linep and leading_ws &gt;&gt;
			i = self.skipSentinelStart(s,0)
		&lt;&lt; handle the line in s &gt;&gt;
	&lt;&lt; handle unexpected end of text &gt;&gt;
	assert(len(s)==0 and nextLine==None) # We get here only if readline fails.
	return lastLines # We get here only if there are problems.</t>
<t tx="T206">if nextLine:
	s = nextLine ; nextLine = None
else:
	s = self.readLine(file)
	if len(s) == 0: break

# trace(`s`)</t>
<t tx="T207">@ For non-sentinel lines we look ahead to see whether the next line is a sentinel.  If so, the newline that ends a non-sentinel line belongs to the next sentinel.
@c

assert(nextLine==None)

kind = self.sentinelKind(s)

if kind == atFile.noSentinel:
	nextLine = self.readLine(file)
	nextKind = self.sentinelKind(nextLine)
else:
	nextLine = nextKind = None

# nextLine != None only if we have a non-sentinel line.
# Therefore, nextLine == None whenever scanText returns.</t>
<t tx="T208">@ lineIndent is the total indentation on a sentinel line.  The first "self.indent" portion of that must be removed when recreating text.  leading_ws is the remainder of the leading whitespace.  linep points to the first "real" character of a line, the character following the "indent" whitespace.
@c

# Point linep past the first self.indent whitespace characters.
if self.raw: # 10/15/02
	linep =0
else:
	linep = self.skipIndent(s,0,self.indent)

# Set lineIndent to the total indentation on the line.
lineIndent = 0 ; i = 0
while i &lt; len(s):
	if s[i] == '\t': lineIndent += (abs(self.tab_width) - (lineIndent % abs(self.tab_width)))
	elif s[i] == ' ': lineIndent += 1
	else: break
	i += 1
# trace("lineIndent:" +`lineIndent` + ", " + `s`)

# Set leading_ws to the additional indentation on the line.
leading_ws = s[linep:i]</t>
<t tx="T209"># Issue the error.
name = self.sentinelName(endSentinelKind)
self.readError("Unexpected end of file. Expecting " + name + "sentinel" )
</t>
<t tx="T210">if kind == atFile.noSentinel:
	&lt;&lt; append non-sentinel line &gt;&gt;
&lt;&lt; handle common sentinels &gt;&gt;
&lt;&lt; handle rare sentinels &gt;&gt;
else:
	&lt;&lt; warn about unknown sentinel &gt;&gt;</t>
<t tx="T211"># We don't output the trailing newline if the next line is a sentinel.
if self.raw: # 10/15/02
	i = 0
else:
	i = self.skipIndent(s,0,self.indent)

assert(nextLine != None)

if nextKind == atFile.noSentinel:
	line = s[i:]
	out.append(line)
else:
	line = s[i:-1] # don't output the newline
	out.append(line)
</t>
<t tx="T212">elif kind in (
	atFile.endAt,  atFile.endBody, atFile.endDoc,
	atFile.endLeo, atFile.endNode, atFile.endOthers):
		&lt;&lt; handle an ending sentinel &gt;&gt;
elif kind == atFile.startBody:
	&lt;&lt; scan @+body &gt;&gt;
elif kind == atFile.startNode:
	&lt;&lt; scan @+node &gt;&gt;
elif kind == atFile.startRef:
	&lt;&lt; scan old ref &gt;&gt;
elif kind == atFile.startAt:
	&lt;&lt; scan @+at &gt;&gt;
elif kind == atFile.startDoc:
	&lt;&lt; scan @+doc &gt;&gt;
elif kind == atFile.startOthers:
	&lt;&lt; scan @+others &gt;&gt;</t>
<t tx="T213"># trace("end sentinel:", self.sentinelName(kind))

if kind == endSentinelKind:
	if kind == atFile.endLeo:
		# Ignore everything after @-leo.
		# Such lines were presumably written by @last.
		while 1:
			s = self.readLine(file)
			if len(s) == 0: break
			lastLines.append(s) # Capture all trailing lines, even if empty.
	elif kind == atFile.endBody:
		self.raw = false
	# nextLine != None only if we have a non-sentinel line.
	# Therefore, nextLine == None whenever scanText returns.
	assert(nextLine==None)
	return lastLines # End the call to scanText.
else:
	# Tell of the structure error.
	name = self.sentinelName(kind)
	expect = self.sentinelName(endSentinelKind)
	self.readError("Ignoring " + name + " sentinel.  Expecting " + expect)</t>
<t tx="T214">@ The sentinel contains an @ followed by a section name in angle brackets.  This code is different from the code for the @@ sentinel: the expansion of the reference does not include a trailing newline.
@c

assert(match(s,i,"&lt;&lt;"))

if len(self.endSentinelComment) == 0:
	line = s[i:-1] # No trailing newline
else:
	k = s.find(self.endSentinelComment,i)
	line = s[i:k] # No trailing newline, whatever k is.
		
# 10/30/02: undo cweb hack here
start = self.startSentinelComment
if start and len(start) &gt; 0 and start[-1] == '@':
	line = line.replace('@@','@')

out.append(line)</t>
<t tx="T215">assert(match(s,i,"+at"))
self.scanDoc(file,s,i,out,kind)</t>
<t tx="T216">assert(match(s,i,"+body"))

child_out = [] ; child = v # Do not change out or v!
oldIndent = self.indent ; self.indent = lineIndent
self.scanText(file,child,child_out,atFile.endBody)

if 0:
	if child.isOrphan():
		self.readError("Replacing body text of orphan: " + child.headString())

# Set the body, removing cursed newlines.
# Note:  This code must be done here, not in the @+node logic.
body = string.join(child_out, "")
body = body.replace('\r', '')
child.t.setTnodeText(body)
self.indent = oldIndent</t>
<t tx="T217">assert(match(s,i,"+doc"))
self.scanDoc(file,s,i,out,kind)</t>
<t tx="T218">assert(match(s,i,"+node:"))
i += 6

childIndex = 0 ; cloneIndex = 0
&lt;&lt; Set childIndex &gt;&gt;
&lt;&lt; Set cloneIndex &gt;&gt;
headline = ""
&lt;&lt; Set headline and ref &gt;&gt;

# print childIndex,headline

if childIndex == 0: # The root node.
	&lt;&lt; Check the filename in the sentinel &gt;&gt;
	# Put the text of the root node in the current node.
	self.scanText(file,v,out,atFile.endNode)
	v.t.setCloneIndex(cloneIndex)
	# if cloneIndex &gt; 0: trace("clone index:" + `cloneIndex` + ", " + `v`)
else:
	# NB: this call to createNthChild is the bottleneck!
	child = self.createNthChild(childIndex,v,headline)
	child.t.setCloneIndex(cloneIndex)
	# if cloneIndex &gt; 0: trace("clone index:" + `cloneIndex` + ", " + `child`)
	self.scanText(file,child,out,atFile.endNode)

&lt;&lt; look for sentinels that may follow a reference &gt;&gt;</t>
<t tx="T219">i = skip_ws(s,i) ; j = i
while i &lt; len(s) and s[i] in string.digits:
	i += 1

if j == i:
	self.readError("Implicit child index in @+node")
	childIndex = 0
else:
	childIndex = int(s[j:i])

if match(s,i,':'):
	i += 1 # Skip the ":".
else:
	self.readError("Bad child index in @+node")</t>
<t tx="T220">while i &lt; len(s) and s[i] != ':' and not is_nl(s,i):
	if match(s,i,"C="):
		# set cloneIndex from the C=nnn, field
		i += 2 ; j = i
		while i &lt; len(s) and s[i] in string.digits:
			i += 1
		if j &lt; i:
			cloneIndex = int(s[j:i])
	else: i += 1 # Ignore unknown status bits.

if match(s,i,":"):
	i += 1
else:
	self.readError("Bad attribute field in @+node")</t>
<t tx="T221"># Set headline to the rest of the line.
# 6/22/03: don't strip leading whitespace.
if len(self.endSentinelComment) == 0:
	headline = s[i:-1].rstrip()
else:
	# 10/24/02: search from the right, not the left.
	k = s.rfind(self.endSentinelComment,i)
	headline = s[i:k].rstrip() # works if k == -1
	
# 10/23/02: The cweb hack: undouble @ signs if the opening comment delim ends in '@'.
if self.startSentinelComment[-1:] == '@':
	headline = headline.replace('@@','@')

# Set reference if it exists.
i = skip_ws(s,i)

if 0: # no longer used
	if match(s,i,"&lt;&lt;"):
		k = s.find("&gt;&gt;",i)
		if k != -1: ref = s[i:k+2]</t>
<t tx="T222">h = headline.strip()

if h[:5] == "@file":
	i,junk,junk = scanAtFileOptions(h)
	fileName = string.strip(h[i:])
	if fileName != self.targetFileName:
		self.readError("File name in @node sentinel does not match file's name")
elif h[:8] == "@rawfile":
	fileName = string.strip(h[8:])
	if fileName != self.targetFileName:
		self.readError("File name in @node sentinel does not match file's name")
else:
	self.readError("Missing @file in root @node sentinel")
</t>
<t tx="T223">s = self.readLine(file)
kind = self.sentinelKind(s)

if len(s) &gt; 1 and kind == atFile.startVerbatimAfterRef:
	s = self.readLine(file)
	# trace("verbatim:"+`s`)
	out.append(s)
elif len(s) &gt; 1 and self.sentinelKind(s) == atFile.noSentinel:
	out.append(s)
else:
	nextLine = s # Handle the sentinel or blank line later.
</t>
<t tx="T224">assert(match(s,i,"+others"))

# Make sure that the generated at-others is properly indented.
out.append(leading_ws + "@others")

self.scanText(file,v,out,atFile.endOthers)</t>
<t tx="T225">elif kind == atFile.startComment:
	&lt;&lt; scan @comment &gt;&gt;
elif kind == atFile.startDelims:
	&lt;&lt; scan @delims &gt;&gt;
elif kind == atFile.startDirective:
	&lt;&lt; scan @@ &gt;&gt;
elif kind == atFile.startLeo:
	&lt;&lt; scan @+leo &gt;&gt;
elif kind == atFile.startVerbatim:
	&lt;&lt; scan @verbatim &gt;&gt;</t>
<t tx="T226">assert(match(s,i,"+leo"))
self.readError("Ignoring unexpected @+leo sentinel")</t>
<t tx="T227"># The first '@' has already been eaten.
assert(match(s,i,"@"))

if match_word(s,i,"@raw"):
	self.raw = true
elif match_word(s,i,"@end_raw"):
	self.raw = false

e = self.endSentinelComment
s2 = s[i:]
if len(e) &gt; 0:
	k = s.rfind(e,i)
	if k != -1:
		s2 = s[i:k] + '\n'
	
start = self.startSentinelComment
if start and len(start) &gt; 0 and start[-1] == '@':
	s2 = s2.replace('@@','@')
out.append(s2)
# trace(`s2`)</t>
<t tx="T228">assert(match(s,i,"comment"))

# We need do nothing more to ignore the comment line!
</t>
<t tx="T229">assert(match(s,i-1,"@delims"));

# Skip the keyword and whitespace.
i0 = i-1
i = skip_ws(s,i-1+7)
	
# Get the first delim.
j = i
while i &lt; len(s) and not is_ws(s[i]) and not is_nl(s,i):
	i += 1

if j &lt; i:
	self.startSentinelComment = s[j:i]
	# print "delim1:", self.startSentinelComment

	# Get the optional second delim.
	j = i = skip_ws(s,i)
	while i &lt; len(s) and not is_ws(s[i]) and not is_nl(s,i):
		i += 1
	end = choose(j&lt;i,s[j:i],"")
	i2 = skip_ws(s,i)
	if end == self.endSentinelComment and (i2 &gt;= len(s) or is_nl(s,i2)):
		self.endSentinelComment = "" # Not really two params.
		line = s[i0:j]
		line = line.rstrip()
		out.append(line+'\n')
	else:
		self.endSentinelComment = end
		# print "delim2:",end
		line = s[i0:i]
		line = line.rstrip()
		out.append(line+'\n')
else:
	self.readError("Bad @delims")
	# Append the bad @delims line to the body text.
	out.append("@delims")</t>
<t tx="T230">assert(match(s,i,"verbatim"))

# Skip the sentinel.
s = self.readLine(file) 

# Append the next line to the text.
i = self.skipIndent(s,0,self.indent)
out.append(s[i:])
</t>
<t tx="T231">j = i
i = skip_line(s,i)
line = s[j:i]
self.readError("Unknown sentinel: " + line)</t>
<t tx="T232"></t>
<t tx="T233"># 4/5/03: config.write_clone_indices no longer used.

def nodeSentinelText(self,v):
	
	if v == self.root or not v.parent():
		index = 0
	else:
		index = v.childIndex() + 1

	h = v.headString()
	&lt;&lt; remove comment delims from h if necessary &gt;&gt;

	return str(index) + '::' + h</t>
<t tx="T234">@ Bug fix 1/24/03:

If the present @language/@comment settings do not specify a single-line comment we remove all block comment delims from h.  This prevents headline text from interfering with the parsing of node sentinels.
@c

start = self.startSentinelComment
end = self.endSentinelComment

if end and len(end) &gt; 0:
	h = h.replace(start,"")
	h = h.replace(end,"")</t>
<t tx="T235">def putCloseNodeSentinel(self,v):

	s = self.nodeSentinelText(v)
	self.putSentinel("@-node:" + s)</t>
<t tx="T236">@ root is an ancestor of v, or root == v.  We call putCloseSentinel for v up to, but not including, root.
@c
def putCloseSentinels(self,root,v):

	self.putCloseNodeSentinel(v)
	while 1:
		v = v.parent()
		assert(v) # root must be an ancestor of v.
		if  v == root: break
		self.putCloseNodeSentinel(v)</t>
<t tx="T237">@ This method is the same as putSentinel except we don't put an opening newline and leading whitespace.
@c
def putOpenLeoSentinel(self,s):
	
	if not self.sentinels:
		return # Handle @nosentinelsfile.

	self.os(self.startSentinelComment)
	self.os(s)
	encoding = self.encoding.lower()
	if encoding != "utf-8":
		self.os("-encoding=")
		self.os(encoding)
		self.os(".")
	self.os(self.endSentinelComment)
	if self.suppress_newlines: # 9/27/02
		self.newline_pending = true # Schedule a newline.
	else:
		self.onl() # End of sentinel.
</t>
<t tx="T238">@ This method puts an open node sentinel for node v.
@c
def putOpenNodeSentinel(self,v):

	if v.isAtFileNode() and v != self.root:
		self.writeError("@file not valid in: " + v.headString())
		return
	
	s = self.nodeSentinelText(v)
	self.putSentinel("@+node:" + s)</t>
<t tx="T239">@ root is an ancestor of v, or root == v.  We call putOpenNodeSentinel on all the descendents of root which are the ancestors of v.
@c
def putOpenSentinels(self,root,v):

	last = root
	while last != v:
		# Set node to v or the ancestor of v that is a child of last.
		node = v
		while node and node.parent() != last:
			node = node.parent()
		assert(node)
		self.putOpenNodeSentinel(node)
		last = node</t>
<t tx="T240">@ All sentinels are eventually output by this method.

Sentinels include both the preceding and following newlines. This rule greatly simplies the code and has several important benefits:

1. Callers never have to generate newlines before or after sentinels.  Similarly, routines that expand code and doc parts never have to add "extra" newlines.
2. There is no need for a "no-newline" directive.  If text follows a section reference, it will appear just after the newline that ends sentinel at the end of the expansion of the reference.  If no significant text follows a reference, there will be two newlines following the ending sentinel.

The only exception is that no newline is required before the opening "leo" sentinel. The putLeoSentinel and isLeoSentinel routines handle this minor exception.
@c
def putSentinel(self,s):
	
	if not self.sentinels:
		return # Handle @nosentinelsfile.

	self.newline_pending = false # discard any pending newline.
	self.onl() ; self.putIndent(self.indent) # Start of sentinel.
	self.os(self.startSentinelComment)

	# 11/1/02: The cweb hack: if the opening comment delim ends in '@',
	# double all '@' signs except the first, which is "doubled" by the
	# trailing '@' in the opening comment delimiter.
	start = self.startSentinelComment
	if start and len(start) &gt; 0 and start[-1] == '@':
		assert(s and len(s)&gt;0 and s[0]=='@')
		s = s.replace('@','@@')[1:]

	self.os(s)
	self.os(self.endSentinelComment)
	if self.suppress_newlines:
		self.newline_pending = true # Schedule a newline.
	else:
		self.onl() # End of sentinel.</t>
<t tx="T241">@ This method tells what kind of sentinel appears in line s.  Typically s will be an empty line before the actual sentinel, but it is also valid for s to be an actual sentinel line.

Returns (kind, s, emptyFlag), where emptyFlag is true if kind == noSentinel and s was an empty line on entry.
@c

sentinelDict = {
	"@comment" : startComment,
	"@delims" :  startDelims,
	"@verbatim": startVerbatim,
	"@verbatimAfterRef": startVerbatimAfterRef,
	"@+at":     startAt,     "@-at":     endAt,
	"@+body":   startBody,   "@-body":   endBody,
	"@+doc":    startDoc,    "@-doc":    endDoc,
	"@+leo":    startLeo,    "@-leo":    endLeo,
	"@+node":   startNode,   "@-node":   endNode,
	"@+others": startOthers, "@-others": endOthers }

def sentinelKind(self,s):

	# trace(s)
	i = skip_ws(s,0)
	if match(s,i,self.startSentinelComment): 
		i += len(self.startSentinelComment)
	else:
		return atFile.noSentinel

	# 10/30/02: locally undo cweb hack here
	start = self.startSentinelComment
	if start and len(start) &gt; 0 and start[-1] == '@':
		s = s[:i] + string.replace(s[i:],'@@','@')

	# Do not skip whitespace here!
	if match(s,i,"@&lt;&lt;"): return atFile.startRef
	if match(s,i,"@@"):   return atFile.startDirective
	if not match(s,i,'@'): return atFile.noSentinel
	j = i # start of lookup
	i += 1 # skip the at sign.
	if match(s,i,'+') or match(s,i,'-'):
		i += 1
	i = skip_c_id(s,i)
	key = s[j:i]
	if len(key) &gt; 0 and atFile.sentinelDict.has_key(key):
		# trace("found:",key)
		return atFile.sentinelDict[key]
	else:
		# trace("not found:",key)
		return atFile.noSentinel</t>
<t tx="T242"># Returns the name of the sentinel for warnings.

sentinelNameDict = {
	noSentinel: "&lt;no sentinel&gt;",
	startAt:     "@+at",     endAt:     "@-at",
	startBody:   "@+body",   endBody:   "@-body",
	startDoc:    "@+doc",    endDoc:    "@-doc",
	startLeo:    "@+leo",    endLeo:    "@-leo",
	startNode:   "@+node",   endNode:   "@-node",
	startOthers: "@+others", endOthers: "@-others",
	startComment:   "@comment",
	startDelims:    "@delims",
	startDirective: "@@",
	startRef:       "@&lt;&lt;",
	startVerbatim:  "@verbatim",
	startVerbatimAfterRef: "@verbatimAfterRef" }

def sentinelName(self, kind):
	if atFile.sentinelNameDict.has_key(kind):
		return atFile.sentinelNameDict[kind]
	else:
		return "&lt;unknown sentinel!&gt;"</t>
<t tx="T243">def skipSentinelStart(self,s,i):

	start = self.startSentinelComment
	assert(start and len(start)&gt;0)

	if is_nl(s,i): i = skip_nl(s,i)
	i = skip_ws(s,i)
	assert(match(s,i,start))
	i += len(start)
	# 7/8/02: Support for REM hack
	i = skip_ws(s,i)
	assert(i &lt; len(s) and s[i] == '@')
	return i + 1
</t>
<t tx="T244"></t>
<t tx="T245">def scanAll (self):

	c = self.commands ; v = c.rootVnode()
	while v:
		if v.isAtIgnoreNode():
			v = v.nodeAfterTree()
		elif v.isAtFileNode():
			self.scanFile(v)
			v = v.nodeAfterTree()
		else: v = v.threadNext()</t>
<t tx="T246">def scanFile(self,root):

	es("scanning: " + root.headString())
	self.targetFileName = root.atFileNodeName()
	self.root = root
	self.errors = self.structureErrors = 0
	&lt;&lt; open file &gt;&gt;
	if self.errors &gt; 0: return 0
	&lt;&lt; Scan the file buffer &gt;&gt;
	if self.structureErrors &gt; 0:
		self.readError(`self.structureErrors` + " errors scanning file")
	return self.errors == 0
</t>
<t tx="T247">if len(self.targetFileName) == 0:
	self.readError("Missing file name")
else:
	try:
		file = open(self.targetFileName,'r')
	except:
		self.readError("Error reading file")
</t>
<t tx="T248">self.indent = 0
out = []
self.scanHeader(file)
self.scanText(file,root,out,atFile.endLeo)
s = string.join(out, "")
root.setBodyStringOrPane(s)</t>
<t tx="T249"></t>
<t tx="T250">@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node v, no @color or @nocolor directives are examined in any ancestor of v.

This code is similar to Commands::scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,v):
	
	"""Scan vnode v and v's ancestors looking for directives,
	setting corresponding atFile ivars.
	"""

	c = self.commands
	&lt;&lt; Set ivars &gt;&gt;
	&lt;&lt; Set path from @file node &gt;&gt;
	old = {}
	while v:
		s = v.t.bodyString
		dict = get_directives_dict(s)
		&lt;&lt; Test for @path &gt;&gt;
		&lt;&lt; Test for @encoding &gt;&gt;
		&lt;&lt; Test for @comment and @language &gt;&gt;
		&lt;&lt; Test for @header and @noheader &gt;&gt;
		&lt;&lt; Test for @lineending &gt;&gt;
		&lt;&lt; Test for @pagewidth &gt;&gt;
		&lt;&lt; Test for @tabwidth &gt;&gt;
		old.update(dict)
		v = v.parent()
	&lt;&lt; Set current directory &gt;&gt;
	&lt;&lt; Set comment Strings from delims &gt;&gt;</t>
<t tx="T251">self.page_width = self.commands.page_width
self.tab_width  = self.commands.tab_width

self.default_directory = None # 8/2: will be set later.

delim1, delim2, delim3 = set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = app().config.default_derived_file_encoding
self.output_newline = getOutputNewline() # 4/24/03: initialize from config settings.</t>
<t tx="T252"># An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

# Bug fix: 10/16/02
if v.isAtFileNode():
	name = v.atFileNodeName()
elif v.isAtRawFileNode():
	name = v.atRawFileNodeName()
elif v.isAtNoSentinelsFileNode():
	name = v.atNoSentinelsFileNodeName()
else:
	name = ""

dir = choose(name,os.path.dirname(name),None)
if dir and len(dir) &gt; 0 and os.path.isabs(dir):
	if os.path.exists(dir):
		self.default_directory = dir
	else: # 9/25/02
		self.default_directory = makeAllNonExistentDirectories(dir)
		if not self.default_directory:
			self.error("Directory \"" + dir + "\" does not exist")
			
</t>
<t tx="T253"># 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

if not old.has_key("comment") and dict.has_key("comment"):
	k = dict["comment"]
	# 11/14/02: Similar to fix below.
	delim1, delim2, delim3 = set_delims_from_string(s[k:])

# Reversion fix: 12/06/02: We must use elif here, not if.
elif not old.has_key("language") and dict.has_key("language"):
	k = dict["language"]
	# 11/14/02: Fix bug reported by J.M.Gilligan.
	self.language,delim1,delim2,delim3 = set_language(s,k)</t>
<t tx="T254">if not old.has_key("encoding") and dict.has_key("encoding"):
	
	e = scanAtEncodingDirective(s,dict)
	if e:
		self.encoding = e</t>
<t tx="T255"># EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if dict.has_key("header") and dict.has_key("noheader"):
	es("conflicting @header and @noheader directives")</t>
<t tx="T256">if not old.has_key("lineending") and dict.has_key("lineending"):
	
	lineending = scanAtLineendingDirective(s,dict)
	if lineending:
		self.output_newline = lineending
</t>
<t tx="T257"># We set the current director to a path so future writes will go to that directory.

loadDir = app().loadDir

if not self.default_directory and not old.has_key("path") and dict.has_key("path"):

	k = dict["path"]
	&lt;&lt; compute relative path from s[k:] &gt;&gt;
	if path and len(path) &gt; 0:
		base = getBaseDirectory() # returns "" on error.
		path = os.path.join(base,path)
		if os.path.isabs(path):
			&lt;&lt; handle absolute path &gt;&gt;
		else:
			self.error("ignoring bad @path: " + path)
	else:
		self.error("ignoring empty @path")</t>
<t tx="T258">j = i = k + len("@path")
i = skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) &gt; 2 and (
	(path[0]=='&lt;' and path[-1] == '&gt;') or
	(path[0]=='"' and path[-1] == '"') ):
	path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
	path = os.path.join(loadDir,path)</t>
<t tx="T259"># path is an absolute path.

if os.path.exists(path):
	self.default_directory = path
else: # 9/25/02
	self.default_directory = makeAllNonExistentDirectories(path)
	if not self.default_directory:
		self.error("invalid @path: " + path)
</t>
<t tx="T260">if dict.has_key("pagewidth") and not old.has_key("pagewidth"):
	
	w = scanAtPagewidthDirective(s,dict,issue_error_flag=true)
	if w and w &gt; 0:
		self.page_width = w</t>
<t tx="T261">if dict.has_key("tabwidth") and not old.has_key("tabwidth"):
	
	w = scanAtTabwidthDirective(s,dict,issue_error_flag=true)
	if w and w != 0:
		self.tab_width = w

</t>
<t tx="T262"># This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
	base = getBaseDirectory() # returns "" on error.
	for dir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
		if dir and len(dir) &gt; 0:
			dir = os.path.join(base,dir)
			if os.path.isabs(dir): # Errors may result in relative or invalid path.
				if os.path.exists(dir):
					self.default_directory = dir ; break
				else: # 9/25/02
					self.default_directory = makeAllNonExistentDirectories(dir)

if not self.default_directory:
	# This should never happen: c.openDirectory should be a good last resort.
	self.error("No absolute directory specified anywhere.")
	self.default_directory = ""</t>
<t tx="T263"># Use single-line comments if we have a choice.
# 8/2/01: delim1,delim2,delim3 now correspond to line,start,end
if delim1:
	self.startSentinelComment = delim1
	self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
	self.startSentinelComment = delim2
	self.endSentinelComment = delim3
else: # Emergency!
	# assert(0)
	es("Unknown language: using Python comment delimiters")
	es("c.target_language:"+`c.target_language`)
	es("delim1,delim2,delim3:" + `delim1`+":"+`delim2`+":"+`delim3`)
	self.startSentinelComment = "#" # This should never happen!
	self.endSentinelComment = ""</t>
<t tx="T264"># Returns the kind of at-directive or noDirective.

def directiveKind(self,s,i):

	n = len(s)
	if i &gt;= n or s[i] != '@':
		return atFile.noDirective

	table = (
		("@c",atFile.cDirective),
		("@code",atFile.codeDirective),
		("@doc",atFile.docDirective),
		("@end_raw",atFile.endRawDirective),
		("@others",atFile.othersDirective),
		("@raw",atFile.rawDirective))

	# This code rarely gets executed, so simple code suffices.
	if i+1 &gt;= n or match(s,i,"@ ") or match(s,i,"@\t") or match(s,i,"@\n"):
		# 10/25/02: @space is not recognized in cweb mode.
		# 11/15/02: Noweb doc parts are _never_ scanned in cweb mode.
		return choose(self.language=="cweb",
			atFile.noDirective,atFile.atDirective)

	# 10/28/02: @c and @(nonalpha) are not recognized in cweb mode.
	# We treat @(nonalpha) separately because @ is in the colorizer table.
	if self.language=="cweb" and (
		match_word(s,i,"@c") or
		i+1&gt;= n or s[i+1] not in string.letters):
		return atFile.noDirective

	for name,directive in table:
		if match_word(s,i,name):
			return directive
	# 10/14/02: return miscDirective only for real directives.
	for name in leoColor.leoKeywords:
		if match_word(s,i,name):
			return atFile.miscDirective

	return atFile.noDirective</t>
<t tx="T265">def error(self,message):

	es_error(message)
	self.errors += 1
</t>
<t tx="T266">def readError(self,message):

	# This is useful now that we don't print the actual messages.
	if self.errors == 0:
		es_error("----- error reading @file " + self.targetFileName)
		self.error(message) # 9/10/02: we must increment self.errors!
		
	print message

	if 0: # CVS conflicts create too many messages.
		self.error(message)
	
	self.root.setOrphan()
	self.root.setDirty()</t>
<t tx="T267"># Skip past whitespace equivalent to width spaces.

def skipIndent(self,s,i,width):

	ws = 0 ; n = len(s)
	while i &lt; n and ws &lt; width:
		if   s[i] == '\t': ws += (abs(self.tab_width) - (ws % abs(self.tab_width)))
		elif s[i] == ' ':  ws += 1
		else: break
		i += 1
	return i</t>
<t tx="T268">def writeError(self,message):

	if self.errors == 0:
		es_error("errors writing: " + self.targetFileName)

	self.error(message)
	self.root.setOrphan()
	self.root.setDirty()</t>
<t tx="T269"></t>
<t tx="T270"></t>
<t tx="T271">def rawWrite(self,root):

	# trace(`root`)
	c = self.commands ; self.root = root
	self.errors = 0
	c.endEditing() # Capture the current headline.
	try:
		self.targetFileName = root.atRawFileNodeName()
		ok = self.openWriteFile(root)
		if not ok: return
		next = root.nodeAfterTree()
		&lt;&lt; write root's tree &gt;&gt;
		self.closeWriteFile()
		self.replaceTargetFileIfDifferent()
		root.clearOrphan() ; root.clearDirty()
	except:
		self.handleWriteException(root)</t>
<t tx="T272">next = root.nodeAfterTree()

if 0: # Clone indices are no longer used.
	self.updateCloneIndices(root, next)

&lt;&lt; put all @first lines in root &gt;&gt;
self.putOpenLeoSentinel("@+leo")
&lt;&lt; put optional @comment sentinel lines &gt;&gt;

v = root
while v and v != next:
	&lt;&lt; Write v's node &gt;&gt;
	v = v.threadNext()

self.putSentinel("@-leo")
&lt;&lt; put all @last lines in root &gt;&gt;</t>
<t tx="T273">@ Write any @first lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines preceding the @+leo sentinel.
@c

s = root.t.bodyString
tag = "@first"
i = 0
while match(s,i,tag):
	i += len(tag)
	i = skip_ws(s,i)
	j = i
	i = skip_to_end_of_line(s,i)
	# 21-SEP-2002 DTHEIN: write @first line, whether empty or not
	line = s[j:i]
	self.putBuffered(line) ; self.onl()
	i = skip_nl(s,i)</t>
<t tx="T274">s2 = app().config.output_initial_comment
if s2:
	lines = string.split(s2,"\\n")
	for line in lines:
		line = line.replace("@date",time.asctime())
		if len(line)&gt; 0:
			self.putSentinel("@comment " + line)
</t>
<t tx="T275">self.putOpenNodeSentinel(v)
	
s = v.bodyString()
if s and len(s) &gt; 0:
	self.putSentinel("@+body")
	if self.newline_pending:
		self.newline_pending = false
		self.onl()
	s = toEncodedString(s,self.encoding,reportErrors=true) # 3/7/03
	self.outputStringWithLineEndings(s)
	self.putSentinel("@-body")
	
self.putCloseNodeSentinel(v)
</t>
<t tx="T276">@ Write any @last lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines following the @-leo sentinel.
@c

tag = "@last"
lines = string.split(root.t.bodyString,'\n')
n = len(lines) ; j = k = n - 1
# Don't write an empty last line.
if j &gt;= 0 and len(lines[j])==0:
	j = k = n - 2
# Scan backwards for @last directives.
while j &gt;= 0:
	line = lines[j]
	if match(line,0,tag): j -= 1
	else: break
# Write the @last lines.
for line in lines[j+1:k+1]:
	i = len(tag) ; i = skip_ws(line,i)
	self.putBuffered(line[i:]) ; self.onl()</t>
<t tx="T277">def silentWrite(self,root):

	# trace(`root`)
	c = self.commands ; self.root = root
	self.errors = 0
	c.endEditing() # Capture the current headline.
	try:
		self.targetFileName = root.atSilentFileNodeName()
		ok = self.openWriteFile(root)
		if not ok: return
		next = root.nodeAfterTree()
		v = root
		while v and v != next:
			&lt;&lt; Write v's headline if it starts with @@ &gt;&gt;
			&lt;&lt; Write v's body &gt;&gt;
			v = v.threadNext()
		self.closeWriteFile()
		self.replaceTargetFileIfDifferent()
		root.clearOrphan() ; root.clearDirty()
	except:
		self.handleWriteException(root)</t>
<t tx="T278">s = v.headString()
if match(s,0,"@@"):
	s = s[2:]
	if s and len(s) &gt; 0:
		s = toEncodedString(s,self.encoding,reportErrors=true) # 3/7/03
		self.outputFile.write(s)
</t>
<t tx="T279">s = v.bodyString()
if s and len(s) &gt; 0:
	s = toEncodedString(s,self.encoding,reportErrors=true) # 3/7/03
	self.outputStringWithLineEndings(s)</t>
<t tx="T280"># This is the entry point to the write code.  root should be an @file vnode.

def write(self,root,nosentinels=false):

	c = self.commands
	self.sentinels = not nosentinels
	&lt;&lt; initialize &gt;&gt;
	try:
		&lt;&lt; open the file; return on error &gt;&gt;
		&lt;&lt; write then entire @file tree &gt;&gt;
		self.closeWriteFile()
		&lt;&lt; warn about @ignored and orphans &gt;&gt;
		&lt;&lt; finish writing &gt;&gt;
	except:
		self.handleWriteException()</t>
<t tx="T281">self.errors = 0 # 9/26/02
c.setIvarsFromPrefs()
self.root = root
self.raw = false
c.endEditing() # Capture the current headline.</t>
<t tx="T282">if nosentinels:
	self.targetFileName = root.atNoSentinelsFileNodeName()
else:
	self.targetFileName = root.atFileNodeName()

ok = self.openWriteFile(root)
if not ok: return</t>
<t tx="T283"># unvisited nodes will be orphans, except in cweb trees.
root.clearVisitedInTree()
next = root.nodeAfterTree()

&lt;&lt; put all @first lines in root &gt;&gt;
&lt;&lt; write the derived file &gt;&gt;
&lt;&lt; put all @last lines in root &gt;&gt;

root.setVisited()</t>
<t tx="T284">tag1 = "@+leo"

self.putOpenLeoSentinel(tag1)
self.putInitialComment()
self.putOpenNodeSentinel(root)
self.putBodyPart(root)
self.putCloseNodeSentinel(root)
self.putSentinel("@-leo")</t>
<t tx="T285"># 10/26/02: Always warn, even when language=="cweb"

next = root.nodeAfterTree()
v = root
while v and v != next:
	if not v.isVisited():
		self.writeError("Orphan node:  " + v.headString())
	if v.isAtIgnoreNode():
		self.writeError("@ignore node: " + v.headString())
	v = v.threadNext()
</t>
<t tx="T286">@ We set the orphan and dirty flags if there are problems writing the file to force Commands::write_LEO_file to write the tree to the .leo file.
@c

if self.errors &gt; 0 or self.root.isOrphan():
	root.setOrphan()
	root.setDirty() # 2/9/02: make _sure_ we try to rewrite this file.
	os.remove(self.outputFileName) # Delete the temp file.
	es("Not written: " + self.outputFileName)
else:
	root.clearOrphan()
	root.clearDirty()
	self.replaceTargetFileIfDifferent()</t>
<t tx="T287">def writeAll(self,writeAtFileNodesFlag=false,writeDirtyAtFileNodesFlag=false):
	
	"""Write @file nodes in all or part of the outline"""

	c = self.commands
	self.initIvars()
	writtenFiles = [] # Files that might be written again.

	if writeAtFileNodesFlag:
		# Write all nodes in the selected tree.
		v = c.currentVnode()
		after = v.nodeAfterTree()
	else:
		# Write dirty nodes in the entire outline.
		v = c.rootVnode()
		after = None

	&lt;&lt; Clear all orphan bits &gt;&gt;
	while v and v != after:
		# trace(`v`)
		if v.isAnyAtFileNode() or v.isAtIgnoreNode():
			&lt;&lt; handle v's tree &gt;&gt;
			v = v.nodeAfterTree()
		else:
			v = v.threadNext()

	&lt;&lt; say the command is finished &gt;&gt;</t>
<t tx="T288">@ We must clear these bits because they may have been set on a previous write.  Calls to atFile::write may set the orphan bits in @file nodes.  If so, write_LEO_file will write the entire @file tree.
@c

v2 = v
while v2 and v2 != after:
	v2.clearOrphan()
	v2 = v2.threadNext()</t>
<t tx="T289"># This code is a little tricky: @ignore not recognised in @silentfile nodes.

if v.isDirty() or writeAtFileNodesFlag or v.t in writtenFiles:

	if v.isAtSilentFileNode():
		self.silentWrite(v)
	elif v.isAtIgnoreNode():
		pass
	elif v.isAtRawFileNode():
		self.rawWrite(v)
	elif v.isAtNoSentinelsFileNode():
		self.write(v,nosentinels=true)
	elif v.isAtFileNode():
		self.write(v)

	if not v.isAtIgnoreNode():
		writtenFiles.append(v.t)</t>
<t tx="T290">if writeAtFileNodesFlag or writeDirtyAtFileNodesFlag:
	if len(writtenFiles) &gt; 0:
		es("finished")
	elif writeAtFileNodesFlag:
		es("no @file nodes in the selected tree")
	else:
		es("no dirty @file nodes")</t>
<t tx="T291">def writeMissing(self,v):

	self.initIvars()
	writtenFiles = false
	after = v.nodeAfterTree()
	while v and v != after:
		if v.isAtSilentFileNode() or (v.isAnyAtFileNode() and not v.isAtIgnoreNode()):
			missing = false ; valid = true
			self.targetFileName = v.anyAtFileNodeName()
			&lt;&lt; set missing if the file does not exist &gt;&gt;
			if valid and missing:
				&lt;&lt; create self.outputFile &gt;&gt;
				if self.outputFile:
					&lt;&lt; write the @file node &gt;&gt;
			v = v.nodeAfterTree()
		elif v.isAtIgnoreNode():
			v = v.nodeAfterTree()
		else:
			v = v.threadNext()
	
	if writtenFiles &gt; 0:
		es("finished")
	else:
		es("no missing @file node in the selected tree")</t>
<t tx="T292"># This is similar, but not the same as, the logic in openWriteFile.

valid = self.targetFileName and len(self.targetFileName) &gt; 0

if valid:
	try:
		# Creates missing directives if option is enabled.
		self.scanAllDirectives(v)
		valid = self.errors == 0
	except:
		es("exception in atFile.scanAllDirectives")
		es_exception()
		valid = false

if valid:
	try:
		fn = self.targetFileName
		self.shortFileName = fn # name to use in status messages.
		self.targetFileName = os.path.join(self.default_directory,fn)
		self.targetFileName = os.path.normpath(self.targetFileName)
		path = self.targetFileName # Look for the full name, not just the directory.
		valid = path and len(path) &gt; 0
		if valid:
			missing = not os.path.exists(path)
	except:
		es("exception creating path:" + fn)
		es_exception()
		valid = false</t>
<t tx="T293">try:
	self.outputFileName = self.targetFileName + ".leotmp"
	self.outputFile = open(self.outputFileName,'wb')
	if self.outputFile == None:
		self.writeError("can not open " + self.outputFileName)
except:
	es("exception opening:" + self.outputFileName)
	es_exception()
	self.outputFile = None
</t>
<t tx="T294">if v.isAtSilentFileNode():
	self.silentWrite(v)
elif v.isAtRawFileNode():
	self.rawWrite(v)
elif v.isAtNoSentinelsFileNode():
	self.write(v,nosentinels=true)
elif v.isAtFileNode():
	self.write(v)
else: assert(0)

writtenFiles = true
</t>
<t tx="T295"></t>
<t tx="T296">def closeWriteFile (self):
	
	if self.outputFile:
		if self.suppress_newlines and self.newline_pending:
			self.newline_pending = false
			self.onl() # Make sure file ends with a newline.
		self.outputFile.flush()
		self.outputFile.close()
		self.outputFile = None
</t>
<t tx="T297">def handleWriteException (self,root=None):
	
	es("exception writing:" + self.targetFileName)
	es_exception()
	
	if self.outputFile:
		self.outputFile.flush()
		self.outputFile.close()
		self.outputFile = None
	
	if self.outputFileName != None:
		try: # Just delete the temp file.
			os.remove(self.outputFileName)
		except:
			es("exception deleting:" + self.outputFileName)
			es_exception()

	if root:
		# Make sure we try to rewrite this file.
		root.setOrphan()
		root.setDirty()</t>
<t tx="T298"># Open files.  Set root.orphan and root.dirty flags and return on errors.

def openWriteFile (self,root):

	try:
		self.scanAllDirectives(root)
		valid = self.errors == 0
	except:
		es("exception in atFile.scanAllDirectives")
		es_exception()
		valid = false
	
	if valid:
		try:
			fn = self.targetFileName
			self.shortFileName = fn # name to use in status messages.
			self.targetFileName = os.path.join(self.default_directory,fn)
			self.targetFileName = os.path.normpath(self.targetFileName)
			path = os.path.dirname(self.targetFileName)
			if path and len(path) &gt; 0:
				valid = os.path.exists(path)
				if not valid:
					self.writeError("path does not exist: " + path)
			else:
				valid = false
		except:
			es("exception creating path:" + fn)
			es_exception()
			valid = false
	
	if valid:
		if os.path.exists(self.targetFileName):
			try:
				read_only = not os.access(self.targetFileName,os.W_OK)
				if read_only:
					es("read only: " + self.targetFileName)
					valid = false
			except:
				pass # os.access() may not exist on all platforms.
		
	if valid:
		try:
			self.outputFileName = self.targetFileName + ".tmp"
			self.outputFile = open(self.outputFileName,'wb')
			valid = self.outputFile != None
			if not valid:
				self.writeError("can not open " + self.outputFileName)
		except:
			es("exception opening:" + self.outputFileName)
			es_exception()
			valid = false
	
	if not valid:
		root.setOrphan()
		root.setDirty()
	
	return valid</t>
<t tx="T299">def putInitialComment (self):
	
	s2 = app().config.output_initial_comment
	if s2:
		lines = string.split(s2,"\\n")
		for line in lines:
			line = line.replace("@date",time.asctime())
			if len(line)&gt; 0:
				self.putSentinel("@comment " + line)</t>
<t tx="T300">def replaceTargetFileIfDifferent (self):
	
	assert(self.outputFile == None)
	
	if os.path.exists(self.targetFileName):
		if filecmp.cmp(self.outputFileName,self.targetFileName):
			&lt;&lt; delete the output file &gt;&gt;
		else:
			&lt;&lt; replace the target file with the output file &gt;&gt;
	else:
		&lt;&lt; rename the output file to be the target file &gt;&gt;
</t>
<t tx="T301">try: # Just delete the temp file.
	os.remove(self.outputFileName)
except:
	es("exception deleting:" + self.outputFileName)
	es_exception()

es("unchanged: " + self.shortFileName)</t>
<t tx="T302">try:
	# 10/6/02: retain the access mode of the previous file,
	# removing any setuid, setgid, and sticky bits.
	mode = (os.stat(self.targetFileName))[0] &amp; 0777
except:
	mode = None

try: # Replace target file with temp file.
	os.remove(self.targetFileName)
	try:
		utils_rename(self.outputFileName,self.targetFileName)
		if mode != None: # 10/3/02: retain the access mode of the previous file.
			try:
				os.chmod(self.targetFileName,mode)
			except:
				es("exception in os.chmod(%s)" % (self.targetFileName))
		es("writing: " + self.shortFileName)
	except:
		# 6/28/03
		self.writeError("exception renaming: %s to: %s" % (self.outputFileName,self.targetFileName))
		es_exception()
except:
	self.writeError("exception removing:" + self.targetFileName)
	es_exception()
	try: # Delete the temp file when the deleting the target file fails.
		os.remove(self.outputFileName)
	except:
		es("exception deleting:" + self.outputFileName)
		es_exception()</t>
<t tx="T303">try:
	utils_rename(self.outputFileName,self.targetFileName)
	es("creating: " + self.targetFileName)
except:
	self.writeError("exception renaming:" + self.outputFileName +
		" to " + self.targetFileName)
	es_exception()</t>
<t tx="T304"># Write the string s as-is except that we replace '\n' with the proper line ending.

def outputStringWithLineEndings (self,s):

	# Calling self.onl() runs afoul of queued newlines.
	self.os(s.replace('\n',self.output_newline))</t>
<t tx="T305">def putBodyPart(self,v):
	
	""" Generate the body enclosed in sentinel lines."""

	# trace(`v`)
	s = v.t.bodyString
	i = skip_ws_and_nl(s, 0)
	if i &gt;= len(s): return

	s = removeTrailingWs(s) # don't use string.rstrip!
	self.putSentinel("@+body")
	&lt;&lt; put code/doc parts and sentinels &gt;&gt;
	self.putSentinel("@-body")</t>
<t tx="T306">i = 0 ; n = len(s)
firstLastHack = 1

if firstLastHack:
	&lt;&lt; initialize lookingForFirst/Last &amp; initialLastDirective &gt;&gt;
while i &lt; n:
	kind = self.directiveKind(s,i)
	if firstLastHack:
		&lt;&lt; set lookingForFirst/Last &amp; initialLastDirective &gt;&gt;
	j = i
	if kind == atFile.docDirective or kind == atFile.atDirective:
		i = self.putDoc(s,i,kind)
	elif ( # 10/16/02
		kind == atFile.miscDirective or
		kind == atFile.rawDirective or
		kind == atFile.endRawDirective ):
		if firstLastHack:
			&lt;&lt; handle misc directives &gt;&gt;
		else:
			i = self.putDirective(s,i)
	elif kind == atFile.noDirective or kind == atFile.othersDirective:
		i = self.putCodePart(s,i,v)
	elif kind == atFile.cDirective or kind == atFile.codeDirective:
		i = self.putDirective(s,i)
		i = self.putCodePart(s,i,v)
	else: assert(false) # We must handle everything that directiveKind returns
	assert(n == len(s))
	assert(j &lt; i) # We must make progress.

if firstLastHack:
	&lt;&lt; put out the last directives, if any &gt;&gt;</t>
<t tx="T307"># 14-SEP-2002 DTHEIN: If this is the root node, then handle all @first directives here
lookingForLast = 0
lookingForFirst = 0
initialLastDirective = -1
lastDirectiveCount = 0
if (v == self.root):
	lookingForLast = 1
	lookingForFirst = 1</t>
<t tx="T308"># 14-SEP-2002 DTHEIN: If first directive isn't @first, then stop looking for @first
if lookingForFirst:
	if kind != atFile.miscDirective:
		lookingForFirst = 0
	elif not match_word(s,i,"@first"):
		lookingForFirst = 0

if lookingForLast:
	if initialLastDirective == -1:
		if (kind == atFile.miscDirective) and match_word(s,i,"@last"):
			# mark the point where the last directive was found
			initialLastDirective = i
	else:
		if (kind != atFile.miscDirective) or (not match_word(s,i,"@last")):
			# found something after @last, so process the @last directives
			# in 'ignore them' mode
			i, initialLastDirective = initialLastDirective, -1
			lastDirectiveCount = 0
			kind = self.directiveKind(s,i)</t>
<t tx="T309">if lookingForFirst: # DTHEIN: can only be true if it is @first directive
	i = self.putEmptyDirective(s,i)
elif (initialLastDirective != -1) and match_word(s,i,"@last"):
	# DTHEIN: can only be here if lookingForLast is true
	# skip the last directive ... we'll output it at the end if it
	# is truly 'last'
	lastDirectiveCount += 1
	i = skip_line(s,i)
else:
	i = self.putDirective(s,i)</t>
<t tx="T310"># 14-SEP-2002 DTHEIN
if initialLastDirective != -1:
	d = initialLastDirective
	for k in range(lastDirectiveCount):
		d = self.putEmptyDirective(s,d)</t>
<t tx="T311">@ This method outputs a doc section terminated by @code or end-of-text.  All other interior directives become part of the doc part.
@c
def putDoc(self,s,i,kind):

	if kind == atFile.atDirective:
		i += 1 ; tag = "at"
	elif kind == atFile.docDirective:
		i += 4 ; tag = "doc"
	else: assert(false)
	# Set j to the end of the doc part.
	n = len(s) ; j = i
	while j &lt; n:
		j = skip_line(s, j)
		kind = self.directiveKind(s, j)
		if kind == atFile.codeDirective or kind == atFile.cDirective:
			break
	self.putSentinel("@+" + tag)
	self.putDocPart(s[i:j])
	self.putSentinel("@-" + tag)
	return j</t>
<t tx="T312"># Puts a comment part in comments.
# Note: this routine is _never_ called in cweb mode,
# so noweb section references are _valid_ in cweb doc parts!

def putDocPart(self,s):

	# j = skip_line(s,0) ; trace(`s[:j]`)
	c = self.commands
	single = len(self.endSentinelComment) == 0
	if not single:
		self.putIndent(self.indent)
		self.os(self.startSentinelComment) ; self.onl()
	# Put all lines.
	i = 0 ; n = len(s)
	while i &lt; n:
		self.putIndent(self.indent)
		leading = self.indent
		if single:
			self.os(self.startSentinelComment) ; self.oblank()
			leading += len(self.startSentinelComment) + 1
		&lt;&lt; copy words, splitting the line if needed &gt;&gt;
	if not single:
		# This comment is like a sentinel.
		self.onl() ; self.putIndent(self.indent)
		self.os(self.endSentinelComment)
		self.onl() # Note: no trailing whitespace.</t>
<t tx="T313">@ We remove trailing whitespace from lines that have _not_ been split so that a newline has been inserted by this routine if and only if it is preceded by whitespace.
@c

line = i # Start of the current line.
while i &lt; n:
	word = i # Start of the current word.
	# Skip the next word and trailing whitespace.
	i = skip_ws(s, i)
	while i &lt; n and not is_nl(s,i) and not is_ws(s[i]):
		i += 1
	i = skip_ws(s,i)
	# Output the line if no more is left.
	if i &lt; n and is_nl(s,i):
		break
	# Split the line before the current word if needed.
	lineLen = i - line
	if line == word or leading + lineLen &lt; self.page_width:
		word = i # Advance to the next word.
	else:
		# Write the line before the current word and insert a newline.
		theLine = s[line:word]
		self.os(theLine)
		self.onl() # This line must contain trailing whitespace.
		line = i = word  # Put word on the next line.
		break
# Remove trailing whitespace and output the remainder of the line.
theLine = string.rstrip(s[line:i]) # from right.
self.os(theLine)
if i &lt; n and is_nl(s,i):
	i = skip_nl(s,i)
	self.onl() # No inserted newline and no trailing whitespace.</t>
<t tx="T314">@ This method expands a code part, terminated by any at-directive except at-others.  It expands references and at-others and outputs @verbatim sentinels as needed.
@c
def putCodePart(self,s,i,v):

	c = self.commands
	atOthersSeen = false # true: at-others has been expanded.
	while i &lt; len(s):
		&lt;&lt; handle the start of a line &gt;&gt;
		&lt;&lt; put the line &gt;&gt;

	# Raw code parts can only end at the end of body text.
	self.raw = false
	return i</t>
<t tx="T315">@ The at-others directive is the only directive that is recognized following leading whitespace, so it is just a little tricky to recognize it.
@c

leading_nl = (s[i] == body_newline) # 9/27/02: look ahead before outputting newline.
if leading_nl:
	i = skip_nl(s,i)
	self.onl() # 10/15/02: simpler to do it here.

#leading_ws1 = i # 1/27/03
j,delta = skip_leading_ws_with_indent(s,i,self.tab_width)
#leading_ws2 = j # 1/27/03
kind1 = self.directiveKind(s,i)
kind2 = self.directiveKind(s,j)
if self.raw:
	if kind1 == atFile.endRawDirective:
		&lt;&lt; handle @end_raw &gt;&gt;
else:
	if kind1 == atFile.othersDirective or kind2 == atFile.othersDirective:
		&lt;&lt; handle @others &gt;&gt;
	elif kind1 == atFile.rawDirective:
		&lt;&lt; handle @raw &gt;&gt;
	elif kind1 == atFile.noDirective:
		&lt;&lt; put @verbatim sentinel if necessary &gt;&gt;
	else:
		break # all other directives terminate the code part.</t>
<t tx="T316"># This skips all indent and delta whitespace, so putAtOthers must generate it all.

if 0: # 9/27/02: eliminates the newline preceeding the @+others sentinel.
	# This does not seem to be a good idea.
	i = skip_line(s,i) 
else:
	i = skip_to_end_of_line(s,i)

if atOthersSeen:
	self.writeError("@others already expanded in: " + v.headString())
else:
	atOthersSeen = true
	self.putAtOthers(v, delta)
	
	# 12/8/02: Skip the newline _after_ the @others.
	if not self.sentinels and is_nl(s,i):
		i = skip_nl(s,i)
</t>
<t tx="T317">self.raw = true
self.putSentinel("@@raw")
i = skip_line(s,i)</t>
<t tx="T318">self.raw = false
self.putSentinel("@@end_raw")
i = skip_line(s,i)</t>
<t tx="T319">if match (s,i,self.startSentinelComment + '@'):
	self.putSentinel("verbatim")</t>
<t tx="T320">if not self.raw:
	# 12/8/02: Don't write trailing indentation if not writing sentinels.
	if self.sentinels or j &lt; len(s):
		self.putIndent(self.indent)

newlineSeen = false
# 12/8/02: we buffer characters here for two reasons:
# 1) to make traces easier to read and 2) to increase speed.
buf = i # Indicate the start of buffered characters.
while i &lt; len(s) and not newlineSeen:
	ch = s[i]
	if ch == body_newline:
		break
	elif ch == body_ignored_newline:
		i += 1
	elif ch == '&lt;' and not self.raw:
		&lt;&lt; put possible section reference &gt;&gt;
	else:
		i += 1
# Output any buffered characters.
self.putBuffered(s[buf:i])</t>
<t tx="T321">isSection, j = self.isSectionName(s, i)

if isSection:
	# Output the buffered characters and clear the buffer.
	s2 = s[buf:i] ; buf = i
	# 7/9/03: don't output trailing indentation if we aren't generating sentinels.
	if not self.sentinels:
		while len(s2) and s2[-1] in (' ','\t'):
			s2 = s2[:-1]
	self.putBuffered(s2)
	# Output the expansion.
	name = s[i:j]
	j,newlineSeen = self.putRef(name,v,s,j,delta)
	assert(j &gt; i) # isSectionName must have made progress
	i = j ; buf = i
else:
	# This is _not_ an error.
	i += 1</t>
<t tx="T322">@ Returns true if v should be included in the expansion of the at-others directive in the body text of v's parent.

7/30/02: v will not be included if it is a definition node or if its body text contains an @ignore directive. Previously, a "nested" @others directive would also inhibit the inclusion of v.
@c
def inAtOthers(self,v):

	# Return false if this has been expanded previously.
	if  v.isVisited(): return false
	# Return false if this is a definition node.
	h = v.headString()
	i = skip_ws(h,0)
	isSection, j = self.isSectionName(h,i)
	if isSection: return false
	# Return false if v's body contains an @ignore or at-others directive.
	if 1: # 7/29/02: New code.  Amazingly, this appears to work!
		return not v.isAtIgnoreNode()
	else: # old &amp; reliable code
		return not v.isAtIgnoreNode() and not v.isAtOthersNode()</t>
<t tx="T323"># returns (flag, end). end is the index of the character after the section name.

def isSectionName(self,s,i):

	if not match(s,i,"&lt;&lt;"):
		return false, -1
	i = find_on_line(s,i,"&gt;&gt;")
	if i:
		return true, i + 2
	else:
		return false, -1</t>
<t tx="T324">@ The at-others directive is recognized only at the start of the line.  This code must generate all leading whitespace for the opening sentinel.
@c
def putAtOthers(self,v,delta):

	self.indent += delta
	self.putSentinel("@+others")

	child = v.firstChild()
	while child:
		if self.inAtOthers( child ):
			self.putAtOthersChild( child )
		child = child.next()

	self.putSentinel("@-others")
	self.indent -= delta</t>
<t tx="T325">def putAtOthersChild(self,v):
	
	# trace("%d %s" % (self.indent,`v`))
	self.putOpenNodeSentinel(v)
	
	# Insert the expansion of v.
	v.setVisited() # Make sure it is never expanded again.
	self.putBodyPart(v)

	# Insert expansions of all children.
	child = v.firstChild()
	while child:
		if self.inAtOthers( child ):
			self.putAtOthersChild( child )
		child = child.next()

	self.putCloseNodeSentinel(v)
</t>
<t tx="T326">def putRef (self,name,v,s,i,delta):

	newlineSeen = false
	ref = findReference(name, v)
	if not ref:
		self.writeError("undefined section: " + name +
			"\n\treferenced from: " + v.headString())
		return i,newlineSeen

	# trace(self.indent,delta,s[i:])
	&lt;&lt; Generate the expansion of the reference &gt;&gt;

	# The newlineSeen allows the caller to break out of the loop.
	return i,newlineSeen</t>
<t tx="T327"># Adjust indent here so sentinel looks better.
self.indent += delta

self.putSentinel("@" + name)
self.putOpenSentinels(v,ref)
self.putBodyPart(ref)
self.putCloseSentinels(v,ref)
&lt;&lt; Add @verbatimAfterRef sentinel if required &gt;&gt;

self.indent -= delta
ref.setVisited()</t>
<t tx="T328">j = skip_ws(s,i)
if j &lt; len(s) and match(s,j,self.startSentinelComment + '@'):
	self.putSentinel("@verbatimAfterRef")
	# 9/27/02: Put the line immediately, before the @-node sentinel.
	k = skip_to_end_of_line(s,i)
	self.putBuffered(s[i:k])
	i = k ; newlineSeen = false</t>
<t tx="T329"></t>
<t tx="T330">def putBuffered (self,s):
	
	"""Put s, converting all tabs to blanks as necessary."""
	
	if s:
		w = self.tab_width
		if w &lt; 0:
			#trace(s)
			lines = s.split('\n')
			for i in xrange(len(lines)):
				line = lines[i]
				line2 = ""
				for j in xrange(len(line)):
					ch = line[j]
					if ch == '\t':
						w2 = computeWidth(s[:j],w)
						w3 = (abs(w) - (w2 % abs(w)))
						line2 += ' ' * w3
					else:
						line2 += ch
				lines[i] = line2
			s = string.join(lines,'\n')
		#trace(s)
		self.os(s)</t>
<t tx="T331">def oblank(self):
	self.os(' ')

def oblanks(self,n):
	self.os(' ' * abs(n))

def onl(self):
	self.os(self.output_newline)

def os(self,s):
	if s is None or len(s) == 0: return
	if self.suppress_newlines and self.newline_pending:
		self.newline_pending = false
		s = self.output_newline + s
	if self.outputFile:
		try:
			s = toEncodedString(s,self.encoding,reportErrors=true)
			self.outputFile.write(s)
		except:
			es("exception writing:" + `s`)
			es_exception()

def otabs(self,n):
	self.os('\t' * abs(n))</t>
<t tx="T332"># This method outputs s, a directive or reference, in a sentinel.

def putDirective(self,s,i):

	tag = "@delims"
	assert(i &lt; len(s) and s[i] == '@')
	k = i
	j = skip_to_end_of_line(s,i)
	directive = s[i:j]

	if match_word(s,k,tag):
		&lt;&lt; handle @delims &gt;&gt;
	else:
		self.putSentinel("@" + directive)

	i = skip_line(s,k)
	return i</t>
<t tx="T333"># Put a space to protect the last delim.
self.putSentinel(directive + " ") # 10/23/02: put @delims, not @@delims

# Skip the keyword and whitespace.
j = i = skip_ws(s,k+len(tag))

# Get the first delim.
while i &lt; len(s) and not is_ws(s[i]) and not is_nl(s,i):
	i += 1
if j &lt; i:
	self.startSentinelComment = s[j:i]
	# Get the optional second delim.
	j = i = skip_ws(s,i)
	while i &lt; len(s) and not is_ws(s[i]) and not is_nl(s,i):
		i += 1
	self.endSentinelComment = choose(j&lt;i, s[j:i], "")
else:
	self.writeError("Bad @delims directive")</t>
<t tx="T334"># 14-SEP-2002 DTHEIN
# added for use by putBodyPart()

# This method outputs the directive without the parameter text
def putEmptyDirective(self,s,i):

	assert(i &lt; len(s) and s[i] == '@')
	
	endOfLine = s.find('\n',i)
	# 21-SEP-2002 DTHEIN: if no '\n' then just use line length
	if endOfLine == -1:
		endOfLine = len(s)
	token = s[i:endOfLine].split()
	directive = token[0]
	self.putSentinel("@" + directive)

	i = skip_line(s,i)
	return i</t>
<t tx="T335">def putIndent(self,n):
	
	"""Put tabs and spaces corresponding to n spaces, assuming that we are at the start of a line."""

	if n != 0:
		# trace(n)
		w = self.tab_width
		if w &gt; 1:
			q,r = divmod(n,w) 
			self.otabs(q) 
			self.oblanks(r)
		else:
			self.oblanks(n)</t>
<t tx="T336">@language python

# Syntax coloring routines for Leo.py

from leoGlobals import *
import string,Tkinter,tkColorChooser

&lt;&lt; define leo keywords &gt;&gt;
&lt;&lt; define colorizer constants &gt;&gt;
&lt;&lt; define color panel data &gt;&gt;

@others</t>
<t tx="T337"># leoKeywords is used by directivesKind, so it should be a module-level symbol.

# leoKeywords must be a list so that plugins may alter it.

leoKeywords = [
	"@","@c","@code","@color","@comment",
	"@delims","@doc","@encoding","@end_raw",
	"@first","@header","@ignore",
	"@language","@last","@lineending",
	"@nocolor","@noheader","@nowrap","@others",
	"@pagewidth","@path","@quiet","@raw","@root","@root-code","@root-doc",
	"@silent","@tabwidth","@terse",
	"@unit","@verbose","@wrap" ]</t>
<t tx="T338"># These defaults are sure to exist.
default_colors_dict = {
	# tag name      :(     option name,           default color),
	"comment"       :("comment_color",               "red"),
	"cwebName"      :("cweb_section_name_color",     "red"),
	"pp"             :("directive_color",             "blue"),
	"docPart"        :("doc_part_color",              "red"),
	"keyword"        :("keyword_color",               "blue"),
	"leoKeyword"     :("leo_keyword_color",           "blue"),
	"link"           :("section_name_color",          "red"),
	"nameBrackets"   :("section_name_brackets_color", "blue"),
	"string"         :("string_color",                "#00aa00"), # Used by IDLE.
	"name"           :("undefined_section_name_color","red"),
	"latexBackground":("latex_background_color","white") }</t>
<t tx="T339">colorPanelData = (
	#Dialog name,                option name,         default color),
	("Brackets",          "section_name_brackets_color", "blue"),
	("Comments",          "comment_color",               "red"),
	("CWEB section names","cweb_section_name_color",     "red"),
	("Directives",        "directive_color",             "blue"),
	("Doc parts",         "doc_part_color",              "red"),
	("Keywords" ,         "keyword_color",               "blue"),
	("Leo Keywords",      "leo_keyword_color",           "blue"),
	("Section Names",     "section_name_color",          "red"),
	("Strings",           "string_color",   "#00aa00"), # Used by IDLE.
	("Undefined Names",   "undefined_section_name_color","red") )

colorNamesList = (
	"gray60", "gray70", "gray80", "gray85", "gray90", "gray95",
	"snow1", "snow2", "snow3", "snow4", "seashell1", "seashell2",
	"seashell3", "seashell4", "AntiqueWhite1", "AntiqueWhite2", "AntiqueWhite3",
	"AntiqueWhite4", "bisque1", "bisque2", "bisque3", "bisque4", "PeachPuff1",
	"PeachPuff2", "PeachPuff3", "PeachPuff4", "NavajoWhite1", "NavajoWhite2",
	"NavajoWhite3", "NavajoWhite4", "LemonChiffon1", "LemonChiffon2",
	"LemonChiffon3", "LemonChiffon4", "cornsilk1", "cornsilk2", "cornsilk3",
	"cornsilk4", "ivory1", "ivory2", "ivory3", "ivory4", "honeydew1", "honeydew2",
	"honeydew3", "honeydew4", "LavenderBlush1", "LavenderBlush2",
	"LavenderBlush3", "LavenderBlush4", "MistyRose1", "MistyRose2",
	"MistyRose3", "MistyRose4", "azure1", "azure2", "azure3", "azure4",
	"SlateBlue1", "SlateBlue2", "SlateBlue3", "SlateBlue4", "RoyalBlue1",
	"RoyalBlue2", "RoyalBlue3", "RoyalBlue4", "blue1", "blue2", "blue3", "blue4",
	"DodgerBlue1", "DodgerBlue2", "DodgerBlue3", "DodgerBlue4", "SteelBlue1",
	"SteelBlue2", "SteelBlue3", "SteelBlue4", "DeepSkyBlue1", "DeepSkyBlue2",
	"DeepSkyBlue3", "DeepSkyBlue4", "SkyBlue1", "SkyBlue2", "SkyBlue3",
	"SkyBlue4", "LightSkyBlue1", "LightSkyBlue2", "LightSkyBlue3",
	"LightSkyBlue4", "SlateGray1", "SlateGray2", "SlateGray3", "SlateGray4",
	"LightSteelBlue1", "LightSteelBlue2", "LightSteelBlue3",
	"LightSteelBlue4", "LightBlue1", "LightBlue2", "LightBlue3",
	"LightBlue4", "LightCyan1", "LightCyan2", "LightCyan3", "LightCyan4",
	"PaleTurquoise1", "PaleTurquoise2", "PaleTurquoise3", "PaleTurquoise4",
	"CadetBlue1", "CadetBlue2", "CadetBlue3", "CadetBlue4", "turquoise1",
	"turquoise2", "turquoise3", "turquoise4", "cyan1", "cyan2", "cyan3", "cyan4",
	"DarkSlateGray1", "DarkSlateGray2", "DarkSlateGray3",
	"DarkSlateGray4", "aquamarine1", "aquamarine2", "aquamarine3",
	"aquamarine4", "DarkSeaGreen1", "DarkSeaGreen2", "DarkSeaGreen3",
	"DarkSeaGreen4", "SeaGreen1", "SeaGreen2", "SeaGreen3", "SeaGreen4",
	"PaleGreen1", "PaleGreen2", "PaleGreen3", "PaleGreen4", "SpringGreen1",
	"SpringGreen2", "SpringGreen3", "SpringGreen4", "green1", "green2",
	"green3", "green4", "chartreuse1", "chartreuse2", "chartreuse3",
	"chartreuse4", "OliveDrab1", "OliveDrab2", "OliveDrab3", "OliveDrab4",
	"DarkOliveGreen1", "DarkOliveGreen2", "DarkOliveGreen3",
	"DarkOliveGreen4", "khaki1", "khaki2", "khaki3", "khaki4",
	"LightGoldenrod1", "LightGoldenrod2", "LightGoldenrod3",
	"LightGoldenrod4", "LightYellow1", "LightYellow2", "LightYellow3",
	"LightYellow4", "yellow1", "yellow2", "yellow3", "yellow4", "gold1", "gold2",
	"gold3", "gold4", "goldenrod1", "goldenrod2", "goldenrod3", "goldenrod4",
	"DarkGoldenrod1", "DarkGoldenrod2", "DarkGoldenrod3", "DarkGoldenrod4",
	"RosyBrown1", "RosyBrown2", "RosyBrown3", "RosyBrown4", "IndianRed1",
	"IndianRed2", "IndianRed3", "IndianRed4", "sienna1", "sienna2", "sienna3",
	"sienna4", "burlywood1", "burlywood2", "burlywood3", "burlywood4", "wheat1",
	"wheat2", "wheat3", "wheat4", "tan1", "tan2", "tan3", "tan4", "chocolate1",
	"chocolate2", "chocolate3", "chocolate4", "firebrick1", "firebrick2",
	"firebrick3", "firebrick4", "brown1", "brown2", "brown3", "brown4", "salmon1",
	"salmon2", "salmon3", "salmon4", "LightSalmon1", "LightSalmon2",
	"LightSalmon3", "LightSalmon4", "orange1", "orange2", "orange3", "orange4",
	"DarkOrange1", "DarkOrange2", "DarkOrange3", "DarkOrange4", "coral1",
	"coral2", "coral3", "coral4", "tomato1", "tomato2", "tomato3", "tomato4",
	"OrangeRed1", "OrangeRed2", "OrangeRed3", "OrangeRed4", "red1", "red2", "red3",
	"red4", "DeepPink1", "DeepPink2", "DeepPink3", "DeepPink4", "HotPink1",
	"HotPink2", "HotPink3", "HotPink4", "pink1", "pink2", "pink3", "pink4",
	"LightPink1", "LightPink2", "LightPink3", "LightPink4", "PaleVioletRed1",
	"PaleVioletRed2", "PaleVioletRed3", "PaleVioletRed4", "maroon1",
	"maroon2", "maroon3", "maroon4", "VioletRed1", "VioletRed2", "VioletRed3",
	"VioletRed4", "magenta1", "magenta2", "magenta3", "magenta4", "orchid1",
	"orchid2", "orchid3", "orchid4", "plum1", "plum2", "plum3", "plum4",
	"MediumOrchid1", "MediumOrchid2", "MediumOrchid3", "MediumOrchid4",
	"DarkOrchid1", "DarkOrchid2", "DarkOrchid3", "DarkOrchid4", "purple1",
	"purple2", "purple3", "purple4", "MediumPurple1", "MediumPurple2",
	"MediumPurple3", "MediumPurple4", "thistle1", "thistle2", "thistle3",
	"thistle4" )
</t>
<t tx="T340"></t>
<t tx="T341"></t>
<t tx="T342"></t>
<t tx="T343"></t>
<t tx="T344"></t>
<t tx="T345"></t>
<t tx="T346"></t>
<t tx="T347"></t>
<t tx="T348"></t>
<t tx="T349"></t>
<t tx="T350"></t>
<t tx="T351"></t>
<t tx="T352"></t>
<t tx="T353"></t>
<t tx="T354"></t>
<t tx="T355"></t>
<t tx="T356"></t>
<t tx="T357"></t>
<t tx="T358"></t>
<t tx="T359"></t>
<t tx="T360"></t>
<t tx="T361"></t>
<t tx="T362"></t>
<t tx="T363"></t>
<t tx="T364"></t>
<t tx="T365"></t>
<t tx="T366"></t>
<t tx="T367"></t>
<t tx="T368"></t>
<t tx="T369"></t>
<t tx="T370"></t>
<t tx="T371"></t>
<t tx="T372"></t>
<t tx="T373"></t>
<t tx="T374"></t>
<t tx="T375"></t>
<t tx="T376"></t>
<t tx="T377"></t>
<t tx="T378"></t>
<t tx="T379"></t>
<t tx="T380"></t>
<t tx="T381"></t>
<t tx="T382"></t>
<t tx="T383"></t>
<t tx="T384"></t>
<t tx="T385"></t>
<t tx="T386"></t>
<t tx="T387"></t>
<t tx="T388"></t>
<t tx="T389"></t>
<t tx="T390"></t>
<t tx="T391"></t>
<t tx="T392"></t>
<t tx="T393"></t>
<t tx="T394"></t>
<t tx="T395"></t>
<t tx="T396"></t>
<t tx="T397"></t>
<t tx="T398"></t>
<t tx="T399"></t>
<t tx="T400"></t>
<t tx="T401"></t>
<t tx="T402"></t>
<t tx="T403"></t>
<t tx="T404"></t>
<t tx="T405"></t>
<t tx="T406"></t>
<t tx="T407"></t>
<t tx="T408"></t>
<t tx="T409"></t>
<t tx="T410"></t>
<t tx="T411"></t>
<t tx="T412"></t>
<t tx="T413"></t>
<t tx="T414"></t>
<t tx="T415"></t>
<t tx="T416"></t>
<t tx="T417"></t>
<t tx="T418"></t>
<t tx="T419"></t>
<t tx="T420"></t>
<t tx="T421"></t>
<t tx="T422"></t>
<t tx="T423"></t>
<t tx="T424"></t>
<t tx="T425"></t>
<t tx="T426"></t>
<t tx="T427"></t>
<t tx="T428"></t>
<t tx="T429"></t>
<t tx="T430"></t>
<t tx="T431"></t>
<t tx="T432"></t>
<t tx="T433"></t>
<t tx="T434"></t>
<t tx="T435"></t>
<t tx="T436"></t>
<t tx="T437"></t>
<t tx="T438"></t>
<t tx="T439"></t>
<t tx="T440">@language python

from leoGlobals import *

# Import the subcommanders.
import leoAtFile,leoFileCommands,leoImport,leoNodes,leoTangle,leoUndo

class baseCommands:
	"""The base class for Leo's main commander."""
	@others

class Commands (baseCommands):
	"""A class that implements most of Leo's commands."""
	pass</t>
<t tx="T441"></t>
<t tx="T442">def __init__(self,frame):

	# trace("__init__", "c.__init__")
	self.frame = frame
	self.initIvars(frame)

	# initialize the sub-commanders
	self.fileCommands = leoFileCommands.fileCommands(self)
	self.atFileCommands = leoAtFile.atFile(self)
	self.importCommands = leoImport.leoImportCommands(self)
	self.tangleCommands = leoTangle.tangleCommands(self)
	self.undoer = leoUndo.undoer(self)

def initIvars(self, frame):
	&lt;&lt; initialize ivars &gt;&gt;</t>
<t tx="T443"># per-document info...
self.hookFunction = None
self.openDirectory = None # 7/2/02

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = false # true if any data has been changed since the last save.
self.loading = false # true if we are loading a file: disables c.setChanged()

# copies of frame info
self.body = frame.body
self.log = frame.log
self.tree = frame.tree
self.canvas = frame.canvas

# For tangle/untangle
self.tangle_errrors = 0

# Global options
self.page_width = 132
self.tab_width = 4
self.tangle_batch_flag = false
self.untangle_batch_flag = false
# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = false
self.output_doc_flag = false
# Default Target Language
self.target_language = "python" # 8/11/02: Required if leoConfig.txt does not exist.

self.setIvarsFromFind()

# New in 3.12
# These are defined here, and updated by the tree.select()
self.beadList = [] # list of vnodes for the Back and Forward commands.
self.beadPointer = -1 # present item in the list.
self.visitedList = [] # list of vnodes for the Nodes dialog.</t>
<t tx="T444">def __repr__ (self):
	
	try:
		return "Commander: " + self.frame.mFileName
	except:
		return "Commander: bad mFileName"
		
__str__ = __repr__
</t>
<t tx="T445"># This should be called whenever we need to use find values:
# i.e., before reading or writing

def setIvarsFromFind (self):

	c = self ; find = app().findFrame
	if find:
		find.set_ivars(c)
</t>
<t tx="T446">@ This should be called whenever we need to use preference:
i.e., before reading, writing, tangling, untangling.

7/2/02: We no longer need this now that the Prefs dialog is modal.
@c

def setIvarsFromPrefs (self):

	pass</t>
<t tx="T447"></t>
<t tx="T448">def cutOutline(self):

	c = self
	if c.canDeleteHeadline():
		c.copyOutline()
		c.deleteHeadline("Cut Node")
		c.recolor()</t>
<t tx="T449">def copyOutline(self):

	c = self
	c.endEditing()
	c.fileCommands.assignFileIndices() # Revert to 3.11.1 code.
	s = c.fileCommands.putLeoOutline()
	# trace(`s`)
	app().root.clipboard_clear()
	app().root.clipboard_append(s)
	# Copying an outline has no undo consequences.
</t>
<t tx="T450">@ To cut and paste between apps, just copy into an empty body first, then copy to Leo's clipboard.
@c

def pasteOutline(self):

	a = app() ; c = self ; current = c.currentVnode()
	
	try:
		s = a.root.selection_get(selection="CLIPBOARD")
	except:
		s = None # This should never happen.

	if not s or not c.canPasteOutline(s):
		return # This should never happen.

	isLeo = match(s,0,a.prolog_prefix_string)

	# trace(`s`)
	if isLeo:
		v = c.fileCommands.getLeoOutline(s)
	else:
		v = c.importCommands.convertMoreStringToOutlineAfter(s,current)
	if v:
		c.endEditing()
		c.beginUpdate()
		if 1: # inside update...
			v.createDependents()# To handle effects of clones.
			c.validateOutline()
			c.selectVnode(v)
			v.setDirty()
			c.setChanged(true)
			# paste as first child if back is expanded.
			back = v.back()
			if back and back.isExpanded():
				v.moveToNthChildOf(back,0)
			c.undoer.setUndoParams("Paste Node",v)
		c.endUpdate()
		c.recolor()
	else:
		es("The clipboard is not a valid " + choose(isLeo,"Leo","MORE") + " file")</t>
<t tx="T451"></t>
<t tx="T452">def beginUpdate(self):

	self.tree.beginUpdate()
	
BeginUpdate = beginUpdate # Compatibility with old scripts</t>
<t tx="T453">def bringToFront(self):

	self.frame.top.deiconify()

BringToFront = bringToFront # Compatibility with old scripts</t>
<t tx="T454">def endUpdate(self, flag=true):
	
	self.tree.endUpdate(flag)
	
EndUpdate = endUpdate # Compatibility with old scripts</t>
<t tx="T455">def recolor(self):

	tree = self.tree
	tree.recolor(tree.currentVnode)</t>
<t tx="T456">def redraw(self):

	self.tree.redraw()
	
# Compatibility with old scripts
Redraw = redraw 
repaint = redraw
Repaint = redraw</t>
<t tx="T457"></t>
<t tx="T458">def convertAllBlanks (self):
	
	c = self ; v = current = c.currentVnode()
	next = v.nodeAfterTree()
	dict = scanDirectives(c)
	tabWidth  = dict.get("tabwidth")
	# Create copy for undo.
	v_copy = v.copyTree()
	oldText = c.body.get("1.0","end") # 7/11/03
	oldSel = getTextSelection(c.body) # 7/11/03
	anyChanged = false
	while v and v != next:
		if v == current:
			if c.convertBlanks():
				anyChanged = true # 7/11/03
		else:
			result = [] ; changed = false
			text = v.t.bodyString
			lines = string.split(text, '\n')
			for line in lines:
				s = optimizeLeadingWhitespace(line,tabWidth)
				if s != line:
					changed = true ; anyChanged = true
				result.append(s)
			if changed:
				result = string.join(result,'\n')
				v.t.setTnodeText(result)
		v.setDirty()
		v = v.threadNext()
	if anyChanged:
		newText = c.body.get("1.0","end") # 7/11/03
		newSel = getTextSelection(c.body) # 7/11/03
		c.undoer.setUndoParams("Convert All Blanks",
			current,select=current,oldTree=v_copy,
			oldText=oldText,newText=newText,
			oldSel=oldSel,newSel=newSel)
	else:
		es("nothing changed")</t>
<t tx="T459">def convertAllTabs (self):

	c = self ; v = current = c.currentVnode()
	next = v.nodeAfterTree()
	dict = scanDirectives(c)
	tabWidth  = dict.get("tabwidth")
	# Create copy for undo.
	v_copy = v.copyTree()
	oldText = c.body.get("1.0","end") # 7/11/03
	oldSel = getTextSelection(c.body) # 7/11/03
	anyChanged = false
	while v and v != next:
		if v == current:
			if self.convertTabs():
				anyChanged = true # 7/11/03
		else:
			result = [] ; changed = false
			text = v.t.bodyString
			lines = string.split(text, '\n')
			for line in lines:
				i,w = skip_leading_ws_with_indent(line,0,tabWidth)
				s = computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
				if s != line:
					changed = true ; anyChanged = true
				result.append(s)
			if changed:
				result = string.join(result,'\n')
				v.t.setTnodeText(result)
		v.setDirty()
		v = v.threadNext()
	if anyChanged:
		newText = c.body.get("1.0","end") # 7/11/03
		newSel = getTextSelection(c.body) # 7/11/03
		c.undoer.setUndoParams("Convert All Tabs",
			current,select=current,oldTree=v_copy,
			oldText=oldText,newText=newText,
			oldSel=oldSel,newSel=newSel)
	else:
		es("nothing changed")</t>
<t tx="T460">def convertBlanks (self):

	c = self ; v = current = c.currentVnode()
	head,lines,tail,oldSel,oldYview = c.getBodyLines()
	result = [] ; changed = false

	# DTHEIN 3-NOV-2002: use the relative @tabwidth, not the global one
	dict = scanDirectives(c)
	tabWidth  = dict.get("tabwidth")

	if 0: # DTHEIN 3-NOV-2002: don't use the global @tabwidth
		for line in lines:
			s = optimizeLeadingWhitespace(line,c.tab_width)
			if s != line: changed = true
			result.append(s)
	else: # DTHEIN 3-NOV-2002: use relative @tabwidth (tabWidth)
		for line in lines:
			s = optimizeLeadingWhitespace(line,tabWidth)
			if s != line: changed = true
			result.append(s)

	if changed:
		result = string.join(result,'\n')
		c.updateBodyPane(head,result,tail,"Convert Blanks",oldSel,oldYview) # Handles undo
		setTextSelection(c.body,"1.0","1.0")
		
	return changed
</t>
<t tx="T461">def convertTabs (self):

	c = self
	head,lines,tail,oldSel,oldYview = self.getBodyLines()
	result = [] ; changed = false
	
	# DTHEIN 3-NOV-2002: use the relative @tabwidth, not the global one
	dict = scanDirectives(c)
	tabWidth  = dict.get("tabwidth")

	if 0: # DTHEIN 3-NOV-2002: don't use the global @tabwidth
		for line in lines:
			i,w = skip_leading_ws_with_indent(line,0,c.tab_width)
			s = computeLeadingWhitespace(w,-abs(c.tab_width)) + line[i:] # use negative width.
			if s != line: changed = true
			result.append(s)
	else: # DTHEIN 3-NOV-2002: use the relative @tabwidth (tabWidth)
		for line in lines:
			i,w = skip_leading_ws_with_indent(line,0,tabWidth)
			s = computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
			if s != line: changed = true
			result.append(s)

	if changed:
		result = string.join(result,'\n')
		c.updateBodyPane(head,result,tail,"Convert Tabs",oldSel,oldYview) # Handles undo
		setTextSelection(c.body,"1.0","1.0")
		
	return changed</t>
<t tx="T462">def createLastChildNode (self,parent,headline,body):
	
	c = self
	if body and len(body) &gt; 0:
		body = string.rstrip(body)
	if not body or len(body) == 0:
		body = ""
	v = parent.insertAsLastChild()
	v.initHeadString(headline)
	v.t.setTnodeText(body)
	v.createDependents() # To handle effects of clones.
	v.setDirty()
	c.validateOutline()</t>
<t tx="T463">def dedentBody (self):

	c = self
	head,lines,tail,oldSel,oldYview = self.getBodyLines()
	result = [] ; changed = false
	for line in lines:
		i, width = skip_leading_ws_with_indent(line,0,c.tab_width)
		s = computeLeadingWhitespace(width-abs(c.tab_width),c.tab_width) + line[i:]
		if s != line: changed = true
		result.append(s)
	if changed:
		result = string.join(result,'\n')
		c.updateBodyPane(head,result,tail,"Undent",oldSel,oldYview)</t>
<t tx="T464">def extract(self):

	c = self ; current = v = c.currentVnode()
	head,lines,tail,oldSel,oldYview = self.getBodyLines()
	if not lines: return
	headline = lines[0] ; del lines[0]
	junk, ws = skip_leading_ws_with_indent(headline,0,c.tab_width)
	# Create copy for undo.
	v_copy = v.copyTree()
	oldText = c.body.get("1.0","end") # 7/11/03
	oldSel = getTextSelection(c.body) # 7/11/03
	&lt;&lt; Set headline for extract &gt;&gt;
	# Remove leading whitespace from all body lines.
	result = []
	for line in lines:
		# Remove the whitespace on the first line
		line = removeLeadingWhitespace(line,ws,c.tab_width)
		result.append(line)
	# Create a new node from lines.
	body = string.join(result,'\n')
	if head and len(head) &gt; 0:
		head = string.rstrip(head)
	c.beginUpdate()
	if 1: # update range...
		c.createLastChildNode(v,headline,body)
		undoType =  "Can't Undo" # 12/8/02: None enables further undoes, but there are bugs now.
		c.updateBodyPane(head,None,tail,undoType,oldSel,oldYview)
		newText = c.body.get("1.0","end") # 7/11/03
		newSel = getTextSelection(c.body) # 7/11/03
		c.undoer.setUndoParams("Extract",
			v,select=current,oldTree=v_copy,
			oldText=oldText,newText=newText,
			oldSel=oldSel,newSel=newSel)
	c.endUpdate()</t>
<t tx="T465">headline = string.strip(headline)
while len(headline) &gt; 0 and headline[0] == '/':
	headline = headline[1:]
headline = string.strip(headline)</t>
<t tx="T466">def extractSection(self):

	c = self ; current = v = c.currentVnode()
	head,lines,tail,oldSel,oldYview = self.getBodyLines()
	if not lines: return
	headline = lines[0] ; del lines[0]
	junk, ws = skip_leading_ws_with_indent(headline,0,c.tab_width)
	line1 = "\n" + headline
	# Create copy for undo.
	v_copy = v.copyTree()
	# trace("v:     " + `v`)
	# trace("v_copy:" + `v_copy`)
	oldText = c.body.get("1.0","end") # 7/11/03
	oldSel = getTextSelection(c.body) # 7/11/03
	&lt;&lt; Set headline for extractSection &gt;&gt;
	# Remove leading whitespace from all body lines.
	result = []
	for line in lines:
		# Remove the whitespace on the first line
		line = removeLeadingWhitespace(line,ws,c.tab_width)
		result.append(line)
	# Create a new node from lines.
	body = string.join(result,'\n')
	if head and len(head) &gt; 0:
		head = string.rstrip(head)
	c.beginUpdate()
	if 1: # update range...
		c.createLastChildNode(v,headline,body)
		undoType = None # Set undo params later.
		c.updateBodyPane(head,line1,tail,undoType,oldSel,oldYview)
		newText = c.body.get("1.0","end") # 7/11/03
		newSel = getTextSelection(c.body) # 7/11/03
		c.undoer.setUndoParams("Extract Section",v,
			select=current,oldTree=v_copy,
			oldText=oldText,newText=newText,
			oldSel=oldSel,newSel=newSel)
	c.endUpdate()</t>
<t tx="T467">while len(headline) &gt; 0 and headline[0] == '/':
	headline = headline[1:]
headline = string.strip(headline)

# Make sure we have a @&lt; or &lt;&lt;
if headline[0:2] != '&lt;&lt;' and headline[0:2] != '@&lt;': return</t>
<t tx="T468">def extractSectionNames(self):

	c = self ; current = v = c.currentVnode()
	head,lines,tail,oldSel,oldYview = self.getBodyLines()
	if not lines: return
	# Create copy for undo.
	v_copy = v.copyTree()
	# No change to body or selection of this node.
	oldText = newText = c.body.get("1.0","end") # 7/11/03
	i, j = oldSel = newSel = self.getBodySelection()
	c.beginUpdate()
	if 1: # update range...
		for s in lines:
			&lt;&lt; Find the next section name &gt;&gt;
			if name: self.createLastChildNode(v,name,None)
		c.selectVnode(v)
		c.validateOutline()
	c.endUpdate()
	# No change to body or selection
	c.undoer.setUndoParams("Extract Names",
		v,select=current,oldTree=v_copy,
		oldText=oldText,newText=newText,
		oldSel=oldSel,newSel=newSel)
	# Restore the selection.
	setTextSelection(c.body,i,j)
	set_focus(c,c.body)</t>
<t tx="T469">head1 = string.find(s,"&lt;&lt;")
if head1 &gt; -1:
	head2 = string.find(s,"&gt;&gt;",head1)
else:
	head1 = string.find(s,"@&lt;")
	if head1 &gt; -1:
		head2 = string.find(s,"@&gt;",head1)
		
if head1 == -1 or head2 == -1 or head1 &gt; head2:
	name = None
else:
	name = s[head1:head2+2]</t>
<t tx="T470">def getBodyLines (self):
	
	c = self
	oldYview = c.frame.body.yview()
	i, j = oldSel = getTextSelection(c.body)
	# if selection was made from back to front, then i and j are reversed
	if i and j and i != j: # 7/7/03
		# Convert all lines containing any part of the selection.
		if c.body.compare(i,"&gt;",j): i,j = j,i
		i = c.body.index(i + "linestart")
		# 12-SEP-2002 DTHEIN: don't include following line in selection
		endSel = j # position of last character of selection
		trailingNewline = ""
		line,col = j.split(".")
		if col == "0":  # DTHEIN: selection ends at start of next line
			endSel = c.body.index(j + "- 1 chars")
			trailingNewline = '\n'
		else: # DTHEIN: selection ends in the midst of a line
			endSel = c.body.index(j + "lineend")
			j = endSel
		head = c.body.get("1.0",i)
		tail = c.body.get(j,"end")
	else: # Convert the entire text.
		i = "1.0" ; j = "end" ; head = tail = ""
		endSel = c.body.index(j + "- 1 chars") # 14-SEP-2002 DTHEIN
		trailingNewline = ""
	if i == endSel:
		head = tail = None ; lines = []
	else:
		lines = c.body.get(i,endSel)
		lines = string.split(lines, '\n')
		lines[-1] += trailingNewline # DTHEIN: add newline if needed
	return head,lines,tail,oldSel,oldYview</t>
<t tx="T471">def getBodySelection (self):

	c = self
	i, j = getTextSelection(c.body)
	if i and j and c.body.compare(i,"&gt;",j):
		i,j = j,i
	return i, j</t>
<t tx="T472">def indentBody (self):

	c = self
	head,lines,tail,oldSel,oldYview = self.getBodyLines()
	result = [] ; changed = false
	for line in lines:
		i, width = skip_leading_ws_with_indent(line,0,c.tab_width)
		s = computeLeadingWhitespace(width+abs(c.tab_width),c.tab_width) + line[i:]
		if s != line: changed = true
		result.append(s)
	if changed:
		result = string.join(result,'\n')
		c.updateBodyPane(head,result,tail,"Indent",oldSel,oldYview)</t>
<t tx="T473">def reformatParagraph(self):
	"""Reformat a text paragraph in a Tk.Text widget

Wraps the concatenated text to present page width setting.
Leading tabs are sized to present tab width setting.
First and second line of original text is used to determine leading whitespace
in reformatted text.  Hanging indentation is honored.

Paragraph is bound by start of body, end of body, blank lines, and lines
starting with "@".  Paragraph is selected by position of current insertion
cursor."""

	c = self ; body = c.frame.body
	x = body.index("current")
	head,lines,tail,oldSel,oldYview = self.getBodyLines()
	result = []

	dict = scanDirectives(c)
	pageWidth = dict.get("pagewidth")
	tabWidth  = dict.get("tabwidth")
	# trace(`tabWidth`+","+`pageWidth`)

	# If active selection, then don't attempt a reformat.
	selStart, selEnd = getTextSelection(body)
	if selStart != selEnd: return

	# Find the paragraph range.
	data = bound_paragraph(body)
	if data:
		start, end, endsWithNL = data
		firstLine = int(float(start)) - 1 # subtract 1 to get on zero basis
		lastLine = int(float(end)) - 1
	else: return
	
	# Compute the leading whitespace.
	indents = [0,0] ; leading_ws = ["",""] # Bug fix: 11/16/02
	for i in (0,1):
		if firstLine + i &lt; len(lines):
			# Use the original, non-optimized leading whitespace.
			leading_ws[i] = ws = get_leading_ws(lines[firstLine+i])
			indents[i] = computeWidth(ws,tabWidth)
	indents[1] = max(indents)
	# 11/17/02: Bug fix suggested by D.T.Hein.
	if 1 == (lastLine - firstLine):
		leading_ws[1] = leading_ws[0]

	# Put the leading unchanged lines.
	for i in range(0,firstLine):
		result.append(lines[i])
		
	# Wrap the lines, decreasing the page width by indent.
	wrapped_lines = wrap_lines(
		lines[firstLine:lastLine],
		pageWidth-indents[1],
		pageWidth-indents[0])
	lineCount = len(wrapped_lines)
		
	i = 0
	for line in wrapped_lines:
		result.append(leading_ws[i] + line)
		if i &lt; 1: i += 1

	# Put the trailing unchanged lines.
	for i in range(lastLine,len(lines)):
		result.append(lines[i])

	# Replace the text if it changed.
	for i in range(firstLine,lineCount+firstLine):
		if i &gt;= lastLine or lines[i] != result[i]:
			result = string.join(result,'\n')
			c.updateBodyPane(head,result,tail,"Reformat Paragraph",oldSel,oldYview) # Handles undo
			break

	&lt;&lt; Set the new insert at the start of the next paragraph &gt;&gt;

	# Make sure we can see the new cursor.
	body.see("insert-5l")
</t>
<t tx="T474">lastLine = firstLine + lineCount
if not endsWithNL:
	insPos = str(lastLine) + ".0lineend"
else:
	endPos = body.index("end")
	endLine = int(float(endPos))
	lastLine += 1
	insPos = str(lastLine) + ".0"
	while lastLine &lt; endLine:
		s = body.get(insPos,insPos + "lineend")
		if s and (0 &lt; len(s)) and not s.isspace():
			break;
		lastLine += 1
		insPos = str(lastLine) + ".0"
setTextSelection(body,insPos,insPos)</t>
<t tx="T475">def updateBodyPane (self,head,middle,tail,undoType,oldSel,oldYview):
	
	c = self ; v = c.currentVnode()
	# trace(v)
	# Update the text and set start, end.
	c.body.delete("1.0","end")
	# The caller must do rstrip.head if appropriate.
	if head and len(head) &gt; 0:
		c.body.insert("end",head)
		start = c.body.index("end-1c")
	else: start = "1.0"
	if middle and len(middle) &gt; 0:
		c.body.insert("end",middle)
		end = c.body.index("end-1c")
	else: end = start
	if tail and len(tail) &gt; 0:
		tail = string.rstrip(tail)
	if tail and len(tail) &gt; 0:
		c.body.insert("end",tail)
	# Activate the body key handler by hand.
	c.tree.onBodyChanged(v,undoType,oldSel=oldSel,oldYview=oldYview)
	# Update the changed mark.
	if not c.isChanged():
		c.setChanged(true)
	# Update the icon.
	c.beginUpdate()
	if not v.isDirty():
		v.setDirty()
	c.endUpdate()
	# Update the selection.
	# trace(`start` + "," + `end`)
	setTextSelection(c.body,start,end)
	if oldYview:
		first,last=oldYview
		c.body.yview("moveto",first)
	else:
		c.body.see("insert")
	set_focus(c,c.body)
	c.recolor() # 7/5/02</t>
<t tx="T476"></t>
<t tx="T477">def canContractAllHeadlines (self):

	c = self ; v = c.rootVnode()
	if not v: return false
	while v:
		if v.isExpanded():
			return true
		v = v.threadNext()
	return false</t>
<t tx="T478">def canContractAllSubheads (self):

	c = self
	v = c.currentVnode()
	if not v: return false
	next = v.nodeAfterTree()
	v = v.threadNext()
	while v and v != next:
		if v.isExpanded():
			return true
		v = v.threadNext()
	return false</t>
<t tx="T479">def canContractParent (self):

	c = self ; v = c.currentVnode()
	return v.parent() != None</t>
<t tx="T480">def canContractSubheads (self):

	c = self ; v = c.currentVnode()
	if not v: return false
	v = v.firstChild()
	while v:
		if v.isExpanded():
			return true
		v = v.next()
	return false</t>
<t tx="T481">def canDeleteHeadline (self):

	c = self ; v = c.currentVnode()
	if not v: return false
	if v.parent(): # v is below the top level.
		return true
	else: # v is at the top level.  We can not delete the last node.
		return v.threadBack() or v.next()

canCutOutline = canDeleteHeadline</t>
<t tx="T482">def canDemote (self):

	c = self
	v = c.currentVnode()
	if not v: return false
	return v.next() != None</t>
<t tx="T483">def canExpandAllHeadlines (self):

	c = self ; v = c.rootVnode()
	if not v: return false
	while v:
		if not v.isExpanded():
			return true
		v = v.threadNext()
	return false</t>
<t tx="T484">def canExpandAllSubheads (self):

	c = self
	v = c.currentVnode()
	if not v: return false
	next = v.nodeAfterTree()
	v = v.threadNext()
	while v and v != next:
		if not v.isExpanded():
			return true
		v = v.threadNext()
	return false</t>
<t tx="T485">def canExpandSubheads (self):

	c = self ; v = c.currentVnode()
	if not v: return false
	v = v.firstChild()
	while v:
		if not v.isExpanded():
			return true
		v = v.next()
	return false</t>
<t tx="T486">def canExtract (self):

	c = self
	if c.body:
		i, j = getTextSelection(c.body)
		return i and j and c.body.compare(i, "!=", j)
	else:
		return false

canExtractSection = canExtract
canExtractSectionNames = canExtract</t>
<t tx="T487">def canFindMatchingBracket (self):
	
	c = self ; body = c.body
	brackets = "()[]{}"
	c1 = body.get("insert -1c")
	c2 = body.get("insert")
	# Bug fix: 2/11/03
	return (c1 and c1 in brackets) or (c2 and c2 in brackets)</t>
<t tx="T488">def canGoToNextDirtyHeadline (self):

	c = self ; current = c.currentVnode()
	if not current: return false

	v = c.rootVnode()
	while v:
		if v.isDirty()and v != current:
			return true
		v = v.threadNext()
	return false</t>
<t tx="T489">def canGoToNextMarkedHeadline (self):

	c = self ; current = c.currentVnode()
	if not current: return false

	v = c.rootVnode()
	while v:
		if v.isMarked()and v != current:
			return true
		v = v.threadNext()
	return false</t>
<t tx="T490">def canMarkChangedHeadlines (self):

	c = self ; v = c.rootVnode()
	while v:
		if v.isDirty():
			return true
		v = v.threadNext()
	return false</t>
<t tx="T491">def canMarkChangedRoots (self):

	c = self ; v = c.rootVnode()
	while v:
		if v.isDirty():
			return true
		v = v.threadNext()
	return false</t>
<t tx="T492">def canMoveOutlineDown (self):

	c = self
	if 1: # The permissive way
		current = c.currentVnode()
		if not current: return false
		v = current.visNext()
		while v and current.isAncestorOf(v):
			v = v.visNext()
		return v != None
	else: # The MORE way.
		return c.currentVnode().next() != None</t>
<t tx="T493">def canMoveOutlineLeft (self):

	c = self ; v = c.currentVnode()
	if 0: # Old code: assumes multiple leftmost nodes.
		return v and v.parent()
	else: # Can't move a child of the root left.
		return v and v.parent() and v.parent().parent()</t>
<t tx="T494">def canMoveOutlineRight (self):

	c = self ; v = c.currentVnode()
	return v and v.back()</t>
<t tx="T495">def canMoveOutlineUp (self):

	c = self ; v = c.currentVnode()
	if 1: # The permissive way.
		return v and v.visBack()
	else: # The MORE way.
		return v and v.back()</t>
<t tx="T496">def canPasteOutline (self,s=None):

	a = app() ; c = self
	if s == None:
		try:
			s = a.root.selection_get(selection="CLIPBOARD")
		except:
			return false

	# trace(s)
	if match(s,0,a.prolog_prefix_string):
		return true
	elif len(s) &gt; 0:
		return c.importCommands.stringIsValidMoreFile(s)
	else:
		return false</t>
<t tx="T497">def canPromote (self):

	c = self ; v = c.currentVnode()
	return v and v.hasChildren()</t>
<t tx="T498">def canRevert (self):

	# c.mFileName will be "untitled" for unsaved files.
	c = self
	return (c.frame and c.frame.mFileName and
		len(c.frame.mFileName) &gt; 0 and c.isChanged())</t>
<t tx="T499"># 7/29/02: The shortcuts for these commands are now unique.

def canSelectThreadBack (self):
	v = self.currentVnode()
	return v and v.threadBack()
	
def canSelectThreadNext (self):
	v = self.currentVnode()
	return v and v.threadNext()

def canSelectVisBack (self):
	v = self.currentVnode()
	return v and v.visBack()
	
def canSelectVisNext (self):
	v = self.currentVnode()
	return v and v.visNext()</t>
<t tx="T500">def canShiftBodyLeft (self):

	c = self
	if c.body:
		s = c.body.GetValue()
		return len(s) &gt; 0
	else:
		return false
		
def canShiftBodyRight (self):

	c = self
	if c.body:
		s = c.body.GetValue()
		return len(s) &gt; 0
	else:
		return false</t>
<t tx="T501">def canSortChildren (self):

	c = self ; v = c.currentVnode()
	return v and v.hasChildren()
	
def canSortSiblings (self):

	c = self ; v = c.currentVnode()
	return v.next() or v.back()</t>
<t tx="T502">def canUndo (self):

	c = self
	return c.undoer.canUndo()
	
def canRedo (self):

	c = self
	return c.undoer.canRedo()</t>
<t tx="T503"># Returns true if any node is marked.

def canUnmarkAll (self):

	c = self ; v = c.rootVnode()
	while v:
		if v.isMarked():
			return true
		v = v.threadNext()
	return false</t>
<t tx="T504"></t>
<t tx="T505"></t>
<t tx="T506">def contractAllHeadlines (self):

	c = self ; current = c.currentVnode()
	v = c.rootVnode()
	c.beginUpdate()

	while v:
		c.contractSubtree(v)
		v = v.next()

	if not current.isVisible():
		# 1/31/03: Select the topmost ancestor of the presently selected node.
		v = current
		while v and v.parent():
			v = v.parent()
		c.selectVnode(v)

	c.endUpdate()
	c.expansionLevel = 1 # Reset expansion level.</t>
<t tx="T507">def contractNode (self):
	
	c = self ; v = c.currentVnode()
	
	c.beginUpdate()
	v.contract()
	c.endUpdate()
</t>
<t tx="T508">def contractParent (self):
	
	c = self ; v = c.currentVnode()
	parent = v.parent()
	if not parent: return
	
	c.beginUpdate()
	c.selectVnode(parent)
	parent.contract()
	c.endUpdate()</t>
<t tx="T509">def expandAllHeadlines(self):

	c = self ; v = root = c.rootVnode()
	c.beginUpdate()
	while v:
		c.expandSubtree(v)
		v = v.next()
	c.selectVnode(root)
	c.endUpdate()
	c.expansionLevel = 0 # Reset expansion level.</t>
<t tx="T510">def expandAllSubheads (self):

	c = self ; v = c.currentVnode()
	if not v: return

	child = v.firstChild()
	c.beginUpdate()
	c.expandSubtree(v)
	while child:
		c.expandSubtree(child)
		child = child.next()
	c.selectVnode(v)
	c.endUpdate()</t>
<t tx="T511">def expandLevel1 (self): self.expandToLevel(1)
def expandLevel2 (self): self.expandToLevel(2)
def expandLevel3 (self): self.expandToLevel(3)
def expandLevel4 (self): self.expandToLevel(4)
def expandLevel5 (self): self.expandToLevel(5)
def expandLevel6 (self): self.expandToLevel(6)
def expandLevel7 (self): self.expandToLevel(7)
def expandLevel8 (self): self.expandToLevel(8)
def expandLevel9 (self): self.expandToLevel(9)
</t>
<t tx="T512">def expandNextLevel (self):

	c = self ; v = c.currentVnode()
	
	# 1/31/02: Expansion levels are now local to a particular tree.
	if c.expansionNode != v:
		c.expansionLevel = 1
		c.expansionNode = v
		
	self.expandToLevel(c.expansionLevel + 1)
</t>
<t tx="T513">def expandNode (self):
	
	c = self ; v = c.currentVnode()
	
	c.beginUpdate()
	v.expand()
	c.endUpdate()

</t>
<t tx="T514">def expandPrevLevel (self):

	c = self ; v = c.currentVnode()
	
	# 1/31/02: Expansion levels are now local to a particular tree.
	if c.expansionNode != v:
		c.expansionLevel = 1
		c.expansionNode = v
		
	self.expandToLevel(max(1,c.expansionLevel - 1))
</t>
<t tx="T515"></t>
<t tx="T516">def contractSubtree (self,v):

	last = v.lastNode()
	while v and v != last:
		v.contract()
		v = v.threadNext()</t>
<t tx="T517">def expandSubtree (self,v):

	c = self
	last = v.lastNode()
	while v and v != last:
		v.expand()
		v = v.threadNext()
	c.tree.redraw()</t>
<t tx="T518">def expandToLevel (self,level):

	c = self
	c.beginUpdate()
	if 1: # 1/31/03: The expansion is local to the present node.
		v = c.currentVnode() ; n = v.level()
		after = v.nodeAfterTree()
		while v and v != after:
			if v.level() - n + 1 &lt; level:
				v.expand()
			else:
				v.contract()
			v = v.threadNext()
	else: # The expansion is global
		# Start the recursion.
		# First contract everything.
		c.contractAllHeadlines()
		v = c.rootVnode()
		while v:
			c.expandTreeToLevelFromLevel(v,level,1)
			v = v.next()
	c.expansionLevel = level
	c.expansionNode = c.currentVnode()
	c.endUpdate()</t>
<t tx="T519"></t>
<t tx="T520"># Compatibility with scripts

def currentVnode (self):

	return self.tree.currentVnode
</t>
<t tx="T521">def clearAllMarked (self):

	c = self ; v = c.rootVnode()
	while v:
		v.clearMarked()
		v = v.threadNext()</t>
<t tx="T522">def clearAllVisited (self):

	c = self ; v = c.rootVnode()
	c.beginUpdate()
	while v:
		# tick("clearAllVisited loop")
		v.clearVisited()
		if v.t:
			v.t.clearVisited()
		v = v.threadNext()
	c.endUpdate(false) # never redraw the tree.</t>
<t tx="T523"># Compatibility with scripts

def fileName (self):

	return self.frame.mFileName
</t>
<t tx="T524">def isChanged (self):

	return self.changed</t>
<t tx="T525"># Compatibility with scripts

def rootVnode (self):

	return self.tree.rootVnode
</t>
<t tx="T526">def setChanged (self,changedFlag):

	c = self
	if not c.frame: return
	# Clear all dirty bits _before_ setting the caption.
	# 9/15/01 Clear all dirty bits except orphaned @file nodes
	if not changedFlag:
		v = c.rootVnode()
		while v:
			if v.isDirty() and not (v.isAtFileNode() or v.isAtRawFileNode()):
				v.clearDirtyJoined()
			v = v.threadNext()
	# Update all derived changed markers.
	c.changed = changedFlag
	s = c.frame.top.title()
	if len(s) &gt; 2 and not c.loading: # don't update while loading.
		if changedFlag:
			# import traceback ; traceback.print_stack()
			if s [0] != '*': c.frame.top.title("* " + s)
		else:
			if s[0:2]=="* ": c.frame.top.title(s[2:])


</t>
<t tx="T527"></t>
<t tx="T528"># Returns false if any node of tree is a clone of parent or any of parents ancestors.

def checkMoveWithParentWithWarning (self,root,parent,warningFlag):

	clone_message = "Illegal move or drag: no clone may contain a clone of itself"
	drag_message  = "Illegal drag: Can't drag a node into its own tree"

	# 10/25/02: Create dictionaries for faster checking.
	parents = {} ; clones = {}
	while parent:
		parents [parent.t] = parent.t
		if parent.isCloned():
			clones [parent.t] = parent.t
		parent = parent.parent()
	
	# 10/25/02: Scan the tree only once.
	v = root ; next = root.nodeAfterTree()
	while v and v != next:
		ct = clones.get(v.t)
		if ct != None and ct == v.t:
			if warningFlag:
				alert(clone_message)
			return false
		v = v.threadNext()

	pt = parents.get(root.t)
	if pt == None:
		return true
	else:
		if warningFlag:
			alert(drag_message)
		return false
</t>
<t tx="T529"># Deletes the current vnode and dependent nodes. Does nothing if the outline would become empty.

def deleteHeadline (self,op_name="Delete Outline"):

	c = self ; v = c.currentVnode()
	if not v: return
	vBack = v.visBack()
	# Bug fix: 1/18/00: if vBack is NULL we are at the top level,
	# the next node should be v.next(), _not_ v.visNext();
	if vBack: newNode = vBack
	else: newNode = v.next()
	if not newNode: return
	c.endEditing()# Make sure we capture the headline for Undo.
	c.beginUpdate()
	v.setDirtyDeleted() # 8/3/02: Mark @file nodes dirty for all clones in subtree.
	# Reinsert v after back, or as the first child of parent, or as the root.
	c.undoer.setUndoParams(op_name,v,select=newNode)
	v.doDelete(newNode) # doDelete destroys dependents.
	c.setChanged(true)
	c.endUpdate()
	c.validateOutline()</t>
<t tx="T530"># Inserts a vnode after the current vnode.  All details are handled by the vnode class.

def insertHeadline (self,op_name="Insert Outline"):

	c = self ; current = c.currentVnode()
	if not current: return

	c.beginUpdate()
	if 1: # inside update...
		if current.hasChildren() and current.isExpanded():
			v = current.insertAsNthChild(0)
		else:
			v = current.insertAfter()
		c.undoer.setUndoParams(op_name,v,select=current)
		v.createDependents() # To handle effects of clones.
		c.selectVnode(v)
		c.editVnode(v)
		v.setDirty() # Essential in Leo2.
		c.setChanged(true)
	c.endUpdate()</t>
<t tx="T531">def clone (self):

	c = self ; v = c.currentVnode()
	if not v: return
	c.beginUpdate()
	clone = v.clone(v)
	clone.setDirty() # essential in Leo2
	c.setChanged(true)
	if c.validateOutline():
		c.selectVnode(clone)
		c.undoer.setUndoParams("Clone",clone)
	c.endUpdate() # updates all icons</t>
<t tx="T532">def initAllCloneBits (self):
	
	"""Initialize all clone bits in the entire outline"""
	# trace()

	c=self
	c.clearAllVisited()
	v = self.tree.rootVnode
	c.beginUpdate()
	while v:
		if not v.t.isVisited():
			v.t.setVisited() # Inhibit visits to all joined nodes.
			c.initJoinedCloneBits(v)
		v = v.threadNext()
	c.endUpdate()
</t>
<t tx="T533"># Initializes all clone bits in the all nodes joined to v.

def initJoinedCloneBits (self,v):

	c = self
	c.beginUpdate()
	mark = v.shouldBeClone()
	if mark:
		# Set clone bit in v and all joined nodes.
		v.setClonedBit()
		for v2 in v.t.joinList:
			v2.setClonedBit()
	else:
		# Set clone bit in v and all joined nodes.
		v.clearClonedBit()
		for v2 in v.t.joinList:
			v2.clearClonedBit()
	c.endUpdate()
</t>
<t tx="T534"># Makes sure all nodes are valid.

def validateOutline (self):

	c = self ; root = c.rootVnode()
	if root:
		return root.validateOutlineWithParent(None)
	else:
		return true</t>
<t tx="T535"></t>
<t tx="T536">def goToNextDirtyHeadline (self):

	c = self ; current = c.currentVnode()
	if not current: return

	v = current.threadNext()
	while v and not v.isDirty():
		v = v.threadNext()
	if not v:
		v = c.rootVnode()
		while v and not v.isDirty():
			v = v.threadNext()
	if v:
		c.selectVnode(v)</t>
<t tx="T537">def goToNextMarkedHeadline(self):

	c = self ; current = c.currentVnode()
	if not current: return

	v = current.threadNext()
	while v and not v.isMarked():
		v = v.threadNext()
	if v:
		c.beginUpdate()
		c.endEditing()
		c.selectVnode(v)
		c.endUpdate()</t>
<t tx="T538">def goToNextClone(self):

	c = self ; current = c.currentVnode()
	if not current: return
	if not current.isCloned(): return

	v = current.threadNext()
	while v and v.t != current.t:
		v = v.threadNext()
		
	if not v:
		# Wrap around.
		v = c.rootVnode()
		while v and v != current and v.t != current.t:
			v = v.threadNext()

	if v:
		c.beginUpdate()
		c.endEditing()
		c.selectVnode(v)
		c.endUpdate()</t>
<t tx="T539">def markChangedHeadlines (self):

	c = self ; v = c.rootVnode()
	c.beginUpdate()
	while v:
		if v.isDirty()and not v.isMarked():
			v.setMarked()
			c.setChanged(true)
		v = v.threadNext()
	c.endUpdate()</t>
<t tx="T540">def markChangedRoots (self):

	c = self ; v = c.rootVnode()
	c.beginUpdate()
	while v:
		if v.isDirty()and not v.isMarked():
			s = v.bodyString()
			flag, i = is_special(s,0,"@root")
			if flag:
				v.setMarked()
				c.setChanged(true)
		v = v.threadNext()
	c.endUpdate()</t>
<t tx="T541">def markAllAtFileNodesDirty (self):

	c = self ; v = c.rootVnode()
	c.beginUpdate()
	while v:
		if v.isAtFileNode()and not v.isDirty():
			v.setDirty()
			v = v.nodeAfterTree()
		else: v = v.threadNext()
	c.endUpdate()</t>
<t tx="T542">def markAtFileNodesDirty (self):

	c = self
	v = c.currentVnode()
	if not v: return
	after = v.nodeAfterTree()
	c.beginUpdate()
	while v and v != after:
		if v.isAtFileNode() and not v.isDirty():
			v.setDirty()
			v = v.nodeAfterTree()
		else: v = v.threadNext()
	c.endUpdate()</t>
<t tx="T543">def markClones (self):

	c = self ; current = v = c.currentVnode()
	if not v: return
	if not v.isCloned(): return
	
	v = c.rootVnode()
	c.beginUpdate()
	while v:
		if v.t == current.t:
			v.setMarked()
		v = v.threadNext()
	c.endUpdate()</t>
<t tx="T544">def markHeadline (self):

	c = self ; v = c.currentVnode()
	if not v: return

	c.beginUpdate()
	if v.isMarked():
		v.clearMarked()
	else:
		v.setMarked()
		v.setDirty()
		c.setChanged(true)
	c.endUpdate()</t>
<t tx="T545">def markSubheads(self):

	c = self ; v = c.currentVnode()
	if not v: return

	child = v.firstChild()
	c.beginUpdate()
	while child:
		if not child.isMarked():
			child.setMarked()
			child.setDirty()
			c.setChanged(true)
		child = child.next()
	c.endUpdate()</t>
<t tx="T546">def unmarkAll(self):

	c = self ; v = c.rootVnode()
	c.beginUpdate()
	while v:
		if v.isMarked():
			v.clearMarked()
			v.setDirty()
			c.setChanged(true)
		v = v.threadNext()
	c.endUpdate()</t>
<t tx="T547"></t>
<t tx="T548">def dragAfter(self,v,after):

	# es("dragAfter")
	c = self
	if not c.checkMoveWithParentWithWarning(v,after.parent(),true): return
	# Remember both the before state and the after state for undo/redo
	oldBack = v.back()
	oldParent = v.parent()
	oldN = v.childIndex()
	c.beginUpdate()
	if 1: # inside update...
		c.endEditing()
		v.setDirty()
		v.moveAfter(after)
		c.undoer.setUndoParams("Drag",v,
			oldBack=oldBack,oldParent=oldParent,oldN=oldN)
		v.setDirty()
		c.selectVnode(v)
		c.setChanged(true)
	c.endUpdate()
	c.updateSyntaxColorer(v) # Dragging can change syntax coloring.</t>
<t tx="T549">def dragCloneToNthChildOf (self,v,parent,n):

	c = self
	c.beginUpdate()
	# trace("v,parent,n:"+v.headString()+","+parent.headString()+","+`n`)
	clone = v.clone(v) # Creates clone &amp; dependents, does not set undo.
	if not c.checkMoveWithParentWithWarning(clone,parent,true):
		clone.doDelete(v) # Destroys clone &amp; dependents. Makes v the current node.
		c.endUpdate(false) # Nothing has changed.
		return
	# Remember both the before state and the after state for undo/redo
	oldBack = v.back()
	oldParent = v.parent()
	oldN = v.childIndex()
	c.endEditing()
	clone.setDirty()
	clone.moveToNthChildOf(parent,n)
	c.initJoinedCloneBits(clone) # Bug fix: 4/29/03
	c.undoer.setUndoParams("Drag &amp; Clone",clone,
		oldBack=oldBack,oldParent=oldParent,oldN=oldN,oldV=v)
	clone.setDirty()
	c.selectVnode(clone)
	c.setChanged(true)
	c.endUpdate()
	c.updateSyntaxColorer(clone) # Dragging can change syntax coloring.</t>
<t tx="T550">def dragToNthChildOf(self,v,parent,n):

	# es("dragToNthChildOf")
	c = self
	if not c.checkMoveWithParentWithWarning(v,parent,true): return
	# Remember both the before state and the after state for undo/redo
	oldBack = v.back()
	oldParent = v.parent()
	oldN = v.childIndex()
	c.beginUpdate()
	if 1: # inside update...
		c.endEditing()
		v.setDirty()
		v.moveToNthChildOf(parent,n)
		c.undoer.setUndoParams("Drag",v,
			oldBack=oldBack,oldParent=oldParent,oldN=oldN)
		v.setDirty()
		c.selectVnode(v)
		c.setChanged(true)
	c.endUpdate()
	c.updateSyntaxColorer(v) # Dragging can change syntax coloring.</t>
<t tx="T551">def sortChildren(self):

	c = self ; v = c.currentVnode()
	if not v or not v.hasChildren(): return
	&lt;&lt; Set the undo info for sortChildren &gt;&gt;
	c.beginUpdate()
	c.endEditing()
	v.sortChildren()
	v.setDirty()
	c.setChanged(true)
	c.endUpdate()
	
def sortSiblings (self):
	
	c = self ; v = c.currentVnode()
	if not v: return
	parent = v.parent()
	if not parent:
		c.sortTopLevel()
	else:
		&lt;&lt; Set the undo info for sortSiblings &gt;&gt;
		c.beginUpdate()
		c.endEditing()
		parent.sortChildren()
		parent.setDirty()
		c.setChanged(true)
		c.endUpdate()</t>
<t tx="T552"># Get the present list of children.
children = []
child = v.firstChild()
while child:
	children.append(child)
	child = child.next()
c.undoer.setUndoParams("Sort Children",v,sort=children)</t>
<t tx="T553"># Get the present list of siblings.
sibs = []
sib = parent.firstChild()
while sib:
	sibs.append(sib)
	sib = sib.next()
c.undoer.setUndoParams("Sort Siblings",v,sort=sibs)</t>
<t tx="T554">def sortTopLevel (self):
	
	# Create a list of vnode, headline tuples
	c = self ; v = root = c.rootVnode()
	if not v: return
	&lt;&lt; Set the undo info for sortTopLevel &gt;&gt;
	pairs = []
	while v:
		pairs.append((v.headString().lower(), v))
		v = v.next()
	# Sort the list on the headlines.
	pairs.sort()
	sortedNodes = pairs
	# Move the nodes
	c.beginUpdate()
	h,v = sortedNodes[0]
	if v != root:
		v.moveToRoot(oldRoot=root)
	for h,next in sortedNodes[1:]:
		next.moveAfter(v)
		v = next
	c.endUpdate()</t>
<t tx="T555"># Get the present list of children.
sibs = []
sib = c.rootVnode()
while sib:
	sibs.append(sib)
	sib = sib.next()
c.undoer.setUndoParams("Sort Top Level",v,sort=sibs)</t>
<t tx="T556">def demote(self):

	c = self ; v = c.currentVnode()
	if not v or not v.next(): return
	last = v.lastChild() # EKR: 3/19/03
	# Make sure all the moves will be valid.
	child = v.next()
	while child:
		if not c.checkMoveWithParentWithWarning(child,v,true):
			return
		child = child.next()
	c.beginUpdate()
	if 1: # update range...
		c.mInhibitOnTreeChanged = true
		c.endEditing()
		while v.next():
			child = v.next()
			child.moveToNthChildOf(v,v.numberOfChildren())
		v.expand()
		c.selectVnode(v)
		v.setDirty()
		c.setChanged(true)
		c.mInhibitOnTreeChanged = false
		c.initAllCloneBits() # 7/6/02
	c.endUpdate()
	c.undoer.setUndoParams("Demote",v,lastChild=last)
	c.updateSyntaxColorer(v) # Moving can change syntax coloring.</t>
<t tx="T557">@ Moving down is more tricky than moving up; we can't move v to be a child of itself.  An important optimization:  we don't have to call checkMoveWithParentWithWarning() if the parent of the moved node remains the same.
@c

def moveOutlineDown(self):

	c = self
	v = c.currentVnode()
	if not v: return
	# Set next to the node after which v will be moved.
	next = v.visNext()
	while next and v.isAncestorOf(next):
		next = next.visNext()
	if not next: return
	c.beginUpdate()
	if 1: # inside update...
		c.endEditing()
		v.setDirty()
		&lt;&lt; Move v down &gt;&gt;
		v.setDirty() # This second call is essential.
		c.selectVnode(v)# 4/23/01
		c.setChanged(true)
	c.endUpdate()
	c.updateSyntaxColorer(v) # Moving can change syntax coloring.</t>
<t tx="T558"># Remember both the before state and the after state for undo/redo
oldBack = v.back()
oldParent = v.parent()
oldN = v.childIndex()

if next.hasChildren() and next.isExpanded():
	# Attempt to move v to the first child of next.
	if c.checkMoveWithParentWithWarning(v,next,true):
		v.moveToNthChildOf(next,0)
		c.undoer.setUndoParams("Move Down",v,
			oldBack=oldBack,oldParent=oldParent,oldN=oldN)
else:
	# Attempt to move v after next.
	if c.checkMoveWithParentWithWarning(v,next.parent(),true):
		v.moveAfter(next)
		c.undoer.setUndoParams("Move Down",v,
			oldBack=oldBack,oldParent=oldParent,oldN=oldN)</t>
<t tx="T559">def moveOutlineLeft(self):
	
	# clear_stats() ; # stat()
	c = self
	v = c.currentVnode()
	if not v: return
	parent = v.parent()
	if not parent: return
	# Remember both the before state and the after state for undo/redo
	oldBack = v.back()
	oldParent = v.parent()
	oldN = v.childIndex()
	c.beginUpdate()
	if 1: # inside update...
		c.endEditing()
		v.setDirty()
		v.moveAfter(parent)
		c.undoer.setUndoParams("Move Left",v,
			oldBack=oldBack,oldParent=oldParent,oldN=oldN)
		v.setDirty()
		c.selectVnode(v)
		c.setChanged(true)
	c.endUpdate()
	c.updateSyntaxColorer(v) # Moving can change syntax coloring.
	# print_stats()</t>
<t tx="T560">def moveOutlineRight(self):
	
	# clear_stats() ; # stat()
	c = self
	v = c.currentVnode()
	if not v: return
	back = v.back()
	if not back: return
	if not c.checkMoveWithParentWithWarning(v,back,true): return
	# Remember both the before state and the after state for undo/redo
	oldBack = v.back()
	oldParent = v.parent()
	oldN = v.childIndex()
	c.beginUpdate()
	if 1: # inside update...
		c.endEditing()
		v.setDirty()
		n = back.numberOfChildren()
		v.moveToNthChildOf(back,n)
		c.undoer.setUndoParams("Move Right",v,
			oldBack=oldBack,oldParent=oldParent,oldN=oldN)
		v.setDirty()
		c.selectVnode(v)
		c.setChanged(true)
		c.initJoinedCloneBits(v) # 7/6/02
	c.endUpdate()
	c.updateSyntaxColorer(v) # Moving can change syntax coloring.
	# print_stats()</t>
<t tx="T561">def moveOutlineUp(self):

	c = self
	v = c.currentVnode()
	if not v: return
	back = v.visBack()
	if not back: return
	back2 = back.visBack()
	c = self
	c.beginUpdate()
	if 1: # inside update...
		c.endEditing()
		v.setDirty()
		&lt;&lt; Move v up &gt;&gt;
		v.setDirty()
		c.selectVnode(v)
		c.setChanged(true)
	c.endUpdate()
	c.updateSyntaxColorer(v) # Moving can change syntax coloring.</t>
<t tx="T562"># Remember both the before state and the after state for undo/redo
oldBack = v.back()
oldParent = v.parent()
oldN = v.childIndex()

if not back2:
	# v will be the new root node
	v.moveToRoot(c.tree.rootVnode) # 3/16/02, 5/17/02
	c.undoer.setUndoParams("Move Up",v,
		oldBack=oldBack,oldParent=oldParent,oldN=oldN)
elif back2.hasChildren() and back2.isExpanded():
	if c.checkMoveWithParentWithWarning(v,back2,true):
		v.moveToNthChildOf(back2,0)
		c.undoer.setUndoParams("Move Up",v,
			oldBack=oldBack,oldParent=oldParent,oldN=oldN)
elif c.checkMoveWithParentWithWarning(v,back2.parent(),true):
	# Insert after back2.
	v.moveAfter(back2)
	c.undoer.setUndoParams("Move Up",v,
		oldBack=oldBack,oldParent=oldParent,oldN=oldN)</t>
<t tx="T563">def promote(self):

	c = self
	v = c.currentVnode()
	if not v or not v.hasChildren(): return
	last = v.lastChild() # EKR: 3/19/03
	c.beginUpdate()
	if 1: # inside update...
		c.endEditing()
		after = v
		while v.hasChildren():
			child = v.firstChild()
			child.moveAfter(after)
			after = child
		v.setDirty()
		c.setChanged(true)
		c.selectVnode(v)
	c.endUpdate()
	c.undoer.setUndoParams("Promote",v,lastChild=last)
	c.updateSyntaxColorer(v) # Moving can change syntax coloring.</t>
<t tx="T564">def dragCloneAfter (self,v,after):

	c = self
	c.beginUpdate()
	clone = v.clone(v) # Creates clone &amp; dependents, does not set undo.
	# trace("v,after:"+v.headString()+","+after.headString())
	if not c.checkMoveWithParentWithWarning(clone,after.parent(),true):
		trace("invalid clone move")
		clone.doDelete(v) # Destroys clone &amp; dependents. Makes v the current node.
		c.endUpdate(false) # Nothing has changed.
		return
	# Remember both the before state and the after state for undo/redo
	oldBack = v.back()
	oldParent = v.parent()
	oldN = v.childIndex()
	c.endEditing()
	clone.setDirty()
	clone.moveAfter(after)
	c.initJoinedCloneBits(clone) # Bug fix: 4/29/03
	c.undoer.setUndoParams("Drag &amp; Clone",clone,
		oldBack=oldBack,oldParent=oldParent,oldN=oldN,oldV=v)
	clone.setDirty()
	c.selectVnode(clone)
	c.setChanged(true)
	c.endUpdate()
	c.updateSyntaxColorer(clone) # Dragging can change syntax coloring.</t>
<t tx="T565"></t>
<t tx="T566"># Selects v: sets the focus to v and edits v.

def editVnode(self,v):

	c = self
	# trace(v)
	if v:
		c.selectVnode(v)
		c.tree.editLabel(v)</t>
<t tx="T567"># Ends the editing in the outline.

def endEditing(self):

	self.tree.endEditLabel()
</t>
<t tx="T568">def selectThreadBack(self):

	c = self ; current = c.currentVnode()
	if not current: return
	
	v = current.threadBack()
	if v:
		c.beginUpdate()
		c.selectVnode(v)
		c.endUpdate()
</t>
<t tx="T569">def selectThreadNext(self):

	c = self ; current = c.currentVnode()
	if not current: return

	v = current.threadNext()
	if v:
		c.beginUpdate()
		c.selectVnode(v)
		c.endUpdate()</t>
<t tx="T570"># This has an up arrow for a control key.

def selectVisBack(self):

	c = self ; current = c.currentVnode()
	if not current: return

	v = current.visBack()
	if v:
		c.beginUpdate()
		c.selectVnode(v)
		c.endUpdate()</t>
<t tx="T571">def selectVisNext(self):

	c = self ; current = c.currentVnode()
	if not current: return
	
	v = current.visNext()
	if v:
		c.beginUpdate()
		c.selectVnode(v)
		c.endUpdate()
</t>
<t tx="T572"># This is called inside commands to select a new vnode.

def selectVnode(self,v,updateBeadList=true):

	# All updating and "synching" of nodes are now done in the event handlers!
	c = self
	c.tree.endEditLabel()
	c.tree.select(v,updateBeadList)
	# trace(v)
	set_focus(c,c.body)
	self.editing = false</t>
<t tx="T573"># Selects the given node and enables editing of the headline if editFlag is true.

def selectVnodeWithEditing(self,v,editFlag):

	c = self
	if editFlag:
		c.editVnode(v)
	else:
		c.selectVnode(v)
</t>
<t tx="T574">@ These routines provide a convenient interface to the syntax colorer.
</t>
<t tx="T575">def updateSyntaxColorer(self,v):

	self.tree.colorizer.updateSyntaxColorer(v)
</t>
<t tx="T576">@language python

# The code for Leo's Compare Panel and the compare class.

from leoGlobals import *
import difflib,filecmp,os,string
import Tkinter,tkFileDialog

@others

if __name__ == "__main__":
	pass</t>
<t tx="T577">def choose(cond, a, b): # warning: evaluates all arguments

	if cond: return a
	else: return b
</t>
<t tx="T578">def go ():

	cmp = leoCompare(
		commands = None,
		
		appendOutput = true,

		ignoreBlankLines = true,
		ignoreFirstLine1 = false,
		ignoreFirstLine2 = false,
		ignoreInteriorWhitespace = false,
		ignoreLeadingWhitespace = true,
		ignoreSentinelLines = false,
		
		limitCount = 9, # Zero means don't stop.
		limitToExtension = ".py",  # For directory compares.
		makeWhitespaceVisible = true,
		
		printBothMatches = false,
		printMatches = false,
		printMismatches = true,
		printTrailingMismatches = false,

		outputFileName = None)

	if 1: # Compare all files in Tangle test directories

		path1 = "c:\\prog\\test\\tangleTest\\"
		path2 = "c:\\prog\\test\\tangleTestCB\\"
		cmp.compare_directories(path1,path2)

	else: # Compare two files.

		name1 = "c:\\prog\\test\\compare1.txt"
		name2 = "c:\\prog\\test\\compare2.txt"
		cmp.compare_files(name1,name2)</t>
<t tx="T579">class baseLeoCompare:
	"""The base class for Leo's compare code."""
	@others
	
class leoCompare (baseLeoCompare):
	"""A class containing Leo's compare code."""
	pass</t>
<t tx="T580"># All these ivars are known to the leoComparePanel class.

def __init__ (self,

	# Keyword arguments are much convenient and more clear for scripts.
	commands = None,
	
	appendOutput = false,

	ignoreBlankLines = true,
	ignoreFirstLine1 = false,
	ignoreFirstLine2 = false,
	ignoreInteriorWhitespace = false,
	ignoreLeadingWhitespace = true,
	ignoreSentinelLines = false,

	limitCount = 0, # Zero means don't stop.
	limitToExtension = ".py",  # For directory compares.
	makeWhitespaceVisible = true,

	printBothMatches = false,
	printMatches = false,
	printMismatches = true,
	printTrailingMismatches = false,

	outputFileName = None ):
		
	# It is more convenient for the leoComparePanel to set these directly.
	self.commands = commands
	
	self.appendOutput = appendOutput

	self.ignoreBlankLines = ignoreBlankLines
	self.ignoreFirstLine1 = ignoreFirstLine1
	self.ignoreFirstLine2 = ignoreFirstLine2
	self.ignoreInteriorWhitespace = ignoreInteriorWhitespace
	self.ignoreLeadingWhitespace = ignoreLeadingWhitespace
	self.ignoreSentinelLines = ignoreSentinelLines

	self.limitCount = limitCount
	self.limitToExtension = limitToExtension

	self.printBothMatches = printBothMatches
	self.printMatches = printMatches
	self.printMismatches = printMismatches
	self.printTrailingMismatches = printTrailingMismatches
	
	# For communication between methods...
	self.outputFileName = outputFileName
	self.fileName1 = None 
	self.fileName2 = None
	# Open files...
	self.outputFile = None</t>
<t tx="T581"># We ignore the filename portion of path1 and path2 if it exists.

def compare_directories (self,path1,path2):
	
	# Ignore everything except the directory name.
	dir1 = os.path.dirname(path1)
	dir2 = os.path.dirname(path2)
	dir1 = os.path.normpath(dir1)
	dir2 = os.path.normpath(dir2)
	
	if dir1 == dir2:
		self.show("Directory names are identical.\nPlease pick distinct directories.")
		return
		
	try:
		list1 = os.listdir(dir1)
	except:
		self.show("invalid directory:" + dir1)
		return
	try:
		list2 = os.listdir(dir2)
	except:
		self.show("invalid directory:" + dir2)
		return
		
	if self.outputFileName:
		self.openOutputFile()
	ok = self.outputFileName == None or self.outputFile
	if not ok:
		return

	# Create files and files2, the lists of files to be compared.
	files1 = []
	files2 = []
	for f in list1:
		junk, ext = os.path.splitext(f)
		if self.limitToExtension:
			if ext == self.limitToExtension:
				files1.append(f)
		else:
			files1.append(f)
	for f in list2:
		junk, ext = os.path.splitext(f)
		if self.limitToExtension:
			if ext == self.limitToExtension:
				files2.append(f)
		else:
			files2.append(f)

	# Compare the files and set the yes, no and fail lists.
	yes = [] ; no = [] ; fail = []
	for f1 in files1:
		head,f2 = os.path.split(f1)
		if f2 in files2:
			try:
				name1 = os.path.join(dir1,f1)
				name2 = os.path.join(dir2,f2)
				val = filecmp.cmp(name1,name2,0)
				if val: yes.append(f1)
				else:    no.append(f1)
			except:
				self.show("exception in filecmp.cmp")
				es_exception()
				fail.append(f1)
		else:
			fail.append(f1)
	
	# Print the results.
	for kind, files in (
		("----- matches --------",yes),
		("----- mismatches -----",no),
		("----- not found ------",fail)):
		self.show(kind)
		for f in files:
			self.show(f)
	
	if self.outputFile:
		self.outputFile.close()
		self.outputFile = None</t>
<t tx="T582">def compare_files (self, name1, name2):
	
	if name1 == name2:
		self.show("File names are identical.\nPlease pick distinct files.")
		return

	f1 = f2 = None
	try:
		f1 = self.doOpen(name1)
		f2 = self.doOpen(name2)
		if self.outputFileName:
			self.openOutputFile()
		ok = self.outputFileName == None or self.outputFile
		ok = choose(ok and ok != 0,1,0)
		if f1 and f2 and ok: # Don't compare if there is an error opening the output file.
			self.compare_open_files(f1,f2,name1,name2)
	except:
		self.show("exception comparing files")
		es_exception()
	try:
		if f1: f1.close()
		if f2: f2.close()
		if self.outputFile:
			self.outputFile.close() ; self.outputFile = None
	except:
		self.show("exception closing files")
		es_exception()</t>
<t tx="T583">def compare_lines (self,s1,s2):
	
	if self.ignoreLeadingWhitespace:
		s1 = string.lstrip(s1)
		s2 = string.lstrip(s2)

	if self.ignoreInteriorWhitespace:
		k1 = skip_ws(s1,0)
		k2 = skip_ws(s2,0)
		ws1 = s1[:k1]
		ws2 = s2[:k2]
		tail1 = s1[k1:]
		tail2 = s2[k2:]
		tail1 = string.replace(tail1," ","")
		tail1 = string.replace(tail1,"\t","")
		tail2 = string.replace(tail2," ","")
		tail2 = string.replace(tail2,"\t","")
		s1 = ws1 + tail1
		s2 = ws2 + tail2

	return s1 == s2</t>
<t tx="T584">def compare_open_files (self, f1, f2, name1, name2):

	# self.show("compare_open_files")
	lines1 = 0 ; lines2 = 0 ; mismatches = 0 ; printTrailing = true
	sentinelComment1 = sentinelComment2 = None
	if self.openOutputFile():
		self.show("1: " + name1)
		self.show("2: " + name2)
		self.show("")
	s1 = s2 = None
	&lt;&lt; handle opening lines &gt;&gt;
	while 1:
		if s1 == None:
			s1 = readlineForceUnixNewline(f1) ; lines1 += 1
		if s2 == None:
			s2 = readlineForceUnixNewline(f2) ; lines2 += 1
		&lt;&lt; ignore blank lines and/or sentinels &gt;&gt;
		n1 = len(s1) ; n2 = len(s2)
		if n1==0 and n2 != 0: self.show("1.eof***:")
		if n2==0 and n1 != 0: self.show("2.eof***:")
		if n1==0 or n2==0: break
		match = self.compare_lines(s1,s2)
		if not match: mismatches += 1
		&lt;&lt; print matches and/or mismatches &gt;&gt;
		&lt;&lt; warn if mismatch limit reached &gt;&gt;
		s1 = s2 = None # force a read of both lines.
	&lt;&lt; handle reporting after at least one eof is seen &gt;&gt;</t>
<t tx="T585">if self.ignoreSentinelLines:
	
	s1 = readlineForceUnixNewline(f1) ; lines1 += 1
	s2 = readlineForceUnixNewline(f2) ; lines2 += 1
	# Note: isLeoHeader may return None.
	sentinelComment1 = self.isLeoHeader(s1)
	sentinelComment2 = self.isLeoHeader(s2)
	if not sentinelComment1: self.show("no @+leo line for " + name1)
	if not sentinelComment2: self.show("no @+leo line for " + name2)
		
if self.ignoreFirstLine1:
	if s1 == None:
		readlineForceUnixNewline(f1) ; lines1 += 1
	s1 = None

if self.ignoreFirstLine2:
	if s2 == None:
		readlineForceUnixNewline(f2) ; lines2 += 1
	s2 = None</t>
<t tx="T586"># Completely empty strings denotes end-of-file.
if s1 and len(s1) &gt; 0:
	if self.ignoreBlankLines and len(string.strip(s1)) == 0:
		s1 = None ; continue
		
	if self.ignoreSentinelLines and sentinelComment1 and self.isSentinel(s1,sentinelComment1):
		s1 = None ; continue

if s2 and len(s2) &gt; 0:
	if self.ignoreBlankLines and len(string.strip(s2)) == 0:
		s2 = None ; continue

	if self.ignoreSentinelLines and sentinelComment2 and self.isSentinel(s2,sentinelComment2):
		s2 = None ; continue
</t>
<t tx="T587">if self.limitCount == 0 or mismatches &lt;= self.limitCount:

	if match and self.printMatches:
		
		if self.printBothMatches:
			self.dump(string.rjust("1." + `lines1`,6) + ' :',s1)
			self.dump(string.rjust("2." + `lines2`,6) + ' :',s2)
		else:
			self.dump(string.rjust(       `lines1`,6) + ' :',s1)
	
	if not match and self.printMismatches:
		
		self.dump(string.rjust("1." + `lines1`,6) + '*:',s1)
		self.dump(string.rjust("2." + `lines2`,6) + '*:',s2)</t>
<t tx="T588">if self.limitCount &gt; 0 and mismatches &gt;= self.limitCount:
	
	if printTrailing:
		self.show("")
		self.show("limit count reached")
		self.show("")
		printTrailing = false</t>
<t tx="T589">if n1 &gt; 0: 
	lines1 += self.dumpToEndOfFile("1.",f1,s1,lines1,printTrailing)
	
if n2 &gt; 0:
	lines2 += self.dumpToEndOfFile("2.",f2,s2,lines2,printTrailing)

self.show("")
self.show("lines1:" + `lines1`)
self.show("lines2:" + `lines2`)
self.show("mismatches:" + `mismatches`)</t>
<t tx="T590">def filecmp (self,f1,f2):

	val = filecmp.cmp(f1,f2)
	if 1:
		if val: self.show("equal")
		else:   self.show("*** not equal")
	else:
		self.show("filecmp.cmp returns:")
		if val: self.show(`val` + " (equal)")
		else:   self.show(`val` + " (not equal)")
	return val</t>
<t tx="T591"></t>
<t tx="T592">def doOpen (self,name):

	try:
		f = open(name,'r')
		return f
	except:
		self.show("can not open:" + '"' + name + '"')
		return None</t>
<t tx="T593">def dump (self,tag,s):

	cmp = self ; out = tag

	for ch in s[:-1]: # don't print the newline
	
		if cmp.makeWhitespaceVisible:
			if ch == '\t':
				out += "[" ; out += "t" ; out += "]"
			elif ch == ' ':
				out += "[" ; out += " " ; out += "]"
			else: out += ch
		else:
			if 1:
				out += ch
			else: # I don't know why I thought this was a good idea ;-)
				if ch == '\t' or ch == ' ':
					out += ' '
				else:
					out += ch

	self.show(out)</t>
<t tx="T594">def dumpToEndOfFile (self,tag,f,s,line,printTrailing):

	trailingLines = 0
	while 1:
		if not s:
			s = readlineForceUnixNewline(f)
		if len(s) == 0: break
		trailingLines += 1
		if self.printTrailingMismatches and printTrailing:
			tag2 = string.rjust(tag + `line`,6) + "+:"
			self.dump(tag2,s)
		s = None

	self.show(tag + `trailingLines` + " trailing lines")
	return trailingLines</t>
<t tx="T595">@ These methods are based on atFile.scanHeader().  They are simpler because we only care about the starting sentinel comment: any line starting with the starting sentinel comment is presumed to be a sentinel line.
@c

def isLeoHeader (self,s):

	tag = "@+leo"
	j = string.find(s,tag)
	if j &gt; 0:
		i = skip_ws(s,0)
		if i &lt; j: return s[i:j]
		else: return None
	else: return None
		
def isSentinel (self,s,sentinelComment):

	i = skip_ws(s,0)
	return match(s,i,sentinelComment)</t>
<t tx="T596">def openOutputFile (self):
	
	if self.outputFileName == None:
		return
	dir,name = os.path.split(self.outputFileName)
	if len(dir) == 0:
		self.show("empty output directory")
		return
	if len(name) == 0:
		self.show("empty output file name")
		return
	if not os.path.exists(dir):
		self.show("output directory not found: " + dir)
	else:
		try:
			if self.appendOutput:
				self.show("appending to " + self.outputFileName)
				self.outputFile = open(self.outputFileName,"ab")
			else:
				self.show("writing to " + self.outputFileName)
				self.outputFile = open(self.outputFileName,"wb")
		except:
			self.outputFile = None
			self.show("exception opening output file")
			es_exception()</t>
<t tx="T597">def show (self,s):
	
	# print s
	if self.outputFile:
		self.outputFile.write(s + '\n')
	elif self.commands:
		es(s)
	else:
		print s
		print</t>
<t tx="T598">def showIvars (self):
	
	self.show("fileName1:"        + `self.fileName1`)
	self.show("fileName2:"        + `self.fileName2`)
	self.show("outputFileName:"   + `self.outputFileName`)
	self.show("limitToExtension:" + `self.limitToExtension`)
	self.show("")

	self.show("ignoreBlankLines:"         + `self.ignoreBlankLines`)
	self.show("ignoreFirstLine1:"         + `self.ignoreFirstLine1`)
	self.show("ignoreFirstLine2:"         + `self.ignoreFirstLine2`)
	self.show("ignoreInteriorWhitespace:" + `self.ignoreInteriorWhitespace`)
	self.show("ignoreLeadingWhitespace:"  + `self.ignoreLeadingWhitespace`)
	self.show("ignoreSentinelLines:"      + `self.ignoreSentinelLines`)
	self.show("")
	
	self.show("limitCount:"              + `self.limitCount`)
	self.show("printMatches:"            + `self.printMatches`)
	self.show("printMismatches:"         + `self.printMismatches`)
	self.show("printTrailingMismatches:" + `self.printTrailingMismatches`)</t>
<t tx="T599">class baseLeoComparePanel:
	"""The base class for Leo's compare panel."""
	@others
	
class leoComparePanel (baseLeoComparePanel):
	"""A class that creates Leo's compare panel."""
	pass
</t>
<t tx="T600">def browser (self,n):
	
	types = [
		("C/C++ files","*.c"),
		("C/C++ files","*.cpp"),
		("C/C++ files","*.h"),
		("C/C++ files","*.hpp"),
		("Java files","*.java"),
		("Pascal files","*.pas"),
		("Python files","*.py"),
		("Text files","*.txt"),
		("All files","*") ]

	fileName = tkFileDialog.askopenfilename(
		title="Choose compare file" + n,
		filetypes=types,
		defaultextension=".txt")
		
	if fileName and len(fileName) &gt; 0:
		# The dialog also warns about this, so this may never happen.
		if not os.path.exists(fileName):
			self.show("not found: " + fileName)
			fileName = None
	else: fileName = None
		
	return fileName</t>
<t tx="T601">def __init__ (self,c,cmp):

	Tk = Tkinter
	self.commands = c
	self.cmp = cmp
	
	# Ivars pointing to Tk elements.
	self.browseEntries = []
	self.extensionEntry = None
	self.countEntry = None
	self.printButtons = []
	
	# No corresponding cmp ivar.
	self.useOutputFileVar = Tk.IntVar()
	
	# These all correspond to ivars in leoCompare.
	self.appendOutputVar             = Tk.IntVar()

	self.ignoreBlankLinesVar         = Tk.IntVar()
	self.ignoreFirstLine1Var         = Tk.IntVar()
	self.ignoreFirstLine2Var         = Tk.IntVar()
	self.ignoreInteriorWhitespaceVar = Tk.IntVar()
	self.ignoreLeadingWhitespaceVar  = Tk.IntVar()
	self.ignoreSentinelLinesVar      = Tk.IntVar()

	self.limitToExtensionVar         = Tk.IntVar()
	self.makeWhitespaceVisibleVar    = Tk.IntVar()
	
	self.printBothMatchesVar         = Tk.IntVar()
	self.printMatchesVar             = Tk.IntVar()
	self.printMismatchesVar          = Tk.IntVar()
	self.printTrailingMismatchesVar  = Tk.IntVar()
	self.stopAfterMismatchVar        = Tk.IntVar()
	
	# These ivars are set from Entry widgets.
	self.limitCount = 0
	self.limitToExtension = None 
	if 0: # we just use the cmp ivars.
		self.pathName1 = None
		self.pathName2 = None
		self.outputFileName = None
	
	# The default file name in the "output file name" browsers.
	self.defaultOutputFileName = "CompareResults.txt"</t>
<t tx="T602"># Initialize ivars from config parameters.

def finishCreate (self):

	config = app().config
	
	# File names.
	for i,option in (
		(0,"compare_file_1"),
		(1,"compare_file_2"),
		(2,"output_file") ):
			
		name = config.getComparePref(option)
		if name and len(name) &gt; 0:
			e = self.browseEntries[i]
			e.delete(0,"end")
			e.insert(0,name)
			
	name = config.getComparePref("output_file")
	b = choose(name and len(name) &gt; 0,1,0)
	self.useOutputFileVar.set(b)

	# File options.
	b = config.getBoolComparePref("ignore_first_line_of_file_1")
	if b == None: b = 0
	self.ignoreFirstLine1Var.set(b)
	
	b = config.getBoolComparePref("ignore_first_line_of_file_2")
	if b == None: b = 0
	self.ignoreFirstLine2Var.set(b)
	
	b = config.getBoolComparePref("append_output_to_output_file")
	if b == None: b = 0
	self.appendOutputVar.set(b)

	ext = config.getComparePref("limit_directory_search_extension")
	b = ext and len(ext) &gt; 0
	b = choose(b and b != 0,1,0)
	self.limitToExtensionVar.set(b)
	if b:
		e = self.extensionEntry
		e.delete(0,"end")
		e.insert(0,ext)
		
	# Print options.
	b = config.getBoolComparePref("print_both_lines_for_matches")
	if b == None: b = 0
	self.printBothMatchesVar.set(b)
	
	b = config.getBoolComparePref("print_matching_lines")
	if b == None: b = 0
	self.printMatchesVar.set(b)
	
	b = config.getBoolComparePref("print_mismatching_lines")
	if b == None: b = 0
	self.printMismatchesVar.set(b)
	
	b = config.getBoolComparePref("print_trailing_lines")
	if b == None: b = 0
	self.printTrailingMismatchesVar.set(b)
	
	n = config.getIntComparePref("limit_count")
	b = n and n &gt; 0
	b = choose(b and b != 0,1,0)
	self.stopAfterMismatchVar.set(b)
	if b:
		e = self.countEntry
		e.delete(0,"end")
		e.insert(0,`n`)

	# Whitespace options.
	b = config.getBoolComparePref("ignore_blank_lines")
	if b == None: b = 1 # unusual default.
	self.ignoreBlankLinesVar.set(b)
	
	b = config.getBoolComparePref("ignore_interior_whitespace")
	if b == None: b = 0
	self.ignoreInteriorWhitespaceVar.set(b)
	
	b = config.getBoolComparePref("ignore_leading_whitespace")
	if b == None: b = 0
	self.ignoreLeadingWhitespaceVar.set(b)
	
	b = config.getBoolComparePref("ignore_sentinel_lines")
	if b == None: b = 0
	self.ignoreSentinelLinesVar.set(b)
	
	b = config.getBoolComparePref("make_whitespace_visible")
	if b == None: b = 0
	self.makeWhitespaceVisibleVar.set(b)</t>
<t tx="T603">def run (self):

	import leoApp, leoCommands

	c = self.commands ; cmp = self.cmp ; Tk = Tkinter
	self.top = top = Tk.Toplevel(app().root)
	top.title("Leo Compare files and directories")
	top.protocol("WM_DELETE_WINDOW", self.onClose)
	&lt;&lt; create the organizer frames &gt;&gt;
	&lt;&lt; create the browser rows &gt;&gt;
	&lt;&lt; create the extension row &gt;&gt;
	&lt;&lt; create the whitespace options frame &gt;&gt;
	&lt;&lt; create the print options frame &gt;&gt;
	&lt;&lt; create the compare buttons &gt;&gt;
	center_dialog(top) # Do this _after_ building the dialog!
	top.resizable(0,0)
	self.finishCreate()</t>
<t tx="T604">outer = Tk.Frame(top, bd=2,relief="groove")
outer.pack(pady=4)

row1 = Tk.Frame(outer)
row1.pack(pady=4)

row2 = Tk.Frame(outer)
row2.pack(pady=4)

row3 = Tk.Frame(outer)
row3.pack(pady=4)

row4 = Tk.Frame(outer)
row4.pack(pady=4,expand=1,fill="x") # for left justification.

options = Tk.Frame(outer)
options.pack(pady=4)

ws = Tk.Frame(options)
ws.pack(side="left",padx=4)

pr = Tk.Frame(options)
pr.pack(side="right",padx=4)

lower = Tk.Frame(outer)
lower.pack(pady=6)</t>
<t tx="T605">for row,text,text2,command,var in (
	(row1,"Compare path 1:","Ignore first line",self.onBrowse1,self.ignoreFirstLine1Var),
	(row2,"Compare path 2:","Ignore first line",self.onBrowse2,self.ignoreFirstLine2Var),
	(row3,"Output file:",   "Use output file",  self.onBrowse3,self.useOutputFileVar) ):

	lab = Tk.Label(row,anchor="e",text=text,width=13)
	lab.pack(side="left",padx=4)
	
	e = Tk.Entry(row)
	e.pack(side="left",padx=2)
	self.browseEntries.append(e)
	
	b = Tk.Button(row,text="browse...",command=command)
	b.pack(side="left",padx=6)

	b = Tk.Checkbutton(row,text=text2,anchor="w",variable=var,width=15)
	b.pack(side="left")</t>
<t tx="T606">b = Tk.Checkbutton(row4,anchor="w",var=self.limitToExtensionVar,
	text="Limit directory compares to type:")
b.pack(side="left",padx=4)

self.extensionEntry = e = Tk.Entry(row4,width=6)
e.pack(side="left",padx=2)

b = Tk.Checkbutton(row4,anchor="w",var=self.appendOutputVar,
	text="Append output to output file")
b.pack(side="left",padx=4)</t>
<t tx="T607">w,f = create_labeled_frame(ws,caption="Whitespace options",relief="groove")
	
for text,var in (
	("Ignore Leo sentinel lines", self.ignoreSentinelLinesVar),
	("Ignore blank lines",        self.ignoreBlankLinesVar),
	("Ignore leading whitespace", self.ignoreLeadingWhitespaceVar),
	("Ignore interior whitespace",self.ignoreInteriorWhitespaceVar),
	("Make whitespace visible",   self.makeWhitespaceVisibleVar) ):
	
	b = Tk.Checkbutton(f,text=text,variable=var)
	b.pack(side="top",anchor="w")
	
spacer = Tk.Frame(f)
spacer.pack(padx="1i")</t>
<t tx="T608">w,f = create_labeled_frame(pr,caption="Print options",relief="groove")

row = Tk.Frame(f)
row.pack(expand=1,fill="x")

b = Tk.Checkbutton(row,text="Stop after",variable=self.stopAfterMismatchVar)
b.pack(side="left",anchor="w")

self.countEntry = e = Tk.Entry(row,width=4)
e.pack(side="left",padx=2)
e.insert(01,"1")

lab = Tk.Label(row,text="mismatches")
lab.pack(side="left",padx=2)

for padx,text,var in (    
	(0,  "Print matched lines",           self.printMatchesVar),
	(20, "Show both matching lines",      self.printBothMatchesVar),
	(0,  "Print mismatched lines",        self.printMismatchesVar),
	(0,  "Print unmatched trailing lines",self.printTrailingMismatchesVar) ):
	
	b = Tk.Checkbutton(f,text=text,variable=var)
	b.pack(side="top",anchor="w",padx=padx)
	self.printButtons.append(b)
	
# To enable or disable the "Print both matching lines" button.
b = self.printButtons[0]
b.configure(command=self.onPrintMatchedLines)

spacer = Tk.Frame(f)
spacer.pack(padx="1i")</t>
<t tx="T609">for text,command in (
	("Compare files",      self.onCompareFiles),
	("Compare directories",self.onCompareDirectories) ):
	
	b = Tk.Button(lower,text=text,command=command,width=18)
	b.pack(side="left",padx=6)</t>
<t tx="T610">def show (self,s):
	
	self.cmp.show(s)</t>
<t tx="T611">def setIvarsFromWidgets (self):

	cmp = self.cmp
	
	# File paths. cmp checks for valid file name.
	e = self.browseEntries[0]
	cmp.fileName1 = e.get()
	
	e = self.browseEntries[1]
	cmp.fileName2 = e.get()

	# Ignore first line settings.
	cmp.ignoreFirstLine1 = self.ignoreFirstLine1Var.get()
	cmp.ignoreFirstLine2 = self.ignoreFirstLine2Var.get()
	
	# Output file.  cmp checks for valid file name.
	if self.useOutputFileVar.get():
		e = self.browseEntries[2]
		name = e.get()
		if name != None and len(name) == 0:
			name = None
		cmp.outputFileName = name
	else:
		cmp.outputFileName = None

	# Extension settings.
	if self.limitToExtensionVar.get():
		cmp.limitToExtension = self.extensionEntry.get()
		if len(cmp.limitToExtension) == 0:
			cmp.limitToExtension = None
	else:
		cmp.limitToExtension = None
		
	cmp.appendOutput = self.appendOutputVar.get()
	
	# Whitespace options.
	cmp.ignoreBlankLines         = self.ignoreBlankLinesVar.get()
	cmp.ignoreInteriorWhitespace = self.ignoreInteriorWhitespaceVar.get()
	cmp.ignoreLeadingWhitespace  = self.ignoreLeadingWhitespaceVar.get()
	cmp.ignoreSentinelLines      = self.ignoreSentinelLinesVar.get()
	cmp.makeWhitespaceVisible    = self.makeWhitespaceVisibleVar.get()
	
	# Print options.
	cmp.printMatches            = self.printMatchesVar.get()
	cmp.printMismatches         = self.printMismatchesVar.get()
	cmp.printTrailingMismatches = self.printTrailingMismatchesVar.get()
	
	if cmp.printMatches:
		cmp.printBothMatches = self.printBothMatchesVar.get()
	else:
		cmp.printBothMatches = false
	
	if self.stopAfterMismatchVar.get():
		try:
			count = self.countEntry.get()
			cmp.limitCount = int(count)
		except: cmp.limitCount = 0
	else:
		cmp.limitCount = 0</t>
<t tx="T612"></t>
<t tx="T613">def onBrowse1 (self):
	
	fileName = self.browser("1")
	if fileName:
		e = self.browseEntries[0]
		e.delete(0,"end")
		e.insert(0,fileName)
	self.top.deiconify()
	
def onBrowse2 (self):
	
	fileName = self.browser("2")
	if fileName:
		e = self.browseEntries[1]
		e.delete(0,"end")
		e.insert(0,fileName)
	self.top.deiconify()
	
def onBrowse3 (self): # Get the name of the output file.

	fileName = tkFileDialog.asksaveasfilename(
		initialfile = self.defaultOutputFileName,
		title="Set output file",
		filetypes=[("Text files", "*.txt")],
		defaultextension=".txt")
		
	if fileName and len(fileName) &gt; 0:
		self.defaultOutputFileName = fileName
		self.useOutputFileVar.set(1) # The user will expect this.
		e = self.browseEntries[2]
		e.delete(0,"end")
		e.insert(0,fileName)</t>
<t tx="T614">def onClose (self):
	
	self.top.withdraw()</t>
<t tx="T615">def onCompareDirectories (self):

	cmp = self.cmp
	self.setIvarsFromWidgets()
	cmp.compare_directories(cmp.fileName1,cmp.fileName2)

def onCompareFiles (self):

	cmp = self.cmp
	self.setIvarsFromWidgets()
	cmp.compare_files(cmp.fileName1,cmp.fileName2)</t>
<t tx="T616">def onPrintMatchedLines (self):
	
	v = self.printMatchesVar.get()
	b = self.printButtons[1]
	state = choose(v,"normal","disabled")
	b.configure(state=state)</t>
<t tx="T617">@language python

from leoGlobals import *
import leoFind
import ConfigParser,exceptions,os,string,sys,tkFont

class baseConfig:
	"""The base class for Leo's configuration handler."""
	&lt;&lt; define defaultsDict &gt;&gt;
	@others
	
class config (baseConfig):
	"""A class to manage configuration settings."""
	pass</t>
<t tx="T618">@ This contains only the "interesting" defaults.
Ints and bools default to 0, floats to 0.0 and strings to "".
@c

defaultBodyFontSize = choose(sys.platform=="win32",9,12)

defaultsDict = {
	# compare options...
	"ignore_blank_lines" : 1,
	"limit_count" : 9,
	"print_mismatching_lines" : 1,
	"print_trailing_lines" : 1,
	# find/change options...
	"search_body" : 1,
	"whole_word" : 1,
	# Prefs panel.
	"default_target_language" : "Python",
	"tab_width" : 4,
	"page_width" : 132,
	"output_doc_chunks" : 1,
	"tangle_outputs_header" : 1,
	# Syntax coloring options...
	# Defaults for colors are handled by leoColor.py.
	"color_directives_in_plain_text" : 1,
	"underline_undefined_section_names" : 1,
	# Window options...
	"body_pane_wraps" : 1,
	"body_text_font_family" : "Courier",
	"body_text_font_size" : defaultBodyFontSize,
	"body_text_font_slant" : "roman",
	"body_text_font_weight" : "normal",
	"headline_text_font_size" : 12,
	"headline_text_font_slant" : "roman",
	"headline_text_font_weight" : "normal",
	"log_text_font_size" : 12,
	"log_text_font_slant" : "roman",
	"log_text_font_weight" : "normal",
	"initial_window_height" : 600, # 7/24/03: In pixels.
	"initial_window_width" :  800, # 7/24/03: In pixels.
	"initial_window_left" : 10,
	"initial_window_top" : 10,
	"initial_splitter_orientation" : "vertical",
	"initial_vertical_ratio" : 0.5,
	"initial_horizontal_ratio" : 0.3,
	"initial_horizontal_secondary_ratio" : 0.5,
	"initial_vertical_secondary_ratio" : 0.7,
	"outline_pane_scrolls_horizontally" : 0,
	"split_bar_color" : "LightSteelBlue2",
	"split_bar_relief" : "groove",
	"split_bar_width" : 7 }</t>
<t tx="T619">def __init__ (self):
	
	&lt;&lt; get the default font &gt;&gt;
	self.init()

def init (self):

	try:
		self.configDir = sys.leo_config_directory
	except:
		self.configDir = os.path.join(app().loadDir,"..","config")
	self.configFileName = os.path.join(self.configDir,"leoConfig.txt")
	self.configsExist = false # True when we successfully open leoConfig.txt.
	
	&lt;&lt; initialize constant ivars, lists &amp; dicts &gt;&gt;
	&lt;&lt; initialize ivars that may be set by config options &gt;&gt;

	self.open() # read and process the configuration file.</t>
<t tx="T620"># Get the default font from a new text widget.
# This should only be done once.

t = Tkinter.Text()
fn = t.cget("font")
font = tkFont.Font(font=fn)
self.defaultFont = font
self.defaultFontFamily = font.cget("family")
</t>
<t tx="T621"># Names of sections.
self.configSection = "config options"
self.compareSection = "compare options"
self.findSection = "find/change options"
self.keysSection = "keyboard shortcuts"
self.prefsSection = "prefs panel options"
self.recentFilesSection = "recent files"
self.colorsSection = "syntax coloring options"
self.windowSection = "window options"

# List of recent files.
self.recentFiles = []

# Section dictionaries
self.compareDict = {}
self.configDict = {} # 10/11/02: we use a dict even for ivars.
self.findDict = {}
self.keysDict = {}
self.prefsDict = {}
self.colorsDict = {}
self.windowDict = {}

# Associations of sections and dictionaries.
self.sectionInfo = (
	(self.configSection,self.configDict),
	(self.compareSection,self.compareDict),
	(self.findSection,self.findDict),
	(self.keysSection,self.keysDict),
	(self.prefsSection,self.prefsDict),
	(self.recentFilesSection,None),
	(self.colorsSection,self.colorsDict),
	(self.windowSection,self.windowDict) )</t>
<t tx="T622"># 10/11/02: Defaults are specified only here.

self.config = None # The current instance of ConfigParser
self.at_root_bodies_start_in_doc_mode = true # For compatibility with previous versions.
self.output_initial_comment = "" # "" or None for compatibility with previous versions.
self.output_newline = "nl"
self.create_nonexistent_directories = false
self.default_derived_file_encoding = "utf-8"
self.load_derived_files_immediately = 0
self.new_leo_file_encoding = "UTF-8" # Upper case for compatibility with previous versions.
self.read_only = true # Make sure we don't alter an illegal leoConfig.txt file!
self.relative_path_base_directory = "!"
self.remove_sentinels_extension = ".txt"
self.save_clears_undo_buffer = false
self.stylesheet = None
self.thin_at_file_trees = 0
self.tkEncoding = None # Defaults to None so it doesn't override better defaults.
self.use_plugins = false # Should never be true here!</t>
<t tx="T623"></t>
<t tx="T624">def getBoolFromDict (self,name,dict):
	val = self.getIntFromDict(name,dict)
	if val and val != None and val != 0: val = 1
	return val

def getFloatFromDict (self,name,dict):
	val = self.getFromDict(name,dict)
	if val:
		try: val = float(val)
		except: val = None
	return val

def getFromDict (self,name,dict):
	val = dict.get(name)
	if val == "ignore":
		val = None
	elif val == None:
		val = self.defaultsDict.get(name)
	return val

def getIntFromDict (self,name,dict):
	val = self.getFromDict(name,dict)
	if val:
		try: val = int(val)
		except: val = None
	return val

def setDict (self,name,val,dict):
	dict [name] = val
		
getStringFromDict = getFromDict
</t>
<t tx="T625">def getBoolColorsPref (self,name):
	return self.getBoolFromDict(name,self.colorsDict)
	
# Basic getters and setters.

def getColorsPref (self,name):
	return self.getFromDict(name,self.colorsDict)

def setColorsPref (self,name,val):
	self.setDict(name,val,self.colorsDict)
	
getStringColorsPref = getColorsPref</t>
<t tx="T626">def getBoolComparePref (self,name):
	return self.getBoolFromDict(name,self.compareDict)
	
def getIntComparePref (self,name):
	return self.getIntFromDict(name,self.compareDict)

# Basic getters and setters.

def getComparePref (self,name):
	return self.getFromDict(name,self.compareDict)

def setComparePref (self,name,val):
	self.setDict(name,val,self.compareDict)
	
getStringComparePref = getComparePref</t>
<t tx="T627">def getBoolFindPref (self,name):
	return self.getBoolFromDict(name,self.findDict)

# Basic getters and setters.

def getFindPref (self,name):
	return self.getFromDict(name,self.findDict)

def setFindPref (self,name,val):
	self.setDict(name,val,self.findDict)
	
getStringFindPref = getFindPref</t>
<t tx="T628">def getBoolPref (self,name):
	return self.getBoolFromDict(name,self.prefsDict)

def getIntPref (self,name):
	return self.getIntFromDict(name,self.prefsDict)
	
# Basic getters and setters.

def getPref (self,name):
	return self.getFromDict(name,self.prefsDict)

def setPref (self,name,val):
	self.setDict(name,val,self.prefsDict)
	
getStringPref = getPref</t>
<t tx="T629">def getRecentFiles (self):
	
	return self.recentFiles

def setRecentFiles (self,files):
	
	self.recentFiles = files
</t>
<t tx="T630">def getBoolWindowPref (self,name):
	return self.getBoolFromDict(name,self.windowDict)
	
def getFloatWindowPref (self,name):
	return self.getFloatFromDict(name,self.windowDict)
	
def getIntWindowPref (self,name):
	return self.getIntFromDict(name,self.windowDict)
	
# Basic getters and setters.

def getWindowPref (self,name):
	return self.getFromDict(name,self.windowDict)

def setWindowPref (self,name,val):
	self.setDict(name,val,self.windowDict)
	
getStringWindowPref = getWindowPref</t>
<t tx="T631">@ A convenience method that computes a font from font parameters.
Arguments are the names of settings to be use.
We return None if there is no family setting so we can use system default fonts.
We default to size=12, slant="roman", weight="normal"
@c

def getFontFromParams(self,family,size,slant,weight):
	
	tag = "getFont..." ; family_name = family

	family = self.getWindowPref(family)
	if not family or family == "":
		# print tag,"using default"
		family = self.defaultFontFamily
		
	size = self.getIntWindowPref(size)
	if not size or size == 0: size = 12
	
	slant = self.getWindowPref(slant)
	if not slant or slant == "": slant = "roman"
	
	weight = self.getWindowPref(weight)
	if not weight or weight == "": weight = "normal"
	
	try:
		font = tkFont.Font(family=family,size=size,slant=slant,weight=weight)
	except:
		es("exception setting font from " + `family_name`)
		es("family,size,slant,weight:"+
			`family`+':'+`size`+':'+`slant`+':'+`weight`)
		es_exception()
		return self.defaultFont
	#print family_name,family,size,slant,weight
	#print "actual_name:",font.cget("family")
	return font</t>
<t tx="T632">def getShortcut (self,name):
	
	val = self.keysDict.get(name)
	
	# 7/19/03: Return "None" if the setting is "None"
	# This allows settings to disable a default shortcut.
	return val</t>
<t tx="T633">def initConfigParam (self,name,defaultVal):
	try:
		val = self.config.get(self.configSection,name,raw=1) # 2/4/03
	except:
		val = defaultVal
	return val

def initBooleanConfigParam (self,name,defaultVal):
	try:
		val = self.config.getboolean(self.configSection,name)
	except:
		val = defaultVal
	return val
</t>
<t tx="T634"># Sets ivars of c that can be overridden by leoConfig.txt

def setCommandsFindIvars (self,c):

	config = self ; findFrame = app().findFrame

	# N.B.: separate c.ivars are much more convenient than a dict.
	for s in findFrame.intKeys:
		val = config.getBoolFindPref(s)
		if val: 
			setattr(c,s+"_flag",val)
			# trace(s+"_flag",val)
			
	val = config.getStringFindPref("change_string")
	if val: c.change_text = val
	
	val = config.getStringFindPref("find_string")
	if val: c.find_text = val

	app().findFrame.init(c)</t>
<t tx="T635"># Sets ivars of c that can be overridden by leoConfig.txt

def setCommandsIvars (self,c):

	config = self ; a = app()
	&lt;&lt; set prefs ivars &gt;&gt;</t>
<t tx="T636">val = config.getIntPref("tab_width")
if val:
	c.tab_width = val
	if 0: # 9/20/02: don't actually redraw.
		c.frame.setTabWidth(c.tab_width)

val = config.getIntPref("page_width")
if val: c.page_width = val

val = config.getIntPref("run_tangle_done.py")
if val: c.tangle_batch_flag = val

val = config.getIntPref("run_untangle_done.py")
if val: c.untangle_batch_flag = val

val = config.getIntPref("output_doc_chunks")
if val: c.output_doc_flag = val

val = config.getIntPref("tangle_outputs_header")
if val: c.use_header_flag = val

val = config.getPref("default_tangle_directory")
if val: c.tangle_directory = val

val = config.getPref("find_string")
if val: c.tangle_directory = val

c.target_language = "python" # default
val = config.getPref("default_target_language")
if val:
	try:
		val = string.lower(val)
		val = string.replace(val,"/","")
		if a.language_delims_dict.get(val):
			c.target_language = val
		
	except: pass</t>
<t tx="T637"># Sets config ivars from c.

def setConfigFindIvars (self,c):
	
	findFrame = app().findFrame

	# N.B.: separate c.ivars are much more convenient than a dict.
	for s in findFrame.intKeys:
		val = getattr(c,s+"_flag")
		# trace(val,s+"_flag")
		self.setFindPref(s,val)
	
	self.setFindPref("change_string",c.change_text)
	self.setFindPref("find_string",c.find_text)</t>
<t tx="T638"># Sets config ivars from c.

def setConfigIvars (self,c):
	
	a = app()
	
	
	if c.target_language and a.language_delims_dict.get(c.target_language):
		language = c.target_language
	else:
		language = "plain"
	self.setPref("default_tangle_directory",c.tangle_directory)
	self.setPref("default_target_language",language)
	self.setPref("output_doc_chunks",`c.output_doc_flag`)
	self.setPref("page_width",`c.page_width`)
	self.setPref("run_tangle_done.py",`c.tangle_batch_flag`)
	self.setPref("run_untangle_done.py",`c.untangle_batch_flag`)
	self.setPref("tab_width",`c.tab_width`)
	self.setPref("tangle_outputs_header",`c.use_header_flag`)
	
	self.setFindPref("batch",`c.batch_flag`)
	self.setFindPref("ignore_case",`c.ignore_case_flag`)
	self.setFindPref("mark_changes",`c.mark_changes_flag`)
	self.setFindPref("mark_finds",`c.mark_finds_flag`)
	self.setFindPref("pattern_match",`c.pattern_match_flag`)
	self.setFindPref("reverse",`c.reverse_flag`)
	self.setFindPref("search_body",`c.search_body_flag`)
	self.setFindPref("search_headline",`c.search_headline_flag`)
	self.setFindPref("suboutline_only",`c.suboutline_only_flag`)
	self.setFindPref("wrap",`c.wrap_flag`)
	self.setFindPref("whole_word",`c.whole_word_flag`)
	
	self.setFindPref("change_string",c.change_text)
	self.setFindPref("find_string",c.find_text)</t>
<t tx="T639">def open (self):
	
	config = ConfigParser.ConfigParser()
	self.config = config
	try:
		cf = open(self.configFileName)
		config.readfp(cf)
		&lt;&lt; get config options &gt;&gt;
		&lt;&lt; get recent files &gt;&gt;
		for section, dict in self.sectionInfo:
			if dict != None:
				try:
					for opt in config.options(section):
						dict[string.lower(opt)]=config.get(section,opt,raw=1) # 2/4/03
				except: pass
		&lt;&lt; convert find/change options to unicode &gt;&gt;
		&lt;&lt; print options &gt;&gt;
		cf.close()
		self.configsExist = true
	except IOError:
		pass
	except:
		es("Exception opening " + self.configFileName)
		es_exception()
		pass
	self.config = None</t>
<t tx="T640">@ Rewritten 10/11/02 as follows:

1. We call initConfigParam and initBooleanConfigParam to get the values.

The general purpose code will enter all these values into configDict.  This allows update() to write the configuration section without special case code.  configDict is not accessible by the user.  Rather, for greater speed the user access these values via the ivars of this class.

2. We pass the ivars themselves as params so that default initialization is done in the ctor, as would normally be expected.
@c

self.at_root_bodies_start_in_doc_mode = self.initBooleanConfigParam(
	"at_root_bodies_start_in_doc_mode",self.at_root_bodies_start_in_doc_mode)
	
self.create_nonexistent_directories = self.initBooleanConfigParam(
	"create_nonexistent_directories",self.create_nonexistent_directories)
	
encoding = self.initConfigParam(
	"default_derived_file_encoding",self.default_derived_file_encoding)

if isValidEncoding(encoding):
	self.default_derived_file_encoding = encoding
else:
	es("bad default_derived_file_encoding: " + encoding)
	
self.load_derived_files_immediately = self.initBooleanConfigParam(
	"load_derived_files_immediately",self.load_derived_files_immediately)
	
encoding = self.initConfigParam(
	"new_leo_file_encoding",
	self.new_leo_file_encoding)

if isValidEncoding(encoding):
	self.new_leo_file_encoding = encoding
else:
	es("bad new_leo_file_encoding: " + encoding)

self.output_initial_comment = self.initConfigParam(
	"output_initial_comment",self.output_initial_comment)

self.output_newline = self.initConfigParam(
	"output_newline",self.output_newline)

self.read_only = self.initBooleanConfigParam(
	"read_only",self.read_only)

self.relative_path_base_directory = self.initConfigParam(
	"relative_path_base_directory",self.relative_path_base_directory)
	
self.remove_sentinels_extension = self.initConfigParam(
	"remove_sentinels_extension",self.remove_sentinels_extension)

self.save_clears_undo_buffer = self.initBooleanConfigParam(
	"save_clears_undo_buffer",self.save_clears_undo_buffer)
	
self.stylesheet = self.initConfigParam(
	"stylesheet",self.stylesheet)
	
self.thin_at_file_trees = self.initBooleanConfigParam(
	"thin_at_file_trees",self.thin_at_file_trees)
	
encoding = self.initConfigParam(
	"tk_encoding",self.tkEncoding)
	
if encoding and len(encoding) &gt; 0: # May be None.
	if isValidEncoding(encoding):
		self.tkEncoding = encoding
	else:
		es("bad tk_encoding: " + encoding)
	
self.use_plugins = self.initBooleanConfigParam(
	"use_plugins",self.use_plugins)</t>
<t tx="T641">section = self.recentFilesSection

if 0: # elegant, but may be a security hole.
	self.recentFiles = eval(config.get(section,"recentFiles",raw=1)) # 2/4/03
else: # easier to read in the config file.
	try:
		for i in xrange(10):
			self.recentFiles.append(config.get(section,"file" + `i`,raw=1)) # 2/4/03
	except: pass</t>
<t tx="T642">find = self.findDict.get("find_string")
if find:
	# Leo always writes utf-8 encoding, but users may not.
	find = toUnicode(find,"utf-8")
	self.findDict["find_string"] = find

change = self.findDict.get("change_string")
if change:
	# Leo always writes utf-8 encoding, but users may not.
	change = toUnicode(change,"utf-8")
	self.findDict["change_string"] = change
</t>
<t tx="T643">if 0:
	print "\n\ncolorsDict:\n" ,self.colorsDict
	print "\n\ncompareDict:\n",self.compareDict
	print "\n\nfindDict:\n"   ,self.findDict
	print "\n\nprefsDict:\n"  ,self.prefsDict
	print "\n\nwindowDict:\n" ,self.windowDict
if 0:
	print "\n\nkeysDict:\n\n"
	for i in self.keysDict.items():
		print i
if 0:
	print "\n\nwindowDict:\n\n"
	for i in self.windowDict.keys():
		print i</t>
<t tx="T644"># Rewrites the entire config file from ivars.
# This is called when a .leo file is written and when the preferences panel changes.

def update (self):
	
	# Do nothing if the file does not exist, or if read_only.
	if self.read_only:
		# print "Read only config file"
		return
	if not os.path.exists(self.configFileName):
		# print "No config file"
		return
	
	config = ConfigParser.ConfigParser()
	self.config = config
	try:
		# 9/1/02: apparently Linux requires w+ and XP requires w.
		mode = choose(sys.platform=="win32","wb","wb+")
		cf = open(self.configFileName,mode)
		config.readfp(cf)
		&lt;&lt; write recent files section &gt;&gt;
		for section,dict in self.sectionInfo:
			if dict:
				self.update_section(config,section,dict)
		config.write(cf)
		cf.flush()
		cf.close()
	except:
		es("exception writing: " + self.configFileName)
		es_exception()
	self.config = None</t>
<t tx="T645">section = self.recentFilesSection
files = self.recentFiles

if config.has_section(section):
	config.remove_section(section)
config.add_section(section)

if 0: # elegant, but may be a security hole.
	config.set(section,"recentFiles",files)
else: # easier to read in the config file.
	for i in xrange(len(files)):
		config.set(section, "file"+`i`, files[i])</t>
<t tx="T646">def update_section (self,config,section,dict):
	
	if config.has_section(section):
		config.remove_section(section)
	config.add_section(section)
	
	keys = dict.keys()
	keys.sort() # Not effective.
	for name in keys:
		val = dict [name]
		val = toEncodedString(val,"utf-8")
		config.set(section,name,val)
</t>
<t tx="T647">@language python

import leoDialog
from leoGlobals import *
import string,Tkinter

Tk = Tkinter

@others</t>
<t tx="T648"></t>
<t tx="T649"></t>
<t tx="T650"></t>
<t tx="T651"></t>
<t tx="T652"></t>
<t tx="T653"></t>
<t tx="T654"></t>
<t tx="T655"></t>
<t tx="T656"></t>
<t tx="T657"></t>
<t tx="T658"></t>
<t tx="T659"></t>
<t tx="T660"></t>
<t tx="T661"></t>
<t tx="T662"></t>
<t tx="T663"></t>
<t tx="T664"></t>
<t tx="T665"></t>
<t tx="T666"></t>
<t tx="T667"></t>
<t tx="T668"></t>
<t tx="T669"></t>
<t tx="T670"></t>
<t tx="T671"></t>
<t tx="T672"></t>
<t tx="T673"></t>
<t tx="T674"></t>
<t tx="T675"></t>
<t tx="T676"></t>
<t tx="T677"></t>
<t tx="T678"></t>
<t tx="T679"></t>
<t tx="T680"></t>
<t tx="T681"></t>
<t tx="T682"></t>
<t tx="T683"></t>
<t tx="T684"></t>
<t tx="T685"></t>
<t tx="T686"></t>
<t tx="T687"></t>
<t tx="T688"></t>
<t tx="T689">@language python

from leoGlobals import *
import leoDialog,leoNodes
import os,os.path,time

@ The list of language names that are written differently from the names in language_delims_dict in leoGlobals.py.  This is needed for compatibility with the borland version of Leo.

We convert from names in xml_language_names to names in language_delims_dict by converting the name to lowercase and by removing slashes.
@c

xml_language_names = (
	"CWEB","C","HTML","Java","LaTeX",
	"Pascal","PerlPod","Perl","Plain","Python","tcl/tk")

class BadLeoFile(Exception):
	def __init__(self, message):
		self.message = message
		Exception.__init__(self,message) # 4/26/03: initialize the base class.
	def __str__(self):
		return "Bad Leo File:" + self.message

class baseFileCommands:
	"""A base class for the fileCommands subcommander."""
	@others
	
class fileCommands (baseFileCommands):
	"""A class creating the fileCommands subcommander."""
	pass</t>
<t tx="T690">def __init__(self,commands):

	# trace("__init__", "fileCommands.__init__")
	self.commands = commands
	self.frame = commands.frame
	self.initIvars()

def initIvars(self):

	# General
	self.maxTnodeIndex = 0
	self.numberOfTnodes = 0
	self.topVnode = None
	self.mFileName = ""
	self.fileDate = -1
	self.leo_file_encoding = app().config.new_leo_file_encoding
	# For reading
	self.fileFormatNumber = 0
	self.ratio = 0.5
	self.fileBuffer = None ; self.fileIndex = 0
	# For writing
	self.read_only = false
	self.outputFile = None # File for normal writing
	self.outputString = None # String for pasting
	self.openDirectory = None
	self.usingClipboard = false
	# New in 3.12
	self.a = app()
	self.copiedTree = None
	self.tnodesDict = {}
</t>
<t tx="T691"></t>
<t tx="T692">def createVnode(self,parent,back,tref,headline):
	
	# trace(`headline` + ", parent:" + `parent` + ", back:" + `back`)
	v = None ; c = self.commands
	# Shared tnodes are placed in the file even if empty.
	if tref == -1:
		t = leoNodes.tnode()
	else:
		t = self.tnodesDict.get(tref)
		if not t:
			t = self.newTnode(tref)
	if back: # create v after back.
		v = back.insertAfter(t)
	elif parent: # create v as the parent's first child.
		v = parent.insertAsNthChild(0,t)
	else: # create a root vnode
		v = leoNodes.vnode(c,t)
		v.moveToRoot()
		c.tree.rootVnode = v
	v.initHeadString(headline,encoding=self.leo_file_encoding)
	return v</t>
<t tx="T693"># This method finishes pasting the outline from the clipboard.
def finishPaste(self):

	c=self.commands
	current = c.currentVnode()
	after = current.nodeAfterTree()
	c.beginUpdate()
	if 1: # inside update...
		if 0: # Warning: this will only join pasted clones, and is very dangerous.
			&lt;&lt; Create join lists of all pasted vnodes &gt;&gt;
		&lt;&lt; Recompute clone bits for pasted vnodes &gt;&gt;
		self.compactFileIndices()
		c.selectVnode(current)
	c.endUpdate()
	return current</t>
<t tx="T694">v = c.currentVnode()

while v and v != after:
	if v not in v.t.joinList:
		v.t.joinList.append(v)
	v = v.threadNext()
</t>
<t tx="T695">@ This must be done after the join lists have been created.  The saved clone bit is unreliable for pasted nodes.
@c

v = c.currentVnode()
while v and v != after:
	v.initClonedBit(v.shouldBeClone())
	v.clearDirty()
	v = v.threadNext()</t>
<t tx="T696"></t>
<t tx="T697"></t>
<t tx="T698">def getBool (self):
	self.skipWs() # guarantees at least one more character.
	ch = self.fileBuffer[self.fileIndex]
	if ch == '0':
		self.fileIndex += 1 ; return false
	elif ch == '1':
		self.fileIndex += 1 ; return true
	else:
		raise BadLeoFile("expecting bool constant")
		
def getDqBool (self):
	self.getDquote() ; val = self.getBool() ; self.getDquote()
	return val
	
def getDqString (self): # 7/10/02
	self.getDquote()
	i = self.fileIndex
	self.fileIndex = j = string.find(self.fileBuffer,'"',i)
	if j == -1: raise BadLeoFile("unterminated double quoted string")
	s = self.fileBuffer[i:j]
	self.getDquote()
	return s

def getDouble (self):
	self.skipWs()
	i = self.fileIndex ; buf = self.fileBuffer
	floatChars = string.digits + 'e' + 'E' + '.' + '+' + '-'
	n = len(buf)
	while i &lt; n and buf[i] in floatChars:
		i += 1
	if i == self.fileIndex:
		raise BadLeoFile("expecting float constant")
	val = float(buf[self.fileIndex:i])
	self.fileIndex = i
	return val

def getDquote (self):
	self.getTag('"')
	
def getIndex (self):
	val = self.getLong()
	if val &lt; 0: raise BadLeoFile("expecting index")
	return val
	
def getLong (self):
	self.skipWs() # guarantees at least one more character.
	i = self.fileIndex
	if self.fileBuffer[i] == '-':
		i += 1
	n = len(self.fileBuffer)
	while i &lt; n and self.fileBuffer[i] in string.digits:
		i += 1
	if i == self.fileIndex:
		raise BadLeoFile("expecting int constant")
	val = int(self.fileBuffer[self.fileIndex:i])
	self.fileIndex = i
	return val
		
def getStringToTag (self,tag):
	buf = self.fileBuffer
	blen = len(buf) ; tlen = len(tag)
	i = j = self.fileIndex
	while i &lt; blen:
		if tag == buf[i:i+tlen]:
			self.fileIndex = i
			return buf[j:i]
		else: i += 1
	raise BadLeoFile("expecting string terminated by " + tag)
	return ""
	
# Look ahead for collapsed tag: tag may or may not end in "&gt;"
# Skips tag and /&gt; if found, otherwise does not alter index.
def getOpenTag (self,tag):
	if tag[-1] == "&gt;":
		# Only the tag itself or a collapsed tag are valid.
		if self.matchTag(tag):
			return false # Not a collapsed tag.
		elif self.matchTag(tag[:-1]):
			# It must be a collapsed tag.
			self.skipWs()
			if self.matchTag("/&gt;"):
				return true
		print "getOpenTag(", tag, ") failed:"
		raise BadLeoFile("expecting" + tag)
	else:
		# The tag need not be followed by "/&gt;"
		if self.matchTag(tag):
			old_index = self.fileIndex
			self.skipWs()
			if self.matchTag("/&gt;"):
				return true
			else:
				self.fileIndex = old_index
				return false
		else:
			print "getOpenTag(", tag, ") failed:"
			raise BadLeoFile("expecting" + tag)
	
# 11/24/02: Look ahead for closing /&gt;
# Return true if found.
def getTag (self,tag):
	if self.matchTag(tag):
		return
	else:
		print "getTag(", tag, ") failed:"
		raise BadLeoFile("expecting" + tag)
</t>
<t tx="T699">def matchChar (self,ch):
	self.skipWs() # guarantees at least one more character.
	if ch == self.fileBuffer[self.fileIndex]:
		self.fileIndex += 1 ; return true
	else: return false

# Warning: does not check for end-of-word,
# so caller must match prefixes first.
def matchTag (self,tag):
	self.skipWsAndNl() # guarantees at least one more character.
	i = self.fileIndex
	if tag == self.fileBuffer[i:i+len(tag)]:
		self.fileIndex += len(tag)
		return true
	else:
		return false

def matchTagWordIgnoringCase (self,tag):
	self.skipWsAndNl() # guarantees at least one more character.
	i = self.fileIndex
	tag = string.lower(tag)
	j = skip_c_id(self.fileBuffer,i)
	word = self.fileBuffer[i:j]
	word = string.lower(word)
	if tag == word:
		self.fileIndex += len(tag)
		return true
	else:
		return false
</t>
<t tx="T700">def getClipboardHeader (self):

	if self.getOpenTag("&lt;leo_header"):
		return # 11/24/02

	while 1:
		if self.matchTag("file_format="):
			self.getDquote() ; self.fileFormatNumber = self.getLong() ; self.getDquote()
		elif self.matchTag("tnodes="):
			self.getDquote() ; self.getLong() ; self.getDquote() # no longer used
		elif self.matchTag("max_tnode_index="):
			self.getDquote() ; self.getLong() ; self.getDquote() # no longer used
		else:
			self.getTag("/&gt;")
			break</t>
<t tx="T701"># For compatibility with old file formats.

def getCloneWindows (self):

	if not self.matchTag("&lt;clone_windows&gt;"):
		return

	while self.matchTag("&lt;clone_window vtag=\"V"):
		self.getLong() ; self.getDquote() ; self.getTag("&gt;")
		if not self.getOpenTag("&lt;global_window_position"):
			self.getTag("&lt;global_window_position")
			self.getPosition()
			self.getTag("/&gt;")
		self.getTag("&lt;/clone_window&gt;")
	self.getTag("&lt;/clone_windows&gt;")</t>
<t tx="T702">def getEscapedString (self):

	# The next '&lt;' begins the ending tag.
	i = self.fileIndex
	self.fileIndex = j = string.find(self.fileBuffer,'&lt;',i)
	if j == -1:
		raise BadLeoFile("unterminated escaped string")
	else:
		# Allocates memory
		return self.xmlUnescape(self.fileBuffer[i:j])</t>
<t tx="T703">def getFindPanelSettings (self):

	c = self.commands ; config = app().config ; findFrame = app().findFrame
	&lt;&lt; Set defaults of all flags &gt;&gt;
	if not self.getOpenTag("&lt;find_panel_settings"):
		while 1:
			if   self.matchTag("batch="): c.batch_flag = self.getDqBool()
			elif self.matchTag("wrap="): c.wrap_flag = self.getDqBool()
			elif self.matchTag("whole_word="): c.whole_word_flag = self.getDqBool()
			elif self.matchTag("ignore_case="): c.ignore_case_flag = self.getDqBool()
			elif self.matchTag("pattern_match="): c.pattern_match_flag = self.getDqBool()
			elif self.matchTag("search_headline="): c.search_headline_flag = self.getDqBool()
			elif self.matchTag("search_body="): c.search_body_flag = self.getDqBool()
			elif self.matchTag("suboutline_only="): c.suboutline_only_flag = self.getDqBool()
			elif self.matchTag("mark_changes="): c.mark_changes_flag = self.getDqBool()
			elif self.matchTag("mark_finds="): c.mark_finds_flag = self.getDqBool()
			elif self.matchTag("reverse="): c.reverse_flag = self.getDqBool()
			elif self.matchTag("node_only="): c.node_only_flag = self.getDqBool()
			else: break
					
		self.getTag("&gt;")
		#
		self.getTag("&lt;find_string&gt;")
		c.find_text = self.getEscapedString()
		self.getTag("&lt;/find_string&gt;")
		#
		self.getTag("&lt;change_string&gt;")
		c.change_text = self.getEscapedString()
		self.getTag("&lt;/change_string&gt;")
		#
		self.getTag("&lt;/find_panel_settings&gt;")
	
	# Override .leo file's preferences if settings are in leoConfig.txt.
	config.setCommandsFindIvars(c)
	# Update the settings immediately.
	app().findFrame.init(c)</t>
<t tx="T704">for var in findFrame.intKeys:
	attr = "%s_flag" % (var)
	setattr(c,attr,false)
</t>
<t tx="T705">def getGlobals (self):

	if self.getOpenTag("&lt;globals"):
		return

	self.getTag("body_outline_ratio=\"")
	self.ratio = self.getDouble() ; self.getDquote() ; self.getTag("&gt;")

	self.getTag("&lt;global_window_position")
	y,x,h,w = self.getPosition() ; self.getTag("/&gt;")
	# print ("y,x,h,w:" + `y` + "," + `x` + "," + `h` + "," + `w`)
	
	# Bug fix: 7/15/02: use max, not min!!!
	y = max(y,0) ; x = max(x,0)
	geom = "%dx%d%+d%+d" % (w,h,x,y)
	self.frame.top.geometry(geom)
	# 7/15/02: Redraw the window before writing into it.
	self.frame.top.deiconify()
	self.frame.top.lift()
	self.frame.top.update()

	self.getTag("&lt;global_log_window_position")
	self.getPosition() ;
	self.getTag("/&gt;") # no longer used.

	self.getTag("&lt;/globals&gt;")</t>
<t tx="T706"># The caller should enclose this in begin/endUpdate.

def getLeoFile (self,frame,fileName,atFileNodesFlag=true):

	c=self.commands
	&lt;&lt; warn on read-only files &gt;&gt;
	self.mFileName = frame.mFileName
	self.tnodesDict = {}
	ok = true
	try:
		c.tree.initing = true # inhibit endEditLabel from marking the file changed.
		## import time ; start = time.clock()
		&lt;&lt; scan all the xml elements &gt;&gt;
		## print "read time" + "%6.3f" % (time.clock()-start)
	except BadLeoFile, message:
		&lt;&lt; raise an alert &gt;&gt;
		ok = false
	if ok and atFileNodesFlag:
		c.atFileCommands.readAll(c.rootVnode(),partialFlag=false)
	if not c.tree.currentVnode:
		c.tree.currentVnode = c.tree.rootVnode
	self.setAllJoinLinks() # 5/3/03
	c.initAllCloneBits() # 5/3/03
	c.selectVnode(c.tree.currentVnode) # load body pane
	c.tree.initing = false # Enable changes in endEditLabel
	self.tnodesDict = {}
	return ok, self.ratio</t>
<t tx="T707">try:
	self.read_only = false
	self.read_only = not os.access(fileName,os.W_OK)
	if self.read_only:
		es("read only: " + fileName,color="red")
		leoDialog.askOk("Read-only ouline",
			"Warning: the outline: " + fileName + " is read-only.").run(modal=true)
except:
	if 0: # testing only: access may not exist on all platforms.
		es("exception getting file access")
		es_exception()</t>
<t tx="T708">self.getXmlVersionTag()
self.getXmlStylesheetTag()
self.getTag("&lt;leo_file&gt;")
self.getLeoHeader()
self.getGlobals()
self.getPrefs()
self.getFindPanelSettings()

# Causes window to appear.
c.frame.resizePanesToRatio(c.frame.ratio,c.frame.secondary_ratio) 
es("reading: " + fileName)

self.getVnodes()
self.getTnodes()
self.getCloneWindows()
self.getTag("&lt;/leo_file&gt;")</t>
<t tx="T709"># All other exceptions are Leo bugs.

# es_exception()
alert(self.mFileName + " is not a valid Leo file: " + `message`)</t>
<t tx="T710">def getLeoHeader (self):

	# Set defaults.
	self.maxTnodeIndex = 0
	self.numberOfTnodes = 0
	if self.getOpenTag("&lt;leo_header"):
		return

	# New in version 1.7: attributes may appear in any order.
	while 1:
		if self.matchTag("file_format="):
			self.getDquote() ; self.fileFormatNumber = self.getLong() ; self.getDquote()
		elif self.matchTag("tnodes="):
			self.getDquote() ; self.numberOfTnodes = self.getLong() ; self.getDquote()
		elif self.matchTag("max_tnode_index="):
			self.getDquote() ; self.maxTnodeIndex = self.getLong() ; self.getDquote()
		elif self.matchTag("clone_windows="):
			self.getDquote() ; self.getLong() ; self.getDquote() # no longer used.
		else:
			self.getTag("/&gt;")
			break</t>
<t tx="T711"># This method reads a Leo outline from string s in clipboard format.
def getLeoOutline (self,s):

	self.usingClipboard = true
	self.fileBuffer = s ; self.fileIndex = 0
	self.tnodesDict = {}

	try:
		self.getXmlVersionTag() # leo.py 3.0
		self.getXmlStylesheetTag() # 10/25/02
		self.getTag("&lt;leo_file&gt;")
		self.getClipboardHeader()
		self.getVnodes()
		self.getTnodes()
		self.getTag("&lt;/leo_file&gt;")
		v = self.finishPaste()
	except BadLeoFile:
		v = None

	# Clean up.
	self.fileBuffer = None ; self.fileIndex = 0
	self.usingClipboard = false
	self.tnodesDict = {}
	return v</t>
<t tx="T712">def getPosition (self):

	top = left = height = width = 0
	# New in version 1.7: attributes may appear in any order.
	while 1:
		if self.matchTag("top=\""):
			top = self.getLong() ; self.getDquote()
		elif self.matchTag("left=\""):
			left = self.getLong() ; self.getDquote()
		elif self.matchTag("height=\""):
			height = self.getLong() ; self.getDquote()
		elif self.matchTag("width=\""):
			width = self.getLong() ; self.getDquote()
		else: break
	return top, left, height, width</t>
<t tx="T713">def getPrefs (self):

	a = app() ; c = self.commands ; config = a.config
	
	if self.getOpenTag("&lt;preferences"):
		return

	while 1:
		if self.matchTag("allow_rich_text="):
			self.getDquote() ; self.getBool() ; self.getDquote() #ignored
		elif self.matchTag("tab_width="):
			self.getDquote() ; c.tab_width = self.getLong() ; self.getDquote()
		elif self.matchTag("page_width="):
			self.getDquote() ; c.page_width = self.getLong() ; self.getDquote()
		elif self.matchTag("tangle_bat="):
			self.getDquote() ; c.tangle_batch_flag = self.getBool() ; self.getDquote()
		elif self.matchTag("untangle_bat="):
			self.getDquote() ; c.untangle_batch_flag = self.getBool() ; self.getDquote()
		# New in version 0.10
		elif self.matchTag("output_doc_chunks="):
			self.getDquote() ; c.output_doc_flag = self.getBool() ; self.getDquote()
		elif self.matchTag("noweb_flag="):
			# New in version 0.19: Ignore this flag.
			self.getDquote() ; self.getBool() ; self.getDquote()
		elif self.matchTag("extended_noweb_flag="):
			# New in version 0.19: Ignore this flag.
			self.getDquote() ; self.getBool() ; self.getDquote()
		elif self.matchTag("defaultTargetLanguage="):
			# New in version 0.15
			self.getDquote()
			&lt;&lt; check for syntax coloring prefs &gt;&gt;
		elif self.matchTag("use_header_flag="):
			self.getDquote() ; c.use_header_flag = self.getBool() ; self.getDquote()
		else: break
	self.getTag("&gt;")
	while 1:
		if self.matchTag("&lt;defaultDirectory&gt;"):
			# New in version 0.16.
			c.tangle_directory = self.getEscapedString()
			self.getTag("&lt;/defaultDirectory&gt;")
			if not os.path.exists(c.tangle_directory):
				es("default tangle directory not found:" + c.tangle_directory)
		elif self.matchTag("&lt;TSyntaxMemo_options&gt;"):
			self.getEscapedString() # ignored
			self.getTag("&lt;/TSyntaxMemo_options&gt;")
		else: break
	self.getTag("&lt;/preferences&gt;")
	
	# Override .leo file's preferences if settings are in leoConfig.txt.
	if config.configsExist:
		config.setCommandsIvars(c)</t>
<t tx="T714"># Must match longer tags before short prefixes.

language = "c" # default

for name in a.language_delims_dict.keys():
	if self.matchTagWordIgnoringCase(name):
		s = string.lower(name)
		language = string.replace(name,"/","")
		self.getDquote()
		break

c.target_language = language</t>
<t tx="T715">def getSize (self):

	# New in version 1.7: attributes may appear in any order.
	height = 0 ; width = 0
	while 1:
		if self.matchTag("height=\""):
			height = self.getLong() ; self.getDquote()
		elif self.matchTag("width=\""):
			width = self.getLong() ; self.getDquote()
		else: break
	return height, width</t>
<t tx="T716">def getTnode (self):

	# we have already matched &lt;t.
	index = -1
	# New in version 1.7: attributes may appear in any order.
	while 1:
		if self.matchTag("tx=\"T"):
			index = self.getIndex() ; self.getDquote()
			# if self.usingClipboard: trace(index)
		elif self.matchTag("rtf=\"1\""): pass # ignored
		elif self.matchTag("rtf=\"0\""): pass # ignored
		else: break
	self.getTag("&gt;")
	t = self.tnodesDict.get(index)
	if t:
		if self.usingClipboard:
			&lt;&lt; handle read from clipboard &gt;&gt;
		else:
			&lt;&lt; handle read from file &gt;&gt;
	else:
		es("no tnode with index: " + `index` + ".  The text will be discarded")
	self.getTag("&lt;/t&gt;")</t>
<t tx="T717">s = self.getEscapedString()
t.setTnodeText(s,encoding=self.leo_file_encoding)</t>
<t tx="T718">if t:
	s = self.getEscapedString()
	t.setTnodeText(s,encoding=self.leo_file_encoding)
	# trace(`index`,`len(s)`)</t>
<t tx="T719">def getTnodes (self):

	# A slight change: we require a tnode element.  But Leo always writes this.
	if self.getOpenTag("&lt;tnodes&gt;"):
		return
		
	while self.matchTag("&lt;t"):
		self.getTnode()
	self.getTag("&lt;/tnodes&gt;")
</t>
<t tx="T720">def getVnode (self,parent,back):

	# trace("parent:" + `parent` + ", back:" + `back`)
	c = self.commands
	setCurrent = setExpanded = setMarked = setOrphan = setTop = false
	tref = -1 ; headline = "" ; tnodeList = None
	# we have already matched &lt;v.
	while 1:
		if self.matchTag("a=\""):
			&lt;&lt; Handle vnode attribute bits &gt;&gt;
		elif self.matchTag("t=\"T"):
			tref = self.getIndex() ; self.getDquote()
		elif self.matchTag("vtag=\"V"):
			self.getIndex() ; self.getDquote() # ignored
		elif self.matchTag("tnodeList=\""):
			tnodeList = self.getTnodeList() # New for 4.0
		else: break
	self.getTag("&gt;")
	# Headlines are optional.
	if self.matchTag("&lt;vh&gt;"):
		headline = self.getEscapedString() ; self.getTag("&lt;/vh&gt;")
	# Link v into the outline using parent and back.
	v = self.createVnode(parent,back,tref,headline)
	if tnodeList:
		v.tnodeList = tnodeList # New for 4.0
		# trace("%4d" % len(tnodeList),v)
	&lt;&lt; Set the remembered status bits &gt;&gt;
	# Recursively create all nested nodes.
	parent = v ; back = None
	while self.matchTag("&lt;v"):
		back = self.getVnode(parent,back)
	# End this vnode.
	self.getTag("&lt;/v&gt;")
	return v</t>
<t tx="T721"># The a=" has already been seen.
while 1:
	if   self.matchChar('C'): pass # Not used: clone bits are recomputed later.
	elif self.matchChar('D'): pass # Not used.
	elif self.matchChar('E'): setExpanded = true
	elif self.matchChar('M'): setMarked = true
	elif self.matchChar('O'): setOrphan = true
	elif self.matchChar('T'): setTop = true
	elif self.matchChar('V'): setCurrent = true
	else: break
self.getDquote()</t>
<t tx="T722">if setCurrent:
	c.tree.currentVnode = v

if setExpanded:
	v.initExpandedBit()

if setMarked:
	v.setMarked()

if setOrphan:
	v.setOrphan()

if setTop:
	c.mTopVnode = v  # Not used at present.
</t>
<t tx="T723">def getTnodeList (self):

	"""Parse a list of tnode indices terminated by a double quote."""

	fc = self ; 
	
	if fc.matchChar('"'):
		return []

	indexList = []
	while 1:
		index = fc.getIndex()
		indexList.append(index)
		if fc.matchChar('"'):
			break
		else:
			fc.getTag(',')
			
	# Resolve all indices.
	tnodeList = []
	for index in indexList:
		t = fc.tnodesDict.get(index)
		if t == None:
			# Not an error: create a new tnode and put it in fc.tnodesDict.
			t = self.newTnode(index)
		tnodeList.append(t)
	return tnodeList</t>
<t tx="T724">def getVnodes (self):

	c=self.commands
	if  self.usingClipboard:
		# Paste after the current vnode.
		back = c.currentVnode() ; parent = back.parent()
	else:
		back = None ; parent = None

	if self.getOpenTag("&lt;vnodes&gt;"):
		return

	while self.matchTag("&lt;v"):
		back = self.getVnode(parent,back)

	self.getTag("&lt;/vnodes&gt;")</t>
<t tx="T725">@ Parses the optional xml stylesheet string, and sets the corresponding config option.

For example, given: &lt;?xml_stylesheet s?&gt;
the config option is s.
@c

def getXmlStylesheetTag (self):
	
	c = self.commands
	tag = "&lt;?xml-stylesheet "

	if self.matchTag(tag):
		s = self.getStringToTag("?&gt;")
		# print "reading:", tag + s + "?&gt;"
		c.frame.stylesheet = s
		self.getTag("?&gt;")
</t>
<t tx="T726"># Parses the encoding string, and sets self.leo_file_encoding.

def getXmlVersionTag (self):
	
	a = app() ; config = a.config

	self.getTag(a.prolog_prefix_string)
	encoding = self.getDqString()
	self.getTag(a.prolog_postfix_string)

	if isValidEncoding(encoding):
		self.leo_file_encoding = encoding
	else:
		es("invalid encoding in .leo file: " + encoding)
</t>
<t tx="T727">def skipWs (self):

	while self.fileIndex &lt; len(self.fileBuffer):
		ch = self.fileBuffer[self.fileIndex]
		if ch == ' ' or ch == '\t':
			self.fileIndex += 1
		else: break

	# The caller is entitled to get the next character.
	if  self.fileIndex &gt;= len(self.fileBuffer):
		raise BadLeoFile("")</t>
<t tx="T728">def skipWsAndNl (self):

	while self.fileIndex &lt; len(self.fileBuffer):
		ch = self.fileBuffer[self.fileIndex]
		if ch == ' ' or ch == '\t' or ch == '\r' or ch == '\n':
			self.fileIndex += 1
		else: break

	# The caller is entitled to get the next character.
	if  self.fileIndex &gt;= len(self.fileBuffer):
		raise BadLeoFile("")</t>
<t tx="T729">def newTnode(self,index):

	if self.tnodesDict.has_key(index):
		es("bad tnode index: " + `index` + ". Using empty text.")
		return leoNodes.tnode()
	else:
		t = leoNodes.tnode()
		t.setFileIndex(index)
		self.tnodesDict[index] = t
		return t</t>
<t tx="T730">def readAtFileNodes (self):

	c = self.commands ; current = c.currentVnode()
	c.atFileCommands.readAll(current,partialFlag=true)
	self.setAllJoinLinks(current) # 5/3/03
	c.initAllCloneBits() # 5/3/03
	c.redraw() # 4/4/03
	
	# 7/8/03: force an update of the body pane.
	current.setBodyStringOrPane(current.bodyString())
	c.tree.onBodyChanged(current,undoType=None)</t>
<t tx="T731">def readOutlineOnly (self,file,fileName):

	c=self.commands
	# Read the entire file into the buffer
	self.fileBuffer = file.read() ; file.close()
	self.fileIndex = 0
	&lt;&lt; Set the default directory &gt;&gt;
	c.beginUpdate()
	ok, ratio = self.getLeoFile(self.frame,fileName,atFileNodesFlag=false)
	c.endUpdate()
	c.frame.top.deiconify()
	c.setChanged(false)
	vflag,junk,secondary_ratio = self.frame.initialRatios()
	c.frame.resizePanesToRatio(ratio,secondary_ratio)
	# This should be done after the pane size has been set.
	if 0: # This can not be done at present.
		if self.topVnode:
			c.tree.scrollTo(self.topVnode)
			c.tree.Refresh()
	# delete the file buffer
	self.fileBuffer = ""
	return ok</t>
<t tx="T732">@ The most natural default directory is the directory containing the .leo file that we are about to open.  If the user has specified the "Default Directory" preference that will over-ride what we are about to set.
@c

dir = os.path.dirname(fileName) 
if len(dir) &gt; 0:
	c.openDirectory = dir</t>
<t tx="T733">def open(self,file,fileName):

	c=self.commands
	# Read the entire file into the buffer
	# t = getTime()
	self.fileBuffer = file.read() ; file.close()
	self.fileIndex = 0
	&lt;&lt; Set the default directory &gt;&gt;
	# esDiffTime("open:read all", t)

	c.beginUpdate()
	if 1: # inside update...
		c.loading = true # disable c.changed
		ok, ratio = self.getLeoFile(self.frame,fileName,atFileNodesFlag=true)
		c.loading = false # reenable c.changed
		c.setChanged(false)
		if 0: # This can't be done directly.
			# This should be done after the pane size has been set.
			top = c.tree.topVnode
			if top: c.tree.scrollTo(top)
	c.endUpdate()
	# delete the file buffer
	self.fileBuffer = ""
	# esDiffTime("open: exit",t)
	return ok</t>
<t tx="T734">def setAllJoinLinks (self,root=None):
	
	"""Update all join links in the tree"""
	
	# trace(root)

	if root: # Only update the subtree.
		v = root # 6/3/03
		after = root.nodeAfterTree()
		while v and v != after:
			if v not in v.t.joinList:
				v.t.joinList.append(v)
			v = v.threadNext()
	else: # Update everything.
		v = self.commands.rootVnode()
		while v:
			if v not in v.t.joinList:
				v.t.joinList.append(v)
			v = v.threadNext()</t>
<t tx="T735">def xmlUnescape(self,s):

	if s:
		s = string.replace(s, '\r', '')
		s = string.replace(s, "&amp;lt;", '&lt;')
		s = string.replace(s, "&amp;gt;", '&gt;')
		s = string.replace(s, "&amp;amp;", '&amp;')
	return s</t>
<t tx="T736"></t>
<t tx="T737">def assignFileIndices (self,root=None):
	
	"""Assign a file index to all tnodes"""
	
	c=self.commands
	
	if root == None:
		root = c.rootVnode()
	v = root
	while v:
		t = v.t

		# 8/28/99.  Write shared tnodes even if they are empty.
		if t.hasBody() or len(v.t.joinList) &gt; 0:
			if t.fileIndex == 0:
				self.maxTnodeIndex += 1
				t.setFileIndex(self.maxTnodeIndex)
		else:
			t.setFileIndex(0)
			
		# if self.usingClipboard: trace(t.fileIndex)
		v = v.threadNext()</t>
<t tx="T738">def compactFileIndices (self):
	
	"""Assign a file index to all tnodes, compacting all file indices"""
	
	c = self.commands ; root = c.rootVnode()
	
	v = root
	self.maxTnodeIndex = 0
	while v: # Clear all indices.
		v.t.setFileIndex(0)
		v = v.threadNext()

	v = c.rootVnode()
	while v: # Set indices for all tnodes that will be written.
		t = v.t
		if t.hasBody() or len(v.t.joinList) &gt; 0: # Write shared tnodes even if they are empty.
			if t.fileIndex == 0:
				self.maxTnodeIndex += 1
				t.setFileIndex(self.maxTnodeIndex)
		v = v.threadNext()</t>
<t tx="T739"></t>
<t tx="T740">def putClipboardHeader (self):

	tnodes = 0
	&lt;&lt; count the number of tnodes &gt;&gt;
	self.put('&lt;leo_header file_format="1" tnodes=')
	self.put_in_dquotes(`tnodes`)
	self.put(" max_tnode_index=")
	self.put_in_dquotes(`tnodes`)
	self.put("/&gt;") ; self.put_nl()</t>
<t tx="T741">c=self.commands
c.clearAllVisited()

# Count the vnode and tnodes.
v = c.currentVnode()
after = v.nodeAfterTree()
while v and v != after:
	t = v.t
	if t and not t.isVisited() and (t.hasBody() or len(v.t.joinList) &gt; 0):
		t.setVisited()
		tnodes += 1
	v = v.threadNext()</t>
<t tx="T742"># All output eventually comes here.
def put (self,s):
	if s and len(s) &gt; 0:
		if self.outputFile:
			s = toEncodedString(s,self.leo_file_encoding,reportErrors=true)
			self.outputFile.write(s)
		elif self.outputString != None: # Write to a string
			self.outputString += s

def put_dquote (self):
	self.put('"')
		
def put_dquoted_bool (self,b):
	if b: self.put('"1"')
	else: self.put('"0"')
		
def put_flag (self,a,b):
	if a:
		self.put(" ") ; self.put(b) ; self.put('="1"')
		
def put_in_dquotes (self,a):
	self.put('"')
	if a: self.put(a) # will always be true if we use backquotes.
	else: self.put('0')
	self.put('"')

def put_nl (self):
	self.put("\n")
	
def put_tab (self):
	self.put("\t")
	
def put_tabs (self,n):
	while n &gt; 0:
		self.put("\t")
		n -= 1</t>
<t tx="T743">@ Surprisingly, the call to xmlEscape here is _much_ faster than calling put for each characters of s.
@c

def putEscapedString (self,s):

	if s and len(s) &gt; 0:
		self.put(self.xmlEscape(s))</t>
<t tx="T744">def putFindSettings (self):

	c = self.commands ; config = app().config

	self.put("&lt;find_panel_settings")
	
	&lt;&lt; put find settings that may exist in leoConfig.txt &gt;&gt;
	
	self.put("&lt;/find_panel_settings&gt;") ; self.put_nl()</t>
<t tx="T745">if config.configsExist and not config.read_only: # 8/6/02
	pass # config.update has already been called.
else:
	self.put_flag(c.batch_flag,"batch")
	self.put_flag(c.ignore_case_flag,"ignore_case")
	self.put_flag(c.mark_changes_flag,"mark_changes")
	self.put_flag(c.mark_finds_flag,"mark_finds")
	self.put_flag(c.pattern_match_flag,"pattern_match")
	self.put_flag(c.reverse_flag,"reverse")
	self.put_flag(c.search_headline_flag,"search_headline")
	self.put_flag(c.search_body_flag,"search_body")
	self.put_flag(c.suboutline_only_flag,"suboutline_only")
	self.put_flag(c.whole_word_flag,"whole_word")
	self.put_flag(c.wrap_flag,"wrap")
	self.put_flag(c.node_only_flag,"node_only")

self.put("&gt;") ; self.put_nl()

if config.configsExist and not config.read_only: # 8/6/02
	self.put_tab()
	self.put("&lt;find_string&gt;&lt;/find_string&gt;") ; self.put_nl()
else:
	self.put_tab()
	self.put("&lt;find_string&gt;") ; self.putEscapedString(c.find_text)
	self.put("&lt;/find_string&gt;") ; self.put_nl()

if config.configsExist and not config.read_only: # 8/6/02
	self.put_tab()
	self.put("&lt;change_string&gt;&lt;/change_string&gt;") ; self.put_nl()
else:
	self.put_tab()
	self.put("&lt;change_string&gt;") ; self.putEscapedString(c.change_text)
	self.put("&lt;/change_string&gt;") ; self.put_nl()</t>
<t tx="T746">def putGlobals (self):

	c=self.commands
	self.put("&lt;globals")
	&lt;&lt; put the body/outline ratio &gt;&gt;
	self.put("&gt;") ; self.put_nl()
	&lt;&lt; put the position of this frame &gt;&gt;
	&lt;&lt; put the position of the log window &gt;&gt;

	self.put("&lt;/globals&gt;") ; self.put_nl()</t>
<t tx="T747"># Puts an innumerate number of digits

self.put(" body_outline_ratio=") ; self.put_in_dquotes(`c.frame.ratio`)</t>
<t tx="T748">width,height,left,top = get_window_info(self.frame.top)
#print ("t,l,h,w:" + `top` + ":" + `left` + ":" + `height` + ":" + `width`)

self.put_tab()
self.put("&lt;global_window_position")
self.put(" top=") ; self.put_in_dquotes(`top`)
self.put(" left=") ; self.put_in_dquotes(`left`)
self.put(" height=") ; self.put_in_dquotes(`height`)
self.put(" width=") ; self.put_in_dquotes(`width`)
self.put("/&gt;") ; self.put_nl()</t>
<t tx="T749">top = left = height = width = 0 # no longer used
self.put_tab()
self.put("&lt;global_log_window_position")
self.put(" top=") ; self.put_in_dquotes(`top`)
self.put(" left=") ; self.put_in_dquotes(`left`)
self.put(" height=") ; self.put_in_dquotes(`height`)
self.put(" width=") ; self.put_in_dquotes(`width`)
self.put("/&gt;") ; self.put_nl()</t>
<t tx="T750">def putHeader (self):

	tnodes = 0 ; clone_windows = 0 # Always zero in Leo2.

	self.put("&lt;leo_header")
	self.put(" file_format=") ; self.put_in_dquotes("2")
	self.put(" tnodes=") ; self.put_in_dquotes(`tnodes`)
	self.put(" max_tnode_index=") ; self.put_in_dquotes(`self.maxTnodeIndex`)
	self.put(" clone_windows=") ; self.put_in_dquotes(`clone_windows`)
	self.put("/&gt;") ; self.put_nl()</t>
<t tx="T751"># Writes a Leo outline to s in a format suitable for pasting to the clipboard.

def putLeoOutline (self):

	self.outputString = "" ; self.outputFile = None
	self.usingClipboard = true
	self.assignFileIndices() # 6/11/03: Must do this for 3.x code.
	self.putProlog()
	self.putClipboardHeader()
	self.putVnodes()
	self.putTnodes()
	self.putPostlog()
	s = self.outputString
	self.outputString = None
	self.usingClipboard = false
	return s</t>
<t tx="T752">def putPrefs (self):

	c = self.commands ; config = app().config

	self.put("&lt;preferences")
	self.put(" allow_rich_text=") ; self.put_dquoted_bool(0) # no longer used
	
	&lt;&lt; put prefs that may exist in leoConfig.txt &gt;&gt;
	
	self.put("&lt;/preferences&gt;") ; self.put_nl()</t>
<t tx="T753">language = c.target_language
for name in xml_language_names:
	s = string.lower(name)
	s = string.replace(s,"/","")
	if s == language:
		language = name ; break

if config.configsExist and not config.read_only: # 8/6/02
	pass # config.update has already been called.
else:
	self.put(" tab_width=") ; self.put_in_dquotes(`c.tab_width`)
	self.put(" page_width=") ; self.put_in_dquotes(`c.page_width`)
	self.put(" tangle_bat=") ; self.put_dquoted_bool(c.tangle_batch_flag)
	self.put(" untangle_bat=") ; self.put_dquoted_bool(c.untangle_batch_flag)
	self.put(" output_doc_chunks=") ; self.put_dquoted_bool(c.output_doc_flag)
	self.put(" use_header_flag=") ; self.put_dquoted_bool(c.use_header_flag)
	self.put(" defaultTargetLanguage=") ; self.put_in_dquotes(language) # 10/11/02: fix reversion.

self.put("&gt;") ; self.put_nl()
# New in version 0.16
&lt;&lt; put default directory &gt;&gt;</t>
<t tx="T754">if config.configsExist:
	pass # Has been done earlier.
elif len(c.tangle_directory) &gt; 0:
	self.put_tab()
	self.put("&lt;defaultDirectory&gt;")
	self.putEscapedString(c.tangle_directory)
	self.put("&lt;/defaultDirectory&gt;")
	self.put_nl()</t>
<t tx="T755">def putProlog (self):

	a = app() ; c = self.commands ; config = a.config

	&lt;&lt; Put the &lt;?xml...?&gt; line &gt;&gt;
	&lt;&lt; Put the optional &lt;?xml-stylesheet...?&gt; line &gt;&gt;

	self.put("&lt;leo_file&gt;") ; self.put_nl()</t>
<t tx="T756"># 1/22/03: use self.leo_file_encoding encoding.
self.put(a.prolog_prefix_string)
self.put_dquote() ; self.put(self.leo_file_encoding) ; self.put_dquote()
self.put(a.prolog_postfix_string) ; self.put_nl()</t>
<t tx="T757">if config.stylesheet or c.frame.stylesheet:
	
	# The stylesheet in the .leo file takes precedence over the default stylesheet.
	if c.frame.stylesheet:
		s = c.frame.stylesheet
	else:
		s = config.stylesheet
		
	tag = "&lt;?xml-stylesheet "
	# print "writing:", tag + s + "?&gt;"
	self.put(tag) ; self.put(s) ; self.put("?&gt;") ; self.put_nl()
</t>
<t tx="T758">def putPostlog (self):

	self.put("&lt;/leo_file&gt;") ; self.put_nl()</t>
<t tx="T759">def putTnodes (self):
	
	"""Puts all tnodes as required for copy or save commands"""

	c=self.commands
	if self.usingClipboard: # write the current tree.
		v = c.currentVnode() ; after = v.nodeAfterTree()
	else: # write everything
		v = c.rootVnode() ; after = None

	self.put("&lt;tnodes&gt;") ; self.put_nl()
	&lt;&lt; write only those tnodes that were referenced &gt;&gt;
	self.put("&lt;/tnodes&gt;") ; self.put_nl()</t>
<t tx="T760"># Populate tnodes
tnodes = {}
while v and v != after:
	index = v.t.fileIndex
	if index &gt; 0 and not tnodes.has_key(index):
		tnodes[index] = v.t
	v = v.threadNext()

# Put all tnodes in index order.
keys = tnodes.keys() ; keys.sort()
for index in keys:
	t = tnodes[index]
	assert(t)
	# Write only those tnodes whose vnodes were written.
	if t.isVisited(): self.putTnode(t)</t>
<t tx="T761">def putTnode (self,t):
	
	# if self.usingClipboard: trace(t.fileIndex)

	self.put("&lt;t")
	self.put(" tx=") ; self.put_in_dquotes("T" + `t.fileIndex`)
	self.put("&gt;")

	if t.bodyString and len(t.bodyString) &gt; 0:
		self.putEscapedString(t.bodyString)

	self.put("&lt;/t&gt;") ; self.put_nl()</t>
<t tx="T762">@ This method puts all vnodes by starting the recursion.  putVnode will write all vnodes in the order in which they appear in the outline.
@c
def putVnodes (self):

	c=self.commands
	c.clearAllVisited()

	self.put("&lt;vnodes&gt;") ; self.put_nl()
	if self.usingClipboard:
		self.putVnode(
			c.currentVnode(), # Write only current tree.
			None) # Don't write top vnode status bit.
	else: 
		v = c.rootVnode()
		while v:
			self.putVnode(
				v, # Write the next top-level node.
				c.tree.topVnode) # Write the top-vnode status bit.
			v = v.next()
	self.put("&lt;/vnodes&gt;") ; self.put_nl()</t>
<t tx="T763">@ This writes full headline and body text for all vnodes, even orphan and @ignored nodes.  This allows all Leo outlines to be used as backup files.
@c

def putVnode (self,v,topVnode):

	c = self.commands
	self.put("&lt;v")
	&lt;&lt; Put tnode index if this vnode has body text &gt;&gt;
	&lt;&lt; Put attribute bits &gt;&gt;
	self.put("&gt;")
	&lt;&lt; write the head text &gt;&gt;
	child = v.firstChild()
	if child:
		self.put_nl()
		while child:
			self.putVnode(child,topVnode)
			child = child.next()
	self.put("&lt;/v&gt;") ; self.put_nl()</t>
<t tx="T764">t = v.t
if t and (t.hasBody() or len(v.t.joinList) &gt; 0):
	if t.fileIndex &gt; 0:
		self.put(" t=") ; self.put_in_dquotes("T" + `t.fileIndex`)
		v.t.setVisited() # Indicate we wrote the body text.
	else:
		es("error writing file(bad vnode)!")
		es("try using the Save To command")</t>
<t tx="T765"># Dummy vnodes carry all attributes.
current = c.currentVnode()
top = topVnode
if ( v.isCloned() or v.isExpanded() or v.isMarked() or
	v == current or v == top ):
	self.put(" a=") ; self.put_dquote()
	if v.isCloned(): self.put("C")
	if v.isExpanded(): self.put("E")
	if v.isMarked(): self.put("M")
	if v.isOrphan(): self.put("O")
	if v == top: self.put("T")
	if v == current: self.put("V")
	self.put_dquote()</t>
<t tx="T766">headString = v.headString()
if len(headString) &gt; 0:
	self.put("&lt;vh&gt;")
	self.putEscapedString(headString)
	self.put("&lt;/vh&gt;")</t>
<t tx="T767">def save(self,fileName):

	c = self.commands ; v = c.currentVnode()

	if not doHook("save1",c=c,v=v,fileName=fileName):
		c.beginUpdate()
		c.endEditing()# Set the current headline text.
		self.compactFileIndices()
		self.setDefaultDirectoryForNewFiles(fileName)
		if self.write_LEO_file(fileName,false): # outlineOnlyFlag
			c.setChanged(false) # Clears all dirty bits.
			es("saved: " + shortFileName(fileName))
			if app().config.save_clears_undo_buffer:
				es("clearing undo")
				c.undoer.clearUndoState()
		c.endUpdate()
	doHook("save2",c=c,v=v,fileName=fileName)</t>
<t tx="T768">def saveAs(self,fileName):

	c = self.commands ; v = c.currentVnode()

	if not doHook("save1",c=c,v=v,fileName=fileName):
		c.beginUpdate()
		c.endEditing() # Set the current headline text.
		self.compactFileIndices()
		self.setDefaultDirectoryForNewFiles(fileName)
		if self.write_LEO_file(fileName,false): # outlineOnlyFlag
			c.setChanged(false) # Clears all dirty bits.
			es("saved: " + shortFileName(fileName))
		c.endUpdate()
	doHook("save2",c=c,v=v,fileName=fileName)
</t>
<t tx="T769">def saveTo (self,fileName):

	c = self.commands ; v = c.currentVnode()

	if not doHook("save1",c=c,v=v,fileName=fileName):
		c.beginUpdate()
		c.endEditing()# Set the current headline text.
		self.compactFileIndices()
		self.setDefaultDirectoryForNewFiles(fileName)
		if self.write_LEO_file(fileName,false): # outlineOnlyFlag
			es("saved: " + shortFileName(fileName))
		c.endUpdate()
	doHook("save2",c=c,v=v,fileName=fileName)
</t>
<t tx="T770">def setDefaultDirectoryForNewFiles (self,fileName):
	
	"""Set c.openDirectory for new files for the benefit of leoAtFile.scanAllDirectives."""
	
	c = self.commands

	if not c.openDirectory or len(c.openDirectory) == 0:
		dir = os.path.dirname(fileName)
		if len(dir) &gt; 0 and os.path.isabs(dir) and os.path.exists(dir):
			c.openDirectory = dir</t>
<t tx="T771"># Surprisingly, this is a time critical routine.

def xmlEscape(self,s):

	assert(s and len(s) &gt; 0) # check is made in putEscapedString
	s = string.replace(s, '\r', '')
	s = string.replace(s, '&amp;', "&amp;amp;")
	s = string.replace(s, '&lt;', "&amp;lt;")
	s = string.replace(s, '&gt;', "&amp;gt;")
	return s</t>
<t tx="T772">def writeAtFileNodes (self):

	self.commands.atFileCommands.writeAll(writeAtFileNodesFlag=true)</t>
<t tx="T773">def writeDirtyAtFileNodes (self): # fileCommands

	"""The Write Dirty @file Nodes command"""

	self.commands.atFileCommands.writeAll(writeDirtyAtFileNodesFlag=true)</t>
<t tx="T774">def writeMissingAtFileNodes (self):

	c = self.commands ; v = c.currentVnode()
	if v:
		at = c.atFileCommands
		at.writeMissing(v)</t>
<t tx="T775">def writeOutlineOnly (self):

	c=self.commands
	c.endEditing()
	self.compactFileIndices()
	self.write_LEO_file(self.mFileName,true) # outlineOnlyFlag</t>
<t tx="T776">def write_LEO_file(self,fileName,outlineOnlyFlag):

	c=self.commands ; config = app().config

	if not outlineOnlyFlag:
		try:
			# Leo2: write all @file nodes and set orphan bits.
			at = c.atFileCommands
			at.writeAll()
		except:
			es_error("exception writing derived files")
			es_exception()
			return false
			
	if self.read_only:
		es_error("read only: " + fileName)
		return false

	try:
		&lt;&lt; create backup file &gt;&gt;
		self.mFileName = fileName
		self.outputFile = open(fileName, 'wb') # 9/18/02
		if not self.outputFile:
			es("can not open " + fileName)
			&lt;&lt; delete backup file &gt;&gt;
			return false
		
		# 8/6/02: Update leoConfig.txt completely here.
		c.setIvarsFromFind()
		config.setConfigFindIvars(c)
		c.setIvarsFromPrefs()
		config.setCommandsIvars(c)
		config.update()
		
		self.putProlog()
		self.putHeader()
		self.putGlobals()
		self.putPrefs()
		self.putFindSettings()
		self.putVnodes()
		self.putTnodes()
		self.putPostlog()
		# raise BadLeoFile # testing
	except:
		es("exception writing: " + fileName)
		es_exception() 
		if self.outputFile:
			try:
				self.outputFile.close()
				self.outputFile = None
			except:
				es("exception closing: " + fileName)
				es_exception()
		&lt;&lt; erase filename and rename backupName to fileName &gt;&gt;
		return false

	if self.outputFile:
		try:
			self.outputFile.close()
			self.outputFile = None
		except:
			es("exception closing: " + fileName)
			es_exception()
		&lt;&lt; delete backup file &gt;&gt;
		return true
	else: # This probably will never happen because errors should raise exceptions.
		&lt;&lt; erase filename and rename backupName to fileName &gt;&gt;
		return false</t>
<t tx="T777"># rename fileName to fileName.bak if fileName exists.
if os.path.exists(fileName):
	try:
		backupName = os.path.join(app().loadDir,fileName)
		backupName = fileName + ".bak"
		if os.path.exists(backupName):
			os.unlink(backupName)
		# os.rename(fileName,backupName)
		utils_rename(fileName,backupName)
	except:
		es("exception creating " + backupName)
		es_exception()
		backupName = None
else:
	backupName = None</t>
<t tx="T778">if backupName and os.path.exists(backupName):
	try:
		os.unlink(backupName)
	except:
		es("exception deleting " + backupName)
		es_exception()
</t>
<t tx="T779">es("error writing " + fileName)

if fileName and os.path.exists(fileName):
	try:
		os.unlink(fileName)
	except:
		es("exception deleting " + fileName)
		es_exception()
		
if backupName:
	es("restoring " + fileName + " from " + backupName)
	try:
		# os.rename(backupName, fileName)
		utils_rename(backupName, fileName)
	except:
		es("exception renaming " + backupName + " to " + fileName)
		es_exception()
</t>
<t tx="T780">@language python

&lt;&lt; Theory of operation of find/change &gt;&gt;

from leoGlobals import *
import leoDialog
import string,sys,Tkinter,types
Tk=Tkinter

@others</t>
<t tx="T781">@ The find and change commands are tricky; there are many details that must be handled properly. This documentation describes the leo.py code. Previous versions of Leo used an inferior scheme.  The following principles govern the leoFind class:

1.	Find and Change commands initialize themselves using only the state of the present Leo window. In particular, the Find class must not save internal state information from one invocation to the next. This means that when the user changes the nodes, or selects new text in headline or body text, those changes will affect the next invocation of any Find or Change command. Failure to follow this principle caused all kinds of problems in the Borland and Macintosh codes. There is one exception to this rule: we must remember where interactive wrapped searches start. This principle simplifies the code because most ivars do not persist. However, each command must ensure that the Leo window is left in a state suitable for restarting the incremental (interactive) Find and Change commands. Details of initialization are discussed below.

2. The Find and Change commands must not change the state of the outline or body pane during execution. That would cause severe flashing and slow down the commands a great deal. In particular, c.selectVnode and c.editVnode methods must not be called while looking for matches.

3. When incremental Find or Change commands succeed they must leave the Leo window in the proper state to execute another incremental command. We restore the Leo window as it was on entry whenever an incremental search fails and after any Find All and Change All command.

Initialization involves setting the self.c, self.v, self.in_headline, self.wrapping and self.s_text ivars. Setting self.in_headline is tricky; we must be sure to retain the state of the outline pane until initialization is complete. Initializing the Find All and Change All commands is much easier because such initialization does not depend on the state of the Leo window.

Using Tk.Text widgets for both headlines and body text results in a huge simplification of the code. Indeed, the searching code does not know whether it is searching headline or body text. The search code knows only that self.s_text is a Tk.Text widget that contains the text to be searched or changed and the insert and sel Tk attributes of self.search_text indicate the range of text to be searched. Searching headline and body text simultaneously is complicated. The selectNextVnode() method handles the many details involved by setting self.s_text and its insert and sel attributes.
</t>
<t tx="T782"></t>
<t tx="T783"></t>
<t tx="T784"></t>
<t tx="T785"></t>
<t tx="T786"></t>
<t tx="T787"></t>
<t tx="T788"></t>
<t tx="T789"></t>
<t tx="T790"></t>
<t tx="T791"></t>
<t tx="T792"></t>
<t tx="T793"></t>
<t tx="T794"></t>
<t tx="T795"></t>
<t tx="T796"></t>
<t tx="T797"></t>
<t tx="T798"></t>
<t tx="T799"></t>
<t tx="T800"></t>
<t tx="T801"></t>
<t tx="T802"></t>
<t tx="T803"></t>
<t tx="T804"></t>
<t tx="T805"></t>
<t tx="T806"></t>
<t tx="T807"></t>
<t tx="T808"></t>
<t tx="T809"></t>
<t tx="T810"></t>
<t tx="T811"></t>
<t tx="T812"></t>
<t tx="T813"></t>
<t tx="T814"></t>
<t tx="T815"></t>
<t tx="T816"></t>
<t tx="T817"></t>
<t tx="T818"></t>
<t tx="T819"></t>
<t tx="T820"></t>
<t tx="T821"></t>
<t tx="T822"></t>
<t tx="T823"></t>
<t tx="T824"></t>
<t tx="T825"></t>
<t tx="T826"></t>
<t tx="T827"></t>
<t tx="T828"></t>
<t tx="T829"></t>
<t tx="T830"></t>
<t tx="T831"></t>
<t tx="T832"></t>
<t tx="T833"></t>
<t tx="T834"></t>
<t tx="T835">@language python

from leoGlobals import *
import exceptions,sys,string,Tkinter,tkFont

class baseLeoFontPanel:
	"""The base class for Leo's font panel."""
	@others
	
class leoFontPanel (baseLeoFontPanel):
	"""A class that creates Leo's font panel."""
	pass</t>
<t tx="T836"></t>
<t tx="T837">def __init__ (self,c):
	
	Tk = Tkinter
	self.commands = c
	self.frame = c.frame
	self.default_font = "Courier"
	self.last_selected_font = None
	self.setRevertVars()
	# Variables to track values of style checkboxes.
	self.sizeVar = Tk.IntVar()
	self.boldVar = Tk.IntVar()
	self.italVar = Tk.IntVar()
	# Variables to track values of pane checkboxes.
	self.bodyVar = Tk.IntVar()
	self.logVar = Tk.IntVar()
	self.treeVar = Tk.IntVar()
	# Slots for callbacks
	self.listBoxIndex = 0
	self.family_list_box = None
	self.size_entry = None
	self.example_entry = None
	self.outer = None</t>
<t tx="T838">def create_outer(self):

	Tk = Tkinter
	top = self.top
	&lt;&lt; Create the organizer frames &gt;&gt;
	&lt;&lt; create the font pane &gt;&gt;
	&lt;&lt; create the checkboxes &gt;&gt;
	&lt;&lt; create the buttons &gt;&gt;</t>
<t tx="T839">self.outer = outer = Tk.Frame(top,bd=2,relief="groove",width="8i")
outer.pack(padx=2,pady=2,expand=1,fill="both")

upper = Tk.Frame(outer)
upper.pack(fill="both",expand=1)

lt = Tk.Frame(upper)
lt.pack(side="left",fill="both",expand=1)

rt = Tk.Frame(upper)
rt.pack(side="right",anchor="n",padx=4) # Not filling or expanding centers contents.

# Not filling or expanding centers contents.
# padx=20 gives more room to the Listbox in the lt frame!
lower = Tk.Frame(outer)
lower.pack(side="top",anchor="w",padx=20)</t>
<t tx="T840"># Create the list box and its scrollbar.
self.family_list_box = box = Tk.Listbox(lt,height=7)

# Fill the listbox to set the width.
names = tkFont.families()
names = list(names)
names.sort()
for name in names:
	box.insert("end", name)

box.pack(padx=4,pady=4,fill="both",expand=1)
box.bind("&lt;Double-Button-1&gt;", self.update)

bar = Tk.Scrollbar(box)
bar.pack(side="right", fill="y")

bar.config(command=box.yview)
box.config(yscrollcommand=bar.set)</t>
<t tx="T841"># Create the style checkboxes.
for text,var in (
	("Bold",self.boldVar),
	("Italic",self.italVar)):

	b = Tk.Checkbutton(rt,text=text,variable=var)
	b.pack(side="top",anchor="w")

# Create the size label and entry widget.
row = Tk.Frame(rt)
row.pack(side="top")

lab = Tk.Label(row,text="Size:")
lab.pack(side="left")

self.size_entry = e = Tk.Entry(row,width=4)
e.pack(side="left")
e.bind("&lt;Key&gt;",self.onSizeEntryKey)

# Create the pane checkboxes.
for text,var in (
	("Body",   self.bodyVar),
	("Outline",self.treeVar,),
	("Log",    self.logVar)):

	b = Tk.Checkbutton(rt,text=text,variable=var)
	b.pack(side="top",anchor="w")</t>
<t tx="T842">for name,command in (
	("Apply",self.onApply),
	("OK",self.onOk),
	("Cancel",self.onCancel),
	("Revert",self.onRevert)):
		
	b = Tk.Button(lower,width=7,text=name,command=command)
	b.pack(side="left",anchor="w",pady=6,padx=4,expand=0)</t>
<t tx="T843">def finishCreate (self):
	
	# self.commands.frame.top.resizable(0,0)
	
	# These do not get changed when reverted.
	self.bodyVar.set(1)
	self.logVar.set(0)
	self.treeVar.set(0)
	
	# All other vars do change when reverted.
	self.revertIvars()
	self.update()</t>
<t tx="T844"></t>
<t tx="T845">def onApply (self):
	
	self.update()
</t>
<t tx="T846">def onCancel (self):

	c = self.commands
	self.onRevert()
	self.showSettings()
	self.hide()</t>
<t tx="T847">def onOk (self):

	c = self.commands
	self.showSettings()
	
	&lt;&lt; update the configuration settings &gt;&gt;

	self.setRevertVars()
	self.hide()</t>
<t tx="T848">set = app().config.setWindowPref

fn = c.body.cget("font")
font = tkFont.Font(font=fn)
name,size,slant,weight = self.getFontSettings(font)
set("body_text_font_family",name)
set("body_text_font_size",size)
set("body_text_font_slant",slant)
set("body_text_font_weight",weight)
	
fn = c.log.cget("font")
font = tkFont.Font(font=fn)
name,size,slant,weight = self.getFontSettings(font)
set("log_text_font_family",name)
set("log_text_font_size",size)
set("log_text_font_slant",slant)
set("log_text_font_weight",weight)
	
font = c.tree.getFont()
name,size,slant,weight = self.getFontSettings(font)
set("headline_text_font_family",name)
set("headline_text_font_size",size)
set("headline_text_font_slant",slant)
set("headline_text_font_weight",weight)</t>
<t tx="T849">def onRevert (self):

	c = self.commands
	c.body.configure(font=self.revertBodyFont)
	c.log.configure (font=self.revertLogFont)
	c.tree.setFont  (font=self.revertTreeFont)
	c.redraw()
	self.revertIvars()
	# Don't call update here.</t>
<t tx="T850"></t>
<t tx="T851">def selectFont (self,font):
	
	box = self.family_list_box
	
	# All selections come here.
	self.last_selected_font = font

	# The name should be on the list!
	name, size, slant, weight = self.getFontSettings(font)
	for i in xrange(0,box.size()):
		item = box.get(i)
		if name == item:
			box.select_clear(0,"end")
			box.select_set(i)
			box.see(i)
			self.last_selected_font = font
			# trace(name)
			return
	# print "not found:" + name</t>
<t tx="T852">def onSizeEntryKey (self,event=None):
	
	self.size_entry.after_idle(self.idle_entry_key)
	
def idle_entry_key (self):
	
	size = self.size_entry.get() # Doesn't work until idle time.
	try:
		size = int(size)
		self.sizeVar.set(size)
	except: # The user typed an invalid number.
		return</t>
<t tx="T853"></t>
<t tx="T854">@ Returns a font corresponding to present visual state of the font panel.  As a benign side effect, this routine selects the font in the list box.

Alas, the selection in the list box may have been cleared.  In that case, we must figure out what it should be. We recreate the family name (and only the family name!) from self.last_selected_font, or in an emergency the font returned from getImpliedFont().
@c

def getActiveFont (self):

	box = self.family_list_box
	family = font = None

	# Get the family name if possible, or font otherwise.
	items = box.curselection()
	if len(items) == 0:
		# Nothing selected.
		if self.last_selected_font:
			font =self.last_selected_font
		else:
			font = self.getImpliedFont()
	else:
		try: # This shouldn't fail now.
			items = map(int, items)
			family = box.get(items[0])
		except:
			es("unexpected exception")
			es_exception()
			font = self.getImpliedFont()
	# At this point we either have family or font.
	assert(font or family)
	if not family:
		# Extract the family from the computed font.
		family,junk,junk,junk = self.getFontSettings(font)
	# At last we have a valid family name!
	# Get all other font settings from the font panel.
	bold = self.boldVar.get()
	ital = self.italVar.get()
	size = self.sizeVar.get()
	# trace(`size`)
	slant=choose(ital,"italic","roman")
	weight=choose(bold,"bold","normal")
	# Compute the font from all the settings.
	font = tkFont.Font(family=family,size=size,slant=slant,weight=weight)
	self.selectFont(font)
	return font</t>
<t tx="T855">def getFontSettings (self, font):

	name   = font.cget("family")
	size   = font.cget("size")
	slant  = font.cget("slant")
	weight = font.cget("weight")

	return name, size, slant, weight</t>
<t tx="T856"># If a single pane's checkbox is checked, select that pane's present font.
# Otherwise, select the present font of some checked pane, it doesn't much matter which.
# If none are check, select the body pane's present font.

def getImpliedFont (self):

	c = self.commands

	body = self.bodyVar.get()
	log  = self.logVar.get()
	tree = self.treeVar.get()
	
	fn = c.body.cget("font")
	bodyFont = tkFont.Font(font=fn)
	fn = c.log.cget("font")
	logFont = tkFont.Font(font=fn)
	treeFont = c.tree.getFont()
	
	if log and not body and not tree:
		font = logFont
	elif tree and not body and not log:
		font = treeFont
	elif body: font = bodyFont
	elif tree: font = treeFont
	elif log:  font = logFont # Exercise for the reader: prove this case will never happen.
	else:      font = bodyFont
	return font</t>
<t tx="T857">def hide (self):
	
	"""Hide the font panel."""
	
	c = self.commands
	
	# c.frame.top.resizable(1,1)
	
	if 1: # Hide the window, preserving its position.
		self.top.withdraw()
	else: # works.
		c.frame.fontPanel=None
		self.top.destroy()</t>
<t tx="T858">def revertIvars (self):
	
	c = self.commands
	# Revert the fonts themselves in the various panes.
	font = self.revertBodyFont
	c.body.configure(font=font)
	font = self.revertLogFont
	c.log.configure(font=font)
	font = self.revertTreeFont
	c.tree.setFont(font=font)
	# Revert the setting of the items in the font panel
	self.last_selected_font = None # Use the font for the selected panes.
	font = self.getImpliedFont()
	self.selectFont(font)
	try:
		name, size, slant, weight = self.getFontSettings(font)
		size=int(size)
	except: pass
	self.sizeVar.set(size)
	self.boldVar.set(choose(weight=="bold",1,0))
	self.italVar.set(choose(slant=="italic",1,0))
	
	e = self.size_entry
	e.delete(0,"end")
	e.insert(0,`size`)</t>
<t tx="T859">def run (self):
	
	Tk = Tkinter ; c = self.commands
	self.top = top = Tk.Toplevel(app().root)
	attachLeoIcon(top)
	top.title("Fonts for " + shortFileName(c.frame.title))
	top.protocol("WM_DELETE_WINDOW", self.onOk)
	self.create_outer()
	
	# This must be done _after_ the dialog has been built!
	w,h,x,y = center_dialog(top)
	top.wm_minsize(height=h,width=w)
	
	# Finish up after the dialog is frozen.
	self.outer.after_idle(self.finishCreate)

	if 0: # The pane now looks decent when resized!
		top.resizable(0,0)

	# Bring up the dialog.
	if 0: # It need not be modal: it will go away if the owning window closes!
		top.grab_set()
		top.focus_set() # Get all keystrokes.</t>
<t tx="T860">def setRevertVars (self):
	
	c = self.commands
	
	# Variables for revert.
	fn = c.body.cget("font")
	self.revertBodyFont = tkFont.Font(font=fn)
	
	fn = c.log.cget("font")
	self.revertLogFont = tkFont.Font(font=fn)
	
	self.revertTreeFont = c.tree.getFont()</t>
<t tx="T861"># Write all settings to the log panel.
# Note that just after a revert all three setting may be different.

def showSettings (self):
	c = self.commands
	es("---------------")
	# Body pane.
	fn = c.body.cget("font")
	font = tkFont.Font(font=fn)
	name,size,slant,weight = self.getFontSettings(font)
	es("body font:" + name + "," + `size` + "," + slant + "," + weight)
	# Log pane.
	fn = c.log.cget("font")
	font = tkFont.Font(font=fn)
	name,size,slant,weight = self.getFontSettings(font)
	es("log font:" + name + "," + `size` + "," + slant + "," + weight)
	# Tree pane.
	font = c.tree.getFont()
	name,size,slant,weight = self.getFontSettings(font)
	es("headline font:" + name + "," + `size` + "," + slant + "," + weight)</t>
<t tx="T862">def update (self,event=None):
	
	"""Update the body text to show the present settings."""
	
	c = self.commands
	size = self.sizeVar.get()
	&lt;&lt; insert the new text in the size box &gt;&gt;
	activeFont = self.getActiveFont()
	bodyChecked = self.bodyVar.get()
	logChecked = self.logVar.get()
	treeChecked = self.treeVar.get()

	if not bodyChecked and not logChecked and not treeChecked:
		es("no pane selected")
		return
	

	# c.frame.body.configure(setgrid=0) # Disable body resizes.
	c.beginUpdate()
	&lt;&lt; set the fonts in all panes &gt;&gt;
	c.endUpdate()
	# c.frame.body.configure(setgrid=1) # Enable body resizes.

	self.top.deiconify()
	self.top.lift()</t>
<t tx="T863">e = self.size_entry
e.delete(0,"end")
e.insert(0,`size`)</t>
<t tx="T864">font = choose(bodyChecked,activeFont,self.revertBodyFont)
c.body.configure(font=font)

font = choose(logChecked,activeFont,self.revertLogFont)
c.log.configure(font=font)

font = choose(treeChecked,activeFont,self.revertTreeFont)
c.tree.setFont(font=font)</t>
<t tx="T865"># To do: Use config params for window height, width and bar color, relief and width.

@language python

__pychecker__ = 'argumentsused=0' # Pychecker param.

from leoGlobals import *
import leoColor,leoCommands,leoCompare,leoDialog,leoFontPanel,leoNodes,leoPlugins,leoPrefs,leoTree
import os,string,sys,Tkinter,tkFileDialog,tkFont
import tempfile

Tk = Tkinter

class baseLeoFrame:
	"""A base class for Leo's main frame class."""
	instances = 0
	@others

class LeoFrame (baseLeoFrame):
	"""A class that represents a Leo window."""
	pass
</t>
<t tx="T866"></t>
<t tx="T867">def __init__(self, title = None):

	Tk = Tkinter
	LeoFrame.instances += 1
	&lt;&lt; set the LeoFrame ivars &gt;&gt;
	self.top = top = Tk.Toplevel()
	if 0: # No longer needed now that Leo never creates more than one Leo frame on startup.
		top.withdraw()
	attachLeoIcon(top)
	
	if sys.platform=="win32":
		self.hwnd = top.frame()
		# trace("__init__", "frame.__init__: self.hwnd:" + `self.hwnd`)

	top.title(title)
	top.minsize(30,10) # In grid units. This doesn't work as I expect.
	
	c = None # Make sure we don't mess with c yet.
	self.createLeoFrame(top)
	self.commands = c = leoCommands.Commands(self)
	self.tree = leoTree.leoTree(self.commands, self.canvas)
	c.tree = self.tree
	self.setTabWidth(c.tab_width)
	&lt;&lt; create the first tree node &gt;&gt;
	v = c.currentVnode()
	if not doHook("menu1",c=c,v=v):
		self.createMenuBar(top)
	app().setLog(self,"frame.__init__") # the LeoFrame containing the log
	app().windowList.append(self)
	# Sign on.
	color = app().config.getWindowPref("log_error_color")
	es("Leo Log Window...",color=color)
	es("Leo 3.12.1 beta 1, ",newline=0)
	n1,n2,n3,junk,junk=sys.version_info
	ver1 = "Python %d.%d.%d" % (n1,n2,n3)
	ver2 = ", Tk " + self.top.getvar("tk_patchLevel")
	es(ver1 + ver2) ; enl()
	
	self.top.protocol("WM_DELETE_WINDOW", self.OnCloseLeoEvent)
	self.top.bind("&lt;Button-1&gt;", self.OnActivateLeoEvent)
	
	self.top.bind("&lt;Activate&gt;", self.OnActivateLeoEvent) # Doesn't work on windows.
	self.top.bind("&lt;Deactivate&gt;", self.OnDeactivateLeoEvent) # Doesn't work on windows.

	self.top.bind("&lt;Control-KeyPress&gt;",self.OnControlKeyDown)
	self.top.bind("&lt;Control-KeyRelease&gt;",self.OnControlKeyUp)
	
	self.tree.canvas.bind("&lt;Button-1&gt;", self.OnActivateTree)
	self.log.bind("&lt;Button-1&gt;", self.OnActivateLog)
	
	self.body.bind("&lt;Button-1&gt;", self.OnBodyClick) # 2/8/03
	self.body.bind("&lt;Button-3&gt;", self.OnBodyRClick) # 2/8/03
	self.body.bind("&lt;Double-Button-1&gt;", self.OnBodyDoubleClick)
	self.body.bind("&lt;Key&gt;", self.tree.OnBodyKey)

	self.body.bind(virtual_event_name("Cut"), self.OnCut)
	self.body.bind(virtual_event_name("Copy"), self.OnCopy)
	self.body.bind(virtual_event_name("Paste"), self.OnPaste)
	
	# print_bindings("body",self.body)
	
	# Handle mouse wheel in the outline pane.
	if sys.platform == "linux2": # This crashes tcl83.dll
		self.tree.canvas.bind("&lt;MouseWheel&gt;", self.OnMouseWheel)
		
	# Remove the initially selected node from the list.
	c.beadPointer = -1
	c.beadList = []
	c.visitedList = []
	doHook("after-create-leo-frame",c=c)</t>
<t tx="T868"># Set title and fileName
if title:
	self.mFileName = title
	title = self.setWindowTitle(title)
else:
	title = "untitled"
	n = app().numberOfWindows
	if n &gt; 0: title += `n`
	app().numberOfWindows = n+1
	self.mFileName = ""
	
self.stylesheet = None # The contents of &lt;?xml-stylesheet...?&gt; line.

# These are set the first time a panel is opened.
# The panel remains open (perhaps hidden) until this frame is closed.
self.colorPanel = None 
self.fontPanel = None 
self.prefsPanel = None
self.comparePanel = None
	
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.title=title # Title of window, not including dirty mark
self.saved=false # True if ever saved
self.startupWindow=false # True if initially opened window
self.openDirectory = ""
self.es_newlines = 0 # newline count for this log stream

self.splitVerticalFlag,self.ratio,self.secondary_ratio = self.initialRatios()

# Created in createLeoFrame and its allies.
self.commands = None
self.tree = None
self.f1 = self.f2 = None
self.log = None  ; self.logBar = None
self.body = None ; self.bodyBar = None ; self.bodyXBar = None
self.canvas = None ; self.treeBar = None
self.splitter1 = self.splitter2 = None
self.icon = None
self.outerFrame = None # 5/20/02
self.iconFrame = None # 5/20/02
self.statusFrame = None # 5/20/02
self.statusText = None # 5/20/02
self.statusLabel = None # 5/20/02

self.menus = {} # Menu dictionary.
self.menuShortcuts = None # List of menu shortcuts for warnings.

# Used by event handlers...
self.redrawCount = 0
self.draggedItem = None
self.recentFiles = [] # List of recent files
self.controlKeyIsDown = false # For control-drags

# Colors of log pane.
self.logColorTags = [] # list of color names used as tags in log window.
self.statusColorTags = [] # list of color names used as tags in status window.

# Previous row and column shown in the status area.
self.lastStatusRow = self.lastStatusCol = 0
self.tab_width = 0 # The tab width in effect in this pane.</t>
<t tx="T869">t = leoNodes.tnode()
v = leoNodes.vnode(c,t)
v.initHeadString("NewHeadline")
v.moveToRoot()

c.beginUpdate()
c.tree.redraw()
c.tree.canvas.focus_get()
c.editVnode(v)
c.endUpdate(false)</t>
<t tx="T870">def __repr__ (self):

	return "&lt;leoFrame: %s&gt;" % (self.title)
</t>
<t tx="T871">def setWindowTitle (self,fileName):
	
	path,fn = os.path.split(fileName)
	if path and len(path) &gt; 0:
		title = fn + " in " + path
	else:
		title = fn
	return title</t>
<t tx="T872">def createLeoFrame (self,top):

	Tk = Tkinter ; config = app().config
	
	self.outerFrame = outerFrame = Tk.Frame(top)
	self.outerFrame.pack(expand=1,fill="both")

	self.createIconBar()
	&lt;&lt; create both splitters &gt;&gt;
	&lt;&lt; create the body pane &gt;&gt;
	&lt;&lt; create the tree pane &gt;&gt;
	&lt;&lt; create the log pane &gt;&gt;
	self.reconfigurePanes()
	
	self.createStatusLine()
	self.putStatusLine("Welcome to Leo")
</t>
<t tx="T873"># Splitter 1 is the main splitter containing splitter2 and the body pane.
f1,bar1,split1Pane1,split1Pane2 = self.createLeoSplitter(outerFrame, self.splitVerticalFlag)
self.f1,self.bar1 = f1,bar1
self.split1Pane1,self.split1Pane2 = split1Pane1,split1Pane2
# Splitter 2 is the secondary splitter containing the tree and log panes.
f2,bar2,split2Pane1,split2Pane2 = self.createLeoSplitter(split1Pane1, not self.splitVerticalFlag)
self.f2,self.bar2 = f2,bar2
self.split2Pane1,self.split2Pane2 = split2Pane1,split2Pane2</t>
<t tx="T874"># A light selectbackground value is needed to make syntax coloring look good.
wrap = config.getBoolWindowPref('body_pane_wraps')
wrap = choose(wrap,"word","none")

# Setgrid=1 cause severe problems with the font panel.
self.body = body = Tk.Text(split1Pane2,name='body',
	bd=2,bg="white",relief="flat",
	setgrid=0,wrap=wrap, selectbackground="Gray80") 
self.setBodyFontFromConfig()

self.bodyBar = bodyBar = Tk.Scrollbar(split1Pane2,name='bodyBar')
body['yscrollcommand'] = bodyBar.set
bodyBar['command'] = body.yview
bodyBar.pack(side="right", fill="y")

# 8/30/03: Always create the horizontal bar.
self.bodyXBar = bodyXBar = Tk.Scrollbar(
	split1Pane2,name='bodyXBar',orient="horizontal")
body['xscrollcommand'] = bodyXBar.set
bodyXBar['command'] = body.xview

if wrap == "none":
	bodyXBar.pack(side="bottom", fill="x")
	
body.pack(expand=1, fill="both")</t>
<t tx="T875">scrolls = config.getBoolWindowPref('outline_pane_scrolls_horizontally')
scrolls = choose(scrolls,1,0)

self.canvas = tree = Tk.Canvas(split2Pane1,name="tree",
	bd=0,bg="white",relief="flat")
	
self.setTreeColorsFromConfig()

# The font is set in the tree code.

# These do nothing...
# selectborderwidth=0,selectforeground="white",selectbackground="white")
self.treeBar = treeBar = Tk.Scrollbar(split2Pane1,name="treeBar")

# Bind mouse wheel event to canvas
if sys.platform != "win32": # Works on 98, crashes on XP.
	self.canvas.bind("&lt;MouseWheel&gt;", self.OnMouseWheel)
	
tree['yscrollcommand'] = self.setCallback
treeBar['command']     = self.yviewCallback

treeBar.pack(side="right", fill="y")
if scrolls: 
	treeXBar = Tk.Scrollbar( 
		split2Pane1,name='treeXBar',orient="horizontal") 
	tree['xscrollcommand'] = treeXBar.set 
	treeXBar['command'] = tree.xview 
	treeXBar.pack(side="bottom", fill="x")
tree.pack(expand=1,fill="both")</t>
<t tx="T876">wrap = config.getBoolWindowPref('log_pane_wraps')
wrap = choose(wrap,"word","none")

self.log = log = Tk.Text(split2Pane2,name="log",
	setgrid=0,wrap=wrap,bd=2,bg="white",relief="flat")
	
self.setLogFontFromConfig()

self.logBar = logBar = Tk.Scrollbar(split2Pane2,name="logBar")

log['yscrollcommand'] = logBar.set
logBar['command'] = log.yview

logBar.pack(side="right", fill="y")
# rr 8/14/02 added horizontal elevator 
if wrap == "none": 
	logXBar = Tk.Scrollbar( 
		split2Pane2,name='logXBar',orient="horizontal") 
	log['xscrollcommand'] = logXBar.set 
	logXBar['command'] = log.xview 
	logXBar.pack(side="bottom", fill="x")
log.pack(expand=1, fill="both")</t>
<t tx="T877">def destroyAllPanels (self):
	
	"""Destroy all panels attached to this frame."""
	
	panels = (self.comparePanel, self.colorPanel, self.fontPanel, self.prefsPanel)

	for panel in panels:
		if panel:
			panel.top.destroy()
			
	self.comparePanel = None
	self.colorPanel = None
	self.fontPanel = None
	self.prefsPanel = None</t>
<t tx="T878">def promptForSave (self):
	
	"""Prompt the user to save changes.
	
	Return true if the user vetos the quit or save operation."""
	
	c = self.commands
	name = choose(self.mFileName, self.mFileName, self.title)
	type = choose(app().quitting, "quitting?", "closing?")
	
	answer = leoDialog.askYesNoCancel("Confirm",
		'Save changes to %s before %s' % (name,type)).run(modal=true)
		
	# print answer	
	if answer == "cancel":
		return true # Veto.
	elif answer == "no":
		return false # Don't save and don't veto.
	else:
		if not self.mFileName:
			&lt;&lt; Put up a file save dialog to set mFileName &gt;&gt;
		if self.mFileName:
			# print "saving", self.mFileName
			c.fileCommands.save(self.mFileName)
			return false # Don't veto.
		else:
			return true # Veto.</t>
<t tx="T879"># Make sure we never pass None to the ctor.
if not self.title:
	self.title = ""
	
self.mFileName = tkFileDialog.asksaveasfilename(
	initialfile = self.mFileName,
	title="Save",
	filetypes=[("Leo files", "*.leo")],
	defaultextension=".leo")
</t>
<t tx="T880"></t>
<t tx="T881">def configureBar (self, bar, verticalFlag):
	
	config = app().config

	# Get configuration settings.
	w = config.getWindowPref("split_bar_width")
	if not w or w &lt; 1: w = 7
	relief = config.getWindowPref("split_bar_relief")
	if not relief: relief = "flat"
	color = config.getWindowPref("split_bar_color")
	if not color: color = "LightSteelBlue2"

	try:
		if verticalFlag:
			# Panes arranged vertically; horizontal splitter bar
			bar.configure(relief=relief,height=w,bg=color,cursor="sb_v_double_arrow")
		else:
			# Panes arranged horizontally; vertical splitter bar
			bar.configure(relief=relief,width=w,bg=color,cursor="sb_h_double_arrow")
	except: # Could be a user error. Use all defaults
		es("exception in user configuration for splitbar")
		es_exception()
		if verticalFlag:
			# Panes arranged vertically; horizontal splitter bar
			bar.configure(height=7,cursor="sb_v_double_arrow")
		else:
			# Panes arranged horizontally; vertical splitter bar
			bar.configure(width=7,cursor="sb_h_double_arrow")</t>
<t tx="T882">def configureBarsFromConfig (self):
	
	config = app().config

	w = config.getWindowPref("split_bar_width")
	if not w or w &lt; 1: w = 7
	
	relief = config.getWindowPref("split_bar_relief")
	if not relief or relief == "": relief = "flat"

	color = config.getWindowPref("split_bar_color")
	if not color or color == "": color = "LightSteelBlue2"

	if self.splitVerticalFlag:
		bar1,bar2=self.bar1,self.bar2
	else:
		bar1,bar2=self.bar2,self.bar1
		
	try:
		bar1.configure(relief=relief,height=w,bg=color)
		bar2.configure(relief=relief,width=w,bg=color)
	except: # Could be a user error.
		es("exception in user configuration for splitbar")
		es_exception()</t>
<t tx="T883">def reconfigureFromConfig (self):
	
	f = self ; c = f.commands
	
	# Not ready yet: just reset the width and color.
	# We need self.bar1 and self.bar2 ivars.
	# self.reconfigureBar(...)
	
	# The calls to redraw are workarounds for an apparent Tk bug.
	# Without them the text settings get applied to the wrong widget!
	# Moreover, only this order seems to work on Windows XP...
	f.tree.setFontFromConfig()
	f.setTreeColorsFromConfig()
	f.configureBarsFromConfig()
	c.redraw()
	f.setBodyFontFromConfig()
	f.setTabWidth(c.tab_width)
	c.redraw()
	f.setLogFontFromConfig()
	c.redraw()</t>
<t tx="T884">def setBodyFontFromConfig (self):
	
	config = app().config ; body = self.body
	#print "body",self.body
	
	font = config.getFontFromParams(
		"body_text_font_family", "body_text_font_size",
		"body_text_font_slant",  "body_text_font_weight")

	body.configure(font=font)
	
	bg = config.getWindowPref("body_text_background_color")
	if bg:
		try: body.configure(bg=bg)
		except: pass
	
	fg = config.getWindowPref("body_text_foreground_color")
	if fg:
		try: body.configure(fg=fg)
		except: pass
		
	# 1/24/03: Gareth McCaughan
	bg = config.getWindowPref("body_insertion_cursor_color")
	if bg:
		try: body.configure(insertbackground=bg)
		except: pass
		
	if sys.platform != "win32": # Maybe a Windows bug.
		fg = config.getWindowPref("body_cursor_foreground_color")
		bg = config.getWindowPref("body_cursor_background_color")
		# print fg, bg
		if fg and bg:
			cursor="xterm" + " " + fg + " " + bg
			try: body.configure(cursor=cursor)
			except:
				import traceback
				traceback.print_exc()</t>
<t tx="T885">def setInitialWindowGeometry(self):
	
	"""Set the position and size of the frame to config params."""
	
	config = app().config

	h = config.getIntWindowPref("initial_window_height")
	w = config.getIntWindowPref("initial_window_width")
	x = config.getIntWindowPref("initial_window_left")
	y = config.getIntWindowPref("initial_window_top")
	# print h,w,x,y
	
	if h == None or h &lt; 5: h = 5
	if w == None or w &lt; 5: w = 10
	y = max(y,0) ; x = max(x,0)

	self.top.geometry("%dx%d%+d%+d" % (w,h,x,y))</t>
<t tx="T886">def setLogFontFromConfig (self):

	log = self.log ; config = app().config
	#print "log",self.log

	font = config.getFontFromParams(
		"log_text_font_family", "log_text_font_size",
		"log_text_font_slant",  "log_text_font_weight")
	
	log.configure(font=font)

	bg = config.getWindowPref("log_text_background_color")
	if bg:
		try: log.configure(bg=bg)
		except: pass
	
	fg = config.getWindowPref("log_text_foreground_color")
	if fg:
		try: log.configure(fg=fg)
		except: pass

</t>
<t tx="T887">def setTabWidth (self, w):
	
	try: # This can fail when called from scripts
		# Use the present font for computations.
		font = self.body.cget("font")
		root = app().root # 4/3/03: must specify root so idle window will work properly.
		font = tkFont.Font(root=root,font=font)
		tabw = font.measure(" " * abs(w)) # 7/2/02
		# tablist = `tabw` + ' ' + `2*tabw`
		self.body.configure(tabs=tabw)
		self.tab_width = w
		# print "frame.setTabWidth:" + `w` + "," + `tabw`
	except:
		es_exception()
		pass
</t>
<t tx="T888">def setTreeColorsFromConfig (self):
	
	config = app().config ; tree = self.tree

	bg = config.getWindowPref("outline_pane_background_color")
	if bg:
		try: self.canvas.configure(bg=bg)
		except: pass
</t>
<t tx="T889">def setWrap (self,v):
	
	c = self.commands
	dict = scanDirectives(c,v)
	if dict != None:
		# 8/30/03: Add scroll bars if we aren't wrapping.
		wrap = dict.get("wrap")
		if wrap:
			self.body.configure(wrap="word")
			self.bodyXBar.pack_forget()
		else:
			self.body.configure(wrap="none")
			self.bodyXBar.pack(side="bottom",fill="x")
</t>
<t tx="T890">def reconfigurePanes (self):
	
	border = app().config.getIntWindowPref('additional_body_text_border')
	if border == None: border = 0
	
	# The body pane needs a _much_ bigger border when tiling horizontally.
	border = choose(self.splitVerticalFlag,2+border,6+border)
	self.body.configure(bd=border)
	
	# The log pane needs a slightly bigger border when tiling vertically.
	border = choose(self.splitVerticalFlag,4,2) 
	self.log.configure(bd=border)</t>
<t tx="T891">def setCallback (self,*args,**keys):
	
	"""Callback to adjust the scrollbar.
	
	Args is a tuple of two floats describing the fraction of the visible area."""

	# if self.tree.trace: print "setCallback:",self.tree.redrawCount,`args`

	apply(self.treeBar.set,args,keys)

	if self.tree.allocateOnlyVisibleNodes:
		self.tree.setVisibleArea(args)
		
def yviewCallback (self,*args,**keys):
	
	"""Tell the canvas to scroll"""
	
	# if self.tree.trace: print "vyiewCallback",`args`,`keys`

	if self.tree.allocateOnlyVisibleNodes:
		self.tree.allocateNodesBeforeScrolling(args)

	apply(self.canvas.yview,args,keys)
	
	
</t>
<t tx="T892"></t>
<t tx="T893"># Called from quit logic and when user closes the window.
# Returns true if the close happened.

def OnCloseLeoEvent(self):

	app().closeLeoWindow(self)</t>
<t tx="T894">def OnControlKeyDown (self,event=None):
	
	self.controlKeyIsDown = true
	
def OnControlKeyUp (self,event=None):

	self.controlKeyIsDown = false
</t>
<t tx="T895"># Handle the "visibility" event and attempt to attach the Leo icon.
# This code must be executed whenever the window is redrawn.

def OnVisibility (self,event):

	if self.icon and event.widget is self.top:

		# print "OnVisibility"
		self.icon.attach(self.top)</t>
<t tx="T896">def OnActivateBody (self,event=None):

	try:
		c = self.commands ; v = c.currentVnode()
		app().setLog(self,"OnActivateBody")
		self.tree.OnDeactivate()
		set_focus(c,c.body)
	except:
		es_event_exception("activate body")


</t>
<t tx="T897">def OnActivateLeoEvent(self,event=None):

	try:
		app().setLog(self,"OnActivateLeoEvent")
	except:
		es_event_exception("activate Leo")

def OnDeactivateLeoEvent(self,event=None):

	try:
		app().setLog(None,"OnDeactivateLeoEvent")
	except:
		es_event_exception("deactivate Leo")</t>
<t tx="T898">def OnActivateLog (self,event=None):

	try:
		app().setLog(self,"OnActivateLog")
		self.tree.OnDeactivate()
	except:
		es_event_exception("activate log")</t>
<t tx="T899">def OnActivateTree (self,event=None):

	try:
		c = self.commands
		app().setLog(self,"OnActivateTree")
		self.tree.undimEditLabel()
		set_focus(c,c.frame.body) # 7/12/03
	except:
		es_event_exception("activate tree")
</t>
<t tx="T900">def OnBodyClick (self,event=None):

	try:
		c = self.commands ; v = c.currentVnode()
		if not doHook("bodyclick1",c=c,v=v,event=event):
			self.OnActivateBody(event=event)
		doHook("bodyclick2",c=c,v=v,event=event)
	except:
		es_event_exception("bodyclick")

def OnBodyRClick(self,event=None):
	
	try:
		c = self.commands ; v = c.currentVnode()
		if not doHook("bodyrclick1",c=c,v=v,event=event):
			pass # By default Leo does nothing.
		doHook("bodyrclick2",c=c,v=v,event=event)
	except:
		es_event_exception("iconrclick")</t>
<t tx="T901">def OnBodyDoubleClick (self,event=None):

	try:
		c = self.commands ; v = c.currentVnode()
		if not doHook("bodydclick1",c=c,v=v,event=event):
			if event: # 8/4/02: prevent wandering insertion point.
				index = "@%d,%d" % (event.x, event.y) # Find where we clicked
			body = self.body
			start = body.index(index + " wordstart")
			end = body.index(index + " wordend")
			setTextSelection(self.body,start,end)
		doHook("bodydclick1",c=c,v=v,event=event)
	except:
		es_event_exception("bodydclick")

	return "break" # Inhibit all further event processing.</t>
<t tx="T902"># Contributed by Tomaz Ficko.  This works on some systems.
# On XP it causes a crash in tcl83.dll.  Clearly a Tk bug.

def OnMouseWheel(self, event=None):

	try:
		if event.delta &lt; 1:
			self.canvas.yview(Tkinter.SCROLL, 1, Tkinter.UNITS)
		else:
			self.canvas.yview(Tkinter.SCROLL, -1, Tkinter.UNITS)
	except:
		es_event_exception("scroll wheel")

	return "break"</t>
<t tx="T903"></t>
<t tx="T904">def createIconBar (self):
	
	"""Create an empty icon bar in the packer's present position"""

	if not self.iconFrame:
		self.iconFrame = Tk.Frame(self.outerFrame,height="5m",bd=2,relief="groove")
		self.iconFrame.pack(fill="x",pady=2)</t>
<t tx="T905">def hideIconBar (self):
	
	"""Hide the icon bar by unpacking it.
	
	A later call to showIconBar will repack it in a new location."""
	
	if self.iconFrame:
		self.iconFrame.pack_forget()
</t>
<t tx="T906">def clearIconBar(self):
	
	"""Destroy all the widgets in the icon bar"""
	
	a = app() ; f = self.iconFrame
	if not f: return
	
	for slave in f.pack_slaves():
		slave.destroy()

	f.configure(height="5m") # The default height.
	a.iconWidgetCount = 0
	a. iconImageRefs = []
</t>
<t tx="T907">def showIconBar(self):
	
	"""Show the icon bar by repacking it"""

	self.iconFrame.pack(fill="x",pady=2)</t>
<t tx="T908">def addIconButton(self,text=None,imagefile=None,image=None,command=None,bg=None):
	
	"""Add a button containing text or a picture to the icon bar.
	
	Pictures take precedence over text"""
	
	a = app() ; f = self.iconFrame
	if not imagefile and not image and not text: return

	# First define n.	
	try:
		a.iconWidgetCount += 1
		n = a.iconWidgetCount
	except:
		n = a.iconWidgetCount = 1

	if not command:
		def command(n=n):
			print "command for widget %s" % (n)

	if imagefile or image:
		&lt;&lt; create a picture &gt;&gt;
	elif text:
		w = min(6,len(text))
		b = Tk.Button(f,text=text,width=w,relief="groove",bd=2,command=command)
		b.pack(side="left", fill="y")
		return b
		
	return None</t>
<t tx="T909">try:
	if imagefile:
		# Create the image.  Throws an exception if file not found
		imagefile = os.path.join(app().loadDir,imagefile)
		imagefile = os.path.normpath(imagefile)
		image = Tkinter.PhotoImage(master=app().root,file=imagefile)
		
		# Must keep a reference to the image!
		try:
			refs = a.iconImageRefs
		except:
			refs = a.iconImageRefs = []
	
		refs.append((imagefile,image),)
	
	if not bg:
		bg = f.cget("bg")

	b = Tk.Button(f,image=image,relief="flat",bd=0,command=command,bg=bg)
	b.pack(side="left",fill="y")
	return b
	
except:
	es_exception()
	return None</t>
<t tx="T910">def longFileName (self):
	return self.mFileName
	
def shortFileName (self):
	return shortFileName(self.mFileName)</t>
<t tx="T911"># All output to the log stream eventually comes here.

def put (self,s,color=None):
	# print `app().quitting`,`self.log`
	if app().quitting: return
	if self.log:
		if type(s) == type(u""): # 3/18/03
			s = toEncodedString(s,app().tkEncoding)
		if color:
			if color not in self.logColorTags:
				self.logColorTags.append(color)
				self.log.tag_config(color,foreground=color)
			self.log.insert("end",s)
			self.log.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
			if "black" not in self.logColorTags:
				self.logColorTags.append("black")
				self.log.tag_config("black",foreground="black")
			self.log.tag_add("black","end")
		else:
			self.log.insert("end",s)
		self.log.see("end")
		self.log.update_idletasks()
	else:
		app().logWaiting.append((s,color),) # 2/25/03
		print "Null log"
		if type(s) == type(u""): # 3/18/03
			s = toEncodedString(s,"ascii")
		print s

def putnl (self):
	if app().quitting: return
	if self.log:
		self.log.insert("end",'\n')
		self.log.see("end")
		self.log.update_idletasks()
	else:
		app().logWaiting.append(('\n',"black"),) # 6/28/03
		print "Null log"
		print</t>
<t tx="T912">def getFocus(self):
	
	"""Returns the widget that has focus, or body if None."""

	f = self.top.focus_displayof()
	if f:
		return f
	else:
		return self.body</t>
<t tx="T913"></t>
<t tx="T914">@ This code "canonicalizes" both the shortcuts that appear in menus and the arguments to bind, mostly ignoring case and the order in which special keys are specified in leoConfig.txt.

For example, Ctrl+Shift+a is the same as Shift+Control+A.  Either may appear in leoConfig.txt.  Each generates Shift+Ctrl-A in the menu and Control+A as the argument to bind.

Returns (bind_shortcut, menu_shortcut)
@c

def canonicalizeShortcut (self,shortcut):
	
	if shortcut == None or len(shortcut) == 0:
		return None,None
	s = shortcut.strip().lower()
	has_alt   = s.find("alt") &gt;= 0
	has_ctrl  = s.find("control") &gt;= 0 or s.find("ctrl") &gt;= 0
	has_shift = s.find("shift") &gt;= 0   or s.find("shft") &gt;= 0
	&lt;&lt; set the last field, preserving case &gt;&gt;
	&lt;&lt; canonicalize the last field &gt;&gt;
	&lt;&lt; synthesize the shortcuts from the information &gt;&gt;
	# print shortcut,bind_shortcut,menu_shortcut
	return bind_shortcut,menu_shortcut</t>
<t tx="T915">bind_last = menu_last = last
if len(last) == 1:
	ch = last[0]
	if ch in string.letters:
		menu_last = string.upper(last)
		if has_shift:
			bind_last = string.upper(last)
		else:
			bind_last = string.lower(last)
	elif ch in string.digits:
		bind_last = "Key-" + ch # 1-5 refer to mouse buttons, not keys.
	else:
		&lt;&lt; define dict of Tk bind names &gt;&gt;
		if ch in dict.keys():
			bind_last = dict[ch]
elif len(last) &gt; 0:
	&lt;&lt; define dict of special names &gt;&gt;
	last2 = string.lower(last)
	if last2 in dict.keys():
		bind_last,menu_last = dict[last2]</t>
<t tx="T916"># These are defined at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
dict = {
	"!" : "exclam",
	'"' : "quotedbl",
	"#" : "numbersign",
	"$" : "dollar",
	"%" : "percent",
	"&amp;" : "ampersand",
	"'" : "quoteright",
	"(" : "parenleft",
	")" : "parenright",
	"*" : "asterisk",
	"+" : "plus",
	"," : "comma",
	"-" : "minus",
	"." : "period",
	"/" : "slash",
	":" : "colon",
	";" : "semicolon",
	"&lt;" : "less",
	"=" : "equal",
	"&gt;" : "greater",
	"?" : "question",
	"@" : "at",
	"[" : "bracketleft",
	"\\": "backslash",
	"]" : "bracketright",
	"^" : "asciicircum",
	"_" : "underscore",
	"`" : "quoteleft",
	"{" : "braceleft",
	"|" : "bar",
	"}" : "braceright",
	"~" : "asciitilde" }</t>
<t tx="T917"># These keys are simply made-up names.  The menu_bind values are known to Tk.
# Case is not significant in the keys.

dict = {
	"bksp"    : ("BackSpace","BkSp"),
	"esc"     : ("Escape","Esc"),
	# Arrow keys...
	"dnarrow" : ("Down", "DnArrow"),
	"ltarrow" : ("Left", "LtArrow"),
	"rtarrow" : ("Right","RtArrow"),
	"uparrow" : ("Up",   "UpArrow"),
	# Page up/down keys...
	"pageup"  : ("Prior","PgUp"),
	"pagedn"  : ("Next", "PgDn")
}

@ The following are not translated, so what appears in the menu is the same as what is passed to Tk.  Case is significant.

Note: the Tk documentation states that not all of these may be available on all platforms.

F1,F2,F3,F4,F5,F6,F7,F8,F9,F10,
BackSpace, Break, Clear, Delete, Escape, Linefeed, Return, Tab,
Down, Left, Right, Up,
Begin, End, Home, Next, Prior,
Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9
</t>
<t tx="T918">s2 = shortcut
s2 = string.strip(s2)

# Replace all minus signs by plus signs, except a trailing minus:
if len(s2) &gt; 0 and s2[-1] == "-":
	s2 = string.replace(s2,"-","+")
	s2 = s2[:-1] + "-"
else:
	s2 = string.replace(s2,"-","+")

fields = string.split(s2,"+")
if fields == None or len(fields) == 0:
	if not app().menuWarningsGiven:
		print "bad shortcut specifier:", s
	return None,None

last = fields[-1]
if last == None or len(last) == 0:
	if not app().menuWarningsGiven:
		print "bad shortcut specifier:", s
	return None,None</t>
<t tx="T919">bind_head = menu_head = ""

if has_shift:
	menu_head = "Shift+"
	if len(last) &gt; 1 or (len(last)==1 and last[0] not in string.letters):
		bind_head = "Shift-"
	# else: print "no shift: last:", `last`

if has_alt:
	bind_head = bind_head + "Alt-"
	menu_head = menu_head + "Alt+"

if has_ctrl:
	bind_head = bind_head + "Control-"
	menu_head = menu_head + "Ctrl+"
	
bind_shortcut = "&lt;" + bind_head + bind_last + "&gt;"
menu_shortcut = menu_head + menu_last</t>
<t tx="T920">def createMenuBar(self, top):

	c = self.commands
	Tk = Tkinter
	topMenu = Tk.Menu(top,postcommand=self.OnMenuClick)
	self.setMenu("top",topMenu)
	self.menuShortcuts = []
	# To do: use Meta rathter than Control for accelerators for Unix
	&lt;&lt; create the file menu &gt;&gt;
	&lt;&lt; create the edit menu &gt;&gt;
	&lt;&lt; create the outline menu &gt;&gt;
	doHook("create-optional-menus",c=c)
	&lt;&lt; create the window menu &gt;&gt;
	&lt;&lt; create the help menu &gt;&gt;
	top.config(menu=topMenu) # Display the menu.
	app().menuWarningsGiven = true
</t>
<t tx="T921">editMenu = self.createNewMenu("&amp;Edit")
&lt;&lt; create the first top-level edit entries &gt;&gt;
&lt;&lt; create the edit body submenu &gt;&gt;
&lt;&lt; create the edit headline submenu &gt;&gt;
&lt;&lt; create the find submenu &gt;&gt;
&lt;&lt; create the last top-level edit entries &gt;&gt;
</t>
<t tx="T922">table = (
	("Can't Undo","Ctrl+Z",self.OnUndo), # &amp;U reserved for Undo
	("Can't Redo","Shift+Ctrl+Z",self.OnRedo), # &amp;R reserved for Redo
	("-",None,None),
	("Cu&amp;t","Ctrl+X",self.OnCutFromMenu), 
	("Cop&amp;y","Ctrl+C",self.OnCopyFromMenu),
	("&amp;Paste","Ctrl+V",self.OnPasteFromMenu),
	("&amp;Delete",None,self.OnDelete),
	("Select &amp;All","Ctrl+A",self.OnSelectAll),
	("-",None,None))

self.createMenuEntries(editMenu,table)
</t>
<t tx="T923">editBodyMenu = self.createNewMenu("Edit &amp;Body...","Edit")

table = (
	("Extract &amp;Section","Shift+Ctrl+E",self.OnExtractSection),
	("Extract &amp;Names","Shift+Ctrl+N",self.OnExtractNames),
	("&amp;Extract","Shift+Ctrl+D",self.OnExtract),
	("-",None,None),
	("Convert All B&amp;lanks",None,self.OnConvertAllBlanks),
	("Convert All T&amp;abs",None,self.OnConvertAllTabs),
	("Convert &amp;Blanks","Shift+Ctrl+B",self.OnConvertBlanks),
	("Convert &amp;Tabs","Shift+Ctrl+J",self.OnConvertTabs),
	("Insert Body Time/&amp;Date","Shift+Ctrl+G",self.OnInsertBodyTime),
	("&amp;Reformat Paragraph","Shift+Ctrl+P",self.OnReformatParagraph),
	("-",None,None),
	("&amp;Indent","Ctrl+]",self.OnIndent),
	("&amp;Unindent","Ctrl+[",self.OnDedent),
	("&amp;Match Brackets","Ctrl+K",self.OnFindMatchingBracket))
	
self.createMenuEntries(editBodyMenu,table)

</t>
<t tx="T924">editHeadlineMenu = self.createNewMenu("Edit &amp;Headline...","Edit")

table = (
	("Edit &amp;Headline","Ctrl+H",self.OnEditHeadline),
	("&amp;End Edit Headline","Escape",self.OnEndEditHeadline),
	("&amp;Abort Edit Headline","Shift-Escape",self.OnAbortEditHeadline),
	("Insert Headline Time/&amp;Date","Shift+Ctrl+H",self.OnInsertHeadlineTime))
	
	# 5/16/03 EKR: I dislike this command.
	#("Toggle Angle Brackets","Ctrl+B",self.OnToggleAngleBrackets)
	
self.createMenuEntries(editHeadlineMenu,table)

</t>
<t tx="T925">findMenu = self.createNewMenu("&amp;Find...","Edit")

table = (
	("&amp;Find Panel","Ctrl+F",self.OnFindPanel),
	("-",None,None),
	("Find &amp;Next","F3",self.OnFindNext),
	("Find &amp;Previous","F4",self.OnFindPrevious),
	("&amp;Replace","Ctrl+=",self.OnReplace),
	("Replace, &amp;Then Find","Ctrl+-",self.OnReplaceThenFind))

self.createMenuEntries(findMenu,table)
</t>
<t tx="T926">label = choose(c.tree.colorizer.showInvisibles,"Hide In&amp;visibles","Show In&amp;visibles")

table = (
	("&amp;Go To Line Number","Alt+G",self.OnGoToLineNumber),
	("&amp;Execute Script","Alt+Shift+E",self.OnExecuteScript),
	("Set Fon&amp;t...","Shift+Alt+T",self.OnFontPanel),
	("Set &amp;Colors...","Shift+Alt+C",self.OnColorPanel),
	(label,"Alt+V",self.OnViewAllCharacters),
	("-",None,None),
	("Prefere&amp;nces","Ctrl+Y",self.OnPreferences))

self.createMenuEntries(editMenu,table)</t>
<t tx="T927">fileMenu = self.createNewMenu("&amp;File")
&lt;&lt; create the top-level file entries &gt;&gt;
&lt;&lt; create the recent files submenu &gt;&gt;
fileMenu.add_separator()
&lt;&lt; create the read/write submenu &gt;&gt;
&lt;&lt; create the tangle submenu &gt;&gt;
&lt;&lt; create the untangle submenu &gt;&gt;
&lt;&lt; create the import submenu &gt;&gt;
&lt;&lt; create the export submenu &gt;&gt;
fileMenu.add_separator()
# Create the last entries.
exitTable = (("E&amp;xit","Ctrl-Q",self.OnQuit),)
self.createMenuEntries(fileMenu,exitTable)

</t>
<t tx="T928">@ leo.py will probably never have a Print command.  Instead, export text files that may be formatted and printed as desired.
@c

table = (
	("&amp;New","Ctrl+N",self.OnNew),
	("&amp;Open...","Ctrl+O",self.OnOpen))
self.createMenuEntries(fileMenu,table)

# 7/1/03: Create a new menu rather than call OnOpenWith.
self.createNewMenu("Open &amp;With...","File")

table = (
	("-",None,None),
	("&amp;Close","Ctrl+W",self.OnClose),
	("&amp;Save","Ctrl+S",self.OnSave),
	("Save &amp;As","Shift+Ctrl+S",self.OnSaveAs),
	("Save To",None,self.OnSaveTo), # &amp;Tangle
	("Re&amp;vert To Saved",None,self.OnRevert)) # &amp;Read/Write
self.createMenuEntries(fileMenu,table)</t>
<t tx="T929">recentFilesMenu = self.createNewMenu("Recent &amp;Files...","File")
self.recentFiles = app().config.getRecentFiles()
self.createRecentFilesMenuItems()

</t>
<t tx="T930">readWriteMenu = self.createNewMenu("&amp;Read/Write...","File")

table = [
		("&amp;Read Outline Only","Shift+Ctrl+R",self.OnReadOutlineOnly),
		("Read @file &amp;Nodes",None,self.OnReadAtFileNodes),
		("-",None,None),
		("Write &amp;Dirty @file Nodes","Shift+Ctrl+Q",self.OnWriteDirtyAtFileNodes),
		("Write &amp;Missing @file Nodes",None,self.OnWriteMissingAtFileNodes),
		("Write &amp;Outline Only",None,self.OnWriteOutlineOnly),
		("&amp;Write @file Nodes","Shift+Ctrl+W",self.OnWriteAtFileNodes)]

self.createMenuEntries(readWriteMenu,table)</t>
<t tx="T931">tangleMenu = self.createNewMenu("&amp;Tangle...","File")

table = (
	("Tangle &amp;All","Shift+Ctrl+A",self.OnTangleAll),
	("Tangle &amp;Marked","Shift+Ctrl+M",self.OnTangleMarked),
	("&amp;Tangle","Shift+Ctrl+T",self.OnTangle))

self.createMenuEntries(tangleMenu,table)

</t>
<t tx="T932">untangleMenu = self.createNewMenu("&amp;Untangle...","File")

table = (
	("Untangle &amp;All",None,self.OnUntangleAll),
	("Untangle &amp;Marked",None,self.OnUntangleMarked),
	("&amp;Untangle","Shift+Ctrl+U",self.OnUntangle))
	
self.createMenuEntries(untangleMenu,table)

</t>
<t tx="T933">importMenu = self.createNewMenu("&amp;Import...","File")

table = (
	("Import To @&amp;file","Shift+Ctrl+F",self.OnImportAtFile),
	("Import To @&amp;root",None,self.OnImportAtRoot),
	("Import &amp;CWEB Files",None,self.OnImportCWEBFiles),
	("Import &amp;noweb Files",None,self.OnImportNowebFiles),
	("Import Flattened &amp;Outline",None,self.OnImportFlattenedOutline))

self.createMenuEntries(importMenu,table)

</t>
<t tx="T934">exportMenu = self.createNewMenu("&amp;Export...","File")

table = [
	("Export &amp;Headlines",None,self.OnExportHeadlines),
	("Outline To &amp;CWEB",None,self.OnOutlineToCWEB),
	("Outline To &amp;Noweb",None,self.OnOutlineToNoweb),
	("&amp;Flatten Outline",None,self.OnFlattenOutline),
	("&amp;Remove Sentinels",None,self.OnRemoveSentinels),
	("&amp;Weave",None,self.OnWeave)]

self.createMenuEntries(exportMenu,table)
</t>
<t tx="T935">outlineMenu = self.createNewMenu("&amp;Outline")
&lt;&lt; create top-level outline menu &gt;&gt;
&lt;&lt; create expand/contract submenu &gt;&gt;
&lt;&lt; create move submenu &gt;&gt;
&lt;&lt; create mark submenu &gt;&gt;
&lt;&lt; create goto submenu &gt;&gt;</t>
<t tx="T936">table = (
	("C&amp;ut Node","Shift+Ctrl+X",self.OnCutNode),
	("C&amp;opy Node","Shift+Ctrl+C",self.OnCopyNode),
	("&amp;Paste Node","Shift+Ctrl+V",self.OnPasteNode),
	("&amp;Delete Node","Shift+Ctrl+BkSp",self.OnDeleteNode),
	("-",None,None),
	("&amp;Insert Node","Ctrl+I",self.OnInsertNode),
	("&amp;Clone Node","Ctrl+`",self.OnCloneNode),
	("Sort C&amp;hildren",None,self.OnSortChildren),
	("&amp;Sort Siblings","Alt-A",self.OnSortSiblings),
	("-",None,None))

self.createMenuEntries(outlineMenu,table)</t>
<t tx="T937">expandMenu = self.createNewMenu("&amp;Expand/Contract...","Outline")

table = (
	("&amp;Contract All","Alt+-",self.OnContractAll),
	("Contract &amp;Node","Alt+[",self.OnContractNode),
	("Contract &amp;Parent","Alt+0",self.OnContractParent),
	("-",None,None),
	("Expand P&amp;rev Level","Alt+.",self.OnExpandPrevLevel),
	("Expand N&amp;ext Level","Alt+=",self.OnExpandNextLevel),
	("-",None,None),
	("Expand To Level &amp;1","Alt+1",self.OnExpandToLevel1),
	("Expand To Level &amp;2","Alt+2",self.OnExpandToLevel2),
	("Expand To Level &amp;3","Alt+3",self.OnExpandToLevel3),
	("Expand To Level &amp;4","Alt+4",self.OnExpandToLevel4),
	("Expand To Level &amp;5","Alt+5",self.OnExpandToLevel5),
	("Expand To Level &amp;6","Alt+6",self.OnExpandToLevel6),
	("Expand To Level &amp;7","Alt+7",self.OnExpandToLevel7),
	("Expand To Level &amp;8","Alt+8",self.OnExpandToLevel8),
	# ("Expand To Level &amp;9","Alt+9",self.OnExpandToLevel9),
	("-",None,None),
	("Expand &amp;All","Alt+9",self.OnExpandAll),
	("Expand N&amp;ode","Alt+]",self.OnExpandNode))


self.createMenuEntries(expandMenu,table)</t>
<t tx="T938">moveSelectMenu = self.createNewMenu("&amp;Move...","Outline")

table = (
	("Move &amp;Down", "Ctrl+D",self.OnMoveDown),
	("Move &amp;Left", "Ctrl+L",self.OnMoveLeft),
	("Move &amp;Right","Ctrl+R",self.OnMoveRight),
	("Move &amp;Up",   "Ctrl+U",self.OnMoveUp),
	("-",None,None),
	("&amp;Promote","Ctrl+{",self.OnPromote),
	("&amp;Demote", "Ctrl+}",self.OnDemote))
	
self.createMenuEntries(moveSelectMenu,table)
</t>
<t tx="T939">markMenu = self.createNewMenu("M&amp;ark/Unmark...","Outline")

table = (
	("&amp;Mark","Ctrl-M",self.OnMark),
	("Mark &amp;Subheads","Alt+S",self.OnMarkSubheads),
	("Mark Changed &amp;Items","Alt+C",self.OnMarkChangedItems),
	("Mark Changed &amp;Roots","Alt+R",self.OnMarkChangedRoots),
	("Mark &amp;Clones","Alt+K",self.OnMarkClones),
	("&amp;Unmark All","Alt+U",self.OnUnmarkAll))
	
self.createMenuEntries(markMenu,table)
</t>
<t tx="T940">gotoMenu = self.createNewMenu("&amp;Go To...","Outline")

table = (
	("Go Back",None,self.OnGoPrevVisitedNode), # Usually use buttons for this.
	("Go Forward",None,self.OnGoNextVisitedNode),
	("-",None,None),
	("Go To Next &amp;Marked","Alt+M",self.OnGoToNextMarked),
	("Go To Next C&amp;hanged","Alt+D",self.OnGoToNextChanged),
	("Go To Next &amp;Clone","Alt+N",self.OnGoToNextClone),
	("-",None,None),
	("Go To &amp;First Node","Alt+Shift+G",self.OnGoToFirstNode),
	("Go To &amp;Last Node","Alt+Shift+H",self.OnGoToLastNode),
	("Go To &amp;Parent","Alt+Shift+P",self.OnGoToParent),
	("Go To P&amp;rev Sibling","Alt+Shift+R",self.OnGoToPrevSibling),
	("Go To Next &amp;Sibling","Alt+Shift+S",self.OnGoToNextSibling),
	("-",None,None),
	("Go To Prev V&amp;isible","Alt-UpArrow",self.OnGoPrevVisible),
	("Go To Next &amp;Visible","Alt-DnArrow",self.OnGoNextVisible),
	("Go To Prev Node","Alt-Shift+UpArrow",self.OnGoBack),
	("Go To Next Node","Alt-Shift-DnArrow",self.OnGoNext))
	
self.createMenuEntries(gotoMenu,table)
</t>
<t tx="T941">windowMenu = self.createNewMenu("&amp;Window")

table = (
	("&amp;Equal Sized Panes","Ctrl-E",self.OnEqualSizedPanes),
	("Toggle &amp;Active Pane","Ctrl-T",self.OnToggleActivePane),
	("Toggle &amp;Split Direction",None,self.OnToggleSplitDirection),
	("-",None,None),
	("Casca&amp;de",None,self.OnCascade),
	("&amp;Minimize All",None,self.OnMinimizeAll),
	("-",None,None),
	("Open &amp;Compare Window",None,self.OnOpenCompareWindow))
	
	# 
	# ("Open &amp;Python Window","Alt+P",self.OnOpenPythonWindow))

self.createMenuEntries(windowMenu,table)
</t>
<t tx="T942">helpMenu = self.createNewMenu("&amp;Help")

table = (
	("&amp;About Leo...",None,self.OnAbout),
	("Online &amp;Home Page",None,self.OnLeoHome),
	("-",None,None),
	("Open Online &amp;Tutorial",None,self.OnLeoTutorial))

self.createMenuEntries(helpMenu,table)

if sys.platform=="win32":
	table = (("Open &amp;Offline Tutorial",None,self.OnLeoHelp),)
	self.createMenuEntries(helpMenu,table)

table = (
	("Open Leo&amp;Docs.leo",None,self.OnLeoDocumentation),
	("-",None,None),
	("Open Leo&amp;Config.leo",None,self.OnLeoConfig),
	("Apply &amp;Settings",None,self.OnApplyConfig))

self.createMenuEntries(helpMenu,table)</t>
<t tx="T943">@ Executes the given command, invoking hooks and catching exceptions.
Command handlers no longer need to return "break".  Yippee!

The code assumes that the "command1" hook has completely handled the command if doHook("command1") returns false.  This provides a very simple mechanism for overriding commands.
@c

def doCommand (self,command,label,event=None):
	
	# A horrible kludge: set app().log to cover for a possibly missing activate event.
	app().setLog(self,"doCommand")

	if label == "cantredo": label = "redo"
	if label == "cantundo": label = "undo"
	app().commandName = label
	c = self.commands ; v = c.currentVnode() # 2/8/03
	if not doHook("command1",c=c,v=v,label=label):
		try:
			command(event)
		except:
			es("exception executing command")
			print "exception executing command"
			es_exception()
	
	doHook("command2",c=c,v=v,label=label)
			
	return "break" # Inhibit all other handlers.
</t>
<t tx="T944">def getMenu (self,menuName):

	cmn = canonicalizeMenuName(menuName)
	return self.menus.get(cmn)
	
def setMenu (self,menuName,menu):
	
	cmn = canonicalizeMenuName(menuName)
	self.menus [cmn] = menu
	
def destroyMenu (self,menuName):
	
	cmn = canonicalizeMenuName(menuName)
	del self.menus[cmn]
</t>
<t tx="T945"></t>
<t tx="T946"></t>
<t tx="T947"></t>
<t tx="T948">def OnNew (self,event=None):

	config = app().config
	frame = LeoFrame() # Create another Leo window.
	top = frame.top
	
	# 5/16/03: Needed for hooks.
	doHook("new",old_c=self,new_c=frame.commands)
	
	# Use the config params to set the size and location of the window.
	frame.setInitialWindowGeometry()

	if 0:
		# Set the size of the new window.
		h = config.getIntWindowPref("initial_window_height")
		w = config.getIntWindowPref("initial_window_width")
		x = config.getIntWindowPref("initial_window_left")
		y = config.getIntWindowPref("initial_window_top")
		# print h,w,x,y
		if h == None or h &lt; 5: h = 5
		if w == None or w &lt; 5: w = 10
		y = max(y,0) ; x = max(x,0)
		geom = "%dx%d%+d%+d" % (w,h,x,y)
		top.geometry(geom)

	top.deiconify()
	top.lift()
	frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
	c = frame.commands # Use the commander of the _new_ frame.
	c.beginUpdate()
	if 1: # within update
		t = leoNodes.tnode()
		v = leoNodes.vnode(c,t)
		v.initHeadString("NewHeadline")
		v.moveToRoot()
		c.editVnode(v)
	c.endUpdate()
	
	set_focus(c,frame.body)</t>
<t tx="T949">def OnOpen(self,event=None):

	c = self.commands
	&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;
	# trace(`closeFlag`)

	fileName = tkFileDialog.askopenfilename(
		title="Open",
		filetypes=[("Leo files", "*.leo"), ("All files", "*")],
		defaultextension=".leo")

	if fileName and len(fileName) &gt; 0:
		ok, frame = self.OpenWithFileName(fileName)
		if ok and closeFlag:
			app().destroyWindow(self)</t>
<t tx="T950">@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c
	
closeFlag = (
	self.startupWindow==true and # The window was open on startup
	c.changed==false and self.saved==false and # The window has never been changed
	app().numberOfWindows == 1) # Only one untitled window has ever been opened
</t>
<t tx="T951">@ This routine handles the items in the Open With... menu.
These items can only be created by createOpenWithMenuFromTable().
Typically this would be done from the "open2" hook.
@c

def OnOpenWith(self,data=None):
	
	a = app() ; c = self.commands ; v = c.currentVnode()
	if not data or len(data) != 3: return # 6/22/03
	try:
		# print "OnOpenWith:",`data`
		openType,arg,ext=data
		if not doHook("openwith1",c=c,v=v,openType=openType,arg=arg,ext=ext):
			&lt;&lt; set ext based on the present language &gt;&gt;
			&lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt;
			&lt;&lt; execute a command to open path in external editor &gt;&gt;
		doHook("openwith2",c=c,v=v,openType=openType,arg=arg,ext=ext)
	except:
		es("exception in OnOpenWith")
		es_exception()

	return "break"</t>
<t tx="T952">if not ext:
	dict = scanDirectives(c)
	language = dict.get("language")
	ext = a.language_extension_dict.get(language)
	# print language,ext
	if ext == None:
		ext = "txt"
	
if ext[0] != ".":
	ext = "."+ext
	
# print "ext",`ext`</t>
<t tx="T953">dict = None ; path = None
&lt;&lt; set dict and path if a temp file already refers to v.t &gt;&gt;
if path:
	&lt;&lt; create or recreate temp file as needed &gt;&gt;
else:
	path = self.createOpenWithTempFile(v,ext)

if not path:
	return # An error has occured.</t>
<t tx="T954">searchPath = self.openWithTempFilePath(v,ext)

if os.path.exists(searchPath):
	for dict in a.openWithFiles:
		if v.t == dict.get("v") and searchPath == dict.get("path"):
			path = searchPath
			break
</t>
<t tx="T955">@ We test for changes in both v and the temp file:

- If only v's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = dict.get("encoding")
old_body = dict.get("body")
new_body = v.bodyString()
new_body = toEncodedString(new_body,encoding,reportErrors=true)

old_time = dict.get("time")
try:
	new_time=os.path.getmtime(path)
except:
	new_time=None
	
body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
	&lt;&lt; Raise dialog about conflict and set result &gt;&gt;
	if result == "cancel": return
	rewrite = result == "outline"
else:
	rewrite = body_changed
		
if rewrite:
	path = self.createOpenWithTempFile(v,ext)
else:
	es("reopening: " + shortFileName(path),color="blue")</t>
<t tx="T956">message = (
	"Conflicting changes in outline and temp file\n\n" +
	"Do you want to use the code in the outline or the temp file?\n\n")

result = leoDialog.askYesNoCancel(
	"Conflict!", message,
	yesMessage = "Outline",
	noMessage = "File",
	defaultButton = "Cancel").run(modal=1)

</t>
<t tx="T957">try:
	if arg == None: arg = ""
	shortPath = path # shortFileName(path)
	if openType == "os.system":
		command  = "os.system("+arg+shortPath+")"
		os.system(arg+path)
	elif openType == "os.startfile":
		command    = "os.startfile("+arg+shortPath+")"
		os.startfile(arg+path)
	elif openType == "exec":
		command    = "exec("+arg+shortPath+")"
		exec arg+path in {} # 12/11/02
	elif openType == "os.spawnl":
		filename = os.path.basename(arg)
		command = "os.spawnl("+arg+","+filename+','+ shortPath+")"
		apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
	elif openType == "os.spawnv":
		filename = os.path.basename(arg)
		command = "os.spawnv("+arg+",("+filename+','+ shortPath+"))"
		apply(os.spawnl,(os.P_NOWAIT,arg,(filename,path)))
	else:
		command="bad command:"+str(openType)
	# This seems a bit redundant.
	# es(command)
except:
	es("exception executing: "+command)
	es_exception()</t>
<t tx="T958">def createOpenWithTempFile (self, v, ext):
	
	c = self.commands ; a = app()
	path = self.openWithTempFilePath(v,ext)
	try:
		if os.path.exists(path):
			es("recreating:  " + shortFileName(path),color="red")
		else:
			es("creating:  " + shortFileName(path),color="blue")
		file = open(path,"w")
		# 3/7/03: convert s to whatever encoding is in effect.
		s = v.bodyString()
		dict = scanDirectives(self.commands,v=v)
		encoding = dict.get("encoding",None)
		if encoding == None:
			encoding = a.config.default_derived_file_encoding
		s = toEncodedString(s,encoding,reportErrors=true) 
		file.write(s)
		file.flush()
		file.close()
		try:    time=os.path.getmtime(path)
		except: time=None
		# es("time: " + str(time))
		# 4/22/03: add body and encoding entries to dict for later comparisons.
		dict = {"body":s, "c":c, "encoding":encoding, "f":file, "path":path, "time":time, "v":v}
		&lt;&lt; remove previous entry from a.openWithFiles if it exists &gt;&gt; # 4/22/03
		a.openWithFiles.append(dict)
		return path
	except:
		file = None
		es("exception creating temp file",color="red")
		es_exception()
		return None</t>
<t tx="T959">for d in a.openWithFiles[:]: # 6/30/03
	v2 = d.get("v")
	if v.t == v2.t:
		print "removing previous entry in a.openWithFiles for",v
		a.openWithFiles.remove(d)</t>
<t tx="T960">def openWithTempFilePath (self,v,ext):
	
	"""Return the path to the temp file corresponding to v and ext."""

	name = "LeoTemp_" + str(id(v.t)) + '_' + sanitize_filename(v.headString()) + ext
	td = os.path.abspath(tempfile.gettempdir())
	path = os.path.join(td,name)
	
	# print "openWithTempFilePath",path
	return path</t>
<t tx="T961">def OpenWithFileName(self,fileName):
	
	return openWithFileName(fileName,self.commands)</t>
<t tx="T962">def OnClose(self,event=None):
	
	"""Handle the File-Close command."""
	
	app().closeLeoWindow(self)</t>
<t tx="T963">def OnSave(self,event=None):

	c = self.commands
	
	# Make sure we never pass None to the ctor.
	if not self.mFileName:
		self.title = ""
		self.mFileName = ""

	if self.mFileName != "":
		c.fileCommands.save(self.mFileName)
		c.setChanged(false)
		return

	fileName = tkFileDialog.asksaveasfilename(
		initialfile = self.mFileName,
		title="Save",
		filetypes=[("Leo files", "*.leo")],
		defaultextension=".leo")

	if len(fileName) &gt; 0:
		# 7/2/02: don't change mFileName until the dialog has suceeded.
		self.mFileName = ensure_extension(fileName, ".leo")
		self.title = self.mFileName
		self.top.title(self.setWindowTitle(self.mFileName)) # 3/25/03
		c.fileCommands.save(self.mFileName)
		self.updateRecentFiles(self.mFileName)</t>
<t tx="T964">def OnSaveAs(self,event=None):

	# Make sure we never pass None to the ctor.
	if not self.mFileName:
		self.title = ""
		
	fileName = tkFileDialog.asksaveasfilename(
		initialfile = self.mFileName,
		title="Save As",
		filetypes=[("Leo files", "*.leo")],
		defaultextension=".leo")

	if len(fileName) &gt; 0:
		# 7/2/02: don't change mFileName until the dialog has suceeded.
		self.mFileName = ensure_extension(fileName, ".leo")
		self.title = self.mFileName
		self.top.title(self.setWindowTitle(self.mFileName)) # 3/25/03
		self.commands.fileCommands.saveAs(self.mFileName)
		self.updateRecentFiles(self.mFileName)</t>
<t tx="T965">def OnSaveTo(self,event=None):

	# Make sure we never pass None to the ctor.
	if not self.mFileName:
		self.title = ""

	# set local fileName, _not_ self.mFileName
	fileName = tkFileDialog.asksaveasfilename(
		initialfile = self.mFileName,
		title="Save To",
		filetypes=[("Leo files", "*.leo")],
		defaultextension=".leo")

	if len(fileName) &gt; 0:
		fileName = ensure_extension(fileName, ".leo")
		self.commands.fileCommands.saveTo(fileName)
		self.updateRecentFiles(self.mFileName)
</t>
<t tx="T966">def OnRevert(self,event=None):
	
	a = app()

	# Make sure the user wants to Revert.
	if not self.mFileName:
		self.mFileName = ""
	if len(self.mFileName)==0:
		return

	reply = leoDialog.askYesNo("Revert",
		"Revert to previous version of " + self.mFileName + "?").run(modal=true)

	if reply=="no":
		return

	# Kludge: rename this frame so OpenWithFileName won't think it is open.
	fileName = self.mFileName ; self.mFileName = ""

	# Create a new frame before deleting this frame.
	ok, frame = self.OpenWithFileName(fileName)
	if ok:
		frame.top.deiconify()
		app().destroyWindow(self)
	else:
		self.mFileName = fileName
</t>
<t tx="T967">def OnQuit(self,event=None):
	
	app().onQuit()</t>
<t tx="T968">def updateRecentFiles (self, fileName):
	
	if not fileName or len(fileName) == 0:
		return
	
	# Update the recent files list in all windows.
	normFileName = os.path.normcase(fileName)
	
	for frame in app().windowList:
		# Remove all versions of the file name.
		for name in frame.recentFiles:
			name2 = os.path.normcase(name)
			name2 = os.path.normpath(name2)
			if normFileName == name2:
				frame.recentFiles.remove(name)
		frame.recentFiles.insert(0,fileName)
		# Recreate the Recent Files menu.
		frame.createRecentFilesMenuItems()
		
	# Update the config file.
	app().config.setRecentFiles(frame.recentFiles)
	app().config.update()</t>
<t tx="T969"></t>
<t tx="T970">def OnOpenRecentFile(self,name=None):
	
	c = self.commands ; v = c.currentVnode()
	&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;
	if not name:
		return

	fileName = name
	if not doHook("recentfiles1",c=c,v=v,fileName=fileName,closeFlag=closeFlag):
		ok, frame = self.OpenWithFileName(fileName)
		if ok and closeFlag:
			app().destroyWindow(self)
			app().setLog(frame,"OnOpenRecentFile") # Sets the log stream for es()

	doHook("recentfiles2",c=c,v=v,fileName=fileName,closeFlag=closeFlag)</t>
<t tx="T971">@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c
	
closeFlag = (
	self.startupWindow==true and # The window was open on startup
	c.changed==false and self.saved==false and # The window has never been changed
	app().numberOfWindows == 1) # Only one untitled window has ever been opened
</t>
<t tx="T972">def createRecentFilesMenuItems (self):
	
	f = self
	recentFilesMenu = f.getMenu("Recent Files...")
	recentFilesMenu.delete(0,len(f.recentFiles))
	i = 1
	for name in f.recentFiles:
		callback = lambda f=f,name=name:f.OnOpenRecentFile(name)
		label = "%d %s" % (i,self.setWindowTitle(name)) # str(i)+" "+name
		recentFilesMenu.add_command(label=label,command=callback,underline=0)
		i += 1</t>
<t tx="T973"></t>
<t tx="T974">def OnReadOutlineOnly (self,event=None):

	fileName = tkFileDialog.askopenfilename(
		title="Read Outline Only",
		filetypes=[("Leo files", "*.leo"), ("All files", "*")],
		defaultextension=".leo")

	if not fileName or len(fileName) == 0:
		return
		
	try: # 11/18/02
		file = open(fileName,'r')
		frame = LeoFrame(fileName)
		frame.top.deiconify()
		frame.top.lift()
		app().root.update() # Force a screen redraw immediately.
		frame.commands.fileCommands.readOutlineOnly(file,fileName) # closes file.
	except:
		es("can not open:" + fileName)</t>
<t tx="T975">def OnReadAtFileNodes (self,event=None):

	c = self.commands

	answer = leoDialog.askOkCancel("Proceed?",
		"Read @file Nodes is not undoable." +
		"\nProceed?").run(modal=true)

	if answer=="ok":
		c.fileCommands.readAtFileNodes()
		c.undoer.clearUndoState()
</t>
<t tx="T976">def OnWriteDirtyAtFileNodes (self,event=None):

	self.commands.fileCommands.writeDirtyAtFileNodes()
</t>
<t tx="T977">def OnWriteMissingAtFileNodes (self,event=None):

	self.commands.fileCommands.writeMissingAtFileNodes()
</t>
<t tx="T978">def OnWriteOutlineOnly (self,event=None):

	self.commands.fileCommands.writeOutlineOnly()
</t>
<t tx="T979">def OnWriteAtFileNodes (self,event=None):

	self.commands.fileCommands.writeAtFileNodes()
</t>
<t tx="T980"></t>
<t tx="T981">def OnTangleAll(self,event=None):

	self.commands.tangleCommands.tangleAll()
</t>
<t tx="T982">def OnTangleMarked(self,event=None):

	self.commands.tangleCommands.tangleMarked()
</t>
<t tx="T983">def OnTangle (self,event=None):

	self.commands.tangleCommands.tangle()
</t>
<t tx="T984"></t>
<t tx="T985">def OnUntangleAll(self,event=None):

	c = self.commands
	c.tangleCommands.untangleAll()
	c.undoer.clearUndoState()
</t>
<t tx="T986">def OnUntangleMarked(self,event=None):

	c = self.commands
	self.commands.tangleCommands.untangleMarked()
	c.undoer.clearUndoState()
</t>
<t tx="T987">def OnUntangle(self,event=None):

	c = self.commands
	self.commands.tangleCommands.untangle()
	c.undoer.clearUndoState()
</t>
<t tx="T988"></t>
<t tx="T989">def OnExportHeadlines (self,event=None):
	
	filetypes = [("Text files", "*.txt"),("All files", "*")]

	fileName = tkFileDialog.asksaveasfilename(
		title="Export Headlines",filetypes=filetypes,
		initialfile="headlines.txt",defaultextension=".txt")

	if fileName and len(fileName) &gt; 0:
		self.commands.importCommands.exportHeadlines(fileName)
</t>
<t tx="T990">def OnFlattenOutline (self,event=None):
	
	filetypes = [("Text files", "*.txt"),("All files", "*")]

	fileName = tkFileDialog.asksaveasfilename(
		title="Flatten Outline",filetypes=filetypes,
		initialfile="flat.txt",defaultextension=".txt")

	if fileName and len(fileName) &gt; 0:
		c = self.commands
		c.importCommands.flattenOutline(fileName)
</t>
<t tx="T991">def OnImportAtRoot (self,event=None):
	
	types = [
		("All files","*"),
		("C/C++ files","*.c"),
		("C/C++ files","*.cpp"),
		("C/C++ files","*.h"),
		("C/C++ files","*.hpp"),
		("Java files","*.java"),
		("Pascal files","*.pas"),
		("Python files","*.py") ]

	fileName = tkFileDialog.askopenfilename(
		title="Import To @root",filetypes=types)
	if fileName and len(fileName) &gt; 0:
		c = self.commands
		paths = [fileName] # alas, askopenfilename returns only a single name.
		c.importCommands.importFilesCommand (paths,"@root")
</t>
<t tx="T992">def OnImportAtFile (self,event=None):
	
	types = [
		("All files","*"),
		("C/C++ files","*.c"),
		("C/C++ files","*.cpp"),
		("C/C++ files","*.h"),
		("C/C++ files","*.hpp"),
		("Java files","*.java"),
		("Pascal files","*.pas"),
		("Python files","*.py") ]
			
	fileName = tkFileDialog.askopenfilename(
		title="Import To @file",filetypes=types)
	if fileName and len(fileName) &gt; 0:
		c = self.commands
		paths = [fileName] # alas, askopenfilename returns only a single name.
		c.importCommands.importFilesCommand (paths,"@file")
</t>
<t tx="T993">def OnImportCWEBFiles (self,event=None):
	
	filetypes = [
		("CWEB files", "*.w"),
		("Text files", "*.txt"),
		("All files", "*")]

	fileName = tkFileDialog.askopenfilename(
		title="Import CWEB Files",filetypes=filetypes,
		defaultextension=".w")
	if fileName and len(fileName) &gt; 0:
		c = self.commands
		paths = [fileName] # alas, askopenfilename returns only a single name.
		c.importCommands.importWebCommand(paths,"cweb")
</t>
<t tx="T994">def OnImportFlattenedOutline (self,event=None):
	
	types = [("Text files","*.txt"), ("All files","*")]
		
	fileName = tkFileDialog.askopenfilename(
		title="Import MORE Text",
		filetypes=types,
		defaultextension=".py")
	if fileName and len(fileName) &gt; 0:
		c = self.commands
		paths = [fileName] # alas, askopenfilename returns only a single name.
		c.importCommands.importFlattenedOutline(paths)
</t>
<t tx="T995">def OnImportNowebFiles (self,event=None):
	
	filetypes = [
		("Noweb files", "*.nw"),
		("Text files", "*.txt"),
		("All files", "*")]

	fileName = tkFileDialog.askopenfilename(
		title="Import Noweb Files",filetypes=filetypes,
		defaultextension=".nw")
	if fileName and len(fileName) &gt; 0:
		c = self.commands
		paths = [fileName] # alas, askopenfilename returns only a single name.
		c.importCommands.importWebCommand(paths,"noweb")
</t>
<t tx="T996">def OnOutlineToCWEB (self,event=None):
	
	filetypes=[
		("CWEB files", "*.w"),
		("Text files", "*.txt"),
		("All files", "*")]

	fileName = tkFileDialog.asksaveasfilename(
		title="Outline To CWEB",filetypes=filetypes,
		initialfile="cweb.w",defaultextension=".w")

	if fileName and len(fileName) &gt; 0:
		c = self.commands
		c.importCommands.outlineToWeb(fileName,"cweb")
</t>
<t tx="T997">def OnOutlineToNoweb (self,event=None):
	
	filetypes=[
		("Noweb files", "*.nw"),
		("Text files", "*.txt"),
		("All files", "*")]

	fileName = tkFileDialog.asksaveasfilename(
		title="Outline To Noweb",filetypes=filetypes,
		initialfile=self.outlineToNowebDefaultFileName,defaultextension=".nw")

	if fileName and len(fileName) &gt; 0:
		c = self.commands
		c.importCommands.outlineToWeb(fileName,"noweb")
		self.outlineToNowebDefaultFileName = fileName
</t>
<t tx="T998">def OnRemoveSentinels (self,event=None):
	
	types = [
		("All files","*"),
		("C/C++ files","*.c"),
		("C/C++ files","*.cpp"),
		("C/C++ files","*.h"),
		("C/C++ files","*.hpp"),
		("Java files","*.java"),
		("Pascal files","*.pas"),
		("Python files","*.py") ]
		
	fileName = tkFileDialog.askopenfilename(
		title="Remove Sentinels",filetypes=types)

	if fileName and len(fileName) &gt; 0:
		c = self.commands
		# alas, askopenfilename returns only a single name.
		c.importCommands.removeSentinelsCommand (fileName)
</t>
<t tx="T999">def OnWeave (self,event=None):
	
	filetypes = [("Text files", "*.txt"),("All files", "*")]

	fileName = tkFileDialog.asksaveasfilename(
		title="Weave",filetypes=filetypes,
		initialfile="weave.txt",defaultextension=".txt")

	if fileName and len(fileName) &gt; 0:
		c = self.commands
		c.importCommands.weave(fileName)
</t>
<t tx="T1000"></t>
<t tx="T1001"></t>
<t tx="T1002">def OnUndo(self,event=None):

	self.commands.undoer.undo()
</t>
<t tx="T1003">def OnRedo(self,event=None):

	self.commands.undoer.redo()
</t>
<t tx="T1004"></t>
<t tx="T1005">def OnCut (self,event=None):

	# Activate the body key handler by hand.
	c = self.commands ; v = c.currentVnode()
	self.commands.tree.onBodyWillChange(v,"Cut")

def OnCutFromMenu (self,event=None):

	w = self.getFocus()
	w.event_generate(virtual_event_name("Cut"))
	
	# 11/2/02: Make sure the event sticks.
	c = self.commands ; v = c.currentVnode()
	c.tree.onHeadChanged(v) # Works even if it wasn't the headline that changed.
</t>
<t tx="T1006">def OnCopy (self,event=None):

	# Copy never changes dirty bits or syntax coloring.
	pass
	
def OnCopyFromMenu (self,event=None):

	# trace()
	w = self.getFocus()
	w.event_generate(virtual_event_name("Copy"))
</t>
<t tx="T1007">def OnPaste (self,event=None):

	# Activate the body key handler by hand.
	c = self.commands ; v = c.currentVnode()
	self.commands.tree.onBodyWillChange(v,"Paste")
	
def OnPasteNode (self,event=None):

	# trace(`event`)
	pass
	
def OnPasteFromMenu (self,event=None):

	w = self.getFocus()
	w.event_generate(virtual_event_name("Paste"))
	
	# 10/23/02: Make sure the event sticks.
	c = self.commands ; v = c.currentVnode()
	c.tree.onHeadChanged(v) # Works even if it wasn't the headline that changed.
</t>
<t tx="T1008">def OnDelete(self,event=None):

	c = self.commands ; v = c.currentVnode()
	first, last = oldSel = getTextSelection(self.body)
	if first and last and first != last:
		self.body.delete(first,last)
		c.tree.onBodyChanged(v,"Delete",oldSel=oldSel)
</t>
<t tx="T1009">@ This executes body text as a Python script.  We execute the selected text, or the entire body text if no text is selected.
@c

def OnExecuteScript(self,event=None,v=None):
	
	c = self.commands ; body = self.body ; s = None
	if v == None:
		v = c.currentVnode() 

	# Assume any selected body text is a script.
	start,end = getTextSelection(body)
	if start and end and start != end:
		s = body.get(start,end)
	else:
		s = body.get("1.0","end")
	if s == None:
		s = ""
		
	s = s.strip()
	if s and len(s) &gt; 0:
		s += '\n' # Make sure we end the script properly.
		try:
			# 12/11/02: Use {} to get a pristine environment!
			exec s in {}
		except:
			es("exception executing script")
			es_exception(full=false)
	else:
		es("no script selected")</t>
<t tx="T1010">def OnGoToLineNumber (self,event=None):

	c = self.commands
	&lt;&lt; set root to the nearest @file, @silentfile or @rawfile ancestor node &gt;&gt;
	&lt;&lt; read the file into lines &gt;&gt;
	&lt;&lt; get n, the line number, from a dialog &gt;&gt;
	# trace("n:"+`n`)
	if n==1:
		v = root ; n2 = 1 ; found = true
	elif n &gt;= len(lines):
		v = root ; found = false
		n2 = v.bodyString().count('\n')
	elif root.isAtSilentFileNode():
		&lt;&lt; count outline lines, setting v,n2,found &gt;&gt;
	else:
		# To do: choose a "suitable line" for searching.
		vnodeName,childIndex,n2 = self.convertLineToVnodeNameIndexLine(lines,n,root)
		found = true
		if not vnodeName:
			es("invalid derived file: " + fileName)
			return
		&lt;&lt; set v to the node given by vnodeName and childIndex &gt;&gt;
	# To do: search for the "suitable line".
	&lt;&lt; select v and make it visible &gt;&gt;
	&lt;&lt; put the cursor on line n2 of the body text &gt;&gt;</t>
<t tx="T1011">v = c.currentVnode()
fileName = None
while v and not fileName:
	if v.isAtFileNode():
		fileName = v.atFileNodeName()
	elif v.isAtSilentFileNode():
		fileName = v.atSilentFileNodeName()
	elif v.isAtRawFileNode():
		fileName = v.atRawFileNodeName()
	else:
		v = v.parent()

root = v
if not root:
	es("no @file node found") ; return</t>
<t tx="T1012"># 1/26/03: calculate the full path.
d = scanDirectives(c)
path = d.get("path")
fileName = os.path.join(path,fileName)

try:
	file=open(fileName)
	lines = file.readlines()
	file.close()
except:
	es("not found: " + fileName)
	return
	
</t>
<t tx="T1013">import leoDialog

d = leoDialog.askOkCancelNumber("Enter Line Number","Line number:")
n = d.run(modal=true)
if n == -1:
	return</t>
<t tx="T1014">v = lastv = root ; after = root.nodeAfterTree()
prev = 0 ; found = false
while v and v != after:
	lastv = v
	s = v.bodyString()
	lines = s.count('\n')
	if len(s) &gt; 0 and s[-1] != '\n':
		lines += 1
	# print lines,prev,v
	if prev + lines &gt;= n:
		found = true ; break
	prev += lines
	v = v.threadNext()

v = lastv
n2 = max(1,n-prev)</t>
<t tx="T1015">after = root.nodeAfterTree()
while v and v != after:
	if v.matchHeadline(vnodeName):
		if childIndex == 0 or v.childIndex() + 1 == childIndex:
			break
	v = v.threadNext()

if not v or v == after:
	es("not found: %s" % vnodeName )
	return</t>
<t tx="T1016">c.beginUpdate()
c.tree.expandAllAncestors(v)
c.selectVnode(v)
c.endUpdate()</t>
<t tx="T1017">if found:
	c.frame.body.mark_set("insert",str(n2)+".0 linestart")
else:
	c.frame.body.mark_set("insert","end-1c")
	es("%d lines" % len(lines), color="blue")</t>
<t tx="T1018">@ We count "real" lines in the derived files, ignoring all sentinels that do not arise from source lines.  When the indicated line is found, we scan backwards for an @+body line, get the vnode's name from that line and set v to the indicated vnode.  This will fail if vnode names have been changed, and that can't be helped.

Returns (vnodeName,offset)

vnodeName: the name found in the previous @+body sentinel.
offset: the offset within v of the desired line.
@c

def convertLineToVnodeNameIndexLine (self,lines,n,root):
	
	"""Convert a line number n to a vnode name, child index and line number."""
	
	childIndex = 0
	&lt;&lt; set delim, leoLine from the @+leo line &gt;&gt;
	if not delim:
		es("bad @+leo sentinel")
		return None,None
	&lt;&lt; scan back to @+node, setting offset,nodeSentinelLine &gt;&gt;
	if nodeSentinelLine == -1:
		# The line precedes the first @+node sentinel
		# trace("before first line")
		return root.headString(),0,1
	s = lines[nodeSentinelLine]
	# trace(s)
	&lt;&lt; set vnodeName and childIndex from s &gt;&gt;
	# trace("childIndex,offset",childIndex,offset,vnodeName)
	return vnodeName,childIndex,offset</t>
<t tx="T1019"># Find the @+leo line.
tag = "@+leo"
i = 0 
while i &lt; len(lines) and lines[i].find(tag)==-1:
	i += 1
leoLine = i # Index of the line containing the leo sentinel
# trace("leoLine:"+`leoLine`)

delim = None # All sentinels start with this.
if leoLine &lt; len(lines):
	# The opening comment delim is the initial non-whitespace.
	s = lines[leoLine]
	i = skip_ws(s,0)
	j = s.find(tag)
	delim = s[i:j]
	if len(delim)==0:
		delim=None
	else:
		delim += '@'</t>
<t tx="T1020">offset = 0 # This is essentially the Tk line number.
nodeSentinelLine = -1
line = n - 1
while line &gt;= 0:
	s = lines[line]
	# trace(`s`)
	i = skip_ws(s,0)
	if match(s,i,delim):
		&lt;&lt; handle delim while scanning backward &gt;&gt;
	else:
		offset += 1 # Assume the line is real.  A dubious assumption.
	line -= 1</t>
<t tx="T1021">if line == n:
	es("line "+str(n)+" is a sentinel line")
i += len(delim)

if match(s,i,"-node"):
	# The end of a nested section.
	line = self.skipToMatchingNodeSentinel(lines,line,delim)
elif match(s,i,"+node"):
	nodeSentinelLine = line
	break
elif match(s,i,"&lt;&lt;") or match(s,i,"@first"):
	offset += 1 # Count these as a "real" lines.</t>
<t tx="T1022"># vnode name is everything following the third ':'

# trace("last body:"+`s`)
vnodeName = None
i = 0 ; colons = 0
while i &lt; len(s) and colons &lt; 3:
	if s[i] == ':':
		colons += 1
		if colons == 1 and i+1 &lt; len(s) and s[i+1] in string.digits:
			junk,childIndex = skip_long(s,i+1)
	i += 1

vnodeName = s[i:].strip()
# trace("vnodeName:"+`vnodeName`)

if len(vnodeName) == 0:
	vnodeName = None
if not vnodeName:
	es("bad @+node sentinel")</t>
<t tx="T1023">def skipToMatchingNodeSentinel (self,lines,n,delim):
	
	s = lines[n]
	i = skip_ws(s,0)
	assert(match(s,i,delim))
	i += len(delim)
	if match(s,i,"+node"):
		start="+node" ; end="-node" ; delta=1
	else:
		assert(match(s,i,"-node"))
		start="-node" ; end="+node" ; delta=-1
	# Scan to matching @+-node delim.
	n += delta ; level = 0
	while 0 &lt;= n &lt; len(lines):
		s = lines[n] ; i = skip_ws(s,0)
		if match(s,i,delim):
			i += len(delim)
			if match(s,i,start):
				level += 1
			elif match(s,i,end):
				if level == 0: break
				else: level -= 1
		n += delta # bug fix: 1/30/02
		
	# trace(n)
	return n</t>
<t tx="T1024">def OnSelectAll(self,event=None):

	setTextSelection(self.body,"1.0","end")
</t>
<t tx="T1025">def OnFontPanel(self,event=None):

	if self.fontPanel:
		# trace()
		self.fontPanel.top.deiconify()
		self.fontPanel.top.lift()
	else:
		self.fontPanel = fp =  leoFontPanel.leoFontPanel(self.commands)
		fp.run()
</t>
<t tx="T1026">def OnColorPanel(self,event=None):
	
	if self.colorPanel:
		# trace()
		self.colorPanel.top.deiconify()
		self.colorPanel.top.lift()
	else:
		self.colorPanel = cp = leoColor.leoColorPanel(self.commands)
		cp.run()

</t>
<t tx="T1027">def OnViewAllCharacters (self, event=None):

	c = self.commands ; v = c.currentVnode() ; colorizer = c.tree.colorizer
	colorizer.showInvisibles = choose(colorizer.showInvisibles,0,1)
	# print `colorizer.showInvisibles`

	# It is much easier to change the menu name here than in the menu updater.
	menu = self.getMenu("Edit")
	if colorizer.showInvisibles:
		setMenuLabel(menu,"Show Invisibles","Hide Invisibles")
	else:
		setMenuLabel(menu,"Hide Invisibles","Show Invisibles")

	c.tree.recolor_now(v)
</t>
<t tx="T1028">def OnPreferences(self,event=None):
	
	c = self.commands
	if self.prefsPanel:
		# trace()
		self.prefsPanel.top.deiconify()
		self.prefsPanel.top.lift()
	else:
		self.prefsPanel = prefs = leoPrefs.LeoPrefs(c)
		top = prefs.top
		center_dialog(top)

		if 0: # No need to make this modal
			top.grab_set() # Make the dialog a modal dialog.
			top.focus_set() # Get all keystrokes.
			app().root.wait_window(top)
</t>
<t tx="T1029"></t>
<t tx="T1030">def OnConvertBlanks(self,event=None):

	self.commands.convertBlanks()

	
def OnConvertAllBlanks(self,event=None):

	self.commands.convertAllBlanks()
</t>
<t tx="T1031">def OnConvertTabs(self,event=None):

	self.commands.convertTabs()
	
def OnConvertAllTabs(self,event=None):

	self.commands.convertAllTabs()

def OnReformatParagraph(self,event=None):
	
	self.commands.reformatParagraph()
</t>
<t tx="T1032">def OnDedent (self,event=None):

	self.commands.dedentBody()
</t>
<t tx="T1033">def OnExtract(self,event=None):

	self.commands.extract()
</t>
<t tx="T1034">def OnExtractNames(self,event=None):

	self.commands.extractSectionNames()
</t>
<t tx="T1035">def OnExtractSection(self,event=None):

	self.commands.extractSection()
</t>
<t tx="T1036">def OnFindMatchingBracket (self,event=None):
	
	c = self ; body = c.body
	brackets = "()[]{}&lt;&gt;"
	ch1=body.get("insert -1c")
	ch2=body.get("insert")

	# Prefer to match the character to the left of the cursor.
	if ch1 in brackets:
		ch = ch1 ; index = body.index("insert -1c")
	elif ch2 in brackets:
		ch = ch2 ; index = body.index("insert")
	else:
		return
	
	index2 = self.findMatchingBracket(ch,body,index)
	if index2:
		if body.compare(index,"&lt;=",index2):
			setTextSelection(self.body,index,index2+"+1c")
		else:
			setTextSelection(self.body,index2,index+"+1c")
		body.mark_set("insert",index2+"+1c")
		body.see(index2+"+1c")
	else:
		es("unmatched " + `ch`)
</t>
<t tx="T1037"># Test  unmatched())
def findMatchingBracket(self,ch,body,index):

	open_brackets  = "([{&lt;"
	close_brackets = ")]}&gt;"
	brackets = open_brackets + close_brackets
	matching_brackets = close_brackets + open_brackets
	forward = ch in open_brackets
	# Find the character matching the initial bracket.
	for n in xrange(len(brackets)):
		if ch == brackets[n]:
			match_ch = matching_brackets[n]
			break
	level = 0
	while 1:
		if (forward and body.compare(index, "&gt;=", "end")):
			return None
		if (not forward and body.compare(index,"&lt;=","1.0")):
			return None
		ch2 = body.get(index)
		if ch2 == ch: level += 1
		if ch2 == match_ch:
			level -= 1
			if level &lt;= 0:
				return index
		index = index + choose(forward,"+1c","-1c")
		index = body.index(index)
	return 0 # unreachable: keeps pychecker happy.
# Test  (
# ([(x){y}]))
# Test  ((x)(unmatched</t>
<t tx="T1038">def OnIndent(self,event=None):

	self.commands.indentBody()
</t>
<t tx="T1039">def OnInsertBodyTime (self,event=None):
	
	c = self.commands ; v = c.currentVnode()
	sel1,sel2 = oldSel = getTextSelection(c.body)
	if sel1 and sel2 and sel1 != sel2: # 7/7/03
		c.body.delete(sel1,sel2)
	c.body.insert("insert",self.getTime(body=true))
	c.tree.onBodyChanged(v,"Typing",oldSel=oldSel)
	
def OnInsertHeadlineTime (self,event=None):

	c = self.commands ; v = c.currentVnode()
	s = v.headString() # Remember the old value.

	if v.edit_text():
		sel1,sel2 = getTextSelection(v.edit_text())
		if sel1 and sel2 and sel1 != sel2: # 7/7/03
			v.edit_text().delete(sel1,sel2)
		v.edit_text().insert("insert",self.getTime(body=false))
		c.tree.idle_head_key(v)
		
	# A kludge to get around not knowing whether we are editing or not.
	if s.strip() == v.headString().strip():
		es("Edit headline to append date/time")</t>
<t tx="T1040">def getTime (self,body=true):
	
	import time
	
	config = app().config
	default_format =  "%m/%d/%Y %H:%M:%S" # E.g., 1/30/2003 8:31:55
	
	# Try to get the format string from leoConfig.txt.
	if body:
		format = config.getWindowPref("body_time_format_string")
		gmt = config.getBoolWindowPref("body_gmt_time")
	else:
		format = config.getWindowPref("headline_time_format_string")
		gmt = config.getBoolWindowPref("headline_gmt_time")

	if format == None:
		format = default_format

	try:
		if gmt:
			s = time.strftime(format,time.gmtime())
		else:
			s = time.strftime(format,time.localtime())
	except:
		es_exception() # Probably a bad format string in leoConfig.txt.
		s = time.strftime(default_format,time.gmtime())
	return s
</t>
<t tx="T1041"></t>
<t tx="T1042">def OnEditHeadline(self,event=None):

	tree = self.commands.tree
	tree.editLabel(tree.currentVnode)</t>
<t tx="T1043">def OnEndEditHeadline(self,event=None):
	
	tree = self.commands.tree
	tree.endEditLabelCommand()
</t>
<t tx="T1044">def OnAbortEditHeadline(self,event=None):
	
	tree = self.commands.tree
	tree.abortEditLabelCommand()
</t>
<t tx="T1045">def OnToggleAngleBrackets (self,event=None):
	
	c = self.commands ; v = c.currentVnode()
	s = v.headString().strip()
	if (s[0:2] == "&lt;&lt;"
		or s[-2:] == "&gt;&gt;"): # Must be on separate line.
		if s[0:2] == "&lt;&lt;": s = s[2:]
		if s[-2:] == "&gt;&gt;": s = s[:-2]
		s = s.strip()
	else:
		s = angleBrackets(' ' + s + ' ')
	
	c.tree.editLabel(v)
	if v.edit_text():
		v.edit_text().delete("1.0","end")
		v.edit_text().insert("1.0",s)
		c.tree.onHeadChanged(v)
</t>
<t tx="T1046"></t>
<t tx="T1047">def OnFindPanel(self,event=None):

	c = self.commands

	find = app().findFrame
	# 15-SEP-2002 DTHEIN: call withdraw() to force findFrame to top after 
	#                     opening multiple Leo files.
	find.top.withdraw()
	find.top.deiconify()
	find.top.lift()
	
	t = find.find_text
	set_focus(c,t)
	setTextSelection (t,"1.0","end") # Thanks Rich.
	find.commands = self
</t>
<t tx="T1048">def OnFindNext(self,event=None):

	c = self.commands
	app().findFrame.findNextCommand(c)
</t>
<t tx="T1049">def OnFindPrevious(self,event=None):

	c = self.commands
	app().findFrame.findPreviousCommand(c)
</t>
<t tx="T1050">def OnReplace(self,event=None):

	c = self.commands
	app().findFrame.changeCommand(c)
</t>
<t tx="T1051">def OnReplaceThenFind(self,event=None):

	c = self.commands
	app().findFrame.changeThenFindCommand(c)
</t>
<t tx="T1052"></t>
<t tx="T1053"></t>
<t tx="T1054">def OnCutNode(self,event=None):

	self.commands.cutOutline()
</t>
<t tx="T1055">def OnCopyNode(self,event=None):

	self.commands.copyOutline()
</t>
<t tx="T1056">def OnPasteNode(self,event=None):

	self.commands.pasteOutline()
</t>
<t tx="T1057">def OnDeleteNode(self,event=None):

	self.commands.deleteHeadline()
</t>
<t tx="T1058">def OnInsertNode(self,event=None):

	self.commands.insertHeadline()</t>
<t tx="T1059">def OnCloneNode(self,event=None):

	self.commands.clone()
</t>
<t tx="T1060">def OnSortChildren(self,event=None):

	self.commands.sortChildren()
	
def OnSortSiblings(self,event=None):

	self.commands.sortSiblings()</t>
<t tx="T1061"></t>
<t tx="T1062"></t>
<t tx="T1063">def OnContractChildren(self,event=None):

	self.commands.contractSubheads()
</t>
<t tx="T1064">def OnContractAllChildren(self,event=None):

	self.commands.contractAllSubheads()
</t>
<t tx="T1065">def OnExpandAllChildren(self,event=None):

	self.commands.expandAllSubheads()
</t>
<t tx="T1066">def OnExpandChildren(self,event=None):

	self.commands.expandSubheads()
</t>
<t tx="T1067">def OnContractAll(self,event=None):

	self.commands.contractAllHeadlines()
</t>
<t tx="T1068">def OnContractNode(self,event=None):

	self.commands.contractNode()
</t>
<t tx="T1069">def OnContractParent(self,event=None):

	self.commands.contractParent()
</t>
<t tx="T1070">def OnExpandAll(self,event=None):

	self.commands.expandAllHeadlines()
</t>
<t tx="T1071">def OnExpandNextLevel(self,event=None):

	self.commands.expandNextLevel()
</t>
<t tx="T1072">def OnExpandNode(self,event=None):

	self.commands.expandNode()
</t>
<t tx="T1073">def OnExpandPrevLevel(self,event=None):

	self.commands.expandPrevLevel()
</t>
<t tx="T1074">def OnExpandToLevel1(self,event=None): self.commands.expandLevel1()
def OnExpandToLevel2(self,event=None): self.commands.expandLevel2()
def OnExpandToLevel3(self,event=None): self.commands.expandLevel3()
def OnExpandToLevel4(self,event=None): self.commands.expandLevel4()
def OnExpandToLevel5(self,event=None): self.commands.expandLevel5()
def OnExpandToLevel6(self,event=None): self.commands.expandLevel6()
def OnExpandToLevel7(self,event=None): self.commands.expandLevel7()
def OnExpandToLevel8(self,event=None): self.commands.expandLevel8()
def OnExpandToLevel9(self,event=None): self.commands.expandLevel9()
</t>
<t tx="T1075"></t>
<t tx="T1076">def OnMoveDown(self,event=None):

	self.commands.moveOutlineDown()
</t>
<t tx="T1077">def OnMoveLeft(self,event=None):

	self.commands.moveOutlineLeft()
</t>
<t tx="T1078">def OnMoveRight(self,event=None):

	self.commands.moveOutlineRight()
</t>
<t tx="T1079">def OnMoveUp(self,event=None):

	self.commands.moveOutlineUp()
</t>
<t tx="T1080">def OnPromote(self,event=None):

	self.commands.promote()
</t>
<t tx="T1081">def OnDemote(self,event=None):

	self.commands.demote()
</t>
<t tx="T1082">def OnGoPrevVisible(self,event=None):

	self.commands.selectVisBack()
</t>
<t tx="T1083">def OnGoNextVisible(self,event=None):

	self.commands.selectVisNext()
</t>
<t tx="T1084">def OnGoBack(self,event=None):

	self.commands.selectThreadBack()
</t>
<t tx="T1085">def OnGoNext(self,event=None):

	self.commands.selectThreadNext()
</t>
<t tx="T1086"></t>
<t tx="T1087">def OnGoPrevVisitedNode(self,event=None):
	
	c = self.commands

	while c.beadPointer &gt; 0:
		c.beadPointer -= 1
		v = c.beadList[c.beadPointer]
		if v.exists(c):
			c.beginUpdate()
			c.tree.expandAllAncestors(v)
			c.selectVnode(v,updateBeadList=false)
			c.endUpdate()
			c.tree.idle_scrollTo(v)
			return
</t>
<t tx="T1088">def OnGoNextVisitedNode(self,event=None):
	
	c = self.commands

	while c.beadPointer + 1 &lt; len(c.beadList):
		c.beadPointer += 1
		v = c.beadList[c.beadPointer]
		if v.exists(c):
			c.beginUpdate()
			c.tree.expandAllAncestors(v)
			c.selectVnode(v,updateBeadList=false)
			c.endUpdate()
			c.tree.idle_scrollTo(v)
			return</t>
<t tx="T1089">def OnGoToFirstNode(self,event=None):
	
	c = self.commands
	v = c.rootVnode()
	if v:
		c.beginUpdate()
		c.selectVnode(v)
		c.endUpdate()</t>
<t tx="T1090">def OnGoToLastNode(self,event=None):
	
	c = self.commands
	v = c.rootVnode()
	while v and v.threadNext():
		v = v.threadNext()
	if v:
		c.beginUpdate()
		c.tree.expandAllAncestors(v)
		c.selectVnode(v)
		c.endUpdate()
</t>
<t tx="T1091">def OnGoToNextChanged(self,event=None):

	self.commands.goToNextDirtyHeadline()
</t>
<t tx="T1092">def OnGoToNextClone(self,event=None):

	self.commands.goToNextClone()
</t>
<t tx="T1093">def OnGoToNextMarked(self,event=None):

	self.commands.goToNextMarkedHeadline()
</t>
<t tx="T1094">def OnGoToNextSibling(self,event=None):
	
	c = self.commands
	v = c.currentVnode()
	if not v: return
	next = v.next()
	if next:
		c.beginUpdate()
		c.selectVnode(next)
		c.endUpdate()</t>
<t tx="T1095">def OnGoToParent(self,event=None):
	
	c = self.commands
	v = c.currentVnode()
	if not v: return
	p = v.parent()
	if p:
		c.beginUpdate()
		c.selectVnode(p)
		c.endUpdate()
</t>
<t tx="T1096">def OnGoToPrevSibling(self,event=None):
	
	c = self.commands
	v = c.currentVnode()
	if not v: return
	back = v.back()
	if back:
		c.beginUpdate()
		c.selectVnode(back)
		c.endUpdate()
</t>
<t tx="T1097">def OnMark(self,event=None):

	self.commands.markHeadline()
</t>
<t tx="T1098">def OnMarkChangedItems(self,event=None):

	self.commands.markChangedHeadlines()
</t>
<t tx="T1099">def OnMarkChangedRoots(self,event=None):

	self.commands.markChangedRoots()
</t>
<t tx="T1100">def OnMarkClones(self,event=None):

	self.commands.markClones()
</t>
<t tx="T1101">def OnMarkSubheads(self,event=None):

	self.commands.markSubheads()
</t>
<t tx="T1102">def OnUnmarkAll(self,event=None):

	self.commands.unmarkAll()
</t>
<t tx="T1103"></t>
<t tx="T1104">def OnEqualSizedPanes(self,event=None):

	frame = self

	frame.resizePanesToRatio(0.5,frame.secondary_ratio)
</t>
<t tx="T1105">def OnToggleActivePane (self,event=None):

	# trace(`event`)
	c = self.commands

	if self.getFocus() == self.body:
		set_focus(c,self.canvas)
	else:
		set_focus(c,self.body)</t>
<t tx="T1106"># The key invariant: self.splitVerticalFlag tells the alignment of the main splitter.

def OnToggleSplitDirection(self,event=None):
	# Abbreviations.
	frame = self
	bar1 = self.bar1 ; bar2 = self.bar2
	split1Pane1,split1Pane2 = self.split1Pane1,self.split1Pane2
	split2Pane1,split2Pane2 = self.split2Pane1,self.split2Pane2
	# Switch directions.
	verticalFlag = self.splitVerticalFlag = not self.splitVerticalFlag
	orientation = choose(verticalFlag,"vertical","horizontal")
	app().config.setWindowPref("initial_splitter_orientation",orientation)
	# Reconfigure the bars.
	bar1.place_forget()
	bar2.place_forget()
	self.configureBar(bar1,verticalFlag)
	self.configureBar(bar2,not verticalFlag)
	# Make the initial placements again.
	self.placeSplitter(bar1,split1Pane1,split1Pane2,verticalFlag)
	self.placeSplitter(bar2,split2Pane1,split2Pane2,not verticalFlag)
	# Adjust the log and body panes to give more room around the bars.
	self.reconfigurePanes()
	# Redraw with an appropriate ratio.
	vflag,ratio,secondary_ratio = frame.initialRatios()
	self.resizePanesToRatio(ratio,secondary_ratio)</t>
<t tx="T1107">def OnCascade(self,event=None):
	
	c = self ; x,y,delta = 10,10,10
	for frame in app().windowList:
		top = frame.top
		# Compute w,h
		top.update_idletasks() # Required to get proper info.
		geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
		dim,junkx,junky = string.split(geom,'+')
		w,h = string.split(dim,'x')
		w,h = int(w),int(h)
		# Set new x,y and old w,h
		frame.top.geometry("%dx%d%+d%+d" % (w,h,x,y))
		# Compute the new offsets.
		x += 30 ; y += 30
		if x &gt; 200:
			x = 10 + delta ; y = 40 + delta
			delta += 10
</t>
<t tx="T1108">def OnMinimizeAll(self,event=None):

	self.minimize(app().findFrame)
	self.minimize(app().pythonFrame)
	for frame in app().windowList:
		self.minimize(frame)
	
def minimize(self, frame):

	if frame and frame.top.state() == "normal":
		frame.top.iconify()</t>
<t tx="T1109">def OnHideLogWindow (self):
	
	c = self.commands ; frame = c.frame
	frame.divideLeoSplitter2(0.99, not frame.splitVerticalFlag)</t>
<t tx="T1110">def OnOpenCompareWindow (self,event=None):
	
	c = self.commands
	cp = self.comparePanel
	
	if cp:
		cp.top.deiconify()
		cp.top.lift()
	else:
		cmp = leoCompare.leoCompare(c)
		self.comparePanel = cp =  leoCompare.leoComparePanel(c,cmp)
		cp.run()</t>
<t tx="T1111">def OnOpenPythonWindow(self,event=None):

	if sys.platform == "linux2":
		&lt;&lt; open idle in Linux &gt;&gt;
	else:
		&lt;&lt; open idle in Windows &gt;&gt;
</t>
<t tx="T1112"># 09-SEP-2002 DHEIN: Open Python window under linux

try:
	pathToLeo = os.path.join(app().loadDir,"leo.py")
	sys.argv = [pathToLeo]
	from idlelib import idle
	if app().idle_imported:
		reload(idle)
	app().idle_imported = true
except:
	try:
		es("idlelib could not be imported.")
		es("Probably IDLE is not installed.")
		es("Run Tools/idle/setup.py to build idlelib.")
		es("Can not import idle")
		es_exception() # This can fail!!
	except: pass
</t>
<t tx="T1113">try:
	executable_dir = os.path.dirname(sys.executable)
	idle_dir=os.path.join(executable_dir,"Tools","idle")
	if idle_dir not in sys.path:
		sys.path.append(idle_dir)
	# Initialize argv: the -t option sets the title of the Idle interp window.
	# pathToLeo = os.path.join(app().loadDir,"leo.py")
	sys.argv = ["leo","-t","leo"]
	import PyShell
	if app().idle_imported:
		reload(idle)
		app().idle_imported = true
	if 1: # Mostly works, but causes problems when opening other .leo files.
		PyShell.main()
	else: # Doesn't work: destroys all of Leo when Idle closes.
		self.leoPyShellMain()
except:
	try:
		es("Can not import idle")
		es("Please add " + `idle_dir` + " to sys.path")
		es_exception() # This can fail!!
	except: pass</t>
<t tx="T1114">@ The key parts of Pyshell.main(), but using Leo's root window instead of a new Tk root window.

This does _not_ work.  Using Leo's root window means that Idle will shut down Leo without warning when the Idle window is closed!
@c

def leoPyShellMain(self):
	
	import PyShell
	root = app().root
	PyShell.fixwordbreaks(root)
	flist = PyShell.PyShellFileList(root)
	shell = PyShell.PyShell(flist)
	flist.pyshell = shell
	shell.begin()</t>
<t tx="T1115"></t>
<t tx="T1116">def OnAbout(self,event=None):
	
	# Don't use triple-quoted strings or continued strings here.
	# Doing so would add unwanted leading tabs.
	ver = "$Revision$" # CVS will update this.
	build = ver[10:-1] # Strip off "$Reversion" and "$"
	version = "leo.py 3.12.1 beta 1, Build " + build + ", July 25, 2003\n\n"
	copyright = (
		"Copyright 1999-2003 by Edward K. Ream\n" +
		"All Rights Reserved\n" +
		"Leo is distributed under the Python License")
	url = "http://webpages.charter.net/edreamleo/front.html"
	email = "edreamleo@charter.net"

	import leoDialog
	leoDialog.aboutLeo(version,copyright,url,email).run(modal=false)
</t>
<t tx="T1117">def OnLeoDocumentation (self,event=None):

	fileName = os.path.join(app().loadDir,"..","doc","LeoDocs.leo")
	try:
		self.OpenWithFileName(fileName)
	except:
		es("not found: LeoDocs.leo")
</t>
<t tx="T1118">def OnLeoHome (self,event=None):
	
	import webbrowser

	url = "http://webpages.charter.net/edreamleo/front.html"
	try:
		webbrowser.open_new(url)
	except:
		es("not found: " + url)</t>
<t tx="T1119">def OnLeoHelp (self,event=None):
	
	file = os.path.join(app().loadDir,"..","doc","sbooks.chm")
	if os.path.exists(file):
		os.startfile(file)
	else:
		answer = leoDialog.askYesNo(
			"Download Tutorial?",
			"Download tutorial (sbooks.chm) from SourceForge?").run(modal=true)

		if answer == "yes":
			try:
				if 0: # Download directly.  (showProgressBar needs a lot of work)
					url = "http://umn.dl.sourceforge.net/sourceforge/leo/sbooks.chm"
					import urllib
					self.scale = None
					urllib.urlretrieve(url,file,self.showProgressBar)
					if self.scale:
						self.scale.destroy()
						self.scale = None
				else:
					url = "http://prdownloads.sourceforge.net/leo/sbooks.chm?download"
					import webbrowser
					os.chdir(app().loadDir)
					webbrowser.open_new(url)
			except:
				es("exception dowloading sbooks.chm")
				es_exception()</t>
<t tx="T1120">def showProgressBar (self,count,size,total):

	# trace("count,size,total:" + `count` + "," + `size` + "," + `total`)
	if self.scale == None:
		&lt;&lt; create the scale widget &gt;&gt;
	self.scale.set(count*size)
	self.scale.update_idletasks()</t>
<t tx="T1121">Tk = Tkinter
top = Tk.Toplevel()
top.title("Download progress")
self.scale = scale = Tk.Scale(top,state="normal",orient="horizontal",from_=0,to=total)
scale.pack()
top.lift()</t>
<t tx="T1122">def OnLeoTutorial (self,event=None):
	
	import webbrowser

	if 1: # new url
		url = "http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm"
	else:
		url = "http://www.evisa.com/e/sbooks/leo/sbframetoc_ie.htm"
	try:
		webbrowser.open_new(url)
	except:
		es("not found: " + url)</t>
<t tx="T1123">def OnLeoConfig (self,event=None):

	# 4/21/03 new code suggested by fBechmann@web.de
	loadDir = app().loadDir
	configDir = app().config.configDir
	# Look in configDir first.
	fileName = os.path.join(configDir, "leoConfig.leo")
	ok, frame = self.OpenWithFileName(fileName)
	if not ok:
		if configDir == loadDir:
			es("leoConfig.leo not found in " + loadDir)
		else:
			# Look in loadDir second.
			fileName = os.path.join(loadDir,"leoConfig.leo")
			ok, frame = self.OpenWithFileName(fileName)
			if not ok:
				es("leoConfig.leo not found in " + configDir + " or " + loadDir)
	
def OnApplyConfig (self,event=None):

	app().config.init()
	self.commands.frame.reconfigureFromConfig()</t>
<t tx="T1124">@ The following convenience routines make creating menus easier.

The Plugins section gives examples of how to use these routines to create custom menus and to add items to the Open With menu.
</t>
<t tx="T1125">@ The old, non-user-configurable code bound shortcuts in createMenuBar.  The new user-configurable code binds shortcuts here.

Centralized tables of shortscuts no longer exist as they did in createAccelerators.  To check for duplicates, (possibly arising from leoConfig.txt) we add entries to a central dictionary here, and report duplicates if an entry for a canonicalized shortcut already exists.
@c

def createMenuEntries (self,menu,table,openWith=0):
	
	for label,accel,command in table:
		if label == None or command == None or label == "-":
			menu.add_separator()
		else:
			&lt;&lt; set name to the label for doCommand &gt;&gt;
			&lt;&lt; set accel to the shortcut for name &gt;&gt;
			&lt;&lt; set bind_shortcut and menu_shortcut using accel &gt;&gt;
			&lt;&lt; define callback function &gt;&gt;
			&lt;&lt; set realLabel, amp_index and menu_shortcut &gt;&gt;

			menu.add_command(label=realLabel,accelerator=menu_shortcut,
				command=callback,underline=amp_index)

			if bind_shortcut:
				&lt;&lt; handle bind_shorcut &gt;&gt;</t>
<t tx="T1126">name = label.strip().lower()

# Remove special characters from command names.
name2 = ""
for ch in name:
	if ch in string.letters or ch in string.digits:
		name2 = name2 + ch
name = name2
</t>
<t tx="T1127">config = app().config
accel2 = config.getShortcut(name)

# 7/19/03: Make sure "None" overrides the default shortcut.
if accel2 == None or len(accel2) == 0:
	pass # Use default shortcut, if any.
elif accel2.lower() == "none":
	accel = None # Remove the default shortcut.
else:
	accel = accel2 # Override the default shortcut.</t>
<t tx="T1128">bind_shortcut,menu_shortcut = self.canonicalizeShortcut(accel)

# Kludge: disable the shortcuts for cut, copy, paste.
# This has already been bound in leoFrame.__init__
# 2/13/03: A _possible_ fix for the Linux control-v bug.

if sys.platform not in ("linux1","linux2"):
	if bind_shortcut in ("&lt;Control-c&gt;","&lt;Control-v&gt;","&lt;Control-x&gt;"):
		bind_shortcut = None</t>
<t tx="T1129">@ Tkinter will call the callback function with:

	- one event argument if the user uses a menu shortcut.
	- no arguments otherwise.

Therefore, the first parameter must be event, and it must default to None.
@c

if openWith:
	def callback(event=None,self=self,data=command):
		# print "event",`event` ; print "self",`self` ; print "data",`data`
		return self.OnOpenWith(data=data)
		
else:
	def callback(event=None,self=self,command=command,label=name):
		# print "event",`event` ; print "self",`self` ; print "command",`command`
		return self.doCommand(command,label,event)</t>
<t tx="T1130">realLabel = app().getRealMenuName(label)
amp_index = realLabel.find("&amp;")
realLabel = realLabel.replace("&amp;","")
if not menu_shortcut:
	menu_shortcut = ""</t>
<t tx="T1131">if bind_shortcut in self.menuShortcuts:
	if not app().menuWarningsGiven:
		es("duplicate shortcut:", accel, bind_shortcut, label,color="red")
		print "duplicate shortcut:", accel, bind_shortcut, label
else:
	self.menuShortcuts.append(bind_shortcut)
	try:
		self.body.bind(bind_shortcut,callback)
		self.top.bind (bind_shortcut,callback)
	except: # could be a user error
		if not app().menuWarningsGiven:
			print "exception binding menu shortcut..."
			print bind_shortcut
			es_exception()
			app().menuWarningsGive = true</t>
<t tx="T1132">def createMenuItemsFromTable (self,menuName,table,openWith=0):
	
	try:
		menu = self.getMenu(menuName)
		if menu == None:
			print "menu does not exist: ", menuName
			es("menu does not exist: " + `menuName`)
			return
		self.createMenuEntries(menu,table,openWith)
	except:
		print "exception creating items for ", menuName," menu"
		es("exception creating items for " + `menuName` + " menu")
		es_exception()</t>
<t tx="T1133">def createNewMenu (self,menuName,parentName="top",before=None):
	
	import Tkinter
	from leoGlobals import app
	try:
		parent = self.getMenu(parentName)
		if parent == None:
			es("unknown parent menu: " + parentName)
			return None
			
		menu = self.getMenu(menuName)
		if menu:
			es("menu already exists: " + menuName,color="red")
		else:
			menu = Tkinter.Menu(parent,tearoff=0)
			self.setMenu(menuName,menu)
			label=app().getRealMenuName(menuName)
			amp_index = label.find("&amp;")
			label = label.replace("&amp;","")
			if before: # Insert the menu before the "before" menu.
				index_label=app().getRealMenuName(before)
				amp_index = index_label.find("&amp;")
				index_label = index_label.replace("&amp;","")
				index = parent.index(index_label)
				parent.insert_cascade(index=index,label=label,menu=menu,underline=amp_index)
			else:
				parent.add_cascade(label=label,menu=menu,underline=amp_index)
			return menu
	except:
		es("exception creating " + menuName + " menu")
		es_exception()
		return None</t>
<t tx="T1134">@ Entries in the table passed to createOpenWithMenuFromTable are
tuples of the form (commandName,shortcut,data).

- command is one of "os.system", "os.startfile", "os.spawnl", "os.spawnv" or "exec".
- shortcut is a string describing a shortcut, just as for createMenuItemsFromTable.
- data is a tuple of the form (command,arg,ext).

Leo executes command(arg+path) where path is the full path to the temp file.
If ext is not None, the temp file has the given extension.
Otherwise, Leo computes an extension based on the @language directive in effect.
@c

def createOpenWithMenuFromTable (self,table):

	a = app()
	a.openWithTable = table # Override any previous table.
	# Delete the previous entry.
	parent = self.getMenu("File")
	label=a.getRealMenuName("Open &amp;With...")
	amp_index = label.find("&amp;")
	label = label.replace("&amp;","")
	try:
		index = parent.index(label)
		parent.delete(index)
	except:
		try:
			index = parent.index("Open With...")
			parent.delete(index)
		except: return
	# Create the "Open With..." menu.
	openWithMenu = Tkinter.Menu(parent,tearoff=0)
	self.setMenu("Open With...",openWithMenu)
	parent.insert_cascade(index,label=label,menu=openWithMenu,underline=amp_index)
	# Populate the "Open With..." menu.
	shortcut_table = []
	for triple in table:
		if len(triple) == 3: # 6/22/03
			shortcut_table.append(triple)
		else:
			es("createOpenWithMenuFromTable: invalid data",color="red")
			return
			
	# for i in shortcut_table: print i
	self.createMenuItemsFromTable("Open &amp;With...",shortcut_table,openWith=1)
</t>
<t tx="T1135">def deleteMenu (self,menuName):

	try:
		menu = self.getMenu(menuName)
		if menu:
			menu.destroy()
			self.destroyMenu(menuName)
		else:
			es("can't delete menu: " + menuName)
	except:
		es("exception deleting " + menuName + " menu")
		es_exception()</t>
<t tx="T1136"># Delete itemName from the menu whose name is menuName.
def deleteMenuItem (self,itemName,menuName="top"):

	from leoGlobals import app
	try:
		menu = self.getMenu(menuName)
		if menu:
			realItemName=app().getRealMenuName(itemName)
			menu.delete(realItemName)
		else:
			es("menu not found: " + menuName)
	except:
		es("exception deleting " + itemName + " from " + menuName + " menu")
		es_exception()</t>
<t tx="T1137">def setRealMenuNamesFromTable (self,table):

	try:
		app().setRealMenuNamesFromTable(table)
	except:
		es("exception in setRealMenuNamesFromTable")
		es_exception()
</t>
<t tx="T1138"></t>
<t tx="T1139"># This is the Tk "postcommand" callback.  It should update all menu items.

def OnMenuClick (self):
	
	# A horrible kludge: set app().log to cover for a possibly missing activate event.
	app().setLog(self,"OnMenuClick")
	
	# Allow the user first crack at updating menus.
	c = self.commands ; v = c.currentVnode() # 2/8/03
	if not doHook("menu2",c=c,v=v):
		self.updateFileMenu()
		self.updateEditMenu()
		self.updateOutlineMenu()

</t>
<t tx="T1140"># Returns true if text in the outline or body text is selected.

def hasSelection (self):

	if self.body:
		first, last = getTextSelection(self.body)
		return first != last
	else:
		return false</t>
<t tx="T1141">def updateFileMenu (self):
	
	c = self.commands
	if not c: return

	try:
		menu = self.getMenu("File")
		enableMenu(menu,"Revert To Saved", c.canRevert())

		openWithMenu = self.getMenu("Open With...")
		enableMenu(menu,"Open With...", app().hasOpenWithMenu)
		
	except:
		es("exception updating File menu")
		es_exception()
</t>
<t tx="T1142">def updateEditMenu (self):

	c = self.commands
	if not c: return
	try:
		# Top level Edit menu...
		menu = self.getMenu("Edit")
		c.undoer.enableMenuItems()
		if 0: # Always on for now.
			enableMenu(menu,"Cut",c.canCut())
			enableMenu(menu,"Copy",c.canCut())
			enableMenu(menu,"Paste",c.canPaste())
		if 0: # Always on for now.
			menu = self.getMenu("Find...")
			enableMenu(menu,"Find Next",c.canFind())
			flag = c.canReplace()
			enableMenu(menu,"Replace",flag)
			enableMenu(menu,"Replace, Then Find",flag)
		# Edit Body submenu...
		menu = self.getMenu("Edit Body...")
		enableMenu(menu,"Extract Section",c.canExtractSection())
		enableMenu(menu,"Extract Names",c.canExtractSectionNames())
		enableMenu(menu,"Extract",c.canExtract())
		enableMenu(menu,"Match Brackets",c.canFindMatchingBracket())
	except:
		es("exception updating Edit menu")
		es_exception()</t>
<t tx="T1143">def updateOutlineMenu (self):

	c = self.commands ; v = c.currentVnode()
	if not c: return
	try:
		# Top level outline menu...
		menu = self.getMenu("Outline")
		enableMenu(menu,"Cut Node",c.canCutOutline())
		enableMenu(menu,"Delete Node",c.canDeleteHeadline())
		enableMenu(menu,"Paste Node",c.canPasteOutline())
		enableMenu(menu,"Sort Siblings",c.canSortSiblings())
		# Expand/Contract submenu...
		menu = self.getMenu("Expand/Contract...")
		hasChildren = v.hasChildren()
		isExpanded = v.isExpanded()
		enableMenu(menu,"Contract Parent",c.canContractParent())
		enableMenu(menu,"Contract Node",hasChildren and isExpanded)
		enableMenu(menu,"Expand Node",hasChildren and not isExpanded)
		enableMenu(menu,"Expand Prev Level",hasChildren and isExpanded)
		enableMenu(menu,"Expand Next Level",hasChildren)
		enableMenu(menu,"Expand To Level 1",hasChildren and isExpanded)
		for i in xrange(2,9):
			enableMenu(menu,"Expand To Level " + str(i), hasChildren)
		# Move submenu...
		menu = self.getMenu("Move...")
		enableMenu(menu,"Move Down",c.canMoveOutlineDown())
		enableMenu(menu,"Move Left",c.canMoveOutlineLeft())
		enableMenu(menu,"Move Right",c.canMoveOutlineRight())
		enableMenu(menu,"Move Up",c.canMoveOutlineUp())
		enableMenu(menu,"Promote",c.canPromote())
		enableMenu(menu,"Demote",c.canDemote())
		# Go To submenu
		menu = self.getMenu("Go To...")
		enableMenu(menu,"Go Back",c.beadPointer &gt; 1)
		enableMenu(menu,"Go Forward",c.beadPointer + 1 &lt; len(c.beadList))
		enableMenu(menu,"Go To Prev Visible",c.canSelectVisBack())
		enableMenu(menu,"Go To Next Visible",c.canSelectVisNext())
		enableMenu(menu,"Go To Next Marked",c.canGoToNextMarkedHeadline())
		enableMenu(menu,"Go To Next Changed",c.canGoToNextDirtyHeadline())
		enableMenu(menu,"Go To Next Clone",v.isCloned())
		enableMenu(menu,"Go To Prev Node",c.canSelectThreadBack())
		enableMenu(menu,"Go To Next Node",c.canSelectThreadNext())
		enableMenu(menu,"Go To Parent",v.parent() != None)
		enableMenu(menu,"Go To Prev Sibling",v.back() != None)
		enableMenu(menu,"Go To Next Sibling",v.next() != None)
		# Mark submenu
		menu = self.getMenu("Mark/Unmark...")
		label = choose(v and v.isMarked(),"Unmark","Mark")
		setMenuLabel(menu,0,label)
		enableMenu(menu,"Mark Subheads",(v and v.hasChildren()))
		enableMenu(menu,"Mark Changed Items",c.canMarkChangedHeadlines())
		enableMenu(menu,"Mark Changed Roots",c.canMarkChangedRoots())
		enableMenu(menu,"Mark Clones",v.isCloned())
	except:
		es("exception updating Outline menu")
		es_exception()</t>
<t tx="T1144">@ The key invariants used throughout this code:

1. self.splitVerticalFlag tells the alignment of the main splitter and
2. not self.splitVerticalFlag tells the alignment of the secondary splitter.

Only the general-purpose divideAnySplitter routine doesn't know about these invariants.  So most of this code is specialized for Leo's window.  OTOH, creating a single splitter window would be much easier than this code.
</t>
<t tx="T1145">def resizePanesToRatio(self,ratio,secondary_ratio):

	self.divideLeoSplitter(self.splitVerticalFlag, ratio)
	self.divideLeoSplitter(not self.splitVerticalFlag, secondary_ratio)
	# trace(`ratio`)
</t>
<t tx="T1146">def bindBar (self, bar, verticalFlag):
	
	if verticalFlag == self.splitVerticalFlag:
		bar.bind("&lt;B1-Motion&gt;", self.onDragMainSplitBar)

	else:
		bar.bind("&lt;B1-Motion&gt;", self.onDragSecondarySplitBar)
</t>
<t tx="T1147"># 5/20/03: Removed the ancient kludge for forcing the height &amp; width of f.
# The code in leoFileCommands.getGlobals now works!

def createLeoSplitter (self, parent, verticalFlag):
	
	"""Create a splitter window and panes into which the caller packs widgets.
	
	Returns (f, bar, pane1, pane2) """

	Tk = Tkinter
	
	# Create the frames.
	f = Tk.Frame(parent,bd=0,relief="flat")
	f.pack(expand=1,fill="both",pady=1)
	pane1 = Tk.Frame(f)
	pane2 = Tk.Frame(f)
	bar =   Tk.Frame(f,bd=2,relief="raised",bg="LightSteelBlue2")

	# Configure and place the frames.
	self.configureBar(bar,verticalFlag)
	self.bindBar(bar,verticalFlag)
	self.placeSplitter(bar,pane1,pane2,verticalFlag)

	return f, bar, pane1, pane2</t>
<t tx="T1148"># This is the general-purpose placer for splitters.
# It is the only general-purpose splitter code in Leo.

def divideAnySplitter (self, frac, verticalFlag, bar, pane1, pane2):

	if verticalFlag:
		# Panes arranged vertically; horizontal splitter bar
		bar.place(rely=frac)
		pane1.place(relheight=frac)
		pane2.place(relheight=1-frac)
	else:
		# Panes arranged horizontally; vertical splitter bar
		bar.place(relx=frac)
		pane1.place(relwidth=frac)
		pane2.place(relwidth=1-frac)</t>
<t tx="T1149"># Divides the main or secondary splitter, using the key invariant.
def divideLeoSplitter (self, verticalFlag, frac):
	if self.splitVerticalFlag == verticalFlag:
		self.divideLeoSplitter1(frac,verticalFlag)
		self.ratio = frac # Ratio of body pane to tree pane.
	else:
		self.divideLeoSplitter2(frac,verticalFlag)
		self.secondary_ratio = frac # Ratio of tree pane to log pane.

# Divides the main splitter.
def divideLeoSplitter1 (self, frac, verticalFlag): 
	self.divideAnySplitter(frac, verticalFlag,
		self.bar1, self.split1Pane1, self.split1Pane2)

# Divides the secondary splitter.
def divideLeoSplitter2 (self, frac, verticalFlag): 
	self.divideAnySplitter (frac, verticalFlag,
		self.bar2, self.split2Pane1, self.split2Pane2)</t>
<t tx="T1150">def initialRatios (self):

	config = app().config
	s = config.getWindowPref("initial_splitter_orientation")
	verticalFlag = s == None or (s != "h" and s != "horizontal")

	if verticalFlag:
		r = config.getFloatWindowPref("initial_vertical_ratio")
		if r == None or r &lt; 0.0 or r &gt; 1.0: r = 0.5
		r2 = config.getFloatWindowPref("initial_vertical_secondary_ratio")
		if r2 == None or r2 &lt; 0.0 or r2 &gt; 1.0: r2 = 0.8
	else:
		r = config.getFloatWindowPref("initial_horizontal_ratio")
		if r == None or r &lt; 0.0 or r &gt; 1.0: r = 0.3
		r2 = config.getFloatWindowPref("initial_horizontal_secondary_ratio")
		if r2 == None or r2 &lt; 0.0 or r2 &gt; 1.0: r2 = 0.8

	# print (`r`,`r2`)
	return verticalFlag,r,r2</t>
<t tx="T1151">def onDragMainSplitBar (self, event):
	self.onDragSplitterBar(event,self.splitVerticalFlag)

def onDragSecondarySplitBar (self, event):
	self.onDragSplitterBar(event,not self.splitVerticalFlag)

def onDragSplitterBar (self, event, verticalFlag):

	# x and y are the coordinates of the cursor relative to the bar, not the main window.
	bar = event.widget
	x = event.x
	y = event.y
	top = bar.winfo_toplevel()

	if verticalFlag:
		# Panes arranged vertically; horizontal splitter bar
		wRoot	= top.winfo_rooty()
		barRoot = bar.winfo_rooty()
		wMax	= top.winfo_height()
		offset = float(barRoot) + y - wRoot
	else:
		# Panes arranged horizontally; vertical splitter bar
		wRoot	= top.winfo_rootx()
		barRoot = bar.winfo_rootx()
		wMax	= top.winfo_width()
		offset = float(barRoot) + x - wRoot

	# Adjust the pixels, not the frac.
	if offset &lt; 3: offset = 3
	if offset &gt; wMax - 2: offset = wMax - 2
	# Redraw the splitter as the drag is occuring.
	frac = float(offset) / wMax
	# trace(`frac`)
	self.divideLeoSplitter(verticalFlag, frac)</t>
<t tx="T1152">def placeSplitter (self,bar,pane1,pane2,verticalFlag):

	if verticalFlag:
		# Panes arranged vertically; horizontal splitter bar
		pane1.place(relx=0.5, rely =   0, anchor="n", relwidth=1.0, relheight=0.5)
		pane2.place(relx=0.5, rely = 1.0, anchor="s", relwidth=1.0, relheight=0.5)
		bar.place  (relx=0.5, rely = 0.5, anchor="c", relwidth=1.0)
	else:
		# Panes arranged horizontally; vertical splitter bar
		# adj gives tree pane more room when tiling vertically.
		adj = choose(verticalFlag != self.splitVerticalFlag,0.65,0.5)
		pane1.place(rely=0.5, relx =   0, anchor="w", relheight=1.0, relwidth=adj)
		pane2.place(rely=0.5, relx = 1.0, anchor="e", relheight=1.0, relwidth=1.0-adj)
		bar.place  (rely=0.5, relx = adj, anchor="c", relheight=1.0)</t>
<t tx="T1153">@tabwidth 4
</t>
<t tx="T1154">def createStatusLine (self):
	
	if self.statusFrame and self.statusLabel:
		return
	
	self.statusFrame = statusFrame = Tk.Frame(self.outerFrame,bd=2)
	statusFrame.pack(fill="x",pady=1)
	
	text = "line 0, col 0"
	width = len(text) + 4
	self.statusLabel = Tk.Label(statusFrame,text=text,width=width,anchor="w")
	self.statusLabel.pack(side="left",padx=1)
	
	bg = statusFrame.cget("background")
	self.statusText = Tk.Text(statusFrame,height=1,state="disabled",bg=bg,relief="groove")
	self.statusText.pack(side="left",expand=1,fill="x")
	
	def idleStatusUpdateCallback(tag,keywords):
		c=keywords.get("c")
		if c: c.frame.updateStatusRowCol()

	# Register an idle-time handler to update the row and column indicators.
	self.statusFrame.after_idle(self.updateStatusRowCol)</t>
<t tx="T1155">def clearStatusLine (self):
	
	t = self.statusText
	t.configure(state="normal")
	t.delete("1.0","end")
	t.configure(state="disabled")
</t>
<t tx="T1156">def putStatusLine (self,s,color=None):
	
	t = self.statusText ; tags = self.statusColorTags
	if not t: return

	t.configure(state="normal")
	
	if "black" not in self.logColorTags:
		tags.append("black")
		
	if color and color not in tags:
		tags.append(color)
		t.tag_config(color,foreground=color)

	if color:
		t.insert("end",s)
		t.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
		t.tag_config("black",foreground="black")
		t.tag_add("black","end")
	else:
		t.insert("end",s)
	
	t.configure(state="disabled")</t>
<t tx="T1157">def updateStatusRowCol (self):
	
	c = self.commands ; body = self.body ; lab = self.statusLabel
	
	# New for Python 2.3: may be called during shutdown.
	if app().killed:
		return

	index = body.index("insert")
	row,col = getindex(body,index)
	if col &gt; 0:
		s = body.get("%d.0" % (row),index)
		col = computeWidth (s,self.tab_width)

	if row != self.lastStatusRow or col != self.lastStatusCol:
		s = "line %d, col %d " % (row,col)
		lab.configure(text=s)
		self.lastStatusRow = row
		self.lastStatusCol = col
		
	# Reschedule this routine 100 ms. later.
	# Don't use after_idle: it hangs Leo.
	self.statusFrame.after(100,self.updateStatusRowCol)</t>
<t tx="T1158">@first # -*- coding: utf-8 -*-

# Global constants, variables and utility functions used throughout Leo.

@language python

import exceptions,os,re,string,sys,time,Tkinter,traceback,types

&lt;&lt; define general constants &gt;&gt;

@others</t>
<t tx="T1159">body_newline = '\n'
body_ignored_newline = '\r'

try:
	true = True
	false = False
except:
	# print "True and False not defined"
	true = True = 1
	false = False = 0 # Better than None

assert(false!=None)</t>
<t tx="T1160"></t>
<t tx="T1161"></t>
<t tx="T1162"></t>
<t tx="T1163"></t>
<t tx="T1164"></t>
<t tx="T1165"></t>
<t tx="T1166"></t>
<t tx="T1167"></t>
<t tx="T1168"></t>
<t tx="T1169"></t>
<t tx="T1170"></t>
<t tx="T1171"></t>
<t tx="T1172"></t>
<t tx="T1173"></t>
<t tx="T1174"></t>
<t tx="T1175"></t>
<t tx="T1176"></t>
<t tx="T1177"></t>
<t tx="T1178"></t>
<t tx="T1179"></t>
<t tx="T1180"></t>
<t tx="T1181"></t>
<t tx="T1182"></t>
<t tx="T1183"></t>
<t tx="T1184"></t>
<t tx="T1185"></t>
<t tx="T1186"></t>
<t tx="T1187"></t>
<t tx="T1188"></t>
<t tx="T1189"></t>
<t tx="T1190"></t>
<t tx="T1191"></t>
<t tx="T1192"></t>
<t tx="T1193"></t>
<t tx="T1194"></t>
<t tx="T1195"></t>
<t tx="T1196"></t>
<t tx="T1197"></t>
<t tx="T1198"></t>
<t tx="T1199"></t>
<t tx="T1200"></t>
<t tx="T1201"></t>
<t tx="T1202"></t>
<t tx="T1203"></t>
<t tx="T1204"></t>
<t tx="T1205"></t>
<t tx="T1206"></t>
<t tx="T1207"></t>
<t tx="T1208"></t>
<t tx="T1209"></t>
<t tx="T1210"></t>
<t tx="T1211"></t>
<t tx="T1212"></t>
<t tx="T1213"></t>
<t tx="T1214"></t>
<t tx="T1215"></t>
<t tx="T1216"></t>
<t tx="T1217"></t>
<t tx="T1218"></t>
<t tx="T1219"></t>
<t tx="T1220"></t>
<t tx="T1221"></t>
<t tx="T1222"></t>
<t tx="T1223"></t>
<t tx="T1224"></t>
<t tx="T1225"></t>
<t tx="T1226"></t>
<t tx="T1227"></t>
<t tx="T1228"></t>
<t tx="T1229"></t>
<t tx="T1230"></t>
<t tx="T1231"></t>
<t tx="T1232"></t>
<t tx="T1233"></t>
<t tx="T1234"></t>
<t tx="T1235"></t>
<t tx="T1236"></t>
<t tx="T1237"></t>
<t tx="T1238"></t>
<t tx="T1239"></t>
<t tx="T1240"></t>
<t tx="T1241"></t>
<t tx="T1242"></t>
<t tx="T1243"></t>
<t tx="T1244"></t>
<t tx="T1245"></t>
<t tx="T1246"></t>
<t tx="T1247"></t>
<t tx="T1248"></t>
<t tx="T1249"></t>
<t tx="T1250"></t>
<t tx="T1251"></t>
<t tx="T1252"></t>
<t tx="T1253"></t>
<t tx="T1254"></t>
<t tx="T1255"></t>
<t tx="T1256"></t>
<t tx="T1257"></t>
<t tx="T1258"></t>
<t tx="T1259"></t>
<t tx="T1260"></t>
<t tx="T1261"></t>
<t tx="T1262"></t>
<t tx="T1263"></t>
<t tx="T1264"></t>
<t tx="T1265"></t>
<t tx="T1266"></t>
<t tx="T1267"></t>
<t tx="T1268"></t>
<t tx="T1269"></t>
<t tx="T1270"></t>
<t tx="T1271"></t>
<t tx="T1272"></t>
<t tx="T1273"></t>
<t tx="T1274"></t>
<t tx="T1275"></t>
<t tx="T1276"></t>
<t tx="T1277"></t>
<t tx="T1278"></t>
<t tx="T1279"></t>
<t tx="T1280"></t>
<t tx="T1281"></t>
<t tx="T1282"></t>
<t tx="T1283"></t>
<t tx="T1284"></t>
<t tx="T1285"></t>
<t tx="T1286"></t>
<t tx="T1287"></t>
<t tx="T1288"></t>
<t tx="T1289"></t>
<t tx="T1290"></t>
<t tx="T1291"></t>
<t tx="T1292"></t>
<t tx="T1293"></t>
<t tx="T1294"></t>
<t tx="T1295"></t>
<t tx="T1296"></t>
<t tx="T1297"></t>
<t tx="T1298"></t>
<t tx="T1299"></t>
<t tx="T1300"></t>
<t tx="T1301"></t>
<t tx="T1302"></t>
<t tx="T1303"></t>
<t tx="T1304"></t>
<t tx="T1305"></t>
<t tx="T1306"></t>
<t tx="T1307"></t>
<t tx="T1308"></t>
<t tx="T1309"></t>
<t tx="T1310"></t>
<t tx="T1311"></t>
<t tx="T1312"></t>
<t tx="T1313"></t>
<t tx="T1314"></t>
<t tx="T1315"></t>
<t tx="T1316"></t>
<t tx="T1317"></t>
<t tx="T1318"></t>
<t tx="T1319"></t>
<t tx="T1320"></t>
<t tx="T1321"></t>
<t tx="T1322"></t>
<t tx="T1323"></t>
<t tx="T1324"></t>
<t tx="T1325"></t>
<t tx="T1326"></t>
<t tx="T1327"></t>
<t tx="T1328"></t>
<t tx="T1329"></t>
<t tx="T1330"></t>
<t tx="T1331"></t>
<t tx="T1332"></t>
<t tx="T1333"></t>
<t tx="T1334"></t>
<t tx="T1335"></t>
<t tx="T1336"></t>
<t tx="T1337"></t>
<t tx="T1338"></t>
<t tx="T1339"></t>
<t tx="T1340"></t>
<t tx="T1341"></t>
<t tx="T1342">@language python

from leoGlobals import *

&lt;&lt; scripts &gt;&gt;

class baseLeoImportCommands:
	"""The base class for Leo's import commands."""
	@others
	
class leoImportCommands (baseLeoImportCommands):
	"""A class that implements Leo's import commands."""
	pass</t>
<t tx="T1343">def __init__ (self,commands):

	self.commands = commands
	
	# Set by ImportFilesFommand.
	self.treeType = "@file" # "@root" or "@file"
	# Set by ImportWebCommand.
	self.webType = "@noweb" # "cweb" or "noweb"

	# Set by create_outline.
	self.fileName = None # The original file name, say x.cpp
	self.methodName = None # x, as in &lt; &lt; x methods &gt; &gt; =
	self.fileType = None # ".py", ".c", etc.
	self.rootLine = "" # Empty or @root + self.fileName

	# Support of output_newline option
	self.output_newline = getOutputNewline()
	
	# Used by Importers.
	self.web_st = []
	self.encoding = app().tkEncoding # 2/25/03: was "utf-8"
</t>
<t tx="T1344">@others</t>
<t tx="T1345"># An example of running this script:
#
# import leoImport
# leoImport.importFiles("c:/prog/test", ".py")

def importFiles (dir, type = None, kind = "@file"):
	
	import os

	# Check the params.
	if kind != "@file" and kind != "@root":
		es("kind must be @file or @root: " + `kind`)
		return
	if not os.path.exists(dir):
		es("directory does not exist: " + `dir`)
		return
	
	c = top() # Get the commander.
	
	try:
		files = os.listdir(dir)
		files2 = []
		for f in files:
			path = os.path.join(dir,f)
			if os.path.isfile(path):
				name, ext = os.path.splitext(f)
				if type == None or ext == type:
					files2.append(path)
		if len(files2) &gt; 0:
			c.importCommands.importFilesCommand(files2,kind)
	except:
		es("exception in importFiles script")
		es_exception()</t>
<t tx="T1346"></t>
<t tx="T1347">def createOutline (self,fileName,parent):

	c = self.commands ; current = c.currentVnode()
	junk, self.fileName = os.path.split(fileName) # junk/fileName
	self.methodName, ext = os.path.splitext(self.fileName) # methodName.fileType
	self.fileType = ext
	self.setEncoding()
	# trace(`self.fileName`) ; trace(`self.fileType`)
	# All file types except the following just get copied to the parent node.
	# Note: we should _not_ import header files using this code.
	ext = ext.lower()
	appendFileFlag = ext not in (
		".c", ".cpp", ".cxx", ".java", ".pas", ".py", ".pyw", ".php")
	&lt;&lt; Read file into s &gt;&gt;
	# Create the top-level headline.
	v = parent.insertAsLastChild()
	c.undoer.setUndoParams("Import",v,select=current)
	if self.treeType == "@file":
		v.initHeadString("@file " + self.fileName)
	else:
		v.initHeadString(self.fileName)
		
	self.rootLine = choose(self.treeType=="@file","","@root "+self.fileName+'\n')

	if appendFileFlag:
		v.setBodyStringOrPane("@ignore\n" + self.rootLine + s)
	elif ext in (".c", ".cpp", ".cxx"):
		self.scanCText(s,v)
	elif ext == ".java":
		self.scanJavaText(s,v,true) #outer level
	elif ext == ".pas":
		self.scanPascalText(s,v)
	elif ext in (".py", ".pyw"):
		self.scanPythonText(s,v)
	elif ext == ".php":
		self.scanPHPText(s,v) # 08-SEP-2002 DTHEIN
	else:
		es("createOutline: can't happen")
	return v</t>
<t tx="T1348">try:
	file = open(fileName)
	s = file.read()
	s = toUnicode(s,self.encoding)
	file.close()
except:
	es("can not read " + fileName)
	es_exception()
	return None</t>
<t tx="T1349">def importFilesCommand (self,files,treeType):

	c = self.commands
	if c == None: return
	v = current = c.currentVnode()
	if current == None: return
	if len(files) &lt; 1: return
	self.treeType = treeType
	c.beginUpdate()
	if 1: # range of update...
		if len(files) == 2:
			&lt;&lt; Create a parent for two files having a common prefix &gt;&gt;
		for i in xrange(len(files)):
			fileName = files[i]
			v = self.createOutline(fileName,current)
			if v: # 8/11/02: createOutline may fail.
				es("imported " + fileName)
				v.contract()
				v.setDirty()
				c.setChanged(true)
		c.validateOutline()
		current.expand()
	c.endUpdate()
	c.selectVnode(current)</t>
<t tx="T1350">@ The two filenames have a common prefix everything before the last period is the same.  For example, x.h and x.cpp.
@c

name0 = files[0]
name1 = files[1]
prefix0, junk = os.path.splitext(name0)
prefix1, junk = os.path.splitext(name1)
if len(prefix0) &gt; 0 and prefix0 == prefix1:
	current = current.insertAsLastChild()
	junk, nameExt = os.path.split(prefix1)
	name,ext = os.path.splitext(prefix1)
	current.initHeadString(name)</t>
<t tx="T1351"></t>
<t tx="T1352"># Used by paste logic.

def convertMoreStringToOutlineAfter (self,s,firstVnode):
	s = string.replace(s,"\r","")
	strings = string.split(s,"\n")
	return self.convertMoreStringsToOutlineAfter(strings,firstVnode)

# Almost all the time spent in this command is spent here.

def convertMoreStringsToOutlineAfter (self,strings,firstVnode):

	c = self.commands
	if len(strings) == 0: return None
	if not self.stringsAreValidMoreFile(strings): return None
	c.beginUpdate()
	firstLevel, junk = self.moreHeadlineLevel(strings[0])
	lastLevel = -1 ; theRoot = lastVnode = None
	index = 0
	while index &lt; len(strings):
		progress = index
		s = strings[index]
		level, newFlag = self.moreHeadlineLevel(s)
		level -= firstLevel
		if level &gt;= 0:
			&lt;&lt; Link a new vnode v into the outline &gt;&gt;
			&lt;&lt; Set the headline string, skipping over the leader &gt;&gt;
			&lt;&lt; Count the number of following body lines &gt;&gt;
			&lt;&lt; Add the lines to the body text of v &gt;&gt;
			v.setDirty()
		else: index += 1
		assert progress &lt; index
	if theRoot:
		theRoot.setDirty()
		c.setChanged(true)
	c.endUpdate()
	return theRoot</t>
<t tx="T1353">assert(level &gt;= 0)
if not lastVnode:
	theRoot = v = firstVnode.insertAfter()
elif level == lastLevel:
	v = lastVnode.insertAfter()
elif level == lastLevel + 1:
	v = lastVnode.insertAsNthChild(0)
else:
	assert(level &lt; lastLevel)
	while level &lt; lastLevel:
		lastLevel -= 1
		lastVnode = lastVnode.parent()
		assert(lastVnode)
		assert(lastLevel &gt;= 0)
	v = lastVnode.insertAfter()
lastVnode = v
lastLevel = level</t>
<t tx="T1354">j = 0
while match(s,j,'\t'):
	j += 1
if match(s,j,"+ ") or match(s,j,"- "):
	j += 2

v.initHeadString(s[j:])</t>
<t tx="T1355">bodyLines = 0
index += 1 # Skip the headline.
while index &lt; len(strings):
	s = strings[index]
	level, junk = self.moreHeadlineLevel(s)
	level -= firstLevel
	if level &gt;= 0:
		break
	# Remove first backslash of the body line.
	if match(s,0,'\\'):
		strings[index] = s[1:]
	bodyLines += 1
	index += 1</t>
<t tx="T1356">if bodyLines &gt; 0:
	body = ""
	n = index - bodyLines
	while n &lt; index:
		body += strings[n]
		if n != index - 1:
			body += "\n"
		n += 1
	v.t.setTnodeText(body)</t>
<t tx="T1357"># On entry,files contains at most one file to convert.
def importFlattenedOutline (self,files):

	c = self.commands ; current = c.currentVnode()
	if current == None: return
	if len(files) &lt; 1: return
	self.setEncoding()
	fileName = files[0]
	&lt;&lt; Read the file into array &gt;&gt;
	# Convert the string to an outline and insert it after the current node.
	newVnode = self.convertMoreStringsToOutlineAfter(array,current)
	if newVnode:
		c.undoer.setUndoParams("Import",newVnode,select=current)
		c.endEditing()
		c.validateOutline()
		c.editVnode(newVnode)
		newVnode.setDirty()
		c.setChanged(true)
	else:
		es(fileName + " is not a valid MORE file.")</t>
<t tx="T1358">try:
	file = open(fileName)
	s = file.read()
	s = string.replace(s,"\r","")
	s = toUnicode(s,self.encoding)
	array = string.split(s,"\n")
	file.close()
except:
	es_exception()
	array = []</t>
<t tx="T1359"># return the headline level of s,or -1 if the string is not a MORE headline.
def moreHeadlineLevel (self,s):

	level = 0 ; i = 0
	while match(s,i,'\t'):
		level += 1
		i += 1
	plusFlag = choose(match(s,i,"+"),true,false)
	if match(s,i,"+ ") or match(s,i,"- "):
		return level, plusFlag
	else:
		return -1, plusFlag</t>
<t tx="T1360"># Used by paste logic.

def stringIsValidMoreFile (self,s):
	
	s = string.replace(s,"\r","")
	strings = string.split(s,"\n")
	return self.stringsAreValidMoreFile(strings)

def stringsAreValidMoreFile (self,strings):

	if len(strings) &lt; 1: return false
	level1, plusFlag = self.moreHeadlineLevel(strings[0])
	if level1 == -1: return false
	# Check the level of all headlines.
	i = 0 ; 	lastLevel = level1
	while i &lt; len(strings):
		s = strings[i] ; i += 1
		level, newFlag = self.moreHeadlineLevel(s)
		if level &gt; 0:
			if level &lt; level1 or level &gt; lastLevel + 1:
				return false # improper level.
			elif level &gt; lastLevel and plusFlag == false:
				return false # parent of this node has no children.
			elif level == lastLevel and plusFlag == true:
				return false # last node has missing child.
			else:
				lastLevel = level
				plusFlag = newFlag
	return true</t>
<t tx="T1361"></t>
<t tx="T1362">def createOutlineFromWeb (self,path,parent):

	c = self.commands ; current = c.currentVnode()
	junk, fileName = os.path.split(path)
	# Create the top-level headline.
	v = parent.insertAsLastChild()
	c.undoer.setUndoParams("Import",v,select=current)
	v.initHeadString(fileName)
	if self.webType=="cweb":
		v.setBodyStringOrPane("@ignore\n" + self.rootLine + "@language cweb")

	# Scan the file,creating one section for each function definition.
	self.scanWebFile(path,v)
	return v</t>
<t tx="T1363">def importWebCommand (self,files,webType):

	c = self.commands ; current = c.currentVnode()
	if current == None: return
	if len(files) &lt; 1: return
	self.webType = webType
	c.beginUpdate()
	for i in xrange(len(files)):
		fileName = files[i]
		v = self.createOutlineFromWeb(fileName,current)
		v.contract()
		v.setDirty()
		c.setChanged(true)
	c.selectVnode(current)
	c.endUpdate()</t>
<t tx="T1364">def findFunctionDef (self,s,i):
	
	# Look at the next non-blank line for a function name.
	i = skip_ws_and_nl(s,i)
	k = skip_line(s,i)
	name = None
	while i &lt; k:
		if is_c_id(s[i]):
			j = i ; i = skip_c_id(s,i) ; name = s[j:i]
		elif s[i] == '(':
			if name: return name
			else: break
		else: i += 1
	return None</t>
<t tx="T1365">@ This method returns the proper headline text.

1. If s contains a section def, return the section ref.
2. cweb only: if s contains @c, return the function name following the @c.
3. cweb only: if s contains @d name, returns @d name.
4. Otherwise, returns "@"
@c

def scanBodyForHeadline (self,s):
	
	if self.webType == "cweb":
		&lt;&lt; scan cweb body for headline &gt;&gt;
	else:
		&lt;&lt; scan noweb body for headline &gt;&gt;
	return "@" # default.</t>
<t tx="T1366">i = 0
while i &lt; len(s):
	i = skip_ws_and_nl(s,i)
	# line = get_line(s,i) ; trace(`line`)
	# Allow constructs such as @ @c, or @ @&lt;.
	if self.isDocStart(s,i):
		i += 2 ; i = skip_ws(s,i)
	if match(s,i,"@d") or match(s,i,"@f"):
		# Look for a macro name.
		directive = s[i:i+2]
		i = skip_ws(s,i+2) # skip the @d or @f
		if i &lt; len(s) and is_c_id(s[i]):
			j = i ; skip_c_id(s,i) ; return s[j:i]
		else: return directive
	elif match(s,i,"@c") or match(s,i,"@p"):
		# Look for a function def.
		name = self.findFunctionDef(s,i+2)
		return choose(name,name,"outer function")
	elif match(s,i,"@&lt;"):
		# Look for a section def.
		# A small bug: the section def must end on this line.
		j = i ; k = find_on_line(s,i,"@&gt;")
		if k &gt; -1 and (match(s,k+2,"+=") or match(s,k+2,"=")):
			return s[j:k+2] # return the section ref.
	i = skip_line(s,i)</t>
<t tx="T1367">i = 0
while i &lt; len(s):
	i = skip_ws_and_nl(s,i)
	# line = get_line(s,i) ; trace(`line`)
	if match(s,i,"&lt;&lt;"):
		k = find_on_line(s,i,"&gt;&gt;=")
		if k &gt; -1:
			ref = s[i:k+2]
			name = string.strip(s[i+2:k])
			if name != "@others":
				return ref
	else:
		name = self.findFunctionDef(s,i)
		if name:
			return name
	i = skip_line(s,i)</t>
<t tx="T1368">def scanWebFile (self,fileName,parent):

	type = self.webType
	lb = choose(type=="cweb","@&lt;","&lt;&lt;")
	rb = choose(type=="cweb","@&gt;","&gt;&gt;")

	try: # Read the file into s.
		f = open(fileName)
		s = f.read()
	except: s = None

	&lt;&lt; Create a symbol table of all section names &gt;&gt;
	&lt;&lt; Create nodes for limbo text and the root section &gt;&gt;
	while i &lt; len(s):
		progress = i
		&lt;&lt; Create a node for the next module &gt;&gt;
		assert(progress &lt; i)</t>
<t tx="T1369">i = 0 ; 	self.web_st = []
while i &lt; len(s):
	i = skip_ws_and_nl(s,i)
	# line = get_line(s,i) ; trace(`line`)
	if self.isDocStart(s,i):
		if type == "cweb": i += 2
		else: i = skip_line(s,i)
	elif type == "cweb" and match(s,i,"@@"):
		i += 2
	elif match(s,i,lb):
		i += 2 ; j = i ; k = find_on_line(s,j,rb)
		if k &gt; -1: self.cstEnter(s[j:k])
	else: i += 1

# trace(self.cstDump())</t>
<t tx="T1370">i = 0
while i &lt; len(s):
	i = skip_ws_and_nl(s,i)
	if self.isModuleStart(s,i) or match(s,i,lb):
		break
	else: i = skip_line(s,i)
	
j = skip_ws(s,0)
if j &lt; i:
	self.createHeadline(parent,"@ " + s[j:i],"Limbo")

j = i
if match(s,i,lb):
	while i &lt; len(s):
		i = skip_ws_and_nl(s,i)
		if self.isModuleStart(s,i):
			break
		else: i = skip_line(s,i)
	self.createHeadline(parent,s[j:i],angleBrackets(" @ "))
	
# trace(`get_line(s,i)`)</t>
<t tx="T1371">if type=="cweb":
	assert(self.isModuleStart(s,i))
	start = i
	if self.isDocStart(s,i):
		i += 2
		while i &lt; len(s):
			i = skip_ws_and_nl(s,i)
			if self.isModuleStart(s,i): break
			else: i = skip_line(s,i)
	&lt;&lt; Handle cweb @d, @f, @c and @p directives &gt;&gt;
else:
	assert(self.isDocStart(s,i)) # isModuleStart == isDocStart for noweb.
	start = i ; i = skip_line(s,i)
	while i &lt; len(s):
		i = skip_ws_and_nl(s,i)
		if self.isDocStart(s,i): break
		else: i = skip_line(s,i)
	
body = s[start:i]
body = self.massageWebBody(body)
headline = self.scanBodyForHeadline(body)
self.createHeadline(parent,body,headline)</t>
<t tx="T1372">if match(s,i,"@d") or match(s,i,"@f"):
	i += 2 ; i = skip_line(s,i)
	# Place all @d and @f directives in the same node.
	while i &lt; len(s):
		i = skip_ws_and_nl(s,i)
		if match(s,i,"@d") or match(s,i,"@f"): i = skip_line(s,i)
		else: break
	i = skip_ws_and_nl(s,i)
	
while i &lt; len(s) and not self.isModuleStart(s,i):
	i = skip_line(s,i)
	i = skip_ws_and_nl(s,i)

if match(s,i,"@c") or match(s,i,"@p"):
	i += 2 ; 
	while i &lt; len(s):
		i = skip_line(s,i)
		i = skip_ws_and_nl(s,i)
		if self.isModuleStart(s,i):
			break</t>
<t tx="T1373"></t>
<t tx="T1374">@ We canonicalize strings before looking them up, but strings are entered in the form they are first encountered.
@c

def cstCanonicalize (self,s,lower=true):
	
	if lower:
		s = string.lower(s)
	s = string.replace(s,"\t"," ")
	s = string.replace(s,"\r","")
	s = string.replace(s,"\n"," ")
	s = string.replace(s,"  "," ")
	s = string.strip(s)
	return s</t>
<t tx="T1375">def cstDump (self):

	self.web_st.sort()
	s = "Web Symbol Table...\n\n"
	for name in self.web_st:
		s += name + "\n"
	return s</t>
<t tx="T1376"># We only enter the section name into the symbol table if the ... convention is not used.

def cstEnter (self,s):

	# Don't enter names that end in "..."
	s = string.rstrip(s)
	if s.endswith("..."): return
	
	# Put the section name in the symbol table, retaining capitalization.
	lower = self.cstCanonicalize(s,true)  # do lower
	upper = self.cstCanonicalize(s,false) # don't lower.
	for name in self.web_st:
		if string.lower(name) == lower:
			return
	self.web_st.append(upper)</t>
<t tx="T1377"># This method returns a string if the indicated string is a prefix of an entry in the web_st.

def cstLookup (self,target):
	
	# Do nothing if the ... convention is not used.
	target = string.strip(target)
	if not target.endswith("..."): return target
	# Canonicalize the target name, and remove the trailing "..."
	ctarget = target[:-3]
	ctarget = self.cstCanonicalize(ctarget)
	ctarget = string.strip(ctarget)
	found = false ; result = target
	for s in self.web_st:
		cs = self.cstCanonicalize(s)
		if cs[:len(ctarget)] == ctarget:
			if found:
				es("****** " + target + ": is also a prefix of: " + s)
			else:
				found = true ; result = s
				# es("replacing: " + target + " with: " + s)
	return result</t>
<t tx="T1378"></t>
<t tx="T1379"></t>
<t tx="T1380">@ Creates a child node c of parent for the class, and children of c for each def in the class.
@c

def scanPythonClass (self,s,i,start,parent):

	# line = get_line(s,i) ; trace(`line`)
	classIndent = self.getLeadingIndent(s,i)
	&lt;&lt; set classname and headline, or return i &gt;&gt;
	i = skip_line(s,i) # Skip the class line.
	&lt;&lt; create class_vnode &gt;&gt;
	savedMethodName = self.methodName
	self.methodName = headline
	# Create a node for leading declarations of the class.
	i = self.scanPythonDecls(s,i,class_vnode,classIndent,indent_parent_ref_flag=true)
	&lt;&lt; create nodes for all defs of the class &gt;&gt;
	self.methodName = savedMethodName
	return i</t>
<t tx="T1381"># Skip to the class name.
i = skip_ws(s,i)
i = skip_c_id(s,i) # skip "class"
i = skip_ws_and_nl(s,i)
if i &lt; len(s) and is_c_id(s[i]):
	j = i ; i = skip_c_id(s,i)
	classname = s[j:i]
	headline = "class " + classname
else:
	return i</t>
<t tx="T1382"># Create the section name using the old value of self.methodName.
if  self.treeType == "@file":
	prefix = ""
else:
	prefix = angleBrackets(" " + self.methodName + " methods ") + "=\n\n"
	self.methodsSeen = true

# i points just after the class line.
body = s[start:i]
body = self.undentBody(body)
class_vnode = self.createHeadline(parent,prefix + body,headline)
</t>
<t tx="T1383">indent =  self.getLeadingIndent(s,i)
start = i = skip_blank_lines(s,i)
parent_vnode = None # 7/6/02
while i &lt; len(s) and indent &gt; classIndent:
	progress = i
	if is_nl(s,i):
		j = skip_nl(s,i)
		indent = self.getLeadingIndent(s,j)
		if indent &gt; classIndent: i = j
		else: break
	elif match_c_word(s,i,"def"):
		if not parent_vnode:
			&lt;&lt; create parent_vnode &gt;&gt;
		i = start = self.scanPythonDef(s,i,start,parent_vnode)
		indent = self.getLeadingIndent(s,i)
	elif match_c_word(s,i,"class"):
		if not parent_vnode:
			&lt;&lt; create parent_vnode &gt;&gt;
		i = start = self.scanPythonClass(s,i,start,parent_vnode)
		indent = self.getLeadingIndent(s,i)
	elif s[i] == '#': i = skip_to_end_of_line(s,i)
	elif s[i] == '"' or s[i] == '\'': i = skip_python_string(s,i)
	else: i += 1
	assert(progress &lt; i)</t>
<t tx="T1384"># This must be done after the declaration reference is generated.
if self.treeType == "@file":
	class_vnode.appendStringToBody("\t@others\n")
else:
	ref = angleBrackets(" class " + classname + " methods ")
	class_vnode.appendStringToBody("\t" + ref + "\n\n")
parent_vnode = class_vnode</t>
<t tx="T1385">@ Creates a node of parent for the def.
@c

def scanPythonDef (self,s,i,start,parent):

	# line = get_line(s,i) ; trace(`line`)
	&lt;&lt; set headline or return i &gt;&gt;
	&lt;&lt; skip the Python def &gt;&gt;
	# Create the def node.
	savedMethodName = self.methodName
	self.methodName = headline
	&lt;&lt; Create def node &gt;&gt;
	self.methodName = savedMethodName
	return i</t>
<t tx="T1386">i = skip_ws(s,i)
i = skip_c_id(s,i) # Skip the "def"
i = skip_ws_and_nl(s,i)
if i &lt; len(s) and is_c_id(s[i]):
	j = i ; i = skip_c_id(s,i)
	headline = s[j:i]
	# trace("headline:" + `headline`)
else: return i</t>
<t tx="T1387"># Set defIndent to the indentation of the def line.
defIndent = self.getLeadingIndent(s,start)
i = skip_line(s,i) # Skip the def line.
indent = self.getLeadingIndent(s,i)
while i &lt; len(s) and indent &gt; defIndent:
	progress = i
	ch = s[i]
	if is_nl(s,i):
		i = skip_nl(s,i)
		indent = self.getLeadingIndent(s,i)
		if indent &lt;= defIndent:
			break
	elif ch == '#':
		i = skip_to_end_of_line(s,i) # 7/29/02
	elif ch == '"' or ch == '\'':
		i = skip_python_string(s,i)
	else: i += 1
	assert(progress &lt; i)</t>
<t tx="T1388"># Create the prefix line for @root trees.
if self.treeType == "@file":
	prefix = ""
else:
	prefix = angleBrackets(" " + savedMethodName + " methods ") + "=\n\n"
	self.methodsSeen = true

# Create body.
start = skip_blank_lines(s,start)
body = s[start:i]
body = self.undentBody(body)

# Create the node.
self.createHeadline(parent,prefix + body,headline)

</t>
<t tx="T1389">def scanPythonDecls (self,s,i,parent,indent,indent_parent_ref_flag=true):
	
	done = false ; start = i
	while not done and i &lt; len(s):
		progress = i
		# line = get_line(s,i) ; trace(`line`)
		ch = s[i]
		if ch == '\n':
			i = skip_nl(s,i)
			# 2/14/03: break on lesser indention.
			j = skip_ws(s,i)
			if not is_nl(s,j) and not match(s,j,"#"):
				lineIndent = self.getLeadingIndent(s,i)
				if lineIndent &lt;= indent:
					break
		elif ch == '#': i = skip_to_end_of_line(s,i)
		elif ch == '"' or ch == '\'':
			i = skip_python_string(s,i)
		elif is_c_id(ch):
			&lt;&lt; break on def or class &gt;&gt;
		else: i += 1
		assert(progress &lt; i)
	j = skip_blank_lines(s,start)
	if is_nl(s,j): j = skip_nl(s,j)
	if j &lt; i:
		&lt;&lt; Create a child node for declarations &gt;&gt;
	return i</t>
<t tx="T1390">if match_c_word(s,i,"def") or match_c_word(s,i,"class"):
	i = find_line_start(s,i)
	done = true
	break
else:
	i = skip_c_id(s,i)</t>
<t tx="T1391">headline = ref = angleBrackets(" " + self.methodName + " declarations ")
leading_tab = choose(indent_parent_ref_flag,"\t","")

# Append the reference to the parent's body.
parent.appendStringToBody(leading_tab + ref + "\n") # 7/6/02

# Create the node for the decls.
body = self.undentBody(s[j:i])
if self.treeType == "@root":
	body = "@code\n\n" + body
self.createHeadline(parent,body,headline)</t>
<t tx="T1392">@ This code creates a child of parent for each Python function definition seen.  See the comments for scanCText for what the text looks like.
@c

def scanPythonText (self,s,parent):

	decls_seen = false ; start = i = 0
	self.methodsSeen = false
	while i &lt; len(s):
		progress = i
		# line = get_line(s,i) ; trace(`line`)
		ch = s[i]
		if ch == '\n' or ch == '\r': i = skip_nl(s,i)
		elif ch == '#': i = skip_to_end_of_line(s,i)
		elif ch == '"' or ch == '\'': i = skip_python_string(s,i)
		elif is_c_id(ch):
			&lt;&lt; handle possible Python function or class &gt;&gt;
		else: i += 1
		assert(progress &lt; i)
	if not decls_seen: # 2/17/03
		parent.appendStringToBody("@ignore\n" + self.rootLine + "@language python\n")
	&lt;&lt; Append a reference to the methods of this file &gt;&gt;
	&lt;&lt; Append any unused python text to the parent's body text &gt;&gt;</t>
<t tx="T1393">if match_c_word(s,i,"def") or match_word(s,i,"class"):
	isDef = match_c_word(s,i,"def")
	if not decls_seen:
		parent.appendStringToBody("@ignore\n" + self.rootLine + "@language python\n")
		i = start = self.scanPythonDecls(s,start,parent,-1,indent_parent_ref_flag=false)
		decls_seen = true
		if self.treeType == "@file": # 7/29/02
			parent.appendStringToBody("@others\n") # 7/29/02
	if isDef:
		i = start = self.scanPythonDef(s,i,start,parent)
	else:
		i = start = self.scanPythonClass(s,i,start,parent)
else:
	i = skip_c_id(s,i)</t>
<t tx="T1394">if self.treeType == "@root" and self.methodsSeen:
	parent.appendStringToBody(
		angleBrackets(" " + self.methodName + " methods ") + "\n\n")</t>
<t tx="T1395"># Do nothing if only whitespace is left.
i = start ; i = skip_ws_and_nl(s,i)
if i &lt; len(s):
	parent.appendStringToBody(s[start:])</t>
<t tx="T1396">@ 08-SEP-2002 DTHEIN: Added for PHP import support
Creates a child of parent for each class and function definition seen.

PHP uses both # and // as line comments, and /* */ as block comments
@c
def scanPHPText (self,s,parent):
	import re
	&lt;&lt; Append file if not pure PHP &gt;&gt;

	&lt;&lt; define scanPHPText vars &gt;&gt;
	# 14-SEP-2002 DTHEIN: Make leading &lt;?php use the @first directive
	parent.appendStringToBody("@first ")	
	parent.appendStringToBody(s[:startOfCode])
	scan_start = i = startOfCode
	while i &lt; endOfCode:
		# line = get_line(s,i) ; trace(`line`)
		ch = s[i]
		# These cases skip tokens.
		if ch == '/' or ch == '#':
			&lt;&lt; handle possible PHP comments &gt;&gt;
		elif ch == '&lt;':
			&lt;&lt; handle possible heredoc string &gt;&gt;
		elif ch == '"' or ch == '\'':
			i = skip_string(s,i)
		# These cases help determine where functions start.
		# FIXME: probably want to capture 'var's as class member data
		elif ch == 'f' or ch =='c':
			&lt;&lt; handle possible class or function &gt;&gt;
		elif class_start and (ch == '}'):
			&lt;&lt; handle end of class &gt;&gt;
		else: i += 1
	&lt;&lt; Append any unused text to the parent's body text &gt;&gt;
	# 14-SEP-2002 DTHEIN: Make leading &lt;?php use the @first directive
	parent.appendStringToBody("@last ")	
	parent.appendStringToBody(s[endOfCode:])</t>
<t tx="T1397"># If the file does not begin with &lt;?php or end with ?&gt; then
# it is simply appended like a generic import would do.
s.strip() #remove inadvertent whitespace
if not s.startswith("&lt;?php") \
or not (s.endswith("?&gt;") or s.endswith("?&gt;\n") or s.endswith("?&gt;\r\n")):
	es("File seems to be mixed HTML and PHP; importing as plain text file.")
	parent.setBodyStringOrPane("@ignore\n" + self.rootLine + s)
	return</t>
<t tx="T1398">scan_start = 0
class_start = 0
function_start = 0
c = self.commands
i = 0
class_body = ""
class_node = ""
phpClassName = re.compile("class\s+([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)")
phpFunctionName = re.compile("function\s+([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)")

# 14-SEP-2002 DTHEIN: added these 2 variables to allow use of @first/last
startOfCode = s.find("\n") + 1 # this should be the line containing the initial &lt;?php
endOfCode = s.rfind("?&gt;") # this should be the line containing the last ?&gt;
</t>
<t tx="T1399">if match(s,i,"&lt;&lt;&lt;"):
	i = skip_heredoc_string(s,i)
else:
	i += 1
</t>
<t tx="T1400">if match(s,i,"//"):
	i = skip_line(s,i)
elif match(s,i,"#"):
	i = skip_line(s,i)
elif match(s,i,"/*"):
	i = skip_block_comment(s,i)
else:
	i += 1</t>
<t tx="T1401">@ In PHP, all functions are typeless and start with the keyword "function;  all classes start with the keyword class.

Functions can be nested, but we don't handle that right now (I don't think it is a common practice anyway).
@c
if match(s,i,"function "):
	#we want to make the function a subnode of either the @file node or a class node
	# 1. get the function name
	# 2. make a reference in the parent
	# 3. create the child node, and dump the function in it.
	function_start = i
	m = phpFunctionName.match(s[i:])
	if (None == m): # function keyword without function name
		i += len("function ")
	else:
		headline = angleBrackets(" function " + m.group(1) + " ")
		# find the end of the function
		openingBrace = s.find('{',i)
		function_end = skip_php_braces(s,openingBrace)
		function_end = skip_to_end_of_line(s,function_end - 1) + 1 # include the line end
		# Insert skipped text into parent's body.
		if class_start:
			class_body += s[scan_start:function_start]
		else:
			parent.appendStringToBody(s[scan_start:function_start])
		# Append the headline to the parent's body.
		if class_start:
			class_body += (headline + "\n")
		else:
			parent.appendStringToBody(headline + "\n")
		# Backup to capture leading whitespace (for undent purposes)
		while (function_start &gt; 0) and (s[function_start - 1] in [" ", "\t"]):
			function_start -= 1
		# Get the body and undent it
		function_body = s[function_start:function_end]
		function_body = self.undentBody(function_body)
		if self.treeType != "@file":
			function_body = "@code\n\n" + function_body
		# Create the new node
		if class_start:
			self.createHeadline(class_node,function_body,headline)
		else:
			self.createHeadline(parent,function_body,headline)
		i = function_end
		scan_start = i
		function_end = 0
		function_start = 0 #done with this function
		function_body = ""
		
elif match(s,i,"class "):
	# we want to make the class a subnode of the @file node
	# 1. get the class name
	# 2. make a reference in the parent
	# 3. create the child node and dump the function in it
	class_start = i
	class_body = ""
	m = phpClassName.match(s[i:])
	if (None == m): # class keyword without class name
		i += len("class ")
	else:
		# Insert skipped text into parent's body.
		parent.appendStringToBody(s[scan_start:class_start])
		# create the headline name
		headline = angleBrackets(" class " + m.group(1) + " ")
		# find the place to start looking for methods (functions)
		openingBrace = s.find('{',i)
		# find the end of the class
		class_end = skip_php_braces(s,openingBrace)
		class_end = skip_to_end_of_line(s,class_end - 1) + 1 # include the line end
		# Append the headline to the parent's body.
		parent.appendStringToBody(headline + "\n")
		# Backup to capture leading whitespace (for undent purposes)
		while (class_start &gt; 0) and (s[class_start - 1] in [" ", "\t"]):
			class_start -= 1
		scan_start = class_start
		# Create the new node
		class_node = self.createHeadline(parent,"",headline)
		i = openingBrace
	
else:
	i += 1</t>
<t tx="T1402"># Capture the rest of the body
class_body += s[scan_start:class_end]
# insert the class node's body
if self.treeType != "@file":
	class_body = "@code\n\n" + class_body
class_body = self.undentBody(class_body)
class_node.appendStringToBody(class_body)
# reset the indices
i = class_end
scan_start = i
class_end = 0
class_start = 0 #done with this class
class_body=""
</t>
<t tx="T1403">parent.appendStringToBody(s[scan_start:endOfCode])
</t>
<t tx="T1404"># Creates a child of parent for each C function definition seen.

def scanCText (self,s,parent):

	&lt;&lt; define scanCText vars &gt;&gt;
	while i &lt; len(s):
		# line = get_line(s,i) ; trace(`line`)
		ch = s[i]
		# These cases skip tokens.
		if ch == '/':
			&lt;&lt; handle possible C comments &gt;&gt;
		elif ch == '"' or ch == '\'':
			i = skip_string(s,i)
		# These cases help determine where functions start.
		elif ch == '=':
			&lt;&lt; handle equal sign in C &gt;&gt;
		elif ch == '(':
			&lt;&lt; handle open paren in C &gt;&gt;
		elif ch == ';':
			&lt;&lt; handle semicolon in C &gt;&gt;
		# These cases and the default case can create child nodes.
		elif ch == '#':
			&lt;&lt; handle # sign &gt;&gt;
		elif ch == '{':
			&lt;&lt; handle open curly bracket in C &gt;&gt;
		elif is_c_id(ch):
			&lt;&lt; handle id, class, typedef, struct, union, namespace &gt;&gt;
		else: i += 1
	&lt;&lt; Append any unused text to the parent's body text &gt;&gt;</t>
<t tx="T1405">c = self.commands
include_seen = method_seen = false
methodKind = choose(self.fileType==".c","functions","methods")
lparen = None   # Non-null if '(' seen at outer level.
scan_start = function_start = 0
name = None
i = 0</t>
<t tx="T1406"># if statements may contain function definitions.
i += 1  # Skip the '#'
if not include_seen and match_c_word(s,i,"include"):
	include_seen = true
	&lt;&lt; create a child node for all #include statements &gt;&gt;
else:
	j = i
	i = skip_pp_directive(s,i)</t>
<t tx="T1407"># Scan back to the start of the line.
include_start = i = find_line_start(s,i)

# Scan to the next line that is neither blank nor and #include.
i = skip_pp_directive(s,i)
i = skip_nl(s,i)
include_end = i
while i &lt; len(s):
	i = skip_ws_and_nl(s,i)
	if match_c_word(s,i,"#include"):
		i = skip_pp_directive(s,i)
		i = skip_nl(s,i)
		include_end = i
	elif i + 2 &lt; len(s) and s[i] == '\\':
		# Handle possible comment.
		if s[i+1] == '\\':
			i = skip_to_end_of_line(s,i)
		elif s[i+1] == '*':
			i = skip_block_comment(s,i + 2)
		else:
			i = include_end ; break
	else:
		i = include_end ; break
		

headline = angleBrackets(" " + self.methodName + " #includes ")
body = s[include_start:include_end]
body = self.undentBody(body)
prefix = choose(self.treeType == "@file","","@code\n\n")
self.createHeadline(parent,prefix + body,headline)
parent.appendStringToBody("@ignore\n" + self.rootLine + "@language c\n")

# Append any previous text to the parent's body.
save_ip = i ; i = scan_start
while i &lt; include_start and is_ws_or_nl(s,i):
	i += 1
if i &lt; include_start:
	parent.appendStringToBody(s[i:include_start])
scan_start = function_start = i = save_ip
# Append the headline to the parent's body.
parent.appendStringToBody(headline + "\n")</t>
<t tx="T1408">j = i = skip_braces(s,i) # Skip all inner blocks.

# This may fail if #if's contain unmatched curly braces.
if (match(s,i,'}') and lparen and name and function_start):
	# Point i _after_ the last character of the function.
	i += 1
	if is_nl(s,i):
		i = skip_nl(s,i)
	function_end = i
	if method_seen:
		# Include everything after the last function.
		function_start = scan_start 
	else:
		&lt;&lt; create a declaration node &gt;&gt;
		&lt;&lt; append C function/method reference to parent node &gt;&gt;
	headline = name
	body = s[function_start:function_end]
	body = self.massageBody(body,"functions")
	self.createHeadline(parent,body,headline)
	
	method_seen = true
	scan_start = function_start = i # Set the start of the _next_ function.
	lparen = None
else:
	i += 1</t>
<t tx="T1409">save_ip = i
i = scan_start
while i &lt; function_start and is_ws_or_nl(s,i):
	i += 1
if i &lt; function_start:
	headline = angleBrackets(" " + self.methodName + " declarations ")
	# Append the headline to the parent's body.
	parent.appendStringToBody(headline + "\n")
	decls = s[scan_start:function_start]
	decls = self.undentBody(decls)
	if self.treeType == "@file":
		body = decls
	else:
		body = "@code\n\n" + decls
	self.createHeadline(parent,body,headline)
i = save_ip
scan_start = i</t>
<t tx="T1410">if self.treeType == "@file":
	parent.appendStringToBody("@others\n")
else:
	cweb = c.target_language == "cweb"
	lb = choose(cweb,"@&lt;","&lt;&lt;")
	rb = choose(cweb,"@&gt;","&gt;&gt;")
	parent.appendStringToBody(
		lb + " " + self.methodName + " " + methodKind + " " + rb + "\n")</t>
<t tx="T1411">if match_c_word(s,i,"typedef"):
	i = skip_typedef(s,i)
	lparen = None
elif match_c_word(s,i,"struct"):
	i = skip_typedef(s,i)
	# lparen = None ;  # This can appear in an argument list.
elif match_c_word(s,i,"union"):
	i = skip_typedef(s,i)
	# lparen = None ;  # This can appear in an argument list.
elif match_c_word(s,i,"namespace"):
	&lt;&lt; create children for the namespace &gt;&gt;
# elif match_c_word(s,i,"class"):
	# &lt; &lt; create children for the class &gt; &gt;
else:
	# Remember the last name before an open parenthesis.
	if lparen == None:
		j = i ; i = skip_c_id(s,i) ; name = s[j:i]
	else:
		i = skip_c_id(s,i)
	&lt;&lt; test for operator keyword &gt;&gt;</t>
<t tx="T1412">@ Namesspaces change the self.moduleName and recursively call self function with a text covering only the range of the namespace. This effectively changes the definition line of any created child nodes. The namespace is written to the top level.
@c

# skip the "namespace" keyword.
i += len("namespace")
i = skip_ws_and_nl(s,i)
# Skip the namespace name.
namespace_name_start = i
namespace_name_end = None
if i &lt; len(s) and is_c_id(s[i]):
	i = skip_c_id(s,i)
	namespace_name_end = i - 1
else: namespace_name_start = None
# Skip the '{'
i = skip_ws_and_nl(s,i)
if match(s,i,'{') and namespace_name_start:
	inner_ip = i + 1
	i = skip_braces(s,i)
	if match(s,i,'}'):
		# Append everything so far to the body.
		if inner_ip &gt; scan_start:
			parent.appendStringToBody(s[scan_start:inner_ip])
		# Save and change self.moduleName to namespaceName
		savedMethodName = self.methodName
		namespaceName = s[namespace_name_start:namespace_name_end]
		self.methodName = "namespace " + namespaceName
		# Recursively call this function .
		self.scanCText(s[inner_ip:],parent)
		# Restore self.moduleName and continue scanning.
		self.methodName = savedMethodName
		scan_start = function_start = i</t>
<t tx="T1413"># We treat a C++ a construct such as operator + as a function name.
if match(name,0,"operator"):
	j = i
	i = skip_ws(s,i) # Don't allow newline in headline.
	if (i &lt; len(s) and not is_c_id(s[i]) and
		s[i]!=' ' and s[i]!='\n' and s[i]!='\r'):
		while (i &lt; len(s) and not is_c_id(s[i]) and
			s[i]!=' ' and s[i]!='\n' and s[i] != '\r'):
			i += 1
		name = s[j:i] # extend the name.</t>
<t tx="T1414">if match(s,i,"//"):
	i = skip_line(s,i)
elif match(s,i,"/*"):
	i = skip_block_comment(s,i)
else:
	i += 1</t>
<t tx="T1415">@ We can not be seeing a function definition when we find an equal sign at the top level. Equal signs inside parentheses are handled by the open paren logic.
@c

i += 1 # skip the '='
function_start = None # We can't be in a function.
lparen = None   # We have not seen an argument list yet.
if match(s,i,'='):
	i = skip_braces(s,i)</t>
<t tx="T1416">lparen = i
# This will skip any equal signs inside the paren.
i = skip_parens(s,i)
if match(s,i,')'):
	i += 1
	i = skip_ws_and_nl(s,i)
	if match(s,i,';'):
		lparen = None # not a function definition.
else: lparen = None</t>
<t tx="T1417">@ A semicolon signals the end of a declaration, thereby potentially starting the _next_ function defintion.   Declarations end a function definition unless we have already seen a parenthesis, in which case we are seeing an old-style function definition.
@c

i += 1 # skip the semicolon.
if lparen == None:
	function_start = i + 1 # The semicolon ends the declaration.</t>
<t tx="T1418"># Used by C, Java and Pascal parsers.
# Do nothing if only whitespace is left.

i = skip_ws_and_nl(s,scan_start)
if i &lt; len(s):
	parent.appendStringToBody(s[scan_start:])</t>
<t tx="T1419"># Creates a child of parent for each Java function definition seen.

def scanJavaText (self,s,parent,outerFlag): # true if at outer level.

	&lt;&lt; define scanJavaText vars &gt;&gt;
	# if not outerFlag: trace("inner:" + `s`)
	while i &lt; len(s):
		# trace(`get_line(s,i)`)
		ch = s[i]
		# These cases skip tokens.
		if ch == '/':
			&lt;&lt; handle possible Java comments &gt;&gt;
		elif ch == '"' or ch == '\'': i = skip_string(s,i)
		# These cases help determine where functions start.
		elif ch == '=':
			&lt;&lt; handle equal sign in Java &gt;&gt;
		elif ch == '(':
			&lt;&lt; handle open paren in Java &gt;&gt;
		elif ch == ';':
			&lt;&lt; handle semicolon in Java &gt;&gt;
			class_seen = false
		# These cases can create child nodes.
		elif ch == '{':
			&lt;&lt; handle open curly bracket in Java &gt;&gt;
		elif is_c_id(s[i]):
			&lt;&lt; skip and remember the Java id &gt;&gt;
		else: i += 1
	&lt;&lt; Append any unused text to the parent's body text &gt;&gt;</t>
<t tx="T1420">method_seen = false
class_seen = false # true: class keyword seen at outer level.
interface_seen = false # true: interface keyword seen at outer level.
lparen = None  # not None if '(' seen at outer level.
scan_start = 0
name = None
function_start = 0 # choose(outerFlag, None, 0)
i = 0</t>
<t tx="T1421">brace_ip1 = i
i = skip_braces(s,i) # Skip all inner blocks.
brace_ip2 = i

if not match (s,i,'}'):
	es("unmatched '{'")
elif not name:
	i += 1
elif (outerFlag and (class_seen or interface_seen)) or (not outerFlag and lparen):
	# trace("starting:"+name)
	# trace("outerFlag:"+`outerFlag`)
	# trace("lparen:"`lparen`)
	# trace("class_seen:"+`class_seen`)
	# trace("scan_start:"+get_line_after(s,scan_start))
	# trace("func_start:"+get_line_after(s,function_start))
	# trace("s:"+get_line(s,i))

	# Point i _after_ the last character of the method.
	i += 1
	if is_nl(s,i):
		i = skip_nl(s,i)
	function_end = i
	headline = name
	if outerFlag:
		leader = "" ; decl_leader = ""
		if class_seen:
			headline = "class " + headline
			methodKind = "classes"
		else:
			headline = "interface " + headline
			methodKind = "interfaces"
	else:
		leader = "\t" # Indent only inner references.
		decl_leader = "\n"  # Declaration leader for inner references.
		methodKind = "methods"
	if method_seen:
		# Include everything after the last fucntion.
		function_start = scan_start
	else:
		&lt;&lt; create a Java declaration node &gt;&gt;
		&lt;&lt; append Java method reference to parent node &gt;&gt;
	if outerFlag: # Create a class.
		# Backtrack so we remove leading whitespace.
		function_start = find_line_start(s,function_start)
		body = s[function_start:brace_ip1+1]
		body = self.massageBody(body,methodKind)
		v = self.createHeadline(parent,body,headline)
		&lt;&lt; recursively scan the text &gt;&gt;
		# Append the brace to the parent.
		v.appendStringToBody("}")
		i = brace_ip2 + 1 # Start after the closing brace.
	else: # Create a method.
		# Backtrack so we remove leading whitespace.
		function_start = find_line_start(s,function_start)
		body = s[function_start:function_end]
		body = self.massageBody(body,methodKind)
		self.createHeadline(parent,body,headline)
		i = function_end
	method_seen = true
	scan_start = function_start = i # Set the start of the _next_ function.
	lparen = None ; class_seen = false
else: i += 1</t>
<t tx="T1422">save_ip = i
i = scan_start
while i &lt; function_start and is_ws_or_nl(s,i):
	i += 1
	
if outerFlag:
	parent.appendStringToBody("@ignore\n" + self.rootLine + "@language java\n")

if i &lt; function_start:
	decl_headline = angleBrackets(" " + self.methodName + " declarations ")

	# Append the headline to the parent's body.
	parent.appendStringToBody(decl_leader + leader + decl_headline + "\n")
	scan_start = find_line_start(s,scan_start) # Backtrack so we remove leading whitespace.
	decls = s[scan_start:function_start]
	decls = self.undentBody(decls)
	body = choose(self.treeType == "@file",decls,"@code\n\n" + decls)
	self.createHeadline(parent,body,decl_headline)

i = save_ip
scan_start = i</t>
<t tx="T1423">if self.treeType == "@file":
	if outerFlag:
		parent.appendStringToBody("\n@others\n")
	else:
		parent.appendStringToBody("\n\t@others\n")
else:
	kind = choose(outerFlag,"classes","methods")
	ref_name = angleBrackets(" " + self.methodName + " " + kind + " ")
	parent.appendStringToBody(leader + ref_name + "\n")</t>
<t tx="T1424"># These mark the points in the present function.
# trace("recursive scan:" + `get_line(s,brace_ip1+ 1)`)
oldMethodName = self.methodName
self.methodName = headline
self.scanJavaText(s[brace_ip1+1:brace_ip2], # Don't include either brace.
	v,false) # inner level
self.methodName = oldMethodName
</t>
<t tx="T1425">if match_c_word(s,i,"class") or match_c_word(s,i,"interface"):
	if match_c_word(s,i,"class"):
		class_seen = true
	else:
		interface_seen = true
	i = skip_c_id(s,i) # Skip the class or interface keyword.
	i = skip_ws_and_nl(s,i)
	if i &lt; len(s) and is_c_id(s[i]):
		# Remember the class or interface name.
		j = i ; i = skip_c_id(s,i) ; name = s[j:i]
else:
	j = i ; i = skip_c_id(s,i)
	if not lparen and not class_seen:
		name = s[j:i] # Remember the name.</t>
<t tx="T1426">if match(s,i,"//"):
	i = skip_line(s,i)
elif match(s,i,"/*"):
	i = skip_block_comment(s,i)
else:
	i += 1</t>
<t tx="T1427">@ We can not be seeing a function definition when we find an equal sign at the top level. Equal signs inside parentheses are handled by the open paren logic.
@c

i += 1 # skip the '='
function_start = 0 # 3/23/03: (bug fix: was None) We can't be in a function.
lparen = None   # We have not seen an argument list yet.
if match(s,i,'='):
	i = skip_braces(s,i)</t>
<t tx="T1428">lparen = i
# This will skip any equal signs inside the paren.
i = skip_parens(s,i)
if match(s,i,')'):
	i += 1
	i = skip_ws_and_nl(s,i)
	if match(s,i,';'):
		lparen = None # not a function definition.
else: lparen = None</t>
<t tx="T1429">@ A semicolon signals the end of a declaration, thereby potentially starting the _next_ function defintion.   Declarations end a function definition unless we have already seen a parenthesis, in which case we are seeing an old-style function definition.
@c

i += 1 # skip the semicolon.
if lparen == None:
	function_start = i + 1 # The semicolon ends the declaration.</t>
<t tx="T1430"># Creates a child of parent for each Pascal function definition seen.

def scanPascalText (self,s,parent):

	method_seen = false ; methodKind = "methods"
	scan_start = function_start = i = 0
	name = None
	while i &lt; len(s):
		# line = get_line(s,i) ; trace(`line`)
		ch = s[i]
		if ch == '{': i = skip_pascal_braces(s,i)
		elif ch == '"' or ch == '\'': i = skip_pascal_string(s,i)
		elif match(s,i,"//"): i = skip_to_end_of_line(s,i)
		elif match(s,i,"(*"): i = skip_pascal_block_comment(s,i)
		elif is_c_id(s[i]):
			&lt;&lt; handle possible Pascal function &gt;&gt;
		else: i += 1
	&lt;&lt; Append any unused text to the parent's body text &gt;&gt;</t>
<t tx="T1431">if match_c_word(s,i,"begin"):
	i = skip_pascal_begin_end(s,i)
	if match_c_word(s,i,"end"):
		i = skip_c_id(s,i)
elif (match_c_word(s,i,"function")  or match_c_word(s,i,"procedure") or
	match_c_word(s,i,"constructor") or match_c_word(s,i,"destructor")):

	# line = get_line(s,i) ; trace(`line`)
	
	start = i
	i = skip_c_id(s,i)
	i = skip_ws_and_nl(s,i)
	&lt;&lt; remember the function name, or continue &gt;&gt;
	&lt;&lt; skip the function definition, or continue &gt;&gt;
	if not method_seen:
		method_seen = true
		&lt;&lt; create a child node for leading declarations &gt;&gt;
		&lt;&lt; append noweb method reference to the parent node &gt;&gt;
		function_start = start
	else: function_start = scan_start
	&lt;&lt; create a child node for the function &gt;&gt;
else: i = skip_c_id(s,i)</t>
<t tx="T1432">save_ip = i
i = scan_start
while i &lt; start and is_ws_or_nl(s,i):
	i += 1
if i &lt; start:
	parent.appendStringToBody("@ignore\n" + self.rootLine + "@language pascal\n")
	headline = angleBrackets(self.methodName + " declarations ")
	# Append the headline to the parent's body.
	parent.appendStringToBody(headline + "\n")
	if self.treeType == "@file":
		body = s[scan_start:start]
	else:
		body = "@code\n\n" + s[scan_start:start]
	body = self.undentBody(body)
	self.createHeadline(parent,body,headline)
i = save_ip
scan_start = i</t>
<t tx="T1433"># Point i _after_ the last character of the function.
i = skip_ws(s,i)
if is_nl(s,i):
	i = skip_nl(s,i)
function_end = i
headline = name
body = s[function_start:function_end]
body = self.massageBody(body,methodKind)
self.createHeadline(parent,body,headline)
scan_start = i</t>
<t tx="T1434">if i &lt; len(s) and is_c_id(s[i]):
	j = i ; i = skip_c_id(s,i)
	while i + 1 &lt; len(s) and s[i] == '.' and is_c_id(s[i+1]):
		i += 1 ; j = i
		i = skip_c_id(s,i)
	name = s[j:i]
else: continue</t>
<t tx="T1435">&lt;&lt; skip past the semicolon &gt;&gt;

if not match_c_word(s,i,"begin"):
	continue
# Skip to the matching end.
i = skip_pascal_begin_end(s,i)
if match_c_word(s,i,"end"):
	i = skip_c_id(s,i)
	i = skip_ws_and_nl(s,i)
	if match(s,i,';'):
		i += 1
	i = skip_ws(s,i)
	if is_nl(s,i):
		i = skip_nl(s,i)
else: continue</t>
<t tx="T1436">while i &lt; len(s) and s[i] != ';':
	# The paremeter list may contain "inner" semicolons.
	if s[i] == '(':
		i = skip_parens(s,i)
		if match(s,i,')'):
			i += 1
		else: break
	else: i += 1
if match(s,i,';'):
	i += 1
i = skip_ws_and_nl(s,i)

if match_c_word(s,i,"var"):
	# Skip to the next begin.
	i = skip_c_id(s,i)
	done = false
	while i &lt; len(s) and not done:
		ch = s[i]
		if ch == '{': i = skip_pascal_braces(s,i)
		elif match(s,i,"//"): i = skip_to_end_of_line(s,i)
		elif match(s,i,"(*"): i = skip_pascal_block_comment(s,i)
		elif is_c_id(ch):
			if match_c_word(s,i,"begin"): done = true
			else: i = skip_c_id(s,i)
		elif ch == '"' or ch == '\'': i = skip_pascal_string(s,i)
		else: i += 1</t>
<t tx="T1437"># Append the headline to the parent's body.
if self.treeType == "@file":
	parent.appendStringToBody("@others\n")
else:
	parent.appendStringToBody(
		angleBrackets(" " + self.methodName + " methods ") + "\n")</t>
<t tx="T1438"></t>
<t tx="T1439">@ Headlines not containing a section reference are ignored in noweb and generate index index in cweb.
@c

def convertCodePartToWeb (self,s,i,v,result):

	# line = get_line(s,i) ; trace(`line`)
	c = self.commands ; nl = self.output_newline
	lb = choose(self.webType=="cweb","@&lt;","&lt;&lt;")
	rb = choose(self.webType=="cweb","@&gt;","&gt;&gt;")
	h = string.strip(v.headString())
	&lt;&lt; put v's headline ref in head_ref &gt;&gt;
	&lt;&lt; put name following @root or @file in file_name &gt;&gt;
	if match_word(s,i,"@root"):
		i = skip_line(s,i)
		&lt;&lt; append ref to file_name &gt;&gt;
	elif match_word(s,i,"@c") or match_word(s,i,"@code"):
		i = skip_line(s,i)
		&lt;&lt; append head_ref &gt;&gt;
	elif match_word(h,0,"@file"):
		# Only do this if nothing else matches.
		&lt;&lt; append ref to file_name &gt;&gt;
		i = skip_line(s,i) # 4/28/02
	else:
		&lt;&lt; append head_ref &gt;&gt;
	i,result = self.copyPart(s,i,result)
	return i, string.strip(result) + nl
	
@ %defs a b c
</t>
<t tx="T1440">@ We look for either noweb or cweb brackets. head_ref does not include these brackets.
@c

head_ref = None
j = 0
if match(h,j,"&lt;&lt;"):
	k = string.find(h,"&gt;&gt;",j)
elif match(h,j,"&lt;@"):
	k = string.find(h,"@&gt;",j)
else:
	k = -1

if k &gt; -1:
	head_ref = string.strip(h[j+2:k])
	if len(head_ref) == 0:
		head_ref = None</t>
<t tx="T1441">if match(h,0,"@file") or match(h,0,"@root"):
	line = h[5:]
	line = string.strip(line)
	&lt;&lt; set file_name &gt;&gt;
else:
	file_name = line = None
</t>
<t tx="T1442"># set j &amp; k so line[j:k] is the file name.
# trace(`line`)

if match(line,0,"&lt;"):
	j = 1 ; k = string.find(line,"&gt;",1)
elif match(line,0,'"'):
	j = 1 ; k = string.find(line,'"',1)
else:
	j = 0 ; k = string.find(line," ",0)
if k == -1:
	k = len(line)

file_name = string.strip(line[j:k])
if file_name and len(file_name) == 0:
	file_name = None</t>
<t tx="T1443">if self.webType == "cweb":
	if not file_name:
		result += "@&lt;root@&gt;=" + nl
	else:
		result += "@(" + file_name + "@&gt;" + nl # @(...@&gt; denotes a file.
else:
	if not file_name:
		file_name = "*"
	result += lb + file_name + rb + "=" + nl
</t>
<t tx="T1444">if self.webType == "cweb":
	if not head_ref:
		result += "@^" + h + "@&gt;" + nl # Convert the headline to an index entry.
		result += "@c" + nl # @c denotes a new section.
	else: 
		escaped_head_ref = string.replace(head_ref,"@","@@")
		result += "@&lt;" + escaped_head_ref + "@&gt;=" + nl
else:
	if not head_ref:
		if v == c.currentVnode():
			head_ref = choose(file_name,file_name,"*")
		else:
			head_ref = "@others"

	result += lb + head_ref + rb + "=" + nl</t>
<t tx="T1445">def convertDocPartToWeb (self,s,i,result):
	
	nl = self.output_newline

	# line = get_line(s,i) ; trace(`line`)
	if match_word(s,i,"@doc"):
		i = skip_line(s,i)
	elif match(s,i,"@ ") or match(s,i,"@\t") or match(s,i,"@*"):
		i += 2
	elif match(s,i,"@\n"):
		i += 1
	i = skip_ws_and_nl(s,i)
	i, result2 = self.copyPart(s,i,"")
	if len(result2) &gt; 0:
		# Break lines after periods.
		result2 = string.replace(result2,".  ","." + nl)
		result2 = string.replace(result2,". ","." + nl)
		result += nl+"@"+nl+string.strip(result2)+nl+nl
	else:
		# All nodes should start with '@', even if the doc part is empty.
		result += choose(self.webType=="cweb",nl+"@ ",nl+"@"+nl)
	return i, result</t>
<t tx="T1446">@ This code converts a vnode to noweb text as follows:

Convert @doc to @
Convert @root or @code to &lt;&lt; name &gt;&gt;=, assuming the headline contains &lt;&lt; name &gt;&gt;
Ignore other directives
Format doc parts so they fit in pagewidth columns.
Output code parts as is.
@c

def convertVnodeToWeb (self,v):

	if not v: return ""
	startInCode = not app().config.at_root_bodies_start_in_doc_mode
	nl = self.output_newline
	s = v.bodyString()
	lb = choose(self.webType=="cweb","@&lt;","&lt;&lt;")
	i = 0 ; result = "" ; docSeen = false
	while i &lt; len(s):
		progress = i
		# line = get_line(s,i) ; trace(`line`)
		i = skip_ws_and_nl(s,i)
		if self.isDocStart(s,i) or match_word(s,i,"@doc"):
			i,result = self.convertDocPartToWeb(s,i,result)
			docSeen = true
		elif (match_word(s,i,"@code") or match_word(s,i,"@root") or
			match_word(s,i,"@c") or match(s,i,lb)):
			&lt;&lt; Supply a missing doc part &gt;&gt;
			i,result = self.convertCodePartToWeb(s,i,v,result)
		elif self.treeType == "@file" or startInCode:
			&lt;&lt; Supply a missing doc part &gt;&gt;
			i,result = self.convertCodePartToWeb(s,i,v,result)
		else:
			i,result = self.convertDocPartToWeb(s,i,result)
			docSeen = true
		assert(progress &lt; i)
	result = string.strip(result)
	if len(result) &gt; 0:
		result += nl
	return result</t>
<t tx="T1447">if not docSeen:
	docSeen = true
	result += choose(self.webType=="cweb",nl+"@ ",nl+"@"+nl)</t>
<t tx="T1448"># Copies characters to result until the end of the present section is seen.

def copyPart (self,s,i,result):

	# line = get_line(s,i) ; trace(`line`)
	lb = choose(self.webType=="cweb","@&lt;","&lt;&lt;")
	rb = choose(self.webType=="cweb","@&gt;","&gt;&gt;")
	type = self.webType
	while i &lt; len(s):
		progress = j = i # We should be at the start of a line here.
		# line = get_line(s,i) ; trace(`line`)
		i = skip_nl(s,i) ; i = skip_ws(s,i)
		if self.isDocStart(s,i):
			return i, result
		if (match_word(s,i,"@doc") or
			match_word(s,i,"@c") or
			match_word(s,i,"@root") or
			match_word(s,i,"@code")): # 2/25/03
			return i, result
		elif (match(s,i,"&lt;&lt;") and # must be on separate lines.
			find_on_line(s,i,"&gt;&gt;=") &gt; -1):
			return i, result
		else:
			# Copy the entire line, escaping '@' and
			# Converting @others to &lt; &lt; @ others &gt; &gt;
			i = skip_line(s,j) ; line = s[j:i]
			if type == "cweb":
				line = string.replace(line,"@","@@")
			else:
				j = skip_ws(line,0)
				if match(line,j,"@others"):
					line = string.replace(line,"@others",lb + "@others" + rb)
				elif match(line,0,"@"):
					# Special case: do not escape @ %defs.
					k = skip_ws(line,1)
					if not match(line,k,"%defs"):
						line = "@" + line
			result += line
		assert(progress &lt; i)
	return i, string.rstrip(result)</t>
<t tx="T1449">def exportHeadlines (self,fileName):
	
	c = self.commands ; v = c.currentVnode()
	nl = self.output_newline
	if not v: return
	self.setEncoding()
	after = v.nodeAfterTree()
	firstLevel = v.level()
	try:
		mode = app().config.output_newline
		mode = choose(mode=="platform",'w','wb')
		file = open(fileName,mode)
		while v and v != after:
			head = v.moreHead(firstLevel,useVerticalBar=true)
			head = toEncodedString(head,self.encoding,reportErrors=true)
			file.write(head + nl)
			v = v.threadNext()
		file.close()
	except:
		es("exception while exporting headlines")
		es_exception()</t>
<t tx="T1450">def flattenOutline (self,fileName):

	c = self.commands ; v = c.currentVnode()
	nl = self.output_newline
	if not v: return
	self.setEncoding()
	after = v.nodeAfterTree()
	firstLevel = v.level()
	try:
		# 10/14/02: support for output_newline setting.
		mode = app().config.output_newline
		mode = choose(mode=="platform",'w','wb')
		file = open(fileName,mode)
		while v and v != after:
			head = v.moreHead(firstLevel)
			head = toEncodedString(head,self.encoding,reportErrors=true)
			file.write(head + nl)
			body = v.moreBody() # Inserts escapes.
			if len(body) &gt; 0:
				body = toEncodedString(body,self.encoding,reportErrors=true)
				file.write(body + nl)
			v = v.threadNext()
		file.close()
	except:
		es("exception while flattening outline")
		es_exception()</t>
<t tx="T1451">def outlineToWeb (self,fileName,webType):

	c = self.commands ; v = c.currentVnode()
	nl = self.output_newline
	if v == None: return
	self.setEncoding()
	self.webType = webType
	after = v.nodeAfterTree()
	try: # This can fail if the file is open by another app.
		# 10/14/02: support for output_newline setting.
		mode = app().config.output_newline
		mode = choose(mode=="platform",'w','wb')
		file = open(fileName,mode)
		self.treeType = "@file"
		# Set self.treeType to @root if v or an ancestor is an @root node.
		while v:
			flag, junk = is_special(v.bodyString(),0,"@root")
			if flag:
				self.treeType = "@root" ; break
			else: v = v.parent()
		v = c.currentVnode()
		while v and v != after:
			s = self.convertVnodeToWeb(v)
			if len(s) &gt; 0:
				s = toEncodedString(s,self.encoding,reportErrors=true)
				file.write(s)
				if s[-1] != '\n':
					file.write(nl)
			v = v.threadNext()
		file.close()
	except:
		es("exception in Outline To noweb command")
		es_exception()</t>
<t tx="T1452">def removeSentinelsCommand (self,fileName):

	self.setEncoding()
	path, self.fileName = os.path.split(fileName) # path/fileName
	# trace(`self.fileName`)
	&lt;&lt; Read file into s &gt;&gt;
	valid = true
	line_delim = start_delim = end_delim = None
	&lt;&lt; set delims from the header line &gt;&gt;
	if valid == false:
		es("invalid @+leo sentinel in " + fileName)
	else:
		if 0:
			trace("line:"+`line_delim`+","+
				"start:"+`start_delim`+","+
				"end:"+`end_delim`)
		s = self.removeSentinelLines(s,line_delim,start_delim,end_delim)
		ext = app().config.remove_sentinels_extension
		if ext == None or len(ext) == 0:
			ext = ".txt"
		if ext[0] == '.':
			newFileName = os.path.join(path,fileName+ext)
		else:
			head,ext2 = os.path.splitext(fileName) 
			newFileName = os.path.join(path,head+ext+ext2)
		# newFileName = os.path.join(path,fileName+".txt") # 8/4/02: use txt, not tmp.
		&lt;&lt; Write s into newFileName &gt;&gt;</t>
<t tx="T1453">try:
	file = open(fileName)
	s = file.read()
	s = toUnicode(s,self.encoding)
	file.close()
except:
	es("exception while reading " + fileName)
	es_exception()
	return</t>
<t tx="T1454">@ This code is similar to atFile::scanHeader.
@c

tag = "@+leo"
# Skip any non @+leo lines.
i = 0
while i &lt; len(s) and not find_on_line(s,i,tag):
	i = skip_line(s,i)
# We should be at the @+leo line.
i = j = skip_ws(s,i)
# The opening comment delim is the initial non-whitespace.
while i &lt; len(s) and not match(s,i,tag) and not is_ws(s[i]) and not is_nl(s,i):
	i += 1
if j &lt; i: line_delim = s[j:i]
else: valid = false
# Make sure we have @+leo
i = skip_ws(s,i)
if match(s,i,tag): i += len(tag)
else: valid = false
# The closing comment delim is the trailing non-whitespace.
i = j = skip_ws(s,i)
while i &lt; len(s) and not is_ws(s[i]) and not is_nl(s,i):
	i += 1
if j &lt; i:
	start_delim = line_delim
	end_delim = s[j:i]
	line_delim = None</t>
<t tx="T1455">try:
	# 10/14/02: support for output_newline setting.
	mode = app().config.output_newline
	mode = choose(mode=="platform",'w','wb')
	file = open(newFileName,mode)
	s = toEncodedString(s,self.encoding,reportErrors=true)
	file.write(s)
	file.close()
	es("creating: " + newFileName)
except:
	es("exception creating: " + newFileName)
	es_exception()</t>
<t tx="T1456">@ Properly removes all sentinel lines in s.  Only leading single-line comments may be sentinels.

line_delim, start_delim and end_delim are the comment delimiters.
@c

def removeSentinelLines(self,s,line_delim,start_delim,end_delim):

	i = 0 ; result = "" ; first = true
	while i &lt; len(s):
		start = i # The start of the next syntax element.
		if first or is_nl(s,i):
			first = false
			&lt;&lt; handle possible sentinel &gt;&gt;
		elif match(s,i,line_delim):
			i = skip_to_end_of_line(s,i)
		elif match(s,i,start_delim):
			i = skip_matching_delims(s,i,start_delim,end_delim)
		elif match(s,i,"'") or match(s,i,'"'):
			i = skip_string(s,i)
		else:
			i += 1
		assert(i==0 or start&lt;i)
		result += s[start:i]
	return result</t>
<t tx="T1457">i = skip_nl(s,i)
i = skip_ws(s,i)

if line_delim:
	if match(s,i,line_delim):
		j = i + len(line_delim)
		i = skip_to_end_of_line(s,i)
		if match(s,j,"@"):
			continue # Remove the sentinel.
elif start_delim:
	if match(s,i,start_delim):
		j = i + len(start_delim)
		i = skip_matching_delims(s,i,start_delim,end_delim)
		if match(s,j,"@"):
			continue # Remove the sentinel.</t>
<t tx="T1458">def weave (self,filename):
	
	c = self.commands ; v = c.currentVnode()
	nl = self.output_newline
	if not v: return
	self.setEncoding()
	&lt;&lt; open filename to f, or return &gt;&gt;
	after = v.nodeAfterTree()
	while v and v != after:
		s = v.bodyString()
		s2 = string.strip(s)
		if s2 and len(s2) &gt; 0:
			f.write("-" * 60) ; f.write(nl)
			&lt;&lt; write the context of v to f &gt;&gt;
			f.write("-" * 60) ; f.write(nl)
			s = toEncodedString(s,self.encoding,reportErrors=true) # 2/25/03
			f.write(string.rstrip(s) + nl)
		v = v.threadNext()
	f.flush()
	f.close()</t>
<t tx="T1459">try:
	# 10/14/02: support for output_newline setting.
	mode = app().config.output_newline
	mode = choose(mode=="platform",'w','wb')
	f = open(filename,mode)
	if not f: return
except:
	es("exception opening:" + filename)
	es_exception()
	return</t>
<t tx="T1460"># write the headlines of v, v's parent and v's grandparent.
context = [] ; v2 = v
for i in xrange(3):
	if not v2: break
	context.append(v2.headString())
	v2 = v2.parent()

context.reverse()
indent = ""
for line in context:
	f.write(indent)
	indent += '\t'
	line = toEncodedString(line,self.encoding,reportErrors=true)
	f.write(line)
	f.write(nl)
</t>
<t tx="T1461"></t>
<t tx="T1462">def createHeadline (self,parent,body,headline):

	# trace("parent,headline:" + `parent` + ":" + `headline`)
	# Create the vnode.
	v = parent.insertAsLastChild()
	v.initHeadString(headline,self.encoding)
	# Set the body.
	if len(body) &gt; 0:
		v.setBodyStringOrPane(body,self.encoding)
	return v</t>
<t tx="T1463">def error (self,s): es(s)</t>
<t tx="T1464">@ This code returns the leading whitespace of a line, ignoring blank and comment lines.
@c

def getLeadingIndent (self,s,i):

	c = self.commands
	i = find_line_start(s,i)
	while i &lt; len(s):
		# trace(`get_line(s,i)`)
		j = skip_ws(s,i) # Bug fix: 2/14/03
		if is_nl(s,j) or match(s,j,"#"): # Bug fix: 2/14/03
			i = skip_line(s,i) # ignore blank lines and comment lines.
		else:
			i, width = skip_leading_ws_with_indent(s,i,c.tab_width)
			# trace("returns:" + `width`)
			return width
	# trace("returns:0")
	return 0</t>
<t tx="T1465"># The start of a document part or module in a noweb or cweb file.
# Exporters may have to test for @doc as well.

def isDocStart (self,s,i):
	
	if not match(s,i,"@"):
		return false

	j = skip_ws(s,i+1)
	if match(s,j,"%defs"):
		return false
	elif self.webType == "cweb" and match(s,i,"@*"):
		return true
	else:
		return match(s,i,"@ ") or match(s,i,"@\t") or match(s,i,"@\n")

def isModuleStart (self,s,i):

	if self.isDocStart(s,i):
		return true
	else:
		return self.webType == "cweb" and (
			match(s,i,"@c") or match(s,i,"@p") or
			match(s,i,"@d") or match(s,i,"@f"))
</t>
<t tx="T1466">def massageBody (self,s,methodKind):
	
	# trace(`s`)
	# trace(`get_line(s,0)`)
	c = self.commands
	if self.treeType == "@file":
		if self.fileType == ".py": # 7/31/02: was "py"
			return self.undentBody(s)
		else:
			newBody, comment = self.skipLeadingComments(s)
			newBody = self.undentBody(newBody)
			newLine = choose(is_nl(newBody,0),"\n","\n\n")
			if len(comment) &gt; 0:
				return comment + "\n@c" + newLine + newBody
			else:
				return newBody
	else:
		# Inserts &lt; &lt; self.methodName methodKind &gt; &gt; =
		cweb = self.fileType == "c" and not c.use_noweb_flag
		lb = choose(cweb,"@&lt;","&lt;&lt;")
		rb = choose(cweb,"@&gt;=","&gt;&gt;=")
		intro = lb + " " + self.methodName + " " + methodKind + " " + rb
		if self.fileType == ".py": # 7/31/02: was "py"
			newBody = self.undentBody(s)
			newLine = choose(is_nl(newBody,0),"\n","\n\n")
			return intro + newLine + newBody
		else:
			newBody, comment = self.skipLeadingComments(s)
			newBody = self.undentBody(newBody)
			newLine = choose(is_nl(newBody,0),"\n","\n\n")
			if len(comment) &gt; 0:
				return comment + "\n" + intro + newLine + newBody
			else:
				return intro + newLine + newBody</t>
<t tx="T1467">@ Returns s with all runs of whitespace and newlines converted to a single blank.  It also removes leading and trailing whitespace.
@c

def massageComment (self,s):

	# trace(`get_line(s,0)`)
	s = string.strip(s)
	s = string.replace(s,"\n"," ")
	s = string.replace(s,"\r"," ")
	s = string.replace(s,"\t"," ")
	s = string.replace(s,"  "," ")
	s = string.strip(s)
	return s</t>
<t tx="T1468">def massageWebBody (self,s):

	type = self.webType
	lb = choose(type=="cweb","@&lt;","&lt;&lt;")
	rb = choose(type=="cweb","@&gt;","&gt;&gt;")
	&lt;&lt; Remove most newlines from @space and @* sections &gt;&gt;
	&lt;&lt; Replace abbreviated names with full names &gt;&gt;
	s = string.rstrip(s)
	return s</t>
<t tx="T1469">i = 0
while i &lt; len(s):
	i = skip_ws_and_nl(s,i)
	if self.isDocStart(s,i):
		# Scan to end of the doc part.
		if match(s,i,"@ %def"):
			# Don't remove the newline following %def
			i = skip_line(s,i) ; start = end = i
		else:
			start = end = i ; i += 2
		while i &lt; len(s):
			i = skip_ws_and_nl(s,i)
			if self.isModuleStart(s,i) or match(s,i,lb):
				end = i ; break
			elif type == "cweb": i += 1
			else: i = skip_to_end_of_line(s,i)
		# Remove newlines from start to end.
		doc = s[start:end]
		doc = string.replace(doc,"\n"," ")
		doc = string.replace(doc,"\r","")
		doc = string.strip(doc)
		if doc and len(doc) &gt; 0:
			if doc == "@":
				doc = choose(self.webType=="cweb", "@ ","@\n")
			else:
				doc += "\n\n"
			# trace("new doc:" + `doc`)
			s = s[:start] + doc + s[end:]
			i = start + len(doc)
	else: i = skip_line(s,i)</t>
<t tx="T1470">i = 0
while i &lt; len(s):
	# trace(`get_line(s,i)`)
	if match(s,i,lb):
		i += 2 ; j = i ; k = find_on_line(s,j,rb)
		if k &gt; -1:
			name = s[j:k]
			name2 = self.cstLookup(name)
			if name != name2:
				# Replace name by name2 in s.
				# trace("replacing:" + `name` + ", by:" + `name2`)
				s = s[:j] + name2 + s[k:]
				i = j + len(name2)
	i = skip_line(s,i)</t>
<t tx="T1471">def setEncoding (self):
	
	# scanDirectives checks the encoding: may return None.
	dict = scanDirectives(self.commands)
	encoding = dict.get("encoding")
	if encoding and isValidEncoding(encoding):
		self.encoding = encoding
	else:
		self.encoding = app().tkEncoding # 2/25/03

	# print self.encoding
</t>
<t tx="T1472">@ This skips all leading comments in s, returning the remaining body text and the massaged comment text.
Returns (body, comment)
@c

def skipLeadingComments (self,s):

	# trace(`get_line(s,0)`)
	s_original = s
	s = string.lstrip(s)
	i = 0 ; comment = ""
	if self.fileType in [".c", ".cpp"]: # 11/2/02: don't mess with java comments.
		&lt;&lt; scan for C-style comments &gt;&gt;
	elif self.fileType == ".pas":
		&lt;&lt; scan for Pascal comments &gt;&gt;
	elif self.fileType == ".py":
		&lt;&lt; scan for Python comments &gt;&gt;
	comment = string.strip(comment)
	if len(comment) == 0:
		return s_original, "" # Bug fix: 11/2/02: don't skip leading whitespace!
	elif self.treeType == "@file":
		return s[i:], "@ " + comment
	else:
		return s[i:], "@ " + comment + "\n"</t>
<t tx="T1473">while i &lt; len(s):
	if match(s,i,"//"): # Handle a C++ comment.
		while match(s,i,'/'):
			i += 1
		j = i ; i = skip_line(s,i)
		comment = comment + self.massageComment(s[j:i]) + "\n"
		# 8/2/02: Preserve leading whitespace for undentBody
		i = skip_ws(s,i)
		i = skip_blank_lines(s,i)
	elif match(s,i,"/*"): # Handle a block C comment.
		j = i + 2 ; i = skip_block_comment (s,i)
		k = choose(match(s,i-2,"*/"),i-2,i)
		if self.fileType == ".java":
			# 8/2/02: a hack: add leading whitespace then remove it.
			comment = self.undentBody(comment)
			comment2 = ' ' * 2 + s[j:k]
			comment2 = self.undentBody(comment2)
			comment = comment + comment2 + "\n"
		else:
			comment = comment + self.massageComment(s[j:k]) + "\n"
		# 8/2/02: Preserve leading whitespace for undentBody
		i = skip_ws(s,i)
		i = skip_blank_lines(s,i)
	else: break</t>
<t tx="T1474">while i &lt; len(s):
	if match(s,i,"//"): # Handle a Pascal line comment.
		while match(s,i,'/'):
			i += 1
		j = i ; i = skip_line(s,i)
		comment = comment + self.massageComment(s[j:i]) + "\n"
		# 8/2/02: Preserve leading whitespace for undentBody
		i = skip_ws(s,i)
		i = skip_blank_lines(s,i)
	elif match(s,i,'(*'):
		j = i + 1 ; i = skip_pascal_block_comment(s,i)
		comment = comment + self.massageComment(s[j:i]) + "\n"
		# 8/2/02: Preserve leading whitespace for undentBody
		i = skip_ws(s,i)
		i = skip_blank_lines(s,i)
	else: break</t>
<t tx="T1475">while i &lt; len(s) and match(s,i,'#'):
	j = i + 1 ; i = skip_line(s,i)
	comment = self.undentBody(comment)
	comment = comment + self.massageComment(s[j:i]) + "\n"
	# 8/2/02: Preserve leading whitespace for undentBody
	i = skip_ws(s,i)
	i = skip_blank_lines(s,i)</t>
<t tx="T1476">@ Removes extra leading indentation from all lines.  We look at the first line to determine how much leading whitespace to delete.
@c

def undentBody (self,s):

	# trace(`s`)
	c = self.commands
	i = 0 ; result = ""
	# Copy an @code line as is.
	if match(s,i,"@code"):
		j = i ; i = skip_line(s,i) # don't use get_line: it is only for dumping.
		result += s[j:i]
	# Calculate the amount to be removed from each line.
	undent = self.getLeadingIndent(s,i)
	if undent == 0: return s
	while i &lt; len(s):
		j = i ; i = skip_line(s,i) # don't use get_line: it is only for dumping.
		line = s[j:i]
		# trace(`line`)
		line = removeLeadingWhitespace(line,undent,c.tab_width)
		result += line
	return result</t>
<t tx="T1477">@language python

&lt;&lt; About the vnode and tnode classes &gt;&gt;
&lt;&lt; About clones &gt;&gt;

from leoGlobals import *
import types

@others</t>
<t tx="T1478">@ This is the design document for clones in Leo. It covers all important aspects of clones. Clones are inherently complex, and this paper will include several different definitions of clones and related concepts.

The following is a definition of clones from the user's point of view.

Definition 1

A clone node is a copy of a node that changes when the original changes. Changes to the children, grandchildren, etc. of a node are simultaneously made to the corresponding nodes contained in all cloned nodes. Clones are marked by a small clone arrow by its leader character.

As we shall see, this definition glosses over a number of complications. Note that all cloned nodes (including the original node) are equivalent. There is no such thing as a "master" node from which all clones are derived. When the penultimate cloned node is deleted, the remaining node becomes an ordinary node again.

Internally, the clone arrow is represented by a clone bit in the status field of the vnode. The Clone Node command sets the clone bits of the original and cloned vnodes when it creates the clone. Setting and clearing clone bits properly when nodes are inserted, deleted or moved, is non-trivial. We need the following machinery to do the job properly.

Two vnodes are joined if a) they share the same tnode (body text) and b) changes to any subtree of either joined vnodes are made to the corresponding nodes in all joined nodes.  For example, Definition 1 defines clones as joined nodes that are marked with a clone arrow.  Leo links all vnodes joined to each other in a circular list, called the join list. For any vnode n, let J(n) denote the join list of n, that is, the set of all vnodes joined to n. Again, maintaining the join lists in an outline is non-trivial.

The concept of structurally similar nodes provides an effective way of determining when two joined nodes should also have their cloned bit set.  Two joined nodes are structurally similar if a) their parents are distinct but joined and b) they are both the nth child of their (distinct) parents.  We can define cloned nodes using the concept of structurally similar nodes as follows:

Definition 2

Clones are joined vnodes such that at least two of the vnodes of J(n) are not structurally similar to each other. Non-cloned vnodes are vnodes such that all of the vnodes of J(n) are structurally similar. In particular, n is a non-cloned vnode if J(n) is empty.

Leo ensures that definitions 1 and 2 are consistent. Definition 1 says that changes to the children, grandchildren, etc. of a node are simultaneously made to the corresponding nodes contained in all cloned nodes. Making "corresponding changes" to the non-cloned descendents of all cloned nodes insures that the non-cloned joined nodes will be structurally similar. On the other hand, cloned nodes are never structurally similar. They are created as siblings, so they have the same parent with different "child indices."  To see how this works in practice, let's look at some examples.

Example 1

+ root
	+ a' (1)
	+ a' (2)

This example shows the simplest possible clone. A prime (') indicates a cloned node.  Node a in position (1) has just been cloned to produce a' in position (2). Clearly, these two cloned nodes are not structurally similar because their parents are not distinct and they occupy different positions relative to their common parent.

Example 2

If we add a node b to either a' node we get the following tree:

+ root
	+ a'
		+ b
	+ a'
		+ b

The b nodes are structurally similar because the a' nodes are joined and each b node is the first child of its parent.

Example 3

If we now clone either b, we will get:

+ root
	+ a'
		+ b' (1)
		+ b' (2)
	+ a'
		+ b' (1)
		+ b' (2)

All b' nodes must be clones because the nodes marked (1) are not structurally similar to the nodes marked (2).

Dependent nodes are nodes created or destroyed when corresponding linked nodes are created or destroyed in another tree. For example, going from example 1 to example 2 above, adding node b to either node a' causes another (dependent) node to be created as the ancestor of the other node a'. Similarly, going from example 2 to example 1, deleting node b from either node a' causes the other (dependent) node b to be deleted from the other node a'.  Cloned nodes may also be dependent nodes. In Example 3, all the b' nodes are dependent on any of the other b' nodes.

We can now give simple rules for inserting and deleting dependent vnodes when other vnodes are created, moved or destroyed. For the purposes of this discussion, moving a node is handled exactly like deleting the node then inserting the node; we need not consider moving nodes further.  We insert a new node n as the nth child of a parent node p as follows. We insert n, then for every node pi linked to p, we insert a dependent node ni as the nth child of pi. Each ni is linked to n. Clearly, each ni is structurally similar to n.  Similarly, it is easy to delete a node n that is the nth child of a parent node p. We delete each dependent node ni that is the nth child of any node pi linked to p. We then delete n.  When inserting or deleting any vnode n we must update its join list, J(n). Updating the join list is easy because the join list is circular: the entire list is accessible from any of its members.

Inserting or deleting nodes can cause the clone bits of all joined nodes to change in non-trivial ways. To see the problems that can arise, consider deleting any of the b' nodes from Example 3. We would be left with the tree in Example 2. There are two remaining b nodes, each with the clone bit set. Unless we know that both b nodes are structurally similar, there would be no way to conclude that we should clear the clone bits in each node. In order to update clone links properly we could examine many special cases, but there is an easier way. Because of definition 2, we can define a shouldBeCloned function that checks J(n) to see whether all nodes of J(n) are structurally similar.

Leo's XML file format does not contain join lists. This makes it easy to change a Leo file "by hand." If join lists were a part of the file, as they are in the Mac version of Leo, corrupting a join list would corrupt the entire file. It is easy to recreate the join lists when reading a file using a dedicated field in the tnode.  This field is the head of a list of all vnodes that points to the tnode. After reading all nodes, Leo creates this list with one pass through the vnodes.  Leo then converts each list to a circular list with one additional pass through the tnodes.
</t>
<t tx="T1479">@ The vnode and tnode classes represent most of the data contained in the outline. These classes are Leo's fundamental Model classes.

A vnode (visual node) represents a headline at a particular location on the screen. When a headline is cloned, vnodes must be copied. vnodes persist even if they are not drawn on the screen. Commanders call vnode routines to insert, delete and move headlines.

The vnode contains data associated with a headline, except the body text data which is contained in tnodes. A vnode contains headline text, a link to its tnode and other information. In leo.py, vnodes contain structure links: parent, firstChild, next and back ivars. To insert, delete, move or clone a vnode the vnode class just alters those links. The Commands class calls the leoTree class to redraw the outline pane whenever it changes. The leoTree class knows about these structure links; in effect, the leoTree and vnode classes work together. The implementation of vnodes is quite different in the Borland version of Leo. This does not affect the rest of the Leo. Indeed, vnodes are designed to shield Leo from such implementation details.

A tnode, (text node) represents body text: a tnode is shared by all vnodes that are clones of each other. In other words, tnodes are the unit of sharing of body text. The tnode class is more private than the vnode class. Most commanders deal only with vnodes, though there are exceptions.

Because leo.py has unlimited Undo commands, vnodes and tnodes can be deleted only when the window containing them is closed. Nodes are deleted indirectly.

Leo uses several kinds of node indices. Leo's XML file format uses tnode indices to indicate which tnodes (t elements) belong to which vnodes (v elements). Such indices are required. Even if we duplicated the body text of shared tnodes within the file, the file format would still need an unambiguous way to denote that tnodes are shared.

Present versions of Leo recompute these tnodes indices whenever Leo writes any .leo file. Earlier versions of Leo remembered tnode indices and rewrote the same indices whenever possible. Those versions of Leo recomputed indices when executing the Save As and Save To commands, so using these commands was a way of "compacting" indices. The main reason for not wanting to change tnode indices in .leo files was to reduce the number of changes reported by CVS and other Source Code Control Systems. I finally abandoned this goal in the interest of simplifying the code. Also, CVS will likely report many differences between two versions of the same .leo file, regardless of whether tnode indices are conserved.

A second kind of node index is the clone index used in @+node sentinels in files derived from @file trees. As with indices in .leo files, indices in derived files are required so that Leo can know unambiguously which nodes are cloned to each other.

It is imperative that clone indices be computed correctly, that is, that tnode @+node sentinels have the same index if and only if the corresponding vnodes are cloned. Early versions of leo.py had several bugs involving these clone indices. Such bugs are extremely serious because they corrupt the derived file and cause read errors when Leo reads the @file tree. Leo must guarantee that clone indices are always recomputed properly. This is not as simple as it might appear at first. In particular, Leo's commands must ensure that @file trees are marked dirty whenever any changed is made that affects cloned nodes within the tree. For example, a change made outside any @file tree may make several @file trees dirty if the change is made to a node with clones in those @file trees.
</t>
<t tx="T1480"></t>
<t tx="T1481"></t>
<t tx="T1482"></t>
<t tx="T1483"></t>
<t tx="T1484"></t>
<t tx="T1485"></t>
<t tx="T1486"></t>
<t tx="T1487"></t>
<t tx="T1488"></t>
<t tx="T1489"></t>
<t tx="T1490"></t>
<t tx="T1491"></t>
<t tx="T1492"></t>
<t tx="T1493"></t>
<t tx="T1494"></t>
<t tx="T1495"></t>
<t tx="T1496"></t>
<t tx="T1497"></t>
<t tx="T1498"></t>
<t tx="T1499"></t>
<t tx="T1500"></t>
<t tx="T1501"></t>
<t tx="T1502"></t>
<t tx="T1503"></t>
<t tx="T1504"></t>
<t tx="T1505"></t>
<t tx="T1506"></t>
<t tx="T1507"></t>
<t tx="T1508"></t>
<t tx="T1509"></t>
<t tx="T1510"></t>
<t tx="T1511"></t>
<t tx="T1512"></t>
<t tx="T1513"></t>
<t tx="T1514"></t>
<t tx="T1515"></t>
<t tx="T1516"></t>
<t tx="T1517"></t>
<t tx="T1518"></t>
<t tx="T1519"></t>
<t tx="T1520"></t>
<t tx="T1521"></t>
<t tx="T1522"></t>
<t tx="T1523"></t>
<t tx="T1524"></t>
<t tx="T1525"></t>
<t tx="T1526"></t>
<t tx="T1527"></t>
<t tx="T1528"></t>
<t tx="T1529"></t>
<t tx="T1530"></t>
<t tx="T1531"></t>
<t tx="T1532"></t>
<t tx="T1533"></t>
<t tx="T1534"></t>
<t tx="T1535"></t>
<t tx="T1536"></t>
<t tx="T1537"></t>
<t tx="T1538"></t>
<t tx="T1539"></t>
<t tx="T1540"></t>
<t tx="T1541"></t>
<t tx="T1542"></t>
<t tx="T1543"></t>
<t tx="T1544"></t>
<t tx="T1545"></t>
<t tx="T1546"></t>
<t tx="T1547"></t>
<t tx="T1548"></t>
<t tx="T1549"></t>
<t tx="T1550"></t>
<t tx="T1551"></t>
<t tx="T1552"></t>
<t tx="T1553"></t>
<t tx="T1554"></t>
<t tx="T1555"></t>
<t tx="T1556"></t>
<t tx="T1557"></t>
<t tx="T1558"></t>
<t tx="T1559"></t>
<t tx="T1560"></t>
<t tx="T1561"></t>
<t tx="T1562"></t>
<t tx="T1563"></t>
<t tx="T1564"></t>
<t tx="T1565"></t>
<t tx="T1566"></t>
<t tx="T1567"></t>
<t tx="T1568"></t>
<t tx="T1569"></t>
<t tx="T1570"></t>
<t tx="T1571"></t>
<t tx="T1572"></t>
<t tx="T1573"></t>
<t tx="T1574"></t>
<t tx="T1575"></t>
<t tx="T1576"></t>
<t tx="T1577"></t>
<t tx="T1578"></t>
<t tx="T1579"></t>
<t tx="T1580"></t>
<t tx="T1581"></t>
<t tx="T1582"></t>
<t tx="T1583"></t>
<t tx="T1584"></t>
<t tx="T1585"></t>
<t tx="T1586"></t>
<t tx="T1587"></t>
<t tx="T1588"></t>
<t tx="T1589"></t>
<t tx="T1590"></t>
<t tx="T1591"></t>
<t tx="T1592"></t>
<t tx="T1593"></t>
<t tx="T1594"></t>
<t tx="T1595"></t>
<t tx="T1596"></t>
<t tx="T1597"></t>
<t tx="T1598"></t>
<t tx="T1599"></t>
<t tx="T1600"></t>
<t tx="T1601"></t>
<t tx="T1602"></t>
<t tx="T1603"></t>
<t tx="T1604"></t>
<t tx="T1605"></t>
<t tx="T1606"></t>
<t tx="T1607"></t>
<t tx="T1608"></t>
<t tx="T1609"></t>
<t tx="T1610"></t>
<t tx="T1611"></t>
<t tx="T1612"></t>
<t tx="T1613"></t>
<t tx="T1614"></t>
<t tx="T1615"></t>
<t tx="T1616"></t>
<t tx="T1617"></t>
<t tx="T1618"></t>
<t tx="T1619"></t>
<t tx="T1620"></t>
<t tx="T1621"></t>
<t tx="T1622"></t>
<t tx="T1623"></t>
<t tx="T1624"></t>
<t tx="T1625"></t>
<t tx="T1626"></t>
<t tx="T1627"></t>
<t tx="T1628"></t>
<t tx="T1629"></t>
<t tx="T1630"></t>
<t tx="T1631"></t>
<t tx="T1632"></t>
<t tx="T1633"></t>
<t tx="T1634"></t>
<t tx="T1635">"""Install and run Leo plugins.

On startup:
- doPlugins() calls loadHandlers() to import all
  mod_XXXX.py files in the Leo directory.

- Imported files should register hook handlers using the
  registerHandler and registerExclusiveHandler functions.
  Only one "exclusive" function is allowed per hook.

After startup:
- doPlugins() calls doHandlersForTag() to handle the hook.
- The first non-None return is sent back to Leo.
"""

from leoGlobals import *

handlers = {}
count = 0 ; examined = 0

def doPlugins(tag,keywords):
	if tag == "start1":
		loadHandlers()
	return doHandlersForTag(tag,keywords)
		
@others</t>
<t tx="T1636"></t>
<t tx="T1637"></t>
<t tx="T1638"></t>
<t tx="T1639"></t>
<t tx="T1640"></t>
<t tx="T1641">@language python

from leoGlobals import *
import string,Tkinter

# Public constants used for defaults when leoConfig.txt can not be read.
default_page_width = 132
default_tab_width = 4
default_target_language = "python"
default_default_directory = None

ivars = [
	"tangle_batch_flag", "untangle_batch_flag",
	"use_header_flag", "output_doc_flag",
	"tangle_directory", "page_width", "tab_width",
	"target_language" ]

class baseLeoPrefs:
	"""The base class of Leo's preferences panel."""
	@others
	
class LeoPrefs (baseLeoPrefs):
	"""A class that creates Leo's preferenes panel."""
	pass</t>
<t tx="T1642">def __init__ (self,c):

	Tk = Tkinter
	&lt;&lt; set ivars &gt;&gt;
	self.commands = c
	self.top = top = Tk.Toplevel()
	c.frame.prefsPanel = self
	head,tail = os.path.split(c.frame.title)
	self.top.title("Prefs for " + tail)
	
	# Create the outer frame
	outer = Tk.Frame(top,bd=2,relief="groove")
	outer.pack(fill="both",expand=1,padx=2,pady=2)
	&lt;&lt; Create the Global Options frame &gt;&gt;
	&lt;&lt; Create the Tangle Options frame &gt;&gt;
	&lt;&lt; Create the Target Language frame &gt;&gt;
	&lt;&lt; Create the Ok, Cancel &amp; Revert buttons &gt;&gt;
	center_dialog(top) # Do this _after_ building the dialog!
	top.resizable(0,0) # neither height or width is resizable.
	self.top.protocol("WM_DELETE_WINDOW", self.onCancel) # 1/31/03
	self.init(c)
	# es("Prefs.__init__")</t>
<t tx="T1643"># These ivars have the same names as the corresponding ivars in commands class.

# Global options
self.page_width = default_page_width
self.tab_width = default_tab_width
self.tangle_batch_flag = 0
self.untangle_batch_flag = 0

self.replace_tabs_var = Tk.IntVar() # 1/30/03
self.tangle_batch_var = Tk.IntVar()
self.untangle_batch_var = Tk.IntVar()

# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = 0
self.output_doc_flag = 0

self.use_header_var = Tk.IntVar()
self.output_doc_var = Tk.IntVar()

# Default Target Language
self.target_language = default_target_language
self.lang_var = Tk.StringVar()</t>
<t tx="T1644"># Frame and title
w,glob = create_labeled_frame (outer,caption="Global Options")
w.pack(padx=2,pady=2,expand=1,fill="x")

# Page width &amp; page width
f = Tk.Frame(glob)
f.pack(anchor="w", pady="1m", expand=1, fill="x")

lab = Tk.Label(f, anchor="w", padx="1m", text="Page width:")
self.pageWidthText = txt = Tk.Text(f, height=1, width=4)
lab.pack(side="left")
txt.pack(side="left")
txt.bind("&lt;Key&gt;", self.idle_set_ivars)

lab2 = Tk.Label(f, padx="1m", text="Tab width:")
self.tabWidthText = txt2 = Tk.Text(f, height=1, width=4)
lab2.pack(side="left")
txt2.pack(side="left")
txt2.bind("&lt;Key&gt;", self.idle_set_ivars)

# Batch Checkbuttons...
self.replaceTabsBox = replaceBox = Tk.Checkbutton(glob,anchor="w",
	text="Replace tabs with spaces",
	variable=self.replace_tabs_var,command=self.idle_set_ivars)
self.doneBox = doneBox = Tk.Checkbutton(glob,anchor="w",
	text="Run tangle_done.py after Tangle",
	variable=self.tangle_batch_var,command=self.idle_set_ivars)
self.unBox = unBox = Tk.Checkbutton(glob,anchor="w",
	text="Run untangle_done.py after Untangle",
	variable=self.untangle_batch_var,command=self.idle_set_ivars)

for box in (replaceBox, doneBox, unBox):
	box.pack(fill="x")</t>
<t tx="T1645"># Frame and title
w,tangle = create_labeled_frame (outer,caption="Default Options")
w.pack(padx=2,pady=2,expand=1,fill="x")

# Label and text
lab3 = Tk.Label(tangle, anchor="w", text="Default tangle directory")
self.tangleDirectoryText = txt3 = Tk.Text(tangle, height=1, width=30)
txt3.bind("&lt;Key&gt;", self.idle_set_ivars) # Capture the change immediately
lab3.pack(            padx="1m", pady="1m", fill="x")
txt3.pack(anchor="w", padx="1m", pady="1m", fill="x")

# Checkbuttons
self.headerBox = header = Tk.Checkbutton(tangle,anchor="w",
	text="Tangle outputs header line",
	variable=self.use_header_var,command=self.idle_set_ivars)
self.docBox = doc = Tk.Checkbutton(tangle,anchor="w",
	text="Tangle outputs document chunks",
	variable=self.output_doc_var,command=self.idle_set_ivars)
header.pack(fill="x")
doc.pack(fill="x")</t>
<t tx="T1646"># Frame and title
w,target = create_labeled_frame (outer,caption="Default Target Language")
w.pack(padx=2,pady=2,expand=1,fill="x")

# Frames for two columns of radio buttons
lt = Tk.Frame(target)
rt = Tk.Frame(target)
lt.pack(side="left")
rt.pack(side="right")

# Left column of radio buttons.
left_data = [
	("ActionScript", "actionscript"),
	("C/C++","c"),
	("CWEB", "cweb"),
	("HTML", "html"),
	("Java", "java"),
	("LaTeX", "latex"),
	("Pascal", "pascal")]

for text,value in left_data:
	button = Tk.Radiobutton(lt,anchor="w",text=text,
		variable=self.lang_var,value=value,command=self.set_lang)
	button.pack(fill="x") 
	
# Right column of radio buttons.
right_data = [
	("Perl", "perl"),
	("Perl+POD", "perlpod"),
	("PHP", "php"),
	("Plain Text", "plain"),
	("Python", "python"),
	("Rebol", "rebol"),
	("tcl/tk", "tcltk")]
	
for text,value in right_data:
	button = Tk.Radiobutton(rt,anchor="w",text=text,
		variable=self.lang_var,value=value,command=self.set_lang)
	button.pack(fill="x")
</t>
<t tx="T1647">buttons = Tk.Frame(outer)
buttons.pack(padx=2,pady=2,expand=1,fill="x")

okButton = Tk.Button(buttons,text="OK",width=7,command=self.onOK)
cancelButton = Tk.Button(buttons,text="Cancel",width=7,command=self.onCancel)
revertButton = Tk.Button(buttons,text="Revert",width=7,command=self.onRevert)

okButton.pack(side="left",pady=7,expand=1)
cancelButton.pack(side="left",pady=7,expand=0)
revertButton.pack(side="left",pady=7,expand=1)</t>
<t tx="T1648"># Initializes prefs ivars and widgets from c's ivars.

def init(self,c):

	self.commands = c
	#trace(`c.tab_width`)

	for var in ivars:
		val = getattr(c,var)
		setattr(self,var,val)
		# trace(val,var)

	&lt;&lt; remember values for revert &gt;&gt;
	&lt;&lt; set widgets &gt;&gt;
	# print "init" ; print self.print_ivars()</t>
<t tx="T1649"># Global options
self.revert_tangle_batch_flag = c.tangle_batch_flag
self.revert_untangle_batch_flag = c.untangle_batch_flag
self.revert_page_width = c.page_width
self.revert_tab_width = c.tab_width
# Default Tangle Options
self.revert_tangle_directory = c.tangle_directory
self.revert_output_doc_flag = c.output_doc_flag
self.revert_use_header_flag = c.use_header_flag
# Default Target Language
if c.target_language == None: # 7/29/02
	c.target_language = "python"
self.revert_target_language = c.target_language</t>
<t tx="T1650"># Global options
self.replace_tabs_var.set(choose(c.tab_width&lt;0,1,0)) # 1/30/03
self.tangle_batch_var.set(c.tangle_batch_flag)
self.untangle_batch_var.set(c.untangle_batch_flag)
self.pageWidthText.delete("1.0","end")
self.pageWidthText.insert("end",`c.page_width`)
self.tabWidthText.delete("1.0","end")
self.tabWidthText.insert("end",`abs(c.tab_width)`) # 1/30/03
# Default Tangle Options
self.tangleDirectoryText.delete("1.0","end")
self.tangleDirectoryText.insert("end",c.tangle_directory)
self.output_doc_var.set(c.output_doc_flag)
self.use_header_var.set(c.use_header_flag)
# Default Target Language
if c.target_language == None:
	c.target_language = "python" # 7/29/02
self.lang_var.set(c.target_language)</t>
<t tx="T1651"></t>
<t tx="T1652"># These event handlers get executed when the user types in the prefs panel.

def set_ivars (self,c):

	&lt;&lt; update ivars &gt;&gt;
	for var in ivars:
		val = getattr(self,var)
		setattr(c,var,val)
		
	c.frame.setTabWidth(c.tab_width)
	# self.print_ivars()

def idle_set_ivars (self, event=None):
	
	c = top() ; v = c.currentVnode()
	self.top.after_idle(self.set_ivars,c)
	c.tree.recolor(v)
	# print self.print_ivars()
	
def print_ivars (self):
	
	for var in ivars:
		trace(var, getattr(self,var))</t>
<t tx="T1653"># Global options
w = self.pageWidthText.get("1.0","end")
w = string.strip(w)
try:
	self.page_width = abs(int(w))
except:
	self.page_width = default_page_width
	
w = self.tabWidthText.get("1.0","end")
w = string.strip(w)
try:
	self.tab_width = abs(int(w))
	if self.replace_tabs_var.get(): # 1/30/03
		self.tab_width = - abs(self.tab_width)
	# print self.tab_width
except:
	self.tab_width = default_tab_width

self.tangle_batch_flag = self.tangle_batch_var.get()
self.untangle_batch_flag = self.untangle_batch_var.get()

# Default Tangle options
dir = self.tangleDirectoryText.get("1.0","end")
self.tangle_directory = string.strip(dir)

self.use_header_flag = self.use_header_var.get()
self.output_doc_flag = self.output_doc_var.get()

# Default Target Language
self.target_language = self.lang_var.get()
</t>
<t tx="T1654"># This event handler gets executed when the user choose a new default language.

def set_lang (self):
	
	c = top() ; v = c.currentVnode()
	language = self.lang_var.get()
	c.target_language = self.target_language = language
	c.tree.recolor(v)
	# print "set_lang",language</t>
<t tx="T1655">def onOK (self):
	app().config.setConfigIvars(self.commands)
	app().config.update()
	if 1: # Hide the window, preserving its position.
		self.top.withdraw()
	else: # works.
		self.commands.frame.prefsPanel = None
		self.top.destroy()
	
def onCancel (self):
	c = self.commands
	&lt;&lt; restore options &gt;&gt;
	self.init(c)
	self.set_ivars(c)
	if 1: # Hide the window, preserving its position.
		self.top.withdraw()
	else: # works.
		self.commands.frame.prefsPanel = None
		self.top.destroy()

def onRevert (self):
	c = self.commands
	&lt;&lt; restore options &gt;&gt;
	self.init(c)
	self.set_ivars(c)</t>
<t tx="T1656"># Global options
c.tangle_batch_flag = self.revert_tangle_batch_flag
c.untangle_batch_flag = self.revert_untangle_batch_flag
c.page_width = self.revert_page_width
c.tab_width = self.revert_tab_width

# Default Tangle Options
c.tangle_directory = self.revert_tangle_directory
c.output_doc_flag = self.revert_output_doc_flag
c.use_header_flag = self.revert_use_header_flag

# Default Target Language
c.target_language = self.revert_target_language</t>
<t tx="T1657">@language python

# Tangle and Untangle.

from leoGlobals import *
import os,string

&lt;&lt; about Tangle and Untangle &gt;&gt;
&lt;&lt; constants &amp; synonyms &gt;&gt;

@others</t>
<t tx="T1658">@ The Tangle command translates the selected @root tree into one or more well-formatted C source files. The outline should contain directives, sections references and section definitions, as described in Chapter 4. The Untangle command is essentially the reverse of the Tangle command. The Tangle command creates a derived file from an @root tree; the Untangle command incorporates changes made to derived files back into the @root tree.

The Tangle command operates in two passes. The first pass discovers the complete definitions of all sections and places these definitions in a symbol table. The first pass also makes a list of root sections. Definitions can appear in any order, so we must scan the entire input file to know whether any particular definition has been completed.

Tangle's second pass creates one file for each @root node. Tangle rescans each section in the list of roots, copying the root text to the output and replacing each section reference by the section's definition. This is a recursive process because any definition may contain other references. We can not allow a section to be defined in terms of itself, either directly or indirectly. We check for such illegally recursive definitions in pass 2 using the section stack class.  Tangle indicates where sections begin and end using comment lines called sentinel lines.  The this part of the appendix discusses the format of the sentinels output by the Tangle command.

The key design principle of the Tangle command is this: Tangle must output newlines in a context-free manner. That is, Tangle must never output conditional newlines, either directly or indirectly. Without this rule Untangle could not determine whether to skip or copy newlines.

The Tangle command increases the indentation level of a section expansion the minimum necessary to align the section expansion with the surrounding code. In essence, this scheme aligns all section expansions with the line of code in which the reference to the section occurs. In some cases, several nested sections expansions will have the same indentation level. This can occur, for example, when a section reference in an outline occurs at the left margin of the outline.

This scheme is probably better than more obvious schemes that indent more "consistently." Such schemes would produce too much indentation for deeply nested outlines. The present scheme is clear enough and avoids indentation wherever possible, yet indents sections adequately. End sentinel lines make this scheme work by making clear where the expansion of one section ends and the expansion of a containing section resumes.

Tangle increases indentation if the section reference does not start a line. Untangle is aware of this hack and adjusts accordingly. This extra indentation handles several common code idioms, which otherwise would create under-indented code. In short, Tangle produces highly readable, given the necessity of preserving newlines for Untangle.

Untangle is inherently complex.  It must do a perfect job of updating the outline, especially whitespace, from expansions of section definitions created by the Tangle command.  Such expansions need not be identical because they may have been generated at different levels of indentation.  The Untangle command can not assume that all expansions of a section will be identical in the derived file; within the derived file, the programmer may have made incompatible changes to two different expansions of the same section. Untangle must check to see that all expansions of a section are "equivalent".  As an added complication, derived files do not contain all the information found in @root trees.  @root trees may contain headlines that generate no code at all.  Also, an outline may define a section in several ways: with an @c or @code directive or with a section definition line.  To be useful, Untangle must handle all these complications flawlessly. The appendix discusses the various conventions used in the sentinels output by the Tangle command.  These conventions allow the Untangle command to recreate whitespace correctly.

Untangle operates in two passes. The first pass finds definitions in the derived file and enters them into the Untangle Symbol Table, or UST.   Definitions often include references to other sections, so definitions often include nested definitions of referenced sections. The first pass of Untangle uses a definition stack to keep track of nested definitions. The top of the stack represents the definition following the latest reference, except for the very first entry pushed on the stack, which represents the code in the outline that contains the @root directive. The stack never becomes empty because of the entry for the @root section. All definitions of a section should match--otherwise there is an inconsistent definition. This pass uses a forgiving compare routine that ignores differences that do not affect the meaning of a program.

Untangle's second pass enters definitions from the outline into the Tangle Symbol Table, or TST. The second pass simultaneously updates all sections in the outline whose definition in the TST does not match the definition in the UST.  The central coding insight of the Untangle command is that the second pass of Untangle is almost identical to the first pass of Tangle! That is, Tangle and Untangle share key parts of code, namely the skip_body() method and its allies.  Just when skip_body() enters a definition into the symbol table, all the information is present that Untangle needs to update that definition.
</t>
<t tx="T1659"># Synonyms for multiple_parts_flag.
allow_multiple_parts = 1
disallow_multiple_parts = 2
unused_parts_flag = 3

# Synonyms for is_root_flag to st_enter.
is_root_name = 1 ; not_root_name = 0

# Synonyms for scanAllDirectives
report_errors = 1 ; dont_report_errors = 0
require_path = 1 ; done_require_path = 0

# Constants...
max_errors = 20

@ All these must be defined together, because they form a single enumeration.  Some of these are used by utility functions.
@c

if 1: # A single enum...

	# Used by token_type().
	plain_line = 1 # all other lines
	at_at	     = 2 # double-at sign.
	at_chapter = 3 # @chapter
	# at_c       = 4 # @c in noweb mode
	at_code	   = 5 # @code, or @c or @p in CWEB mode.
	at_doc	    = 6 # @doc
	at_other   = 7 # all other @directives
	at_root	   = 8 # @root or noweb * sections
	at_section = 9 # @section
	# at_space   = 10 # @space
	at_web	    = 11 # any CWEB control code, except at_at.
	
	# Returned by self.skip_section_name() and allies and used by token_type.
	bad_section_name = 12  # &lt; &lt; with no matching &gt; &gt;
	section_ref	 = 13  # &lt; &lt; name &gt; &gt;
	section_def	 = 14  # &lt; &lt; name &gt; &gt; =
	
	# Returned by is_sentinal_line.
	non_sentinel_line   = 15
	start_sentinel_line = 16
	end_sentinel_line   = 17
	
	# Stephen P. Schaefer 9/13/2002
	# add support for @first
	at_last    = 18
</t>
<t tx="T1660"></t>
<t tx="T1661"></t>
<t tx="T1662"></t>
<t tx="T1663"></t>
<t tx="T1664"></t>
<t tx="T1665"></t>
<t tx="T1666"></t>
<t tx="T1667"></t>
<t tx="T1668"></t>
<t tx="T1669"></t>
<t tx="T1670"></t>
<t tx="T1671"></t>
<t tx="T1672"></t>
<t tx="T1673"></t>
<t tx="T1674"></t>
<t tx="T1675"></t>
<t tx="T1676"></t>
<t tx="T1677"></t>
<t tx="T1678"></t>
<t tx="T1679"></t>
<t tx="T1680"></t>
<t tx="T1681"></t>
<t tx="T1682"></t>
<t tx="T1683"></t>
<t tx="T1684"></t>
<t tx="T1685"></t>
<t tx="T1686"></t>
<t tx="T1687"></t>
<t tx="T1688"></t>
<t tx="T1689"></t>
<t tx="T1690"></t>
<t tx="T1691"></t>
<t tx="T1692"></t>
<t tx="T1693"></t>
<t tx="T1694"></t>
<t tx="T1695"></t>
<t tx="T1696"></t>
<t tx="T1697"></t>
<t tx="T1698"></t>
<t tx="T1699"></t>
<t tx="T1700"></t>
<t tx="T1701"></t>
<t tx="T1702"></t>
<t tx="T1703"></t>
<t tx="T1704"></t>
<t tx="T1705"></t>
<t tx="T1706"></t>
<t tx="T1707"></t>
<t tx="T1708"></t>
<t tx="T1709"></t>
<t tx="T1710"></t>
<t tx="T1711"></t>
<t tx="T1712"></t>
<t tx="T1713"></t>
<t tx="T1714"></t>
<t tx="T1715"></t>
<t tx="T1716"></t>
<t tx="T1717"></t>
<t tx="T1718"></t>
<t tx="T1719"></t>
<t tx="T1720"></t>
<t tx="T1721"></t>
<t tx="T1722"></t>
<t tx="T1723"></t>
<t tx="T1724"></t>
<t tx="T1725"></t>
<t tx="T1726"></t>
<t tx="T1727"></t>
<t tx="T1728"></t>
<t tx="T1729"></t>
<t tx="T1730"></t>
<t tx="T1731"></t>
<t tx="T1732"></t>
<t tx="T1733"></t>
<t tx="T1734"></t>
<t tx="T1735"></t>
<t tx="T1736"></t>
<t tx="T1737"></t>
<t tx="T1738"></t>
<t tx="T1739"></t>
<t tx="T1740"></t>
<t tx="T1741"></t>
<t tx="T1742"></t>
<t tx="T1743"></t>
<t tx="T1744"></t>
<t tx="T1745"></t>
<t tx="T1746"></t>
<t tx="T1747"></t>
<t tx="T1748"></t>
<t tx="T1749"></t>
<t tx="T1750"></t>
<t tx="T1751"></t>
<t tx="T1752"></t>
<t tx="T1753"></t>
<t tx="T1754"></t>
<t tx="T1755"></t>
<t tx="T1756"></t>
<t tx="T1757"></t>
<t tx="T1758"></t>
<t tx="T1759"></t>
<t tx="T1760"></t>
<t tx="T1761"></t>
<t tx="T1762"></t>
<t tx="T1763"></t>
<t tx="T1764"></t>
<t tx="T1765"></t>
<t tx="T1766"></t>
<t tx="T1767"></t>
<t tx="T1768"></t>
<t tx="T1769"></t>
<t tx="T1770"></t>
<t tx="T1771"></t>
<t tx="T1772"></t>
<t tx="T1773"></t>
<t tx="T1774"></t>
<t tx="T1775"></t>
<t tx="T1776"></t>
<t tx="T1777"></t>
<t tx="T1778"></t>
<t tx="T1779"></t>
<t tx="T1780"></t>
<t tx="T1781"></t>
<t tx="T1782"></t>
<t tx="T1783"></t>
<t tx="T1784"></t>
<t tx="T1785"></t>
<t tx="T1786"></t>
<t tx="T1787"></t>
<t tx="T1788"></t>
<t tx="T1789"></t>
<t tx="T1790"></t>
<t tx="T1791"></t>
<t tx="T1792"></t>
<t tx="T1793"></t>
<t tx="T1794"></t>
<t tx="T1795"></t>
<t tx="T1796"></t>
<t tx="T1797"></t>
<t tx="T1798"></t>
<t tx="T1799"></t>
<t tx="T1800"></t>
<t tx="T1801"></t>
<t tx="T1802"></t>
<t tx="T1803"></t>
<t tx="T1804"></t>
<t tx="T1805"></t>
<t tx="T1806"></t>
<t tx="T1807"></t>
<t tx="T1808"></t>
<t tx="T1809"></t>
<t tx="T1810"></t>
<t tx="T1811"></t>
<t tx="T1812"></t>
<t tx="T1813"></t>
<t tx="T1814"></t>
<t tx="T1815"></t>
<t tx="T1816"></t>
<t tx="T1817"></t>
<t tx="T1818"></t>
<t tx="T1819"></t>
<t tx="T1820"></t>
<t tx="T1821"></t>
<t tx="T1822"></t>
<t tx="T1823"></t>
<t tx="T1824"></t>
<t tx="T1825"></t>
<t tx="T1826"></t>
<t tx="T1827"></t>
<t tx="T1828"></t>
<t tx="T1829"></t>
<t tx="T1830"></t>
<t tx="T1831"></t>
<t tx="T1832"></t>
<t tx="T1833"></t>
<t tx="T1834"></t>
<t tx="T1835"></t>
<t tx="T1836"></t>
<t tx="T1837"></t>
<t tx="T1838"></t>
<t tx="T1839"></t>
<t tx="T1840"></t>
<t tx="T1841"></t>
<t tx="T1842">@language python

&lt;&lt; about the tree classes &gt;&gt;

from leoGlobals import *
import leoColor
import os,string,Tkinter,tkFont,types

&lt;&lt; about drawing and events &gt;&gt;
&lt;&lt; drawing constants &gt;&gt;

class baseLeoTree:
	"""The base class of the Leo's tree class."""
	@others
	
class leoTree (baseLeoTree):
	"""A class that draws and handles events in an outline."""
	pass</t>
<t tx="T1843">@ This class implements a tree control similar to Windows explorer.  The draw code is based on code found in Python's IDLE program.  Thank you Guido van Rossum!

The tree class knows about vnodes.  The vnode class could be split into a base class (say a treeItem class) containing the ivars known to the tree class, and a derived class containing everything else, including, e.g., the bodyString ivar.  I haven't chosen to split the vnode class this way because nothing would be gained in Leo.
</t>
<t tx="T1844">@ Leo must redraw the outline pane when commands are executed and as the result of mouse and keyboard events.  The main challenges are eliminating flicker and handling events properly.  These topics are interrelated.

Eliminating flicker.  Leo must update the outline pane with minimum flicker.  Various versions of Leo have approached this problem in different ways.  The drawing code in leo.py is robust, flexible, relatively simple and should work in almost any conceivable environment.

Leo assumes that all code that changes the outline pane will be enclosed in matching calls to the c.beginUpdate and c.endUpdate  methods of the Commands class. c.beginUpdate() inhibits drawing until the matching c.endUpdate().  These calls may be nested; only the outermost call to c.endUpdate() calls c.redraw() to force a redraw of the outline pane.

In leo.py, code may call c.endUpdate(flag) instead of c.endUpdate().  Leo redraws the screen only if flag is true.  This allows code to suppress redrawing entirely when needed.  For example, study the idle_body_key event handler to see how Leo conditionally redraws the outline pane.

The leoTree class redraws all icons automatically when c.redraw() is called.  This is a major simplification compared to previous versions of Leo.  The entire machinery of drawing icons in the vnode class has been eliminated.  The v.computeIcon method tells what the icon should be.  The v.iconVal ivar that tells what the present icon is. The event handler simply compares these two values and sets redraw_flag if they don't match.

Handling events. Besides redrawing the screen, Leo must handle events or commands that change the text in the outline or body panes.  It is surprisingly difficult to ensure that headline and body text corresponds to the vnode and tnode corresponding to presently selected outline, and vice versa. For example, when the user selects a new headline in the outline pane, we must ensure that 1) the vnode and tnode of the previously selected node have up-to-date information and 2) the body pane is loaded from the correct data in the corresponding tnode.  Early versions of Leo attempted to satisfy these conditions when the user switched outline nodes.  Such attempts never worked well; there were too many special cases.  Later versions of Leo, including leo.py, use a much more direct approach.  The event handlers make sure that the vnode and tnode corresponding to the presently selected node are always kept up-to-date.  In particular, every keystroke in the body pane causes the presently selected tnode to be updated immediately.  There is no longer any need for the c.synchVnode method, though that method still exists for compatibility with old scripts.

The leoTree class contains all the event handlers for the body and outline panes.  The actual work is done in the idle_head_key and idle_body_key methods.  These routines are surprisingly complex; they must handle all the tasks mentioned above, as well as others. The idle_head_key and idle_body_key methods should not be called outside the leoTree class.  However, it often happens that code that handles user commands must simulate an event.  That is, the code needs to indicate that headline or body text has changed so that the screen may be redrawn properly.   The leoTree class defines the following simplified event handlers: onBodyChanged, onBodyWillChange, onBodyKey, onHeadChanged and onHeadlineKey.  Commanders and subcommanders call these event handlers to indicate that a command has changed, or will change, the headline or body text.  Calling event handlers rather than c.beginUpdate and c.endUpdate ensures that the outline pane is redrawn only when needed.
</t>
<t tx="T1845">box_padding = 5 # extra padding between box and icon
box_width = 9 + box_padding
icon_width = 20
text_indent = 4 # extra padding between icon and tex
child_indent = 28 # was 20
hline_y = 7 # Vertical offset of horizontal line
root_left = 7 + box_width
root_top = 2
hiding = true # True if we don't reallocate items
line_height = 17 + 2 # To be replaced by Font height</t>
<t tx="T1846"></t>
<t tx="T1847">def __init__(self,commands,canvas):

	# Objects associated with this tree.
	self.colorizer = leoColor.colorizer(commands)
	self.commands = commands
	self.canvas = canvas
	self.rootVnode = None
	self.topVnode = None
	
	# Miscellaneous info.
	self.iconimages = {} # Image cache set by getIconImage().
	self.active = false # true if tree is active
	self.revertHeadline = None # Previous headline text for abortEditLabel.
	
	# Set self.font and self.fontName.
	self.setFontFromConfig()
	
	# Recycling bindings.
	self.bindings = [] # List of bindings to be unbound when redrawing.
	self.tagBindings = [] # List of tag bindings to be unbound when redrawing.
	self.icon_id_dict = {} # New in 3.12: keys are icon id's, values are vnodes.
	self.edit_text_dict = {} # New in 3.12: keys vnodes, values are edit_text (Tk.Text widgets)
	self.widgets = [] # Widgets that must be destroyed when redrawing.

	# Controlling redraws
	self.updateCount = 0 # self.redraw does nothing unless this is zero.
	self.redrawCount = 0 # For traces
	self.redrawScheduled = false # true if redraw scheduled.

	# Selection ivars.
	self.currentVnode = None # The presently selected vnode.
	self.editVnode = None # The vnode being edited.
	self.initing = false # true: opening file.
	
	# Drag and drop
	self.drag_v = None
	self.dragging = false # true: presently dragging.
	self.controlDrag = false # true: control was down when drag started.
	self.drag_id = None # To reset bindings after drag
	self.keyCount = 0 # For debugging.
	
	# 20-SEP-2002 DTHEIN: keep track of popup menu so we can handle
	#                     behavior better on Linux
	# Context menu
	self.popupMenu = None
	
	# Incremental redraws:
	self.allocateOnlyVisibleNodes = false # true: enable incremental redraws.
	self.trace = false # true enabling of various traces.
	self.prevMoveToFrac = None
	self.visibleArea = None
	self.expandedVisibleArea = None
	
	self.allocatedNodes = 0 # A crucial statistic.
		# Incremental drawing allocates visible nodes at most twice.
		# Non-incremetal drawing allocates all visible nodes once.
		
	if self.allocateOnlyVisibleNodes:
		self.commands.frame.bar1.bind("&lt;B1-ButtonRelease&gt;", self.redraw)</t>
<t tx="T1848">def deleteBindings (self):
	
	"""Delete all tree bindings and all references to tree widgets."""
	
	# print "deleteBindings: %d, %d" % (len(self.tagBindings),len(self.bindings))

	count = 0
	# Unbind all the tag bindings.
	for id,id2,binding in self.tagBindings:
		self.canvas.tag_unbind(id,binding,id2)
		count += 1
	self.tagBindings = []
	# Unbind all the text bindings.
	for t,id,binding in self.bindings:
		t.unbind(binding,id)
		count += 1
	self.bindings = []
	# print("bindings freed:"+`count`)</t>
<t tx="T1849"># canvas.delete("all") does _not_ delete the Tkinter objects associated with those objects!

def deleteWidgets (self):
	
	"""Delete all widgets in the canvas"""
	
	self.icon_id_dict = {} # Delete all references to icons.
	self.edit_text_dict = {} # Delete all references to Tk.Edit widgets.
		
	# Fixes a _huge_ memory leak.
	for w in self.widgets:
		w.destroy() 
	self.widgets = []</t>
<t tx="T1850"></t>
<t tx="T1851">@ About drawing and updating strategy.

This version of Leo draws the outline "by hand" using the Tk canvas widget.  Surprisingly, this is not only easy, but simplifies the vnode and Commands classes.

1.  Updating and redraw.  The tree.redraw() method is called automatically from the "outermost" call to tree.endUpdate.  Moreover, calling .tree.redraw() inside a tree.beginUpdate/tree.endUpdate pair does nothing.  c.redraw(), c.beginUpdate() and c.endUpdate() just call the corresponding tree methods.  Finally, beginUpdate()/endUpdate(false) can be used to suppress redrawing entirely.

Therefore, the Commands class never needs to worry about extra calls to tree.redraw() provided all code that draws to the tree is enclosed in a tree.beginUpdate/tree.endUpdate pair.  The tree.idle_body_key event handler manages redrawing "by hand" by maintaining a redraw_flag and then calling endUpdate(redraw_flag).

2.  The tree.redraw() method deletes all old canvas items and recomputes all data, including v.iconVal.  This means that v.doDelete need not actually delete vnodes for them to disappear from the screen.  Indeed, vnode are never actually deleted, only unlinked.  It would be valid for "dependent" vnodes to be deleted, but there really is no need to do so.
</t>
<t tx="T1852">def beginUpdate (self):

	self.updateCount += 1</t>
<t tx="T1853">def drawBox (self,v,x,y):
	
	y += 7 # draw the box at x, y+7

	iconname = choose(v.isExpanded(),"minusnode.gif", "plusnode.gif")
	image = self.getIconImage(iconname)
	id = self.canvas.create_image(x,y,image=image)

	id1 = self.canvas.tag_bind(id, "&lt;1&gt;", v.OnBoxClick)
	id2 = self.canvas.tag_bind(id, "&lt;Double-1&gt;", lambda x: None)
	
	# Remember the bindings so deleteBindings can delete them.
	self.tagBindings.append((id,id1,"&lt;1&gt;"),)
	self.tagBindings.append((id,id2,"&lt;Double-1&gt;"),)
</t>
<t tx="T1854"># Draws icon for v at x,y

def drawIcon(self,v,x,y):

	v.iconx, v.icony = x,y
	y += 2 # draw icon at y + 2

	# Always recompute icon.
	val = v.iconVal = v.computeIcon()
	assert(0 &lt;= val &lt;= 15)
	
	# Compute the image name
	imagename = "box"
	if val &lt; 10: imagename += "0"
	imagename += `val`

	# Get the image
	image = self.getIconImage(imagename + ".GIF")
	id = self.canvas.create_image(x,y,anchor="nw",image=image)
	self.icon_id_dict[id] = v # Remember which vnode belongs to the icon.

	id1 = self.canvas.tag_bind(id,"&lt;1&gt;",v.OnIconClick)
	id2 = self.canvas.tag_bind(id,"&lt;Double-1&gt;",v.OnIconDoubleClick)
	id3 = self.canvas.tag_bind(id,"&lt;3&gt;",v.OnIconRightClick)
	
	# Remember the bindings so deleteBindings can delete them.
	self.tagBindings.append((id,id1,"&lt;1&gt;"),)
	self.tagBindings.append((id,id2,"&lt;Double-1&gt;"),)
	self.tagBindings.append((id,id3,"&lt;3&gt;"),)

	return 0 # dummy icon height</t>
<t tx="T1855"></t>
<t tx="T1856"># Calling redraw inside c.beginUpdate()/c.endUpdate() does nothing.
# This _is_ useful when a flag is passed to c.endUpdate.

def redraw (self,event=None):
	
	# trace()
	
	if self.updateCount == 0 and not self.redrawScheduled:
		self.redrawScheduled = true
		self.canvas.after_idle(self.idle_redraw)
		
</t>
<t tx="T1857"># Schedules a redraw even if inside beginUpdate/endUpdate
def force_redraw (self):

	# trace()

	if not self.redrawScheduled:
		self.redrawScheduled = true
		self.canvas.after_idle(self.idle_redraw)</t>
<t tx="T1858"># Redraws immediately: used by Find so a redraw doesn't mess up selections.
# It is up to the caller to ensure that no other redraws are pending.
def redraw_now (self):

	# trace()

	self.idle_redraw()</t>
<t tx="T1859">def idle_redraw (self):
	
	self.redrawScheduled = false # 7/10/03: Always do this here.

	frame = self.commands.frame
	if frame not in app().windowList or app().quitting:
		# trace("no frame")
		return
		
	if self.drag_v:
		# trace("dragging",self.drag_v)
		return

	# trace()

	self.expandAllAncestors(self.currentVnode)
	oldcursor = self.canvas['cursor']
	self.canvas['cursor'] = "watch"
	self.allocatedNodes = 0
	if not doHook("redraw-entire-outline",c=self.commands):
		# Erase and redraw the entire tree.
		self.topVnode = None
		self.deleteBindings()
		self.canvas.delete("all")
		self.deleteWidgets()
		self.setVisibleAreaToFullCanvas()
		self.drawTree(self.rootVnode,root_left,root_top,0,0)
		# Set up the scroll region after the tree has been redrawn.
		x0, y0, x1, y1 = self.canvas.bbox("all")
		self.canvas.configure(scrollregion=(0, 0, x1, y1))
		# Do a scrolling operation after the scrollbar is redrawn
		self.canvas.after_idle(self.idle_scrollTo)
		if self.trace:
			self.redrawCount += 1
			print "idle_redraw allocated:",self.redrawCount, self.allocatedNodes
		doHook("after_redraw-outline",c=self.commands)

	self.canvas['cursor'] = oldcursor</t>
<t tx="T1860">def idle_second_redraw (self):
	
	# trace()
		
	# Erase and redraw the entire tree the SECOND time.
	# This ensures that all visible nodes are allocated.
	self.topVnode = None
	args = self.canvas.yview()
	self.setVisibleArea(args)
	self.deleteBindings()
	self.canvas.delete("all")
	self.drawTree(self.rootVnode,root_left,root_top,0,0)
	
	if self.trace:
		print "idle_second_redraw allocated:",self.redrawCount, self.allocatedNodes</t>
<t tx="T1861">def drawNode(self,v,x,y):

	"""Draw horizontal line from vertical line to icon"""

	self.canvas.create_line(x, y+7, x+box_width, y+7,tag="lines",fill="gray50") # stipple="gray25")

	if self.inVisibleArea(y):
		return self.force_draw_node(v,x,y)
	else:
		return self.line_height
	
def force_draw_node(self,v,x,y):

	self.allocatedNodes += 1
	if v.firstChild():
		self.drawBox(v,x,y)
	icon_height = self.drawIcon(v,x+box_width,y)
	text_height = self.drawText(v,x+box_width+icon_width,y)
	return max(icon_height, text_height)</t>
<t tx="T1862"># draws text for v at x,y

def drawText(self,v,x,y):
	
	x += text_indent

	t = Tkinter.Text(self.canvas,
		font=self.font,bd=0,relief="flat",width=self.headWidth(v),height=1)
	self.edit_text_dict[v] = t # Remember which text widget belongs to v.
	
	# Remember the widget so deleteBindings can delete it.
	self.widgets.append(t) # Fixes a _huge_ memory leak.

	t.insert("end", v.headString())
	&lt;&lt; configure the text depending on state &gt;&gt;

	id1 = t.bind("&lt;1&gt;", v.OnHeadlineClick)
	id2 = t.bind("&lt;3&gt;", v.OnHeadlineRightClick) # 9/11/02.
	if 0: # 6/15/02: Bill Drissel objects to this binding.
		t.bind("&lt;Double-1&gt;", v.OnBoxClick)
	id3 = t.bind("&lt;Key&gt;", v.OnHeadlineKey)
	id4 = t.bind("&lt;Control-t&gt;",self.OnControlT)
		# 10/16/02: Stamp out the erroneous control-t binding.
		
	# Remember the bindings so deleteBindings can delete them.
	self.bindings.append((t,id1,"&lt;1&gt;"),)
	self.bindings.append((t,id2,"&lt;3&gt;"),)
	self.bindings.append((t,id3,"&lt;Key&gt;"),)
	self.bindings.append((t,id4,"&lt;Control-t&gt;"),)

	id = self.canvas.create_window(x,y,anchor="nw",window=t)
	self.canvas.tag_lower(id)

	return self.line_height</t>
<t tx="T1863">if v == self.currentVnode:
	# trace("editVnode",self.editVnode)
	if v == self.editVnode:
		self.setNormalLabelState(v) # 7/7/03
	else:
		self.setDisabledLabelState(v) # selected, disabled
else:
	self.setUnselectedLabelState(v) # unselected</t>
<t tx="T1864">def drawTree(self,v,x,y,h,level):
	
	# Recursive routine, stat() not useful.
	yfirst = ylast = y
	if level==0: yfirst += 10
	while v:
		# trace(`x` + ", " + `y` + ", " + `v`)
		h = self.drawNode(v,x,y)
		y += h ; ylast = y
		if v.isExpanded() and v.firstChild():
			y = self.drawTree(v.firstChild(),x+child_indent,y,h,level+1)
		v = v.next()
	&lt;&lt; draw vertical line &gt;&gt;
	return y</t>
<t tx="T1865">id = self.canvas.create_line(
	x, yfirst-hline_y+4,
	x, ylast+hline_y-h,
	fill="gray50", # stipple="gray50"
	tag="lines")

self.canvas.tag_lower(id)</t>
<t tx="T1866">def endUpdate (self, flag=true):

	assert(self.updateCount &gt; 0)
	self.updateCount -= 1
	if flag and self.updateCount == 0:
		self.redraw()</t>
<t tx="T1867">@ Returns the proper width of the entry widget for the headline. This has been a problem.
@c

def headWidth(self,v):

	return max(10,5 + len(v.headString()))</t>
<t tx="T1868">def inVisibleArea (self,y1):
	
	if self.allocateOnlyVisibleNodes:
		if self.visibleArea:
			vis1,vis2 = self.visibleArea
			y2 = y1 + self.line_height
			return y2 &gt;= vis1 and y1 &lt;= vis2
		else: return false
	else:
		return true # This forces all nodes to be allocated on all redraws.
		
def inExpandedVisibleArea (self,y1):
	
	if self.expandedVisibleArea:
		vis1,vis2 = self.expandedVisibleArea
		y2 = y1 + self.line_height
		return y2 &gt;= vis1 and y1 &lt;= vis2
	else:
		return false</t>
<t tx="T1869"># Returns the last visible node of the screen.

def lastVisible (self):

	v = self.rootVnode
	while v:
		last = v
		if v.firstChild():
			if v.isExpanded():
				v = v.firstChild()
			else:
				v = v.nodeAfterTree()
		else:
			v = v.threadNext()
	return last</t>
<t tx="T1870">def setLineHeight (self,font):
	
	try:
		metrics = font.metrics()
		linespace = metrics ["linespace"]
		self.line_height = linespace + 5 # Same as before for the default font on Windows.
		# print metrics
	except:
		self.line_height = line_height # was 17 + 2
		es("exception setting outline line height")
		es_exception()</t>
<t tx="T1871">def getFont (self):

	return self.font
		
# Called by leoFontPanel.
def setFont (self, font=None, fontName=None):
	
	if fontName:
		self.fontName = fontName
		self.font = tkFont.Font(font=fontName)
	else:
		self.fontName = None
		self.font = font
		
	self.setLineHeight(self.font)
	
# Called by ctor and when config params are reloaded.
def setFontFromConfig (self):

	font = app().config.getFontFromParams(
		"headline_text_font_family", "headline_text_font_size",
		"headline_text_font_slant",  "headline_text_font_weight")

	self.setFont(font)</t>
<t tx="T1872">def getIconImage (self, name):

	# Return the image from the cache if possible.
	if self.iconimages.has_key(name):
		return self.iconimages[name]
		
	try:
		fullname = os.path.join(app().loadDir,"..","Icons",name)
		fullname = os.path.normpath(fullname)
		image = Tkinter.PhotoImage(master=self.canvas, file=fullname)
		self.iconimages[name] = image
		return image
	except:
		es("Exception loading: " + fullname)
		es_exception()
		return None</t>
<t tx="T1873">@ This scrolls the canvas so that v is in view.  This is done at idle time after a redraw so that treeBar.get() will return proper values.
@c

def idle_scrollTo(self,v=None):

	frame = self.commands.frame
	last = self.lastVisible()
	nextToLast = last.visBack()
	# print 'v,last',`v`,`last`
	if v == None:
		v = self.currentVnode
	h1 = self.yoffset(v)
	h2 = self.yoffset(last)
	if nextToLast: # 2/2/03: compute approximate line height.
		lineHeight = h2 - self.yoffset(nextToLast)
	else:
		lineHeight = 20 # A reasonable default.
	# Compute the fractions to scroll down/up.
	lo, hi = frame.treeBar.get()
	if h2 &gt; 0.1:
		frac = float(h1)/float(h2) # For scrolling down.
		frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
		frac2 = frac2 - (hi - lo)
	else:
		frac = frac2 = 0.0 # probably any value would work here.
	# 2/2/03: new logic for scrolling up.
	frac =  max(min(frac,1.0),0.0)
	frac2 = max(min(frac2,1.0),0.0)

	if frac &lt;= lo:
		if self.prevMoveToFrac != frac:
			self.prevMoveToFrac = frac
			self.canvas.yview("moveto",frac)
	elif frac2 + (hi - lo) &gt;= hi:
		if self.prevMoveToFrac != frac2:
			self.prevMoveToFrac = frac2
			self.canvas.yview("moveto",frac2)
			
	if self.allocateOnlyVisibleNodes:
		self.canvas.after_idle(self.idle_second_redraw)

	# print "%3d %3d %1.3f %1.3f %1.3f %1.3f" % (h1,h2,frac,frac2,lo,hi)</t>
<t tx="T1874">def numberOfVisibleNodes(self):
	
	n = 0 ; v = self.rootVnode
	while v:
		n += 1
		v = v.visNext()
	return n</t>
<t tx="T1875">def recolor(self,v,incremental=0):

	body = self.commands.frame.body
	
	if 0: # Do immediately
		self.colorizer.colorize(v,body,incremental)
	else: # Do at idle time
		self.colorizer.schedule(v,body,incremental)

def recolor_now(self,v,incremental=0):

	body = self.commands.frame.body
	self.colorizer.colorize(v,body,incremental)
	
def recolor_range(self,v,leading,trailing):

	body = self.commands.frame.body
	self.colorizer.recolor_range(v,body,leading,trailing)</t>
<t tx="T1876">@ We can't just return icony because the tree hasn't been redrawn yet.  For the same reason we can't rely on any TK canvas methods here.
@c

def yoffset(self, v1):

	# if not v1.isVisible(): print "yoffset not visible:", `v1`
	root = self.rootVnode
	h, flag = self.yoffsetTree(root,v1)
	# flag can be false during initialization.
	# if not flag: print "yoffset fails:", h, `v1`
	return h

# Returns the visible height of the tree and all sibling trees, stopping at v1

def yoffsetTree(self,v,v1):

	h = 0
	while v:
		# print "yoffsetTree:", `v`
		if v == v1:
			return h, true
		h += self.line_height
		child = v.firstChild()
		if v.isExpanded() and child:
			h2, flag = self.yoffsetTree(child,v1)
			h += h2
			if flag: return h, true
		v = v.next()
	return h, false</t>
<t tx="T1877">@ Important note: most hooks are created in the vnode callback routines, _not_ here.
</t>
<t tx="T1878">def OnActivate (self,v,event=None):

	try:
		c = self.commands
		&lt;&lt; activate this window &gt;&gt;
	except:
		es_event_exception("activate tree")</t>
<t tx="T1879">c = self.commands
# trace(`v`)

if v == self.currentVnode:
	if self.active:
		self.editLabel(v)
	else:
		self.undimEditLabel()
		set_focus(c,self.canvas) # Essential for proper editing.
else:
	self.select(v)
	if v.t.insertSpot != None: # 9/1/02
		c.body.mark_set("insert",v.t.insertSpot)
		c.body.see(v.t.insertSpot)
	else:
		c.body.mark_set("insert","1.0")
	set_focus(c,c.body)

self.active = true</t>
<t tx="T1880"># Called on click in box and double-click in headline.

def OnBoxClick (self,v):

	# Note: "boxclick" hooks handled by vnode callback routine.
	c = self.commands

	if v.isExpanded():
		v.contract()
	else:
		v.expand()

	self.active = true
	self.select(v)
	set_focus(c,c.body) # 7/12/03
	self.redraw()</t>
<t tx="T1881">def OnDeactivate (self,event=None):
	
	"""Deactivate the tree pane, dimming any headline being edited."""

	c = self.commands
	focus = get_focus(c.frame.top)

	# Bug fix: 7/13/03: Only do this as needed.
	# Doing this on every click would interfere with the double-clicking.
	if focus not in (c.frame.body, c.frame.log):
		try:
			# trace(focus)
			self.endEditLabel()
			self.dimEditLabel()
		except:
			es_event_exception("deactivate tree")</t>
<t tx="T1882">def findVnodeWithIconId (self,id):
	
	# Due to an old bug, id may be a tuple.
	try:
		return self.icon_id_dict.get(id[0])
	except:
		return self.icon_id_dict.get(id)
</t>
<t tx="T1883">@ The &lt;Key&gt; event generates the event before the body text is changed(!), so we register an idle-event handler to do the work later.

1/17/02: Rather than trying to figure out whether the control or alt keys are down, we always schedule the idle_handler.  The idle_handler sees if any change has, in fact, been made to the body text, and sets the changed and dirty bits only if so.  This is the clean and safe way.

2/19/02: We must distinguish between commands like "Find, Then Change", that call onBodyChanged, and commands like "Cut" and "Paste" that call onBodyWillChange.  The former commands have already changed the body text, and that change must be captured immediately.  The latter commands have not changed the body text, and that change may only be captured at idle time.
@c

@others</t>
<t tx="T1884">def idle_body_key (self,v,oldSel,undoType,ch=None,oldYview=None,newSel=None,oldText=None):
	
	"""Update the body pane at idle time."""

	c = self.commands
	if not c or not v or v != c.currentVnode():
		return "break"
	if doHook("bodykey1",c=c,v=v,ch=ch,oldSel=oldSel,undoType=undoType):
		return "break" # The hook claims to have handled the event.
	body = v.bodyString()
	if not newSel:
		newSel = getTextSelection(c.body)
	if oldText != None:
		s = oldText
	else:
		&lt;&lt; set s to the widget text &gt;&gt;
	&lt;&lt; return if nothing has changed &gt;&gt;
	&lt;&lt; set removeTrailing &gt;&gt;
	if ch in ('\n','\r'):
		&lt;&lt; Do auto indent &gt;&gt;
	elif ch == '\t' and c.tab_width &lt; 0:
		&lt;&lt; convert tab to blanks &gt;&gt;
	&lt;&lt; set s to widget text, removing trailing newlines if necessary &gt;&gt;
	if undoType:
		c.undoer.setUndoTypingParams(v,undoType,body,s,oldSel,newSel,oldYview=oldYview)
	v.t.setTnodeText(s)
	v.t.insertSpot = c.body.index("insert")
	&lt;&lt; recolor the body &gt;&gt;
	if not c.changed:
		c.setChanged(true)
	&lt;&lt; redraw the screen if necessary &gt;&gt;
	doHook("bodykey2",c=c,v=v,ch=ch,oldSel=oldSel,undoType=undoType)
	return "break"</t>
<t tx="T1885">s = c.body.get("1.0", "end")

if s == None:
	s = u""

if type(s) == type(""):
	s = toUnicode(s,app().tkEncoding) # 2/25/03
	# if len(ch) &gt; 0: print `s`</t>
<t tx="T1886"># 6/22/03: Make sure we handle delete key properly.

if ch not in ('\n','\r',chr(8)):

	if s == body:
		return "break"
	
	# Do nothing for control characters.
	if (ch == None or len(ch) == 0) and body == s[:-1]:
		return "break"
	
# print `ch`,len(body),len(s)</t>
<t tx="T1887">@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually done. We need only make a reasonable guess here.   setUndoTypingParams stores the number of trailing newlines in each undo bead, so whatever we do here can be faithfully undone and redone.
@c
new = s ; old = body

if len(new) == 0 or new[-1] != '\n':
	# There is no newline to remove.  Probably will never happen.
	# trace("false: no newline to remove")
	removeTrailing = false
elif len(old) == 0:
	# Ambigous case.
	# trace("false: empty old")
	removeTrailing = ch != '\n' # false
elif old == new[:-1]:
	# A single trailing character has been added.
	# trace("false: only changed trailing.")
	removeTrailing = false
else:
	# The text didn't have a newline, and now it does.
	# Moveover, some other change has been made to the text,
	# So at worst we have misreprented the user's intentions slightly.
	# trace("true")
	removeTrailing = true
	
# trace(`ch`+","+`removeTrailing`)


</t>
<t tx="T1888"># Do nothing if we are in @nocolor mode or if we are executing a Change command.
if self.colorizer.useSyntaxColoring(v) and undoType != "Change":
	# Get the previous line.
	s=c.body.get("insert linestart - 1 lines","insert linestart -1c")
	# Add the leading whitespace to the present line.
	junk,width = skip_leading_ws_with_indent(s,0,c.tab_width)
	if s and len(s) &gt; 0 and s[-1]==':':
		# For Python: increase auto-indent after colons.
		if self.colorizer.scanColorDirectives(v) == "python":
			width += abs(c.tab_width)
	if app().config.getBoolWindowPref("smart_auto_indent"):
		# Added Nov 18 by David McNab, david@rebirthing.co.nz
		# Determine if prev line has unclosed parens/brackets/braces
		brackets = [width]
		tabex = 0
		for i in range(0, len(s)):
			if s[i] == '\t':
				tabex += c.tab_width - 1
			if s[i] in '([{':
				brackets.append(i+tabex + 1)
			elif s[i] in '}])' and len(brackets) &gt; 1:
				brackets.pop()
		width = brackets.pop()
		# end patch by David McNab
	ws = computeLeadingWhitespace (width,c.tab_width)
	if ws and len(ws) &gt; 0:
		c.body.insert("insert", ws)
		removeTrailing = false # bug fix: 11/18</t>
<t tx="T1889"># Do nothing if we are executing a Change command.
if undoType != "Change":
	
	# Get the characters preceeding the tab.
	prev=c.body.get("insert linestart","insert -1c")
	
	if 1: # 6/26/03: Convert tab no matter where it is.

		w = computeWidth(prev,c.tab_width)
		w2 = (abs(c.tab_width) - (w % abs(c.tab_width)))
		# print "prev w:" + `w` + ", prev chars:" + `prev`
		c.body.delete("insert -1c")
		c.body.insert("insert",' ' * w2)
	
	else: # Convert only leading tabs.
	
		# Get the characters preceeding the tab.
		prev=c.body.get("insert linestart","insert -1c")

		# Do nothing if there are non-whitespace in prev:
		all_ws = true
		for ch in prev:
			if ch != ' ' and ch != '\t':
				all_ws = false
		if all_ws:
			w = computeWidth(prev,c.tab_width)
			w2 = (abs(c.tab_width) - (w % abs(c.tab_width)))
			# print "prev w:" + `w` + ", prev chars:" + `prev`
			c.body.delete("insert -1c")
			c.body.insert("insert",' ' * w2)</t>
<t tx="T1890">s = c.body.get("1.0", "end")
s = toUnicode(s,app().tkEncoding) #2/25/03
if len(s) &gt; 0 and s[-1] == '\n' and removeTrailing:
	s = s[:-1]</t>
<t tx="T1891">self.scanForTabWidth(v)
incremental = undoType not in ("Cut","Paste")
self.recolor_now(v,incremental=incremental)</t>
<t tx="T1892">redraw_flag = false

c.beginUpdate()

# Update dirty bits.
if not v.isDirty() and v.setDirty(): # Sets all cloned and @file dirty bits
	redraw_flag = true
	
# Update icons.
val = v.computeIcon()
if val != v.iconVal:
	v.iconVal = val
	redraw_flag = true

c.endUpdate(redraw_flag) # redraw only if necessary</t>
<t tx="T1893"># Called by command handlers that have already changed the text.

def onBodyChanged (self,v,undoType,oldSel=None,oldYview=None,newSel=None,oldText=None):
	
	"""Handle a change to the body pane."""
	
	c = self.commands
	if not v:
		v = c.currentVnode()

	if not oldSel:
		oldSel = getTextSelection(c.body)

	self.idle_body_key(v,oldSel,undoType,oldYview=oldYview,newSel=newSel,oldText=oldText)
</t>
<t tx="T1894">def OnBodyKey (self,event):
	
	"""Handle any key press event in the body pane."""

	c = self.commands ; v = c.currentVnode() ; ch = event.char
	oldSel = getTextSelection(c.body)
	
	if 0:
		self.keyCount += 1
		if ch and len(ch)&gt;0: print "%4d %s" % (self.keyCount,repr(ch))
		
	# We must execute this even if len(ch) &gt; 0 to delete spurious trailing newlines.
	self.commands.body.after_idle(self.idle_body_key,v,oldSel,"Typing",ch)</t>
<t tx="T1895"># Called by command handlers that change the text just before idle time.

def onBodyWillChange (self,v,undoType,oldSel=None,oldYview=None):
	
	"""Queue the body changed idle handler."""
	
	c = self.commands
	if not v: v = c.currentVnode()
	if not oldSel:
		oldSel = getTextSelection(c.body)
	  
	self.commands.body.after_idle(self.idle_body_key,v,oldSel,undoType,oldYview)

</t>
<t tx="T1896">def OnContinueDrag(self,v,event):

	try:
		&lt;&lt; continue dragging &gt;&gt;
	except:
		es_event_exception("continue drag")</t>
<t tx="T1897"># trace(`v`)
assert(v == self.drag_v)

c = self.commands 
canvas = self.canvas
frame = self.commands.frame

if event:
	x,y = event.x,event.y
else:
	x,y = frame.top.winfo_pointerx(),frame.top.winfo_pointery()
	if x == -1 or y == -1: return # Stop the scrolling if we go outside the entire window.

canvas_x = canvas.canvasx(x)
canvas_y = canvas.canvasy(y)

id = self.canvas.find_closest(canvas_x,canvas_y)

# OnEndDrag() halts the scrolling by clearing self.drag_id when the mouse button goes up.
if self.drag_id: # This gets cleared by OnEndDrag()
	&lt;&lt; scroll the canvas as needed &gt;&gt;</t>
<t tx="T1898"># Scroll the screen up or down one line if the cursor (y) is outside the canvas.
h = canvas.winfo_height()
if y &lt; 0 or y &gt; h:
	lo, hi = frame.treeBar.get()
	n = self.savedNumberOfVisibleNodes
	line_frac = 1.0 / float(n)
	frac = choose(y &lt; 0, lo - line_frac, lo + line_frac)
	frac = min(frac,1.0)
	frac = max(frac,0.0)
	# es("lo,hi,frac:" + `lo` + " " + `hi` + " " + `frac`)
	canvas.yview("moveto", frac)
	
	# Queue up another event to keep scrolling while the cursor is outside the canvas.
	lo, hi = frame.treeBar.get()
	if (y &lt; 0 and lo &gt; 0.1) or (y &gt; h and hi &lt; 0.9):
		canvas.after_idle(self.OnContinueDrag,v,None) # Don't propagate the event.</t>
<t tx="T1899"># This works around an apparent Tk bug.

def OnControlT (self,event=None):

	# If we don't inhibit further processing the Tx.Text widget switches characters!
	return "break"</t>
<t tx="T1900"># This precomputes numberOfVisibleNodes(), a significant optimization.
# We also indicate where findVnodeWithIconId() should start looking for tree id's.

def OnDrag(self,v,event):

	# Note: "drag" hooks handled by vnode callback routine.
	# trace(event)
	
	c = self.commands
	assert(v == self.drag_v)

	if not event:
		return

	if not self.dragging:
		# 11/25/02: Only do this once: greatly speeds drags.
		self.savedNumberOfVisibleNodes = self.numberOfVisibleNodes()
		self.dragging = true
		self.controlDrag = c.frame.controlKeyIsDown
		# 1/29/03: support this new option.
		flag = app().config.getBoolWindowPref("look_for_control_drag_on_mouse_down")
		if flag:
			if self.controlDrag:
				es("dragged node will be cloned")
			else:
				es("dragged node will be moved")
		self.canvas['cursor'] = "hand2" # "center_ptr"

	self.OnContinueDrag(v,event)</t>
<t tx="T1901">def OnEndDrag(self,v,event):
	
	"""Tree end-of-drag handler called from vnode event handler."""
	
	# trace(v)
	
	# 7/10/03: Make sure we are still dragging.
	if not self.drag_v:
		return

	assert(v == self.drag_v)
	c = self.commands ; canvas = self.canvas

	if event:
		&lt;&lt; set vdrag, childFlag &gt;&gt;
		# 1/29/03: support for this new option.
		flag = app().config.getBoolWindowPref("look_for_control_drag_on_mouse_down")
		if not flag:
			self.controlDrag = c.frame.controlKeyIsDown
		if vdrag and vdrag != v:
			if self.controlDrag: # Clone v and move the clone.
				if childFlag:
					c.dragCloneToNthChildOf(v,vdrag,0)
				else:
					c.dragCloneAfter(v,vdrag)
			else: # Just drag v.
				if childFlag:
					c.dragToNthChildOf(v,vdrag,0)
				else:
					c.dragAfter(v,vdrag)
		else:
			if v and self.dragging:
				pass # es("not dragged: " + v.headString())
			if 0: # Don't undo the scrolling we just did!
				self.idle_scrollTo(v)
	
	# 1216/02: Reset the old cursor by brute force.
	self.canvas['cursor'] = "arrow"

	if self.drag_id:
		canvas.tag_unbind(self.drag_id , "&lt;B1-Motion&gt;")
		canvas.tag_unbind(self.drag_id , "&lt;Any-ButtonRelease-1&gt;")
		self.drag_id = None
		
	self.dragging = false
	self.drag_v = None</t>
<t tx="T1902">x,y = event.x,event.y
canvas_x = canvas.canvasx(x)
canvas_y = canvas.canvasy(y)

id = self.canvas.find_closest(canvas_x,canvas_y)
vdrag = self.findVnodeWithIconId(id)
childFlag = vdrag and vdrag.hasChildren() and vdrag.isExpanded()</t>
<t tx="T1903">@ The &lt;Key&gt; event generates the event before the headline text is changed(!), so we register an idle-event handler to do the work later.
@c

@others</t>
<t tx="T1904">def onHeadChanged (self,v):
	
	"""Handle a change to headline text."""

	self.commands.body.after_idle(self.idle_head_key,v)


</t>
<t tx="T1905">def OnHeadlineKey (self,v,event):
	
	"""Handle a key event in a headline."""

	ch = event.char
	self.commands.body.after_idle(self.idle_head_key,v,ch)

</t>
<t tx="T1906">def idle_head_key (self,v,ch=None):
	
	"""Update headline text at idle time."""

	c = self.commands
	if not v or not v.edit_text() or v != c.currentVnode():
		return "break"
	if doHook("headkey1",c=c,v=v,ch=ch):
		return "break" # The hook claims to have handled the event.

	&lt;&lt; set s to the widget text &gt;&gt;
	&lt;&lt; set head to vnode text &gt;&gt;
	changed = s != head
	done = ch and (ch == '\r' or ch == '\n')
	if not changed and not done:
		return "break"
	if changed:
		c.undoer.setUndoParams("Change Headline",v,newText=s,oldText=head)
	index = v.edit_text().index("insert")
	if changed:
		&lt;&lt; update v and all nodes joined to v &gt;&gt;
	&lt;&lt; reconfigure v and all nodes joined to v &gt;&gt;
	&lt;&lt; update the screen &gt;&gt;

	doHook("headkey2",c=c,v=v,ch=ch)
	return "break"</t>
<t tx="T1907">s = v.edit_text().get("1.0","end")
s = toUnicode(s,app().tkEncoding) # 2/25/03
if not s:
	s = u""
s = s.replace('\n','')
s = s.replace('\r','')
# trace(`s`)
</t>
<t tx="T1908">head = v.headString()
if head == None:
	head = u""
head = toUnicode(head,"utf-8")
</t>
<t tx="T1909">c.beginUpdate()

# Update changed bit.
if not c.changed:
	c.setChanged(true)

# Update all dirty bits.
v.setDirty()

# Update v.
v.initHeadString(s)
v.edit_text().delete("1.0","end")
v.edit_text().insert("end",s)
v.edit_text().mark_set("insert",index)

# Update all joined nodes.
for v2 in v.t.joinList:
	if v2 != v:
		v2.initHeadString(s)
		if v2.edit_text(): # v2 may not be visible
			v2.edit_text().delete("1.0","end")
			v2.edit_text().insert("end",s)

c.endUpdate(false) # do not redraw now.</t>
<t tx="T1910"># Reconfigure v's headline.
if done:
	self.setDisabledLabelState(v)

v.edit_text().configure(width=self.headWidth(v))

# Reconfigure all joined headlines.
for v2 in v.t.joinList:
	if v2 != v:
		if v2.edit_text(): # v2 may not be visible
			v2.edit_text().configure(width=self.headWidth(v2))</t>
<t tx="T1911">if done:
	c.beginUpdate()
	self.endEditLabel()
	c.endUpdate()

elif changed:
	# update v immediately.  Joined nodes are redrawn later by endEditLabel.
	# Redrawing the whole screen now messes up the cursor in the headline.
	self.drawIcon(v,v.iconx,v.icony) # just redraw the icon.</t>
<t tx="T1912">def OnIconClick (self,v,event):

	# Note: "iconclick" hooks handled by vnode callback routine.

	canvas = self.canvas
	if event:
		canvas_x = canvas.canvasx(event.x)
		canvas_y = canvas.canvasy(event.y)
		id = canvas.find_closest(canvas_x,canvas_y)
		if id != None:
			try: id = id[0]
			except: pass
			# trace("drag_v",v)
			self.drag_v = v
			self.drag_id = id
			id4 = canvas.tag_bind(id,"&lt;B1-Motion&gt;", v.OnDrag)
			id5 = canvas.tag_bind(id,"&lt;Any-ButtonRelease-1&gt;", v.OnEndDrag)
			
			# Remember the bindings so deleteBindings can delete them.
			self.tagBindings.append((id,id4,"&lt;B1-Motion&gt;"),)
			self.tagBindings.append((id,id5,"&lt;Any-ButtonRelease-1&gt;"),)

	self.select(v)
	
def OnIconRightClick (self,v,event):

	self.select(v)</t>
<t tx="T1913">def OnIconDoubleClick (self,v,event=None):

	# Note: "icondclick" hooks handled by vnode callback routine.

	c = self.commands
	s = v.headString().strip()
	if match_word(s,0,"@url"):
		if not doHook("@url1",c=c,v=v):
			url = s[4:].strip()
			&lt;&lt; stop the url after any whitespace &gt;&gt;
			&lt;&lt; check the url; return if bad &gt;&gt;
			&lt;&lt; pass the url to the web browser &gt;&gt;
		doHook("@url2",c=c,v=v)</t>
<t tx="T1914"># For safety, the URL string should end at the first whitespace.

url = url.replace('\t',' ')
i = url.find(' ')
if i &gt; -1:
	if 0: # No need for a warning.  Assume everything else is a comment.
		es("ignoring characters after space in url:"+url[i:])
		es("use %20 instead of spaces")
	url = url[:i]
</t>
<t tx="T1915">if not url or len(url) == 0:
	es("no url following @url")
	return
	
@ A valid url is (according to D.T.Hein):

3 or more lowercase alphas, followed by,
one ':', followed by,
one or more of: (excludes !"#;&lt;&gt;[\]^`|)
  $%&amp;'()*+,-./0-9:=?@A-Z_a-z{}~
followed by one of: (same as above, except no minus sign or comma).
  $%&amp;'()*+/0-9:=?@A-Z_a-z}~
@c

urlPattern = "[a-z]{3,}:[\$-:=?-Z_a-z{}~]+[\$-+\/-:=?-Z_a-z}~]"
import re
# 4/21/03: Add http:// if required.
if not re.match('^([a-z]{3,}:)',url):
	url = 'http://' + url
if not re.match(urlPattern,url):
	es("invalid url: "+url)
	return
</t>
<t tx="T1916">@ Most browsers should handle the following urls:
  ftp://ftp.uu.net/public/whatever.
  http://localhost/MySiteUnderDevelopment/index.html
  file:///home/me/todolist.html
@c

try:
	import os
	import webbrowser
	os.chdir(app().loadDir)
	# print "url:",url
	webbrowser.open(url)
except:
	es("exception opening " + url)
	es_exception()</t>
<t tx="T1917">def OnPopup (self,v,event):
	
	"""Handle right-clicks in the outline."""
	
	# Note: "headrclick" hooks handled by vnode callback routine.

	if event != None:
		c = self.commands
		if not doHook("create-popup-menu",c=c,v=v,event=event):
			self.createPopupMenu(v,event)
		if not doHook("enable-popup-menu-items",c=c,v=v,event=event):
			self.enablePopupMenuItems(v,event)
		if not doHook("show-popup-menu",c=c,v=v,event=event):
			self.showPopupMenu(v,event)

	return "break"</t>
<t tx="T1918">@ On Linux we must do something special to make the popup menu "unpost" if the mouse is clicked elsewhere.  So we have to catch the &lt;FocusOut&gt; event and explicitly unpost.  In order to process the &lt;FocusOut&gt; event, we need to be able to find the reference to the popup window again, so this needs to be an attribute of the tree object; hence, "self.popupMenu".

Aside: though Tk tries to be muli-platform, the interaction with different window managers does cause small differences that will need to be compensated by system specific application code. :-(
@c

# 20-SEP-2002 DTHEIN: This event handler is only needed for Linux.

def OnPopupFocusLost(self,event=None):

	self.popupMenu.unpost()
	
</t>
<t tx="T1919">def createPopupMenu (self,v,event):
	
	a = app() ; c = self.commands ; frame = c.frame
	
	# If we are going to recreate it, we had better destroy it.
	if self.popupMenu:
		self.popupMenu.destroy()
		self.popupMenu = None
	
	self.popupMenu = menu = Tkinter.Menu(app().root, tearoff=0)
	
	# Add the Open With entries if they exist.
	if a.openWithTable:
		frame.createMenuEntries(menu,a.openWithTable,openWith=1)
		table = (("-",None,None),)
		frame.createMenuEntries(menu,table)
		
	&lt;&lt; Create the menu table &gt;&gt;
	frame.createMenuEntries(menu,table)</t>
<t tx="T1920">table = (
	("&amp;Read @file Nodes",None,frame.OnReadAtFileNodes),
	("&amp;Write @file Nodes",None,frame.OnWriteAtFileNodes),
	("-",None,None),
	("&amp;Tangle","Shift+Ctrl+T",frame.OnTangle),
	("&amp;Untangle","Shift+Ctrl+U",frame.OnUntangle),
	("-",None,None),
	("Toggle Angle &amp;Brackets","Ctrl+B",frame.OnToggleAngleBrackets),
	("-",None,None),
	("Cut Node","Shift+Ctrl+X",frame.OnCutNode),
	("Copy Node","Shift+Ctrl+C",frame.OnCopyNode),
	("&amp;Paste Node","Shift+Ctrl+V",frame.OnPasteNode),
	("&amp;Delete Node","Shift+Ctrl+BkSp",frame.OnDeleteNode),
	("-",None,None),
	("&amp;Insert Node","Ctrl+I",frame.OnInsertNode),
	("&amp;Clone Node","Ctrl+`",frame.OnCloneNode),
	("Sort C&amp;hildren",None,frame.OnSortChildren),
	("&amp;Sort Siblings","Alt-A",frame.OnSortSiblings),
	("-",None,None),
	("Contract Parent","Alt+0",frame.OnContractParent))</t>
<t tx="T1921">def enablePopupMenuItems (self,v,event):
	
	"""Enable and disable items in the popup menu."""
	
	c = self.commands ; menu = self.popupMenu

	&lt;&lt; set isAtRoot and isAtFile if v's tree contains @root or @file nodes &gt;&gt;
	isAtFile = choose(isAtFile,1,0)
	isAtRoot = choose(isAtRoot,1,0)
	canContract = v.parent() != None
	canContract = choose(canContract,1,0)
	
	for name in ("Read @file Nodes", "Write @file Nodes"):
		enableMenu(menu,name,isAtFile)
	for name in ("Tangle", "Untangle"):
		enableMenu(menu,name,isAtRoot)
	
	enableMenu(menu,"Cut Node",c.canCutOutline())
	enableMenu(menu,"Delete Node",c.canDeleteHeadline())
	enableMenu(menu,"Paste Node",c.canPasteOutline())
	enableMenu(menu,"Sort Children",c.canSortChildren())
	enableMenu(menu,"Sort Siblings",c.canSortSiblings())
	enableMenu(menu,"Contract Parent",c.canContractParent())</t>
<t tx="T1922">isAtFile = false ; isAtRoot = false
v2 = v ; next = v.nodeAfterTree()

while (not isAtFile or not isAtRoot) and v2 != None and v2 != next:
	if (
		v2.isAtFileNode() or
		v.isAtRawFileNode() or
		v.isAtSilentFileNode() or
		v.isAtNoSentinelsFileNode()):
		isAtFile = true

	isRoot, junk = is_special(v2.bodyString(),0,"@root")
	if isRoot:
		isAtRoot = true
	v2 = v2.threadNext()</t>
<t tx="T1923">def showPopupMenu (self,v,event):
	
	"""Show a popup menu."""
	
	c = self.commands ; menu = self.popupMenu

	if sys.platform == "linux2": # 20-SEP-2002 DTHEIN: not needed for Windows
		menu.bind("&lt;FocusOut&gt;",self.OnPopupFocusLost)
	
	menu.post(event.x_root, event.y_root)

	# Make certain we have focus so we know when we lose it.
	# I think this is OK for all OSes.
	set_focus(c,menu)</t>
<t tx="T1924"></t>
<t tx="T1925">def allocateNodes(self,where,lines):
	
	"""Allocate Tk widgets in nodes that will become visible as the result of an upcoming scroll"""
	
	assert(where in ("above","below"))

	# print "allocateNodes: %d lines %s visible area" % (lines,where)
	
	# Expand the visible area: a little extra delta is safer.
	delta = lines * (self.line_height + 4)
	y1,y2 = self.visibleArea

	if where == "below":
		y2 += delta
	else:
		y1 = max(0.0,y1-delta)

	self.expandedVisibleArea=y1,y2
	# print "expandedArea:   %5.1f %5.1f" % (y1,y2)
	
	# Allocate all nodes in expanded visible area.
	self.updatedNodeCount = 0
	self.updateTree(self.rootVnode,root_left,root_top,0,0)
	# if self.updatedNodeCount: print "updatedNodeCount:", self.updatedNodeCount
</t>
<t tx="T1926">def allocateNodesBeforeScrolling (self, args):
	
	"""Calculate the nodes that will become visible as the result of an upcoming scroll.

	args is the tuple passed to the Tk.Canvas.yview method"""

	if not self.allocateOnlyVisibleNodes: return

	# print "allocateNodesBeforeScrolling:",self.redrawCount,`args`

	assert(self.visibleArea)
	assert(len(args)==2 or len(args)==3)
	kind = args[0] ; n = args[1]
	lines = 2 # Update by 2 lines to account for rounding.
	if len(args) == 2:
		assert(kind=="moveto")
		frac1,frac2 = args
		if float(n) != frac1:
			where = choose(n&lt;frac1,"above","below")
			self.allocateNodes(where=where,lines=lines)
	else:
		assert(kind=="scroll")
		linesPerPage = self.canvas.winfo_height()/self.line_height + 2
		n = int(n) ; assert(abs(n)==1)
		where = choose(n == 1,"below","above")
		lines = choose(args[2] == "pages",linesPerPage,lines)
		self.allocateNodes(where=where,lines=lines)</t>
<t tx="T1927">def updateNode (self,v,x,y):
	
	"""Draw a node that may have become visible as a result of a scrolling operation"""

	if self.inExpandedVisibleArea(y):
		# This check is a major optimization.
		if not v.edit_text():
			return self.force_draw_node(v,x,y)
		else:
			return self.line_height

	return self.line_height</t>
<t tx="T1928">def setVisibleAreaToFullCanvas(self):
	
	if self.visibleArea:
		y1,y2 = self.visibleArea
		y2 = max(y2,y1 + self.canvas.winfo_height())
		self.visibleArea = y1,y2</t>
<t tx="T1929">def setVisibleArea (self,args):

	r1,r2 = args
	r1,r2 = float(r1),float(r2)
	# print "scroll ratios:",r1,r2

	try:
		s = self.canvas.cget("scrollregion")
		x1,y1,x2,y2 = scanf(s,"%d %d %d %d")
		x1,y1,x2,y2 = int(x1),int(y1),int(x2),int(y2)
	except:
		self.visibleArea = None
		return
		
	scroll_h = y2-y1
	# print "height of scrollregion:", scroll_h

	vy1 = y1 + (scroll_h*r1)
	vy2 = y1 + (scroll_h*r2)
	self.visibleArea = vy1,vy2
	# print "setVisibleArea: %5.1f %5.1f" % (vy1,vy2)
</t>
<t tx="T1930">def updateTree (self,v,x,y,h,level):

	yfirst = ylast = y
	if level==0: yfirst += 10
	while v:
		# trace(`x` + ", " + `y` + ", " + `v`)
		h = self.updateNode(v,x,y)
		y += h ; ylast = y
		if v.isExpanded() and v.firstChild():
			y = self.updateTree(v.firstChild(),x+child_indent,y,h,level+1)
		v = v.next()
	return y
</t>
<t tx="T1931"></t>
<t tx="T1932">def abortEditLabelCommand (self):
	
	v = self.currentVnode
	# trace(v)
	if self.revertHeadline and v.edit_text() and v == self.editVnode:
		
		# trace(`self.revertHeadline`)
		v.edit_text().delete("1.0","end")
		v.edit_text().insert("end",self.revertHeadline)
		self.idle_head_key(v) # Must be done immediately.
		self.revertHeadline = None
		self.select(v)
		if v and len(v.t.joinList) &gt; 0:
			# 3/26/03: changed redraw_now to force_redraw.
			self.force_redraw() # force a redraw of joined headlines.</t>
<t tx="T1933"># Convenience methods so the caller doesn't have to know the present edit node.

def dimEditLabel (self):

	v = self.currentVnode
	self.setDisabledLabelState(v)

def undimEditLabel (self):

	v = self.currentVnode
	self.setSelectedLabelState(v)</t>
<t tx="T1934"># Start editing v.edit_text()

def editLabel (self, v):

	# End any previous editing
	if self.editVnode and v != self.editVnode:
		self.endEditLabel()
		self.revertHeadline = None
		
	self.editVnode = v # 7/7/03.

	# Start editing
	if v and v.edit_text():
		# trace(`v`)
		self.setNormalLabelState(v)
		self.revertHeadline = v.headString()</t>
<t tx="T1935"># End editing for self.editText

def endEditLabel (self):

	c = self.commands ; v = self.editVnode
	# trace(v)
	if v and v.edit_text():
		self.setUnselectedLabelState(v)
		self.editVnode = None
	if v: # Bug fix 10/9/02: also redraw ancestor headlines.
		# 3/26/03: changed redraw_now to force_redraw.
		self.force_redraw() # force a redraw of joined and ancestor headlines.
	set_focus(c,c.body) # 10/14/02
		
def endEditLabelCommand (self):

	c = self.commands ; v = self.editVnode
	# trace(v)
	if v and v.edit_text():
		self.select(v)
	if v: # Bug fix 10/9/02: also redraw ancestor headlines.
		# 3/26/03: changed redraw_now to force_redraw.
		self.force_redraw() # force a redraw of joined headlines.
	set_focus(c,c.body) # 10/14/02</t>
<t tx="T1936">def expandAllAncestors (self,v):

	redraw_flag = false
	p = v.parent()
	while p:
		if not p.isExpanded():
			p.expand()
			redraw_flag = true
		p = p.parent()
	return redraw_flag</t>
<t tx="T1937"># Similar to code in scanAllDirectives.

def scanForTabWidth (self, v):
	
	c = self.commands ; w = c.tab_width

	while v:
		s = v.t.bodyString
		dict = get_directives_dict(s)
		&lt;&lt; set w and break on @tabwidth &gt;&gt;
		v = v.parent()

	c.frame.setTabWidth(w)</t>
<t tx="T1938">if dict.has_key("tabwidth"):
	
	val = scanAtTabwidthDirective(s,dict,issue_error_flag=false)
	if val and val != 0:
		w = val
		break</t>
<t tx="T1939"># Warning: do not try to "optimize" this by returning if v==tree.currentVnode.

def select (self,v,updateBeadList=true):
	
	# trace(v)

	&lt;&lt; define vars and stop editing &gt;&gt;

	if not doHook("unselect1",c=c,new_v=v,old_v=old_v):
		&lt;&lt; unselect the old node &gt;&gt;
	else: old_body = u""

	doHook("unselect2",c=c,new_v=v,old_v=old_v)
	
	if not doHook("select1",c=c,new_v=v,old_v=old_v):
		&lt;&lt; select the new node &gt;&gt;
		if v and v != old_v: # 3/26/03: Suppress duplicate call.
			try: # may fail during initialization
				self.idle_scrollTo(v)
			except: pass
		&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;
		&lt;&lt; update c.visitedList &gt;&gt;

	&lt;&lt; set the current node and redraw &gt;&gt;
	doHook("select2",c=c,new_v=v,old_v=old_v)
	doHook("select3",c=c,new_v=v,old_v=old_v)
</t>
<t tx="T1940">c = self.commands ; frame = c.frame ; body = frame.body
old_v = c.currentVnode()

# Unselect any previous selected but unedited label.
self.endEditLabel()
old = self.currentVnode
self.setUnselectedLabelState(old)</t>
<t tx="T1941"># Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.body.index("insert")

# Remember the old body text
old_body = body.get("1.0","end")

if old and old != v and old.edit_text():
	old.t.scrollBarSpot = yview
	old.t.insertSpot = insertSpot
</t>
<t tx="T1942">frame.setWrap(v)

# Delete only if necessary: this may reduce flicker slightly.
s = v.t.bodyString
s = toUnicode(s,"utf-8")
old_body = toUnicode(old_body,"utf-8")
if old_body != s:
	body.delete("1.0","end")
	body.insert("1.0",s)

# We must do a full recoloring: we may be changing context!
self.recolor_now(v)

if v and v.t.scrollBarSpot != None:
	first,last = v.t.scrollBarSpot
	body.yview("moveto",first)

if v.t.insertSpot != None: # 9/21/02: moved from c.selectVnode
	c.body.mark_set("insert",v.t.insertSpot)
	c.body.see(v.t.insertSpot)
else:
	c.body.mark_set("insert","1.0")</t>
<t tx="T1943">if updateBeadList:
	if c.beadPointer &gt; -1:
		present_v = c.beadList[c.beadPointer]
	else:
		present_v = None
	
	if v != present_v:
		# Replace the tail of c.beadList by c and make c the present node.
		# print "updating c.beadList"
		c.beadPointer += 1
		c.beadList[c.beadPointer:] = []
		c.beadList.append(v)
</t>
<t tx="T1944"># Make v the most recently visited node on the list.
if v in c.visitedList:
	c.visitedList.remove(v)
	
c.visitedList.insert(0,v)</t>
<t tx="T1945">self.currentVnode = v
self.setSelectedLabelState(v)
self.scanForTabWidth(v) # 9/13/02 #GS I believe this should also get into the select1 hook
set_focus(c,c.body)
</t>
<t tx="T1946">def setNormalLabelState (self,v): # selected, editing
	if v and v.edit_text():
		# trace(v)
		&lt;&lt; set editing headline colors &gt;&gt;
		v.edit_text().tag_remove("sel","1.0","end")
		v.edit_text().tag_add("sel","1.0","end")
		set_focus(self.commands,v.edit_text())

def setDisabledLabelState (self,v): # selected, disabled
	if v and v.edit_text():
		# trace(v)
		&lt;&lt; set selected, disabled headline colors &gt;&gt;

def setSelectedLabelState (self,v): # selected, not editing
	self.setDisabledLabelState(v)

def setUnselectedLabelState (self,v): # not selected.
	if v and v.edit_text():
		# trace(v)
		&lt;&lt; set unselected headline colors &gt;&gt;</t>
<t tx="T1947">config = app().config
fg   = config.getWindowPref("headline_text_editing_foreground_color")
bg   = config.getWindowPref("headline_text_editing_background_color")
selfg = config.getWindowPref("headline_text_editing_selection_foreground_color")
selbg = config.getWindowPref("headline_text_editing_selection_background_color")

if not fg or not bg:
	fg,bg = "black","white"
	
try:
	if selfg and selbg:
		v.edit_text().configure(
			selectforeground=selfg,selectbackground=selbg,
			state="normal",highlightthickness=1,fg=fg,bg=bg)
	else:
		v.edit_text().configure(
			state="normal",highlightthickness=1,fg=fg,bg=bg)
except:
	es_exception()</t>
<t tx="T1948">config = app().config
fg = config.getWindowPref("headline_text_selected_foreground_color")
bg = config.getWindowPref("headline_text_selected_background_color")

if not fg or not bg:
	fg,bg = "black","gray80"

try:
	v.edit_text().configure(
		state="disabled",highlightthickness=0,fg=fg,bg=bg)
except:
	es_exception()</t>
<t tx="T1949">config = app().config
fg = config.getWindowPref("headline_text_unselected_foreground_color")
bg = config.getWindowPref("headline_text_unselected_background_color")

if not fg or not bg:
	fg,bg = "black","white"

try:
	v.edit_text().configure(
		state="disabled",highlightthickness=0,fg=fg,bg=bg)
except:
	es_exception()</t>
<t tx="T1950">def OnUpKey   (self,event=None): return self.moveUpDown("up")
def OnDownKey (self,event=None): return self.moveUpDown("down")

def moveUpDown (self,upOrDown):
	c = self.commands ; body = c.frame.body
	# Make the insertion cursor visible so bbox won't return an empty list.
	body.see("insert")
	# Find the coordinates of the cursor and set the new height.
	# There may be roundoff errors because character postions may not match exactly.
	ins =  body.index("insert")
	lines,char = scanf(ins,"%d.%d")
	x,y,junk,textH = body.bbox("insert")
	bodyW,bodyH = body.winfo_width(),body.winfo_height()
	junk,maxy,junk,junk = body.bbox("@%d,%d" % (bodyW,bodyH))
	# Make sure y is within text boundaries.
	if upOrDown == "up":
		if y &lt;= textH:
			body.yview("scroll",-1,"units")
		else: y = max(y-textH,0)
	else:
		if y &gt;= maxy:
			body.yview("scroll",1,"units")
		else: y = min(y+textH,maxy)
	# Position the cursor on the proper side of the characters.
	newx,newy,width,junk = body.bbox("@%d,%d" % (x,y))
	if x &gt; newx + width/2:
		x = newx + width + 1
	result = body.index("@%d,%d" % (x,y))
	body.mark_set("insert",result)
	# trace("entry:  %s.%s" % (lines,char))
	# trace("result:",result)
	# trace("insert:",body.index("insert"))
	return "break" # Inhibit further bindings.</t>
<t tx="T1951">@language python

# Undo manager for leo.py.

&lt;&lt; How Leo implements unlimited undo &gt;&gt;
&lt;&lt; Define optional ivars &gt;&gt;
from leoGlobals import *
import types

class baseUndoer:
	"""The base class of the undoer class."""
	@others
	
class undoer (baseUndoer):
	"""A class that implements unlimited undo and redo."""
	pass</t>
<t tx="T1952">@ Only leo.py supports unlimited undo.  Unlimited undo is straightforward; it merely requires that all commands that affect the outline or body text must be undoable. In other words, everything that affects the outline or body text must be remembered.

We may think of all the actions that may be Undone or Redone as a string of beads (undo nodes). Undoing an operation moves backwards to the next bead; redoing an operation moves forwards to the next bead. A bead pointer points to the present bead. The bead pointer points in front of the first bead when Undo is disabled.  The bead pointer points at the last bead when Redo is disabled. An undo node is a Python dictionary containing all information needed to undo or redo the operation.

The Undo command uses the present bead to undo the action, then moves the bead pointer backwards. The Redo command uses the bead after the present bead to redo the action, then moves the bead pointer forwards. All undoable operations call setUndoParams() to create a new bead. The list of beads does not branch; all undoable operations (except the Undo and Redo commands themselves) delete any beads following the newly created bead.

I did not invent this model of unlimited undo.  I first came across it in the documentation for Apple's Yellow Box classes.
</t>
<t tx="T1953">optionalIvars = (
	"lastChild",
	"parent","oldParent",
	"back","oldBack",
	"n","oldN","oldV",
	"oldText","newText",
	"oldSel","newSel",
	"sort","select",
	"oldTree",
	"yview",
	# For incremental undo typing...
	"leading","trailing",
	"oldMiddleLines","newMiddleLines",
	"oldNewlines","newNewlines")</t>
<t tx="T1954">def __init__ (self,commands):
	
	u = self ; u.commands = commands
	
	# Ivars to transition to new undo scheme...
	
	u.debug = false # true: enable debugging code in new undo scheme.
	u.debug_print = false # true: enable print statements in debug code.
	u.new_undo = true # true: enable new debug code.
	
	# Statistics comparing old and new ways (only if u.debug is on).
	u.new_mem = 0
	u.old_mem = 0
	
	# State ivars...
	u.undoType = "Can't Undo"
	# Bug fix: 12/16/02: These must be set here, _not_ in clearUndoState.
	u.redoMenuLabel = "Can't Redo"
	u.undoMenuLabel = "Can't Undo"
	u.realRedoMenuLabel = "Can't Redo"
	u.realUndoMenuLabel = "Can't Undo"
	u.undoing = false # True if executing an Undo command.
	u.redoing = false # True if executing a Redo command.

	u.clearUndoState()</t>
<t tx="T1955">def clearIvars (self):
	
	self.v = None # The node being operated upon for undo and redo.
	for ivar in optionalIvars:
		setattr(self,ivar,None)</t>
<t tx="T1956"></t>
<t tx="T1957">@ This method clears then entire Undo state.  All non-undoable commands should call this method.
@c

def clearUndoState (self):
	
	u = self
	
	if 0: # Bug fix: 12/16/02: setUndo/Redo type needs the old values.
		u.redoMenuLabel = "Can't Redo" 
		u.undoMenuLabel = "Can't Undo"
	
	if 0: # Wrong: set realLabel only when calling setMenuLabel.
		realLabel = app().getRealMenuName("Can't Redo")
		u.realRedoMenuLabel = realLabel.replace("&amp;","")
		realLabel = app().getRealMenuName("Can't Undo")
		u.realUndoMenuLabel = realLabel.replace("&amp;","")
		
	u.setRedoType("Can't Redo")
	u.setUndoType("Can't Undo")
	u.beads = [] # List of undo nodes.
	u.bead = -1 # Index of the present bead: -1:len(beads)
	u.clearIvars()</t>
<t tx="T1958"># Translation does not affect these routines.

def canRedo (self):

	u = self
	return u.redoMenuLabel != "Can't Redo"

def canUndo (self):

	u = self
	return u.undoMenuLabel != "Can't Undo"
</t>
<t tx="T1959">def enableMenuItems (self):

	u = self ; c = u.commands
	menu = c.frame.getMenu("Edit")

	enableMenu(menu,u.redoMenuLabel,u.canRedo())
	enableMenu(menu,u.undoMenuLabel,u.canUndo())
</t>
<t tx="T1960">def getBead (self,n):
	
	u = self
	if n &lt; 0 or n &gt;= len(u.beads): return false
	d = u.beads[n]
	# trace(`n` + ":" + `len(u.beads)` + ":" + `d`)
	self.clearIvars()
	u.v = d["v"]
	u.undoType = d["undoType"]

	for ivar in optionalIvars:
		val = d.get(ivar,None)
		setattr(u,ivar,val)

	if not u.new_undo: # Recreate an "oldText" entry if necessary.
		if u.undoType == "Typing" and u.oldText == None:
			assert(n &gt; 0)
			old_d = u.beads[n-1]
			# The user will lose data if these asserts fail.
			assert(old_d["undoType"] == "Typing")
			assert(old_d["v"] == u.v)
			u.oldText = old_d["newText"]
			# trace(`u.oldText`)
	return d
	
def peekBead (self,n):
	
	u = self
	if n &lt; 0 or n &gt;= len(u.beads): return false
	d = u.beads[n]
	# trace(`n` + ":" + `len(u.beads)` + ":" + `d`)
	return d

def setBead (self,n,keywords=None):

	u = self ; d = {}
	d["undoType"]=u.undoType
	d["v"]=u.v
	# Only enter significant entries into the dictionary.
	# This is an important space optimization for typing.
	for ivar in optionalIvars:
		if getattr(u,ivar) != None:
			d[ivar] = getattr(u,ivar)
	# copy all significant keywords to d.
	if keywords:
		for key in keywords.keys():
			if keywords[key] != None:
				d[key] = keywords[key]
	# Clear the "oldText" entry if the previous entry was a "Typing" entry.
	# This optimization halves the space needed for Undo/Redo Typing.
	if not u.new_undo:
		if u.undoType == "Typing" and n &gt; 0:
			old_d = u.beads[n-1]
			if old_d["undoType"] == "Typing" and old_d["v"] == u.v:
				del d["oldText"] # We can recreate this entry from old_d["newText"]
				# trace(`u.oldText`)
	# trace(`d`)
	return d</t>
<t tx="T1961">def redoMenuName (self,name):

	if name=="Can't Redo":
		return name
	else:
		return "Redo " + name

def undoMenuName (self,name):

	if name=="Can't Undo":
		return name
	else:
		return "Undo " + name</t>
<t tx="T1962"># These routines update both the ivar and the menu label.
def setRedoType (self,type):
	u = self ; c = u.commands
	menu = c.frame.getMenu("Edit")
	name = u.redoMenuName(type)
	if name != u.redoMenuLabel:
		# Update menu using old name.
		realLabel = app().getRealMenuName(name)
		if realLabel == name:
			underline=choose(match(name,0,"Can't"),-1,0)
		else:
			underline = realLabel.find("&amp;")
		realLabel = realLabel.replace("&amp;","")
		setMenuLabel(menu,u.realRedoMenuLabel,realLabel,underline=underline)
		u.redoMenuLabel = name
		u.realRedoMenuLabel = realLabel

def setUndoType (self,type):
	u = self ; c = u.commands
	menu = c.frame.getMenu("Edit")
	name = u.undoMenuName(type)
	if name != u.undoMenuLabel:
		# Update menu using old name.
		realLabel = app().getRealMenuName(name)
		if realLabel == name:
			underline=choose(match(name,0,"Can't"),-1,0)
		else:
			underline = realLabel.find("&amp;")
		realLabel = realLabel.replace("&amp;","")
		setMenuLabel(menu,u.realUndoMenuLabel,realLabel,underline=underline)
		u.undoType = type
		u.undoMenuLabel = name
		u.realUndoMenuLabel = realLabel</t>
<t tx="T1963">@ This routine saves enough information so an operation can be undone and redone.  We do nothing when called from the undo/redo logic because the Undo and Redo commands merely reset the bead pointer.
@c

def setUndoParams (self,undo_type,v,**keywords):

	u = self
	if u.redoing or u.undoing: return None
	if undo_type == None:
		return None
	if undo_type == "Can't Undo":
		u.clearUndoState()
		return None
	# trace(undo_type,v)
	# Set the type: set the menu labels later.
	u.undoType = undo_type
	# Calculate the standard derived information.
	u.v = v
	u.parent = v.parent()
	u.back = v.back()
	u.n = v.childIndex()
	# Push params on undo stack, clearing all forward entries.
	u.bead += 1
	d = u.setBead(u.bead,keywords)
	u.beads[u.bead:] = [d]
	# trace(`u.bead` + ":" + `len(u.beads)` + ":" + `keywords`)
	# Recalculate the menu labels.
	u.setUndoTypes()
	return d</t>
<t tx="T1964">@ This routine saves enough information so a typing operation can be undone and redone.

We do nothing when called from the undo/redo logic because the Undo and Redo commands merely reset the bead pointer.
@c

def setUndoTypingParams (self,v,undo_type,oldText,newText,oldSel,newSel,oldYview=None):

	u = self ; c = u.commands
	if u.redoing or u.undoing: return None
	if undo_type == None:
		return None
	if undo_type == "Can't Undo":
		u.clearUndoState()
		return None
	if oldText == newText:
		# trace("no change")
		return None
	# Clear all optional params.
	for ivar in optionalIvars:
		setattr(u,ivar,None)
	# Set the params.
	u.undoType = undo_type
	u.v = v
	&lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;
	&lt;&lt; save undo text info &gt;&gt;
	u.oldSel = oldSel ; u.newSel = newSel
	# 11/13/02: Remember the scrolling position.
	if oldYview:
		u.yview = oldYview
	else:
		u.yview = c.frame.body.yview()
	# Push params on undo stack, clearing all forward entries.
	u.bead += 1
	d = u.setBead(u.bead)
	u.beads[u.bead:] = [d]
	# trace(`u.bead` + ":" + `len(u.beads)`)
	u.setUndoTypes() # Recalculate the menu labels.
	return d
</t>
<t tx="T1965">@ Incremental undo typing is similar to incremental syntax coloring.  We compute the number of leading and trailing lines that match, and save both the old and new middle lines.

NB: the number of old and new middle lines may be different.
@c

old_lines = string.split(oldText,'\n')
new_lines = string.split(newText,'\n')
new_len = len(new_lines)
old_len = len(old_lines)
min_len = min(old_len,new_len)

i = 0
while i &lt; min_len:
	if old_lines[i] != new_lines[i]:
		break
	i += 1
leading = i

if leading == new_len:
	# This happens when we remove lines from the end.
	# The new text is simply the leading lines from the old text.
	trailing = 0
else:
	i = 0
	while i &lt; min_len - leading:
		if old_lines[old_len-i-1] != new_lines[new_len-i-1]:
			break
		i += 1
	trailing = i
	
# NB: the number of old and new middle lines may be different.
if trailing == 0:
	old_middle_lines = old_lines[leading:]
	new_middle_lines = new_lines[leading:]
else:
	old_middle_lines = old_lines[leading:-trailing]
	new_middle_lines = new_lines[leading:-trailing]
	
# Remember how many trailing newlines in the old and new text.
i = len(oldText) - 1 ; old_newlines = 0
while i &gt;= 0 and oldText[i] == '\n':
	old_newlines += 1
	i -= 1

i = len(newText) - 1 ; new_newlines = 0
while i &gt;= 0 and newText[i] == '\n':
	new_newlines += 1
	i -= 1

if u.debug_print:
	trace()
	print "lead,trail",leading,trailing
	print "old mid,nls:",len(old_middle_lines),old_newlines,oldText
	print "new mid,nls:",len(new_middle_lines),new_newlines,newText
	#print "lead,trail:",leading,trailing
	#print "old mid:",old_middle_lines
	#print "new mid:",new_middle_lines
	print "---------------------"</t>
<t tx="T1966">@ This is the start of the incremental undo algorithm.

We must save enough info to do _both_ of the following:

Undo: Given newText, recreate oldText.
Redo: Given oldText, recreate oldText.

The "given" texts for the undo and redo routines are simply v.bodyString().
@c

if u.new_undo:
	if u.debug:
		# Remember the complete text for comparisons...
		u.oldText = oldText
		u.newText = newText
		# Compute statistics comparing old and new ways...
		# The old doesn't often store the old text, so don't count it here.
		u.old_mem += len(newText)
		s1 = string.join(old_middle_lines,'\n')
		s2 = string.join(new_middle_lines,'\n')
		u.new_mem += len(s1) + len(s2)
	else:
		u.oldText = None
		u.newText = None
else:
	u.oldText = oldText
	u.newText = newText

self.leading = leading
self.trailing = trailing
self.oldMiddleLines = old_middle_lines
self.newMiddleLines = new_middle_lines
self.oldNewlines = old_newlines
self.newNewlines = new_newlines</t>
<t tx="T1967">def setUndoTypes (self):
	
	u = self
	# trace(`u.bead` + ":" + `len(u.beads)`)

	# Set the undo type and undo menu label.
	d = u.peekBead(u.bead)
	if d:
		u.setUndoType(d["undoType"])
	else:
		u.setUndoType("Can't Undo")

	# Set only the redo menu label.
	d = u.peekBead(u.bead+1)
	if d:
		u.setRedoType(d["undoType"])
	else:
		u.setRedoType("Can't Redo")



</t>
<t tx="T1968">def redo (self):
	
	# clear_stats() ; stat()
	u = self ; c = u.commands
	if not u.canRedo(): return
	if not u.getBead(u.bead+1): return
	current = c.currentVnode()
	if not current: return
	# trace(`u.bead+1` + ":" + `len(u.beads)` + ":" + `u.peekBead(u.bead+1)`)
	u.redoing = true
	redrawFlag = true
	c.beginUpdate()
	redoType = u.undoType # Use the type of the next bead.
	if 1: # range...
		&lt;&lt; redo clone cases &gt;&gt;
		&lt;&lt; redo insert cases &gt;&gt;
		&lt;&lt; redo delete cases &gt;&gt;
		&lt;&lt; redo move &amp; drag cases &gt;&gt;
		&lt;&lt; redo promote and demote cases &gt;&gt;
		&lt;&lt; redo replace cases &gt;&gt;
		&lt;&lt; redo sort cases &gt;&gt;
		&lt;&lt; redo typing cases &gt;&gt;
		else: trace("Unknown case: " + `redoType`)
		c.setChanged(true)
		if u.v: u.v.setDirty()
	c.endUpdate(redrawFlag) # 11/08/02
	u.redoing = false
	u.bead += 1
	u.setUndoTypes()
	# print_stats()</t>
<t tx="T1969">if redoType in ("Clone","Drag &amp; Clone"):

	if u.back:
		u.v.linkAfter(u.back)
	elif u.parent:
		u.v.linkAsNthChild(u.parent,0)
	else:
		u.v.linkAsRoot()

	shared = u.findSharedVnode(u.v)
	if shared: u.v.joinTreeTo(shared)
	u.v.createDependents()
	c.initAllCloneBits()
	c.selectVnode(u.v)
</t>
<t tx="T1970">elif redoType == "Delete Outline" or redoType == "Cut Node":

	c.selectVnode(u.v)
	c.deleteHeadline()</t>
<t tx="T1971">elif redoType in ["Import", "Insert Outline", "Paste Node"]:

	if u.back:
		u.v.linkAfter(u.back)
	elif u.parent:
		u.v.linkAsNthChild(u.parent,0)
	else:
		u.v.linkAsRoot()

	shared = u.findSharedVnode(u.v)
	if shared: u.v.joinTreeTo(shared)
	u.v.createDependents()
	c.initAllCloneBits()
	c.selectVnode(u.v)</t>
<t tx="T1972">elif redoType in ["Drag","Move Down","Move Left","Move Right","Move Up"]:

	if u.parent:
		u.v.moveToNthChildOf(u.parent,u.n)
	elif u.back:
		u.v.moveAfter(u.back)
	else:
		# 3/16/02: Moving up is the only case that can do this.
		parent = u.v.parent()
		u.v.moveToRoot(c.tree.rootVnode) # 5/27/02
		if parent: # We could assert(parent)
			parent.moveAfter(u.v)
	c.initJoinedCloneBits(u.v) # 7/6/02
	c.selectVnode(u.v)
	
elif redoType == "Drag":

	u.v.moveToNthChildOf(u.parent,u.n)
	c.initJoinedCloneBits(u.v) # 7/6/02
	c.selectVnode(u.v)</t>
<t tx="T1973">elif redoType == "Demote":

	c.selectVnode(u.v)
	c.demote()
	
elif redoType == "Promote":

	c.selectVnode(u.v)
	c.promote()</t>
<t tx="T1974">elif redoType in (
	"Convert All Blanks","Convert All Tabs",
	"Extract","Extract Names","Extract Section"):
	
	u.v = self.undoReplace(u.oldTree,u.v,u.newText)
	c.selectVnode(u.v) # Does full recolor.
	if u.newSel:
		start,end=u.newSel
		setTextSelection(c.frame.body,start,end)
	redrawFlag = redoType in ("Extract","Extract Names","Extract Section")
</t>
<t tx="T1975">elif redoType == "Sort Children":

	c.selectVnode(u.v)
	c.sortChildren()

elif redoType == "Sort Siblings":

	c.selectVnode(u.v)
	c.sortSiblings()
	
elif redoType == "Sort Top Level":
	
	c.selectVnode(u.v)
	c.sortTopLevel()
	u.v = None # don't mark u.v dirty
</t>
<t tx="T1976">elif redoType in ( "Typing",
	"Change","Convert Blanks","Convert Tabs","Cut",
	"Delete","Indent","Paste","Reformat Paragraph","Undent"):

	# trace(`redoType` + ":" + `u.v`)
	# selectVnode causes recoloring, so avoid if possible.
	if current != u.v:
		c.selectVnode(u.v) ## Optimize this away??
	self.undoRedoText(
		u.v,u.leading,u.trailing,
		u.newMiddleLines,u.oldMiddleLines,
		u.newNewlines,u.oldNewlines,
		tag="redo")
	
	if u.newSel:
		start,end=u.newSel
		setTextSelection (c.frame.body,start,end)
	if u.yview:
		first,last=u.yview
		c.body.yview("moveto",first)
	redrawFlag = (current != u.v)
		
elif redoType == "Change All":

	while 1:
		u.bead += 1
		d = u.getBead(u.bead+1)
		assert(d)
		redoType = u.undoType
		# trace(`redoType`)
		if redoType == "Change All":
			c.selectVnode(u.v)
			break
		elif redoType == "Change":
			u.v.t.setTnodeText(u.newText)
			u.v.setDirty()
		elif redoType == "Change Headline":
			u.v.initHeadString(u.newText)
		else: assert(false)

elif redoType == "Change Headline":
	
	# trace(`u.newText`)
	u.v.setHeadStringOrHeadline(u.newText)
	# Update all joined headlines.
	for v2 in u.v.t.joinList:
		if v2 != u.v:
			v2.setHeadString(u.newText)
	c.selectVnode(u.v)</t>
<t tx="T1977">@ This function and its allies undo the operation described by the undo parmaters.
@c

def undo (self):
	
	# clear_stats() ; # stat()
	u = self ; c = u.commands
	if not u.canUndo(): return
	if not u.getBead(u.bead): return
	current = c.currentVnode()
	if not current: return
	# trace(`u.bead` + ":" + `len(u.beads)` + ":" + `u.peekBead(u.bead)`)
	c.endEditing()# Make sure we capture the headline for a redo.
	u.undoing = true
	c.beginUpdate()
	undoType = u.undoType
	redrawFlag = true
	if 1: # range...
		&lt;&lt; undo clone cases &gt;&gt;
		&lt;&lt; undo delete cases &gt;&gt;
		&lt;&lt; undo insert cases &gt;&gt;
		&lt;&lt; undo move &amp; drag cases &gt;&gt;
		&lt;&lt; undo promote and demote cases &gt;&gt;
		&lt;&lt; undo replace cases &gt;&gt;
		&lt;&lt; undo sort cases &gt;&gt;
		&lt;&lt; undo typing cases &gt;&gt;
		else: trace("Unknown case: " + `u.undoType`)
		c.setChanged(true)
		if u.v: u.v.setDirty()
	c.endUpdate(redrawFlag) # 11/9/02
	u.undoing = false
	u.bead -= 1
	u.setUndoTypes()
	# print_stats()</t>
<t tx="T1978"># We can immediately delete the clone because clone() can recreate it using only v.

if undoType == "Clone":
	
	c.selectVnode(u.v)
	c.deleteHeadline()
	c.selectVnode(u.back)
	
elif undoType == "Drag &amp; Clone":
	
	c.selectVnode(u.v)
	c.deleteHeadline()
	c.selectVnode(u.oldV)</t>
<t tx="T1979">@ Deleting a clone is _not_ the same as undoing a clone: the clone may have been moved, so there is no necessary relationship between the two nodes.
@c

elif undoType == "Delete Outline" or undoType == "Cut Node":
	
	if u.back:
		u.v.linkAfter(u.back)
	elif u.parent:
		u.v.linkAsNthChild(u.parent,0)
	else:
		u.v.linkAsRoot()
	shared = u.findSharedVnode(u.v)
	if shared: u.v.joinTreeTo(shared)
	u.v.createDependents()
	c.initAllCloneBits()
	c.selectVnode(u.v)</t>
<t tx="T1980">elif undoType in ["Import", "Insert Outline", "Paste Node"]:
	
	c.selectVnode(u.v)
	c.deleteHeadline()
	if u.select:
		# trace("Insert/Paste:" + `u.select`)
		c.selectVnode(u.select)</t>
<t tx="T1981">elif undoType in ["Drag", "Move Down","Move Left","Move Right","Move Up"]:

	if u.oldParent:
		u.v.moveToNthChildOf(u.oldParent,u.oldN)
	elif u.oldBack:
		u.v.moveAfter(u.oldBack)
	else:
		# 3/16/02: Moving up is the only case that can do this.
		parent = u.v.parent()
		u.v.moveToRoot(c.tree.rootVnode) # 5/27/02
		if parent: # We could assert(parent)
			parent.moveAfter(u.v)
	
	c.initJoinedCloneBits(u.v) # 7/6/02
	c.selectVnode(u.v)
</t>
<t tx="T1982">elif undoType in (
	"Convert All Blanks","Convert All Tabs",
	"Extract","Extract Names","Extract Section"):
		
	u.v = self.undoReplace(u.v,u.oldTree,u.oldText)
	c.selectVnode(u.v) # Does full recolor.
	if u.oldSel:
		start,end=u.oldSel
		setTextSelection(c.frame.body,start,end)
	redrawFlag = true</t>
<t tx="T1983">@ Promote and demote operations are the hard to undo, because they involve relinking a list of nodes. We pass the work off to routines dedicated to the task.
@c

elif undoType == "Demote":

	u.undoDemote()

elif undoType == "Promote":
	
	u.undoPromote()</t>
<t tx="T1984">@ Sort operations are the hard to undo, because they involve relinking a list of nodes. We pass the work off to routines dedicated to the task.
@c

elif undoType == "Sort Children":
	
	u.undoSortChildren()

elif undoType == "Sort Siblings":
	
	u.undoSortSiblings()
	
elif undoType == "Sort Top Level":
	
	u.undoSortTopLevel()
	u.v = None # don't mark u.v dirty</t>
<t tx="T1985">@ When making "large" changes to text, we simply save the old and new text for undo and redo.  This happens rarely, so the expense is minor.

But for typical typing situations, where we are typing a single character, saving both the old and new text wastes a huge amount of space and puts extreme stress on the garbage collector.  This in turn can cause big performance problems.
@c
	
elif undoType in ( "Typing",
	"Change","Convert Blanks","Convert Tabs","Cut",
	"Delete","Indent","Paste","Reformat Paragraph","Undent"):

	# trace(`undoType` + ":" + `u.v`)
	# selectVnode causes recoloring, so don't do this unless needed.
	if current != u.v:
		c.selectVnode(u.v) ## Optimize this away??
	self.undoRedoText(
		u.v,u.leading,u.trailing,
		u.oldMiddleLines,u.newMiddleLines,
		u.oldNewlines,u.newNewlines,
		tag="undo")
	if u.oldSel:
		start,end=u.oldSel
		setTextSelection (c.frame.body,start,end)
	if u.yview:
		first,last=u.yview
		c.body.yview("moveto",first)
	redrawFlag = (current != u.v)
		
elif undoType == "Change All":

	while 1:
		u.bead -= 1
		d = u.getBead(u.bead)
		assert(d)
		undoType = u.undoType
		# trace(`undoType`)
		if undoType == "Change All":
			c.selectVnode(u.v)
			break
		elif undoType == "Change":
			u.v.t.setTnodeText(u.oldText)
			u.v.setDirty()
		elif undoType == "Change Headline":
			u.v.initHeadString(u.oldText)
		else: assert(false)
		
elif undoType == "Change Headline":
	
	# trace(`u.oldText`)
	u.v.setHeadStringOrHeadline(u.oldText)
	# 9/24/02: update all joined headlines.
	for v2 in u.v.t.joinList:
		if v2 != u.v:
			v2.setHeadString(u.oldText)
	c.selectVnode(u.v)</t>
<t tx="T1986"></t>
<t tx="T1987">def findSharedVnode (self,target):

	u = self ; c = u.commands ; v = c.rootVnode()
	while v:
		if v != target and v.t == target.t:
			return v
		v = v.threadNext()
	return None</t>
<t tx="T1988"># undoes the previous demote operation.
def undoDemote (self):

	u = self ; c = u.commands
	ins = v = u.v
	last = u.lastChild
	child = v.firstChild()
	assert(child)
	c.beginUpdate()
	# 3/19/03: do not undemote children up to last.
	if last:
		while child and child != last:
			child = child.next()
		if child:
			child = child.next()
	while child:
		next = child.next()
		child.moveAfter(ins)
		ins = child
		child = next
	c.selectVnode(v)
	c.endUpdate()</t>
<t tx="T1989"># Undoes the previous promote operation.
def undoPromote (self):

	u = self ; c = u.commands
	v = v1 = u.v
	assert(v1)
	last = u.lastChild
	next = v.next()
	assert(next)
	c.beginUpdate()
	while next:
		v = next
		next = v.next()
		n = v1.numberOfChildren()
		v.moveToNthChildOf(v1,n)
		if v == last: break
	c.selectVnode(v1)
	c.endUpdate()</t>
<t tx="T1990">@ This routine implements undo for any kind of operation, no matter how complex.  Just do:

	v_copy = v.copyTree(v)
	(make arbitrary changes to v's tree.)
	c.undoer.setUndoParams("Op Name",v,select=current,oldTree=v_copy)
@c

def undoReplace (self,new_v,old_v,text):
	
	"""Replace new_v with old_v during undo."""

	# trace("new_v:%s" % new_v)
	# trace("old_v:%s" % old_v)
	# trace("text:",text)
	assert(new_v and old_v)
	assert(text is not None)
	u = self ; c = u.commands
	joinList = new_v.t.joinList[:]
	if 0:
		trace("joinList")
		for j in joinList:
			print '\t',j
	assert(new_v in joinList)
	result = None
	for v in joinList:
		if v == new_v: result = copy = old_v
		else: copy = old_v.copyTree()
		# Remember how to link the new node.
		parent = v.parent()
		prev = v.back()
		next = v.next()
		n = v.childIndex()
		# Unlink the old tree.
		v.unjoinTree()
		v.unlink()
		# Link in the new tree.
		if parent: copy.linkAsNthChild(parent,n)
		elif prev: copy.linkAfter(prev)
		else:      copy.linkAsRoot(oldRoot=next)
		copy.addTreeToJoinLists()
		assert(copy in copy.t.joinList)

	assert(result == old_v)
	result.t.setTnodeText(text)
	result.setBodyStringOrPane(text)

	c.initAllCloneBits()
	return result</t>
<t tx="T1991"># Handle text undo and redo.
# The terminology is for undo: converts _new_ text into _old_ text.

def undoRedoText (self,v,
	leading,trailing, # Number of matching leading &amp; trailing lines.
	oldMidLines,newMidLines, # Lists of unmatched lines.
	oldNewlines,newNewlines, # Number of trailing newlines.
	tag="undo"): # "undo" or "redo"

	u = self ; c = u.commands
	assert(v == c.currentVnode())

	&lt;&lt; Incrementally update the Tk.Text widget &gt;&gt;
	&lt;&lt; Compute the result using v's body text &gt;&gt;
	#trace(`v`)
	#trace("old:"+`v.bodyString()`)
	v.t.setTnodeText(result)
	#trace("new:"+`v.bodyString()`)
	&lt;&lt; Get textResult from the Tk.Text widget &gt;&gt;
	if textResult == result:
		# print "incremental undo:",leading,trailing
		c.tree.recolor_range(v,leading,trailing)
	else: # 11/19/02: # Rewrite the pane and do a full recolor.
		if u.debug_print:
			&lt;&lt; print mismatch trace &gt;&gt;
		# print "non-incremental undo"
		v.setBodyStringOrPane(result)
</t>
<t tx="T1992"># Only update the changed lines.
mid_text = string.join(oldMidLines,'\n')
new_mid_len = len(newMidLines)
# Maybe this could be simplified, and it is good to treat the "end" with care.
if trailing == 0:
	c.frame.body.delete(str(1+leading)+".0","end")
	if leading &gt; 0:
		c.frame.body.insert("end",'\n')
	c.frame.body.insert("end",mid_text)
else:
	if new_mid_len &gt; 0:
		c.frame.body.delete(str(1+leading)+".0",
			str(leading+new_mid_len)+".0 lineend")
	elif leading &gt; 0:
		c.frame.body.insert(str(1+leading)+".0",'\n')
	c.frame.body.insert(str(1+leading)+".0",mid_text)
# Try to end the Tk.Text widget with oldNewlines newlines.
# This may be off by one, and we don't care because
# we never use body text to compute undo results!
s = c.frame.body.get("1.0","end")
s = toUnicode(s,app().tkEncoding) # 2/25/03
newlines = 0 ; i = len(s) - 1
while i &gt;= 0 and s[i] == '\n':
	newlines += 1 ; i -= 1
while newlines &gt; oldNewlines:
	c.frame.body.delete("end-1c")
	newlines -= 1
if oldNewlines &gt; newlines:
	c.frame.body.insert("end",'\n'*(oldNewlines-newlines))
</t>
<t tx="T1993"># Recreate the text using the present body text.
body = v.bodyString()
body = toUnicode(body,"utf-8")
body_lines = body.split('\n')
s = []
if leading &gt; 0:
	s.extend(body_lines[:leading])
if len(oldMidLines) &gt; 0:
	s.extend(oldMidLines)
if trailing &gt; 0:
	s.extend(body_lines[-trailing:])
s = string.join(s,'\n')
# Remove trailing newlines in s.
while len(s) &gt; 0 and s[-1] == '\n':
	s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines &gt; 0:
	s = s + '\n' * oldNewlines
result = s
if u.debug_print:
	print "body:  ",`body`
	print "result:",`result`</t>
<t tx="T1994">textResult = c.frame.body.get("1.0","end")
textResult = toUnicode(textResult,app().tkEncoding) # 2/25/03

if textResult != result:
	# Remove the newline from textResult if that is the only difference.
	if len(textResult) &gt; 0 and textResult[:-1] == result:
		textResult = result</t>
<t tx="T1995">print "undo mismatch"
print "expected:",`result`
print "actual  :",`textResult`
</t>
<t tx="T1996">def undoSortChildren (self):

	u = self ; c = u.commands ; v = u.v
	assert(v)
	c.beginUpdate()
	if 1: # inside update...
		c.endEditing()
		index = 0
		for child in u.sort:
			child.moveToNthChildOf(v,index)
			index += 1
		v.setDirty()
		c.setChanged(true)
	c.endUpdate()</t>
<t tx="T1997">def undoSortSiblings (self):
	
	u = self ; c = u.commands ; v = u.v
	parent = v.parent()
	assert(v and parent)
	c.beginUpdate()
	if 1: # inside update...
		c.endEditing()
		index = 0
		for sib in u.sort:
			sib.moveToNthChildOf(parent,index)
			index += 1
		parent.setDirty()
		c.setChanged(true)
	c.endUpdate()</t>
<t tx="T1998">def undoSortTopLevel (self):
	
	u = self ; c = u.commands
	root = c.rootVnode()
	
	c.beginUpdate()
	c.endEditing()
	v = u.sort[0]
	v.moveToRoot(oldRoot=root)
	for next in u.sort[1:]:
		next.moveAfter(v)
		v = next
	c.setChanged(true)
	c.endUpdate()
</t>
</tnodes>
</leo_file>
