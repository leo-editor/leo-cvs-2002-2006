<?xml version="1.0" encoding="UTF-8"?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="101" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="88" left="369" height="734" width="662"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences allow_rich_text="0">
</preferences>
<find_panel_settings>
	<find_string></find_string>
	<change_string></change_string>
</find_panel_settings>
<vnodes>
<v t="T1" a="V"><vh>Distribution checklist</vh></v>
<v t="T2"><vh>Distribution scripts</vh></v>
<v t="T3"><vh>Notes</vh>
<v t="T4"><vh>Quote from Alex Martelli</vh></v>
<v t="T5"><vh>Singleton sequences</vh></v>
<v t="T6"><vh>How to get screenshots</vh></v>
</v>
<v t="T7"><vh>Previous tests</vh>
<v t="T8"><vh>@encoding test</vh>
<v t="T9"><vh>@file c:\prog\test\encodingTest.txt</vh>
<v t="T10"><vh>Umlaut in headline ë</vh></v>
</v>
</v>
<v t="T11"><vh>@file c:\prog\test\tab_test.txt</vh></v>
<v t="T12"><vh>@image Icons/Leoapp.GIF</vh></v>
<v t="T13"><vh>alloc tests</vh></v>
<v t="T14"><vh>Assignment tests</vh></v>
<v t="T15"><vh>Coloring Test</vh>
<v t="T16"><vh>Colorizing Test</vh></v>
<v t="T17"><vh>Color test without images</vh></v>
<v t="T18"><vh>Color names test</vh></v>
</v>
<v t="T19"><vh>Copy/Clones test</vh>
<v t="T20" a="C"><vh>a Å</vh>
<v t="T21" a="C"><vh>b</vh>
<v t="T22"><vh>c</vh></v>
</v>
<v t="T21" a="C"><vh>b</vh>
<v t="T22"><vh>c</vh></v>
</v>
</v>
<v t="T20" a="C"><vh>a Å</vh>
<v t="T21" a="C"><vh>b</vh>
<v t="T22"><vh>c</vh></v>
</v>
<v t="T21" a="C"><vh>b</vh>
<v t="T22"><vh>c</vh></v>
</v>
</v>
</v>
<v t="T23"><vh>Dialog tests</vh>
<v t="T24"><vh>Test askOk</vh></v>
<v t="T25"><vh>Test aboutLeo</vh></v>
<v t="T26"><vh>Test askLeoID</vh></v>
<v t="T27"><vh>Test askOkCancelNumber</vh></v>
<v t="T28"><vh>Test askOkCancel</vh></v>
<v t="T29"><vh>Test askYesNo</vh></v>
<v t="T30"><vh>Test askYesNoCancel</vh></v>
</v>
<v t="T31"><vh>Go to line number test</vh>
<v t="T32" a="E"><vh>@file c:\prog\test\goToLineNumber.txt</vh>
<v t="T33"><vh>__init__</vh></v>
<v t="T34"><vh>__init__</vh></v>
</v>
</v>
<v t="T35"><vh>Icon bar</vh>
<v t="T36"><vh>add some buttons</vh></v>
<v t="T37"><vh>add all gif files</vh></v>
<v t="T38"><vh>clear</vh></v>
<v t="T39"><vh>hide</vh></v>
<v t="T40"><vh>configure</vh></v>
<v t="T41"><vh>show (puts at bottom)</vh></v>
</v>
<v t="T42"><vh>Ignore</vh>
<v t="T43"><vh>@lineending and @encoding tests</vh></v>
<v t="T44"><vh>@file test.py</vh>
<v t="T45"><vh>Outer</vh>
<v t="T46"><vh>A2</vh></v>
<v t="T47"><vh>B</vh></v>
</v>
</v>
<v t="T48"><vh>Check clones links</vh></v>
</v>
<v t="T49"><vh>Line break problems</vh>
<v t="T50" a="E"><vh>Error</vh>
<v t="T51" a="E"><vh>@nosentinelsfile c:\prog\test\lineBreakError.txt</vh>
<v t="T52" a="E"><vh>functions</vh>
<v t="T53" a="E"><vh>objects</vh>
<v t="T54" a="EM"><vh>class shape</vh>
<v t="T55"><vh>&lt;&lt; class shape declarations &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
</v>
</v>
<v t="T56"><vh>New import</vh></v>
<v t="T57"><vh>Overriding core classes</vh></v>
<v t="T58"><vh>Read @file nodes</vh>
<v t="T59"><vh>@file c:\prog\test\atFileTest.txt</vh>
<v t="T60"><vh>Node 1</vh></v>
</v>
</v>
<v t="T61"><vh>reformatParagraph test</vh></v>
<v t="T62"><vh>Spell test </vh>
<v t="T63"><vh>node two</vh></v>
<v t="T64"><vh>node two no misspellings</vh></v>
</v>
<v t="T65"><vh>Status line</vh>
<v t="T66"><vh>put message</vh></v>
<v t="T67"><vh>clear</vh></v>
<v t="T68"><vh>tab width tests</vh>
<v t="T69"><vh>2</vh></v>
<v t="T70"><vh>4</vh></v>
<v t="T71"><vh>6</vh></v>
<v t="T72"><vh>8</vh></v>
</v>
</v>
<v t="T73"><vh>Test of recent sections &amp; clones</vh>
<v t="T74" a="C"><vh>&lt;&lt; section a &gt;&gt;</vh></v>
<v t="T75" a="C"><vh>hyper link test</vh>
<v t="T74" a="C"><vh>&lt;&lt; section a &gt;&gt;</vh></v>
<v t="T76"><vh>&lt;&lt; section b &gt;&gt;</vh></v>
</v>
<v t="T75" a="C"><vh>hyper link test</vh>
<v t="T74" a="C"><vh>&lt;&lt; section a &gt;&gt;</vh></v>
<v t="T76"><vh>&lt;&lt; section b &gt;&gt;</vh></v>
</v>
</v>
<v t="T77"><vh>timeit (in 2.3b1)</vh></v>
<v t="T78"><vh>Trailing newline in body</vh></v>
<v t="T79"><vh>Undo typing tests</vh></v>
<v t="T80"><vh>v.__repr__ and v.__str___</vh></v>
<v t="T81"><vh>wrap test</vh>
<v t="T82"><vh>@file c:\prog\test\wrap_test.txt</vh>
<v t="T83"><vh>wrap node</vh></v>
<v t="T84"><vh>nowrap node</vh></v>
</v>
</v>
<v t="T85"><vh>Write Missing @file nodes test</vh>
<v t="T86"><vh>@file ../test/missing_test.txt</vh></v>
</v>
</v>
<v t="T87"><vh>To do</vh>
<v t="T88"><vh>Use xml.sax</vh></v>
<v t="T89"><vh>Rebol keywords (- ? ~ ! not recognized as a part of a keyword)</vh></v>
<v t="T90"><vh>Actionscript keywords</vh></v>
</v>
<v t="T91"><vh>clone tests</vh>
<v t="T92" a="C"><vh>A</vh>
<v t="T93" a="C"><vh>B</vh>
<v t="T94" a="C"><vh>C</vh>
<v t="T95"><vh>D</vh></v>
</v>
<v t="T94" a="C"><vh>C</vh>
<v t="T95"><vh>D</vh></v>
</v>
</v>
<v t="T93" a="CE"><vh>B</vh>
<v t="T94" a="CE"><vh>C</vh>
<v t="T95"><vh>D</vh></v>
</v>
<v t="T94" a="C"><vh>C</vh>
<v t="T95"><vh>D</vh></v>
</v>
</v>
</v>
<v t="T96" a="C"><vh>New root</vh>
<v t="T92" a="CE"><vh>A</vh>
<v t="T93" a="C"><vh>B</vh>
<v t="T94" a="C"><vh>C</vh>
<v t="T95"><vh>D</vh></v>
</v>
<v t="T94" a="C"><vh>C</vh>
<v t="T95"><vh>D</vh></v>
</v>
</v>
<v t="T93" a="CE"><vh>B</vh>
<v t="T94" a="CE"><vh>C</vh>
<v t="T95"><vh>D</vh></v>
</v>
<v t="T94" a="C"><vh>C</vh>
<v t="T95"><vh>D</vh></v>
</v>
</v>
</v>
</v>
<v t="T96" a="C"><vh>New root</vh>
<v t="T92" a="CE"><vh>A</vh>
<v t="T93" a="C"><vh>B</vh>
<v t="T94" a="C"><vh>C</vh>
<v t="T95"><vh>D</vh></v>
</v>
<v t="T94" a="C"><vh>C</vh>
<v t="T95"><vh>D</vh></v>
</v>
</v>
<v t="T93" a="C"><vh>B</vh>
<v t="T94" a="C"><vh>C</vh>
<v t="T95"><vh>D</vh></v>
</v>
<v t="T94" a="C"><vh>C</vh>
<v t="T95"><vh>D</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="T97" a="E"><vh>Undo replace tests</vh>
<v t="T98" a="CE"><vh>A</vh>
<v t="T99" a="CE"><vh>B</vh>
<v t="T100" a="E"><vh>C</vh></v>
<v t="T101"><vh>C2</vh></v>
</v>
<v t="T99" a="CE"><vh>B</vh>
<v t="T100"><vh>C</vh></v>
<v t="T101"><vh>C2</vh></v>
</v>
</v>
<v t="T98" a="CE"><vh>A</vh>
<v t="T99" a="CE"><vh>B</vh>
<v t="T100"><vh>C</vh></v>
<v t="T101"><vh>C2</vh></v>
</v>
<v t="T99" a="CE"><vh>B</vh>
<v t="T100"><vh>C</vh></v>
<v t="T101"><vh>C2</vh></v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="T1">@color

# **** Run this from test.leo ****

# Run pychecker from idle.
if 1:
	import pychecker.checker
	import leo
@nocolor
Documentation
	- Update readme.txt
	- Update LeoDocs.leo
	- Update web site.
Version numbers
	- Update version number in Help menu.
	- Update version number in setup.py (@ignore'd!!)
@color

if 1: # Save all files and tangle leoConfig.leo
	from leoGlobals import importFromPath
	preSetup = importFromPath("preSetup","c:\prog\leoCvs\leo")
	preSetup.setup()

if 1: # Replace config settings and create .zip file.
	import os
	os.system(r"c:\python22\python c:\prog\leoCvs\leo\setup.py sdist --formats=zip")

@nocolor
Create and test leosetup.exe.
	- Create leosetup.exe by right-clicking leo.nsi and choosing "compile with NSI (bz2)"
	- Test created leosetup.exe file.
	- test the files created in c:\program files\leo
Create Release on SourceForge
Uploads
    - Upload leodocs.zip
	- Upload leosetup.exe
	- Upload leo-x-y.zip
	- Upload sbook.chm if it has been changed.
Announcements
	- Announce to SourceForge itself. USE ANNOUNCEMENT FORMAT, not readme format.
	- Announce to Leo's SourceForce site.
	- Announce to comp.lang.python
	- Announce to comp.programming.literate</t>
<t tx="T2">@color

# These scripts are now intended to be run only from here.

if 1: # Save all files and tangle leoConfig.leo
	from leoGlobals import importFromPath
	preSetup = importFromPath("preSetup","c:\prog\leoCvs\leo")
	preSetup.setup()

if 1: # Replace config settings and create .zip file.
	import os
	os.system(r"c:\python22\python c:\prog\leoCvs\leo\setup.py sdist --formats=zip")</t>
<t tx="T3"></t>
<t tx="T4">@nocolor

Personally, I nominate timeit.py as THE outstanding enhancement of Python 2.3
-- I love many of the others (the performance improvement in particular), but
timeit.py is the one I find myself using all of the time -- seems to provide an
innocuous way for programmers' typical obsession with performance and
micro-optimization to discharge itself harmlessly, cleansing their souls to
choose idioms on the basis of clarity, maintainability and readability, as of
course SHOULD be done :-)</t>
<t tx="T5"># Empty tuples are constructed by an empty pair of parentheses.
# tuple with one item is constructed by following a value with a comma.
# Examples:

# empty = ()
# singleton = 'hello',    # &lt;-- note trailing comma

s = "abc",

for i in s:
	print `i`
	
s = {"x":1, "y":2},

for i in s:
	print `i`</t>
<t tx="T6">import ImageGrab,os # requires PIL 1.1.3 or later

path = os.path.join(app().loadDir,"../","test","screenshot.gif")

ImageGrab.grab().save(path)
</t>
<t tx="T7"></t>
<t tx="T8">@encoding iso-8859-1</t>
<t tx="T9">@others

This is an umlaute ë</t>
<t tx="T10"></t>
<t tx="T11">----*---*---*---*---*---*
	.	.	.	.	.	
                        
.   ..  ... ....    .   
        .   ..</t>
<t tx="T12"></t>
<t tx="T13">import gc,Tkinter

# gc.set_debug(gc.DEBUG_STATS)

lastObjectCount = 0

def printGarbage(s):
	global lastObjectCount
	n  = len(gc.garbage)
	n2 = len(gc.get_objects())
	fmt = "%8s garbage: %d, objects:%+6d =%6d"
	print fmt % (s,n,n2-lastObjectCount,n2)
	lastObjectCount = n2

gc.collect()
printGarbage("start 1")
# Create a canvas widget for experimentation.
top = Tkinter.Tk()
frame = Tkinter.Frame(top) ; frame.pack()
canvas = Tkinter.Canvas(frame) ; canvas.pack()
# Allocate and (try to) deallocate widgets in the canvas.
x,y = 10,10
printGarbage("start 2")
for i in xrange(5):
	t = Tkinter.Text(canvas)
	canvas.create_window(x,y,window=t)
	y += 40
	printGarbage(" loop 1")
	t.destroy()
	canvas.delete("all")
	gc.collect() # Nuts...
	printGarbage(" loop 2")
# See when objects are really freed.
top.destroy()
printGarbage("end 1") # Huh ???
gc.collect()
printGarbage("end 2")
top = frame = canvas = None
gc.collect()
printGarbage("end 3")</t>
<t tx="T14"># The output of this is 5 5 6
# This shows that o2 is merely an alias for o.

class obj:
	def __init__(self,n):
		self.n = n

o = obj(5) ; print o.n,
o2  = o    ; print o2.n,
o.n = 6    ; print o2.n</t>
<t tx="T15">@markup wiki</t>
<t tx="T16">@language python

""" {picture file=../Icons/Leoapp.GIF}this """ # Problems with correct indexing following a graphic.

""" {picture file=../Icons/Leoapp.GIF}this """ # two copies work.

abc

""" {picture file=../Icons/Leodoc.GIF} """ # xyz


""" continued
string"""

@ ''ab'' __xxx__ ''wx'' __xyz__
@c

# /* ''ab'' __xxx__ ''wx'' __xyz__ */

# Test

""" ''' """ ''' """'''  # Leo handles the common cases correctly.

''' ''ab'' __xxx__ ''wx'' __xyz__ ''' # No wiki markup in ''' strings.

""" ''ab'' __xxx__ ''wx'' __xyz__ """

# ''ab'' __xxx__ ''wx'' __xyz__

""" ''y'' """

""" text~~#ff00ff:some text~~more text""

and if

from leoGlobals import * ; print app().loadDir</t>
<t tx="T17">""" continued
string"""

@ ''ab'' __xxx__ ''wx'' __xyz__  __''bolditalic''__ and ''__italicbold__''
@c

# /* ''ab'' __xxx__ ''wx'' __xyz__ */

__abc__ 

# Test

""" ''' """ ''' """'''  # Leo handles the __b__ common cases correctly.

''' ''ab'' __xxx__ ''wx'' __xyz__ ''' # No wiki markup in ''' strings.

""" ''ab'' __xxx__ ''wx'' __xyz__ """

# ''ab'' __xxx__ ''wx'' __xyz__

""" ''y'' """

""" text~~#ee00ff:some text~~more text"""



and if

from leoGlobals import * ; print app().loadDir
</t>
<t tx="T18">""" text~~red:some text~~more text"""

""" text~~#ee0ff:some text~~more text"""</t>
<t tx="T19"></t>
<t tx="T20"></t>
<t tx="T21"></t>
<t tx="T22"></t>
<t tx="T23"></t>
<t tx="T24">from leoGlobals import *
import leoDialog

if 1: # passed
	print leoDialog.askOk(
		"My Test Dialog",
		"Please hit return to test this dialog.",
		text="whoopee",
		resizeable=false).run(modal=true)
	
if 1: # passed
	message = "leo.py requires Python 2.1 or higher"
	print leoDialog.askOk("Python version error",message=message,text="Exit").run(modal=true)
	
if 1: # passed
	fileName = "xyzzy"
	print leoDialog.askOk("Read-only ouline",
		"Warning: the outline: " + fileName + " is read-only.").run(modal=true)</t>
<t tx="T25">from leoGlobals import *
import leoDialog

ver = "version 3.14159 "
build = "-3.8" 
version = "leo.py 4.0 alpha 2, Build " + build + ", June 13, 2003\n\n"
copyright = (
	"Copyright 1999-2003 by Edward K. Ream\n" +
	"All Rights Reserved\n" +
	"Leo is distributed under the Python License")
url = "http://webpages.charter.net/edreamleo/front.html"
email = "edreamleo@charter.net"

leoDialog.aboutLeo(version,copyright,url,email).run(modal=false)</t>
<t tx="T26">import leoDialog

print leoDialog.askLeoID().run(modal=1)</t>
<t tx="T27">import leoDialog

print leoDialog.askOkCancelNumber("Enter Line Number","Line number:").run(modal=1)
</t>
<t tx="T28">import leoDialog

print leoDialog.askOkCancel("Proceed?",
	"Read @file Nodes is not undoable.\nProceed?").run(modal=1)</t>
<t tx="T29">import leoDialog

if 1: # passed
	message = "Replace changed outline with external changes?"
	print leoDialog.askYesNo("Conflict!",message).run(modal=1)
	
if 1: # passed
	print leoDialog.askYesNo("Revert",
		"Revert to previous version of xyzzy?").run(modal=1)
		
if 1: # passed
	print leoDialog.askYesNo(
		"Download Tutorial?",
		"Download tutorial (sbooks.chm) from SourceForge?").run(modal=1)</t>
<t tx="T30">import leoDialog

if 1: # passed
	print leoDialog.askYesNoCancel("Confirm",
		'Save changes to xyzzy before crashing?').run(modal=1)
		
if 1: # passed
	message = (
		"Conflicting changes in outline and temp file\n\n" +
		"Do you want to use the code in the outline or the temp file?\n\n")
	
	print leoDialog.askYesNoCancel(
		"Conflict!", message,
		yesMessage = "Outline",
		noMessage = "File",
		defaultButton = "Cancel").run(modal=1)</t>
<t tx="T31"></t>
<t tx="T32">@others</t>
<t tx="T33">def __init__ (self):
	
	pass # line 9</t>
<t tx="T34">def __init__ (self):
	
	pass # line 16</t>
<t tx="T35"></t>
<t tx="T36">from leoGlobals import *

top().frame.addIconButton(imagefile="../Icons/Leoapp.gif")

top().frame.addIconButton(text="hi")

top().frame.addIconButton(imagefile="../Icons/Leodoc.gif")</t>
<t tx="T37">from leoGlobals import *
import glob,os

f = top().frame

pattern = "c:/prog/leoCVS/leo/Icons/*.gif"
files = glob.glob(pattern)
files.sort()

f.clearIconBar()
for file in files:
	f.addIconButton(imagefile=file,bg="lightBlue")</t>
<t tx="T38">from leoGlobals import *

top().frame.clearIconBar()</t>
<t tx="T39">from leoGlobals import *

top().frame.hideIconBar()</t>
<t tx="T40">from leoGlobals import *

top().frame.iconFrame.configure(height="15m")</t>
<t tx="T41">from leoGlobals import *

top().frame.showIconBar()</t>
<t tx="T42">@ignore</t>
<t tx="T43">@lineending nl         (the default, Linux)
@lineending cr         (Mac)
@lineending crlf       (Windows)
@lineending lf          (same as nl, not recommended)
@lineending platform (same as platform value for output_newline setting in leoConfig.txt)

@encoding utf-8</t>
<t tx="T44"># Test file for cut/paste operations.

@others</t>
<t tx="T45"></t>
<t tx="T46">node A Text</t>
<t tx="T47">node B text</t>
<t tx="T48">from leoGlobals import *

checkClones2Links(verbose=true)</t>
<t tx="T49"></t>
<t tx="T50">@ EKR: the doc string in class shape is improperly indented.
@c

@language Python
@tabwidth -4</t>
<t tx="T51">@first #!/usr/bin/python

@others
</t>
<t tx="T52">@others
</t>
<t tx="T53">@others
</t>
<t tx="T54">class shape(object):
  	&lt;&lt; class shape declarations &gt;&gt;
  	# after decls</t>
<t tx="T55">"""Parent class of all shapes."""
pass
</t>
<t tx="T56"># This shows that Python programs _could_ use .xpy files (xml files containing Leo/Python code).

from leoGlobals import *
import imp
import sys

old_import = __import__ # Get the global function

def leo_import(name,old_import,globals=None, locals=None, fromlist=None):
	try:
		mod = sys.modules.get(name)
		if mod:
			es("Leo import: module exists: " + name, color="blue")
		else:
			mod = old_import(name,globals,locals,fromlist)
			es("Leo import: " + name,color="blue")
	except ImportError:
		es("Leo import: not found: " + name,color="blue")
		mod = None
	return mod
		
m = leo_import("leoTest",__import__)
es(m,color="red")</t>
<t tx="T57">import leoFrame
print "%d leoFrame instances" % leoFrame.LeoFrame.instances</t>
<t tx="T58">@ignore</t>
<t tx="T59">@nocolor
This is a test file
@others</t>
<t tx="T60">Node one text.  changed 2.</t>
<t tx="T61">@language plain
@pagewidth 72
@tabwidth 2

The intent of this tool is to provide 
an aid to memorization practice.  The 
tool is directed at memorization of 
prose or poetry, not music or 
mathematics.  It would probably not 
be useful for memorization of dialog.  The 
purpose of such memorization is 
to be able to recreate a chunk of 
text in your head or on paper, and perhaps verbally.

The steps might be as follows:</t>
<t tx="T62">a b leoDialogs leoFind leoAtFile leoFileCommands leoGlobals modal end
line tooo changed 9
</t>
<t tx="T63">this is another test.

hello there jkk this is werg
		
the cht sat on the marh
the cat was sitting phew, another day. by zz z z 
two initabc
</t>
<t tx="T64">everything good.</t>
<t tx="T65"></t>
<t tx="T66">from leoGlobals import *
f = top().frame

f.clearStatusLine()

f.putStatusLine ("Hello")

for color in ("red","blue","yellow","green","orange"):
	f.putStatusLine (" %s " % (color),color=color)

f.putStatusLine(" World")</t>
<t tx="T67">from leoGlobals import *
f = top().frame

f.clearStatusLine()
</t>
<t tx="T68"></t>
<t tx="T69">@tabwidth 2

a
	b
		c	d</t>
<t tx="T70">@tabwidth 4

a
	b
		c	d</t>
<t tx="T71">@tabwidth 6

a
	b
		c	d</t>
<t tx="T72">@tabwidth 8

a
	b
		c	d</t>
<t tx="T73"></t>
<t tx="T74">This is section a.</t>
<t tx="T75">&lt;&lt; section a &gt;&gt;</t>
<t tx="T76"></t>
<t tx="T77">import timeit</t>
<t tx="T78">ab
</t>
<t tx="T79">test one</t>
<t tx="T80">from leoGlobals import *
c = top() ; v = c.currentVnode()
print v
print `v`</t>
<t tx="T81"></t>
<t tx="T82">@others</t>
<t tx="T83">@wrap

this should wrap aaaaaaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbbbbbb cccccccccccccccccc ddddddddddddddddddd eeeeeeeeeeeeeeeeeeeeee ffffffffffffffffffff</t>
<t tx="T84">@nowrap

this should NOT wrap aaaaaaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbbbbbb cccccccccccccccccc ddddddddddddddddddd eeeeeeeeeeeeeeeeeeeeee ffffffffffffffffffff</t>
<t tx="T85">@ignore</t>
<t tx="T86"></t>
<t tx="T87"></t>
<t tx="T88">from leoGlobals import *
import gc,os,time,leoNodes
from xml.sax import saxutils, make_parser
from xml.sax.xmlreader import InputSource

path = os.path.join(app().loadDir,"../","test","test2.leo")
# path = os.path.join(app().loadDir,"LeoPy.leo")
path = os.path.normpath(path)

verbose = true
tnodes = vnodes = 0
start = None

def clean(s): return toEncodedString(s,"ascii")

class trace_parse(saxutils.XMLGenerator):
	lastContent = None
	def startDocument(self):
		if 0: # Doesn't smooth things out.
			gc.collect() 
		global start ; start = time.clock()
		if verbose:
			print ; print ; print '*' * 30 + " dump " + '*' * 30 ; print
			trace()
	def endDocument(self):
		global start ; print "total time" + "%6.3f" % (time.clock()-start)
		if verbose: trace()
	def startElement(self,name,attrs):
		global vnodes,tnodes
		self.lastContent = None
		if verbose:
			name = clean(name).strip()
			self.lastName = name
			a = []
			keys = attrs.keys()
			keys.sort()
			for key in keys:
				a.append("%s=%s" % (key,attrs.getValue(key)))
			if name not in (("vh"),):
				print
			if a:
				print '&lt;%s %s&gt;' % (name, string.join(a,' ')),
			else:
				print '&lt;%s&gt;' % name,
			# if name in (("t"),): print
		if name == "v":
			vnodes += 1 ; v = leoNodes.vnode(top(),leoNodes.tnode())
		elif name == "t":
			tnodes += 1 ; t = leoNodes.tnode()
	def endElement(self,name):
		name = clean(name).strip()
		if verbose:
			if self.lastContent and name not in (("vh"),):
				print
			print '&lt;/%s&gt;' % name,
		self.lastName = name
	def characters(self,content):
		self.lastContent = content = content.replace('\r','')
		if verbose and content.strip():
			if self.lastName != "vh": print
			print clean(content),
	def ignorableWhitespace(self):                trace()
	def processingInstruction (self,target,data): trace()
	def skippedEntity(self,name):                 trace(name)
	def startElementNS(self,name,qname,attrs):    trace(name)
	def endElementNS(self,name,qname):            trace(name)
	
try:
	f = None
	try:
		print path
		if 1: # not needed, and it works.
			source = InputSource(path)
			# source.setEncoding(app().tkEncoding)
		else:
			source = f = open(path)
		parser = make_parser()
		parser.setContentHandler(trace_parse())
		parser.parse(source)
		print "vnodes,tnodes:",`vnodes`,`tnodes`
	except: es_exception()
finally:
	if f: f.close()</t>
<t tx="T89">@language rebol

; a comment
about abs absolute add alert alias all alter and and~ any append arccosine arcsine arctangent array ask at  
back bind boot-prefs break browse build-port build-tag  
call caret-to-offset catch center-face change change-dir charset checksum choose clean-path clear clear-fields close comment complement compose compress confirm continue-post context copy cosine create-request crypt cvs-date cvs-version  
debase decode-cgi decode-url decompress deflag-face dehex delete demo desktop detab dh-compute-key dh-generate-key dh-make-key difference dirize disarm dispatch divide do do-boot do-events do-face do-face-alt does dsa-generate-key dsa-make-key dsa-make-signature dsa-verify-signature  
echo editor either else emailer enbase entab exclude exit exp extract 
fifth find find-key-face find-window flag-face first flash focus for forall foreach forever form forskip fourth free func function  
get get-modes get-net-info get-style  
halt has head help hide hide-popup  
if import-email in inform input insert insert-event-func intersect 
join 
last launch launch-thru layout license list-dir load load-image load-prefs load-thru log-10 log-2 log-e loop lowercase  
make make-dir make-face max maximum maximum-of min minimum minimum-of mold multiply  
negate net-error next not now  
offset-to-caret open open-events or or~ 
parse parse-email-addrs parse-header parse-header-date parse-xml path-thru pick poke power prin print probe protect protect-system  
q query quit  
random read read-io read-net read-thru reboot recycle reduce reform rejoin remainder remold remove remove-event-func rename repeat repend replace request request-color request-date request-download request-file request-list request-pass request-text resend return reverse rsa-encrypt rsa-generate-key rsa-make-key 
save save-prefs save-user scroll-para second secure select send send-and-check set set-modes set-font set-net set-para set-style set-user set-user-name show show-popup sine size-text skip sort source split-path square-root stylize subtract switch  
tail tangent textinfo third throw throw-on-error to to-binary to-bitset to-block to-char to-date to-decimal to-email to-event to-file to-get-word to-hash to-hex to-idate to-image to-integer to-issue to-list to-lit-path to-lit-word to-local-file to-logic to-money to-none to-pair to-paren to-path to-rebol-file to-refinement to-set-path to-set-word to-string to-tag to-time to-tuple to-url to-word trace trim try  
unfocus union unique uninstall unprotect unset until unview update upgrade uppercase usage use  
vbug view view-install view-prefs  
wait what what-dir while write write-io  
xor xor~  
action! any-block! any-function! any-string! any-type! any-word!  
binary! bitset! block!  
char!  
datatype! date! decimal! 
email! error! event!  
file! function!  
get-word!  
hash!  
image! integer! issue!  
library! list! lit-path! lit-word! logic!  
money!  
native! none! number!  
object! op!  
pair! paren! path! port!  
refinement! routine!  
series! set-path! set-word! string! struct! symbol!  
tag! time! tuple!  
unset! url!  
word!  
any-block? any-function? any-string? any-type? any-word?  
binary? bitset? block?  
char? connected? crypt-strength? 
datatype? date? decimal? dir?  
email? empty? equal? error? even? event? exists? exists-key?
file? flag-face? found? function?  
get-word? greater-or-equal? greater?  
hash? head?  
image? in-window? index? info? input? inside? integer? issue?  
length? lesser-or-equal? lesser? library? link-app? link? list? lit-path? lit-word? logic?  
modified? money?  
native? negative? none? not-equal? number?  
object? odd? offset? op? outside?  
pair? paren? path? port? positive?  
refinement? routine?  
same? screen-offset? script? series? set-path? set-word? size? span? strict-equal? strict-not-equal? string? struct?  
tag? tail? time? tuple? type?  
unset? url?  
value? view? 
within? word?  
zero?</t>
<t tx="T90">@language actionscript

break
call, continue
delete, do
else
false, for, function
goto
if, in
new, null
return
true, typeof
undefined
var, void, while, with
#include
catch, constructor
prototype
this, try
_parent, _root, __proto__
// Jeeze hasn't anyone ever heard of namespaces??
ASnative, abs, acos, appendChild, asfunction, asin, atan, atan2, attachMovie, attachSound, attributes
BACKSPACE
CAPSLOCK, CONTROL, ceil, charAt, charCodeAt, childNodes, chr, cloneNode, close, concat, connect, cos, createElement, createTextNode
DELETEKEY, DOWN, docTypeDecl, duplicateMovieClip
END, ENTER, ESCAPE, enterFrame, entry, equal, eval, evaluate, exp
firstChild, floor, fromCharCode, fscommand, getAscii
getBeginIndex, getBounds, getBytesLoaded, getBytesTotal, getCaretIndex, getCode, getDate, getDay, getEndIndex, getFocus, getFullYear, getHours, getMilliseconds, getMinutes, getMonth, getPan, getProperty, getRGB, getSeconds, getTime, getTimer, getTimezoneOffset, getTransform, getURL, getUTCDate, getUTCDay, getUTCFullYear, getUTCHours, getUTCMilliseconds, getUTCMinutes, getUTCMonth, getUTCSeconds, getVersion, getVolume, getYear, globalToLocal, gotoAndPlay, gotoAndStop
HOME, haschildNodes, hide, hitTest
INSERT, Infinity, ifFrameLoaded, ignoreWhite, indexOf, insertBefore, int, isDown, isFinite, isNaN, isToggled
join
keycode, keyDown, keyUp
LEFT, LN10, LN2, LOG10E, LOG2E, lastChild, lastIndexOf, length, load, loaded, loadMovie, loadMovieNum, loadVariables, loadVariablesNum, localToGlobal, log
MAX_VALUE, MIN_VALUE, max, maxscroll, mbchr, mblength, mbord, mbsubstring, min, 
NEGATIVE_INFINITY, NaN, newline, nextFrame, nextScene, nextSibling, nodeName, nodeType, nodeValue
on, onClipEvent, onClose, onConnect, onData, onLoad, onXML, ord
PGDN, PGUP, PI, POSITIVE_INFINITY, parentNode, parseFloat, parseInt, parseXML, play, pop, pow, press, prevFrame, previousSibling, prevScene, print, printAsBitmap, printAsBitmapNum, printNum, push
RIGHT, random, release, removeMovieClip, removeNode, reverse, round
SPACE, SQRT1_2, SQRT2, scroll, send, sendAndLoad, set, setDate, setFocus, setFullYear, setHours, setMilliseconds, setMinutes, setMonth, setPan, setProperty, setRGB, setSeconds, setSelection, setTime, setTransform, setUTCDate, setUTCFullYear, setUTCHours, setUTCMilliseconds, setUTCMinutes, setUTCMonth, setUTCSeconds, setVolume, setYear, shift, show, sin, slice, sort, start, startDrag, status, stop, stopAllSounds, stopDrag, substr, substring, swapDepths, splice, split, sqrt
TAB, tan, targetPath, tellTarget, toggleHighQuality, toLowerCase, toString, toUpperCase, trace
UP, UTC, unescape, unloadMovie, unLoadMovieNum, unshift, updateAfterEvent
valueOf
xmlDecl, _alpha
_currentframe
_droptarget
_focusrect, _framesloaded
_height, _highquality
_name
_quality
_rotation
_soundbuftime
_target, _totalframes
_url
_visible
_width
_x, _xmouse, _xscale
_y, _ymouse, _yscale
and, add, eq, ge, gt, le, lt, ne, not, or, Array, Boolean, Color, Date, Key, Math, MovieClip, Mouse, Number, Object, Selection, Sound, String, XML, XMLSocket</t>
<t tx="T91"># The following corrupts the outline: extract section (in B), undo.
</t>
<t tx="T92"></t>
<t tx="T93"># The following corrupts the outline: extract section, undo.

&lt;&lt; test &gt;&gt;
line 1
line 2

after</t>
<t tx="T94"></t>
<t tx="T95"></t>
<t tx="T96"></t>
<t tx="T97"></t>
<t tx="T98"></t>
<t tx="T99"># The following corrupts the outline: extract section, undo.

&lt;&lt; test &gt;&gt;
line 1
	line 2

	after</t>
<t tx="T100"></t>
<t tx="T101"></t>
</tnodes>
</leo_file>
