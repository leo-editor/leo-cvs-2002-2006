<?xml version="1.0" encoding="UTF-8"?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="2674" clone_windows="0"/>
<globals body_outline_ratio="0.38383838383838381">
	<global_window_position top="66" left="253" height="755" width="860"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences>
</preferences>
<find_panel_settings>
	<find_string></find_string>
	<change_string></change_string>
</find_panel_settings>
<vnodes>
<v t="ekr.20040303080938"><vh>Diary</vh>
<v t="ekr.20040303080938.1"><vh>3/3/04: created position tests</vh></v>
</v>
<v t="ekr.20040303062846"><vh>Unit Testing</vh>
<v t="ekr.20040303062846.1"><vh>To do</vh></v>
<v t="ekr.20040303062846.2" tnodeList="ekr.20040303062846.2,ekr.20040303062846.3,ekr.20040303062846.4,ekr.20040303062846.5,ekr.20040303062846.6,ekr.20040303062846.7,ekr.20040303062846.8,ekr.20040303062846.9,ekr.20040303062846.10,ekr.20040303062846.12,ekr.20040303062846.13,ekr.20040303062846.14,ekr.20040303062846.15,ekr.20040303062846.16,ekr.20040303062846.17,ekr.20040303062846.18,ekr.20040303062846.20,ekr.20040303062846.21,ekr.20040303062846.22,ekr.20040303062846.23,ekr.20040303062846.24,ekr.20040303062846.25,ekr.20040303062846.26,ekr.20040303062846.28,ekr.20040303062846.29,ekr.20040303062846.30,ekr.20040303062846.31,ekr.20040303062846.32,ekr.20040303062846.33,ekr.20040303062846.34,ekr.20040303062846.35,ekr.20040303062846.37,ekr.20040303062846.38,ekr.20040303062846.39,ekr.20040303062846.40,ekr.20040303062846.41,ekr.20040303062846.42,ekr.20040303062846.64,ekr.20040303062846.65,ekr.20040303062846.66,ekr.20040303062846.67,ekr.20040303062846.68,ekr.20040303062846.69,ekr.20040303062846.70,ekr.20040303062846.71,ekr.20040303062846.73,ekr.20040303062846.74,ekr.20040303062846.75,ekr.20040303062846.76,ekr.20040303062846.77,ekr.20040303062846.78,ekr.20040303062846.79,ekr.20040303064013,ekr.20040303063118,ekr.20040303063118.4,ekr.20040303064020.1,ekr.20040303064020.2,ekr.20040303064020.3,ekr.20040303064020.4,ekr.20040303064020.5,ekr.20040303064020.6,ekr.20040303064020.7,ekr.20040303064020.8,ekr.20040303091606,ekr.20040303092153,ekr.20040303092153.1,ekr.20040303062846.80,ekr.20040303062846.81,ekr.20040303062846.82,ekr.20040303062846.83,ekr.20040303062846.84,ekr.20040303062846.85,ekr.20040303062846.86,ekr.20040303062846.87,ekr.20040303062846.88,ekr.20040303062846.89,ekr.20040303062846.90,ekr.20040303062846.91,ekr.20040303062846.92,ekr.20040303062846.93,ekr.20040303062846.94,ekr.20040303062846.95,ekr.20040303062846.96,ekr.20040303062846.97,ekr.20040303062846.98,ekr.20040303062846.99,ekr.20040303062846.100,ekr.20040303062846.101,ekr.20040303062846.102,ekr.20040303062846.103,ekr.20040303062846.104"><vh>@file ..\src\leoTest.py</vh>
<v t="ekr.20040303062846.3"><vh> class testUtils</vh>
<v t="ekr.20040303062846.4"><vh>compareOutlines</vh></v>
<v t="ekr.20040303062846.5"><vh>findChildrenOf &amp; findSubnodesOf</vh></v>
<v t="ekr.20040303062846.6"><vh>findNodeInRootTree, findNodeInTree, findNodeAnywhere</vh></v>
<v t="ekr.20040303062846.7"><vh>numberOfNodesInOutline, numberOfClonesInOutline</vh></v>
<v t="ekr.20040303062846.8"><vh>replaceOutline</vh></v>
<v t="ekr.20040303062846.9"><vh>validateOutline TODO</vh></v>
</v>
<v t="ekr.20040303062846.10"><vh> fail</vh></v>
<v t="ekr.20040303062846.11"><vh>Colorizer tests</vh>
<v t="ekr.20040303062846.12"><vh> makeColorSuite</vh></v>
<v t="ekr.20040303062846.13"><vh>class colorTestCase</vh>
<v t="ekr.20040303062846.14"><vh>__init__</vh></v>
<v t="ekr.20040303062846.15"><vh>color</vh></v>
<v t="ekr.20040303062846.16"><vh>setUp</vh></v>
<v t="ekr.20040303062846.17"><vh>tearDown</vh></v>
<v t="ekr.20040303062846.18"><vh>runTest</vh></v>
</v>
</v>
<v t="ekr.20040303062846.19"><vh>Edit body tests</vh>
<v t="ekr.20040303062846.20"><vh> makeEditBodySuite</vh></v>
<v t="ekr.20040303062846.21"><vh>class editBodyTestCase</vh>
<v t="ekr.20040303062846.22"><vh>__init__</vh></v>
<v t="ekr.20040303062846.23"><vh>editBody</vh></v>
<v t="ekr.20040303062846.24"><vh>tearDown</vh></v>
<v t="ekr.20040303062846.25"><vh>setUp</vh></v>
<v t="ekr.20040303062846.26"><vh>runTest</vh></v>
</v>
</v>
<v t="ekr.20040303062846.27"><vh>Import/Export tests</vh>
<v t="ekr.20040303062846.28"><vh>makeImportExportSuite</vh></v>
<v t="ekr.20040303062846.29"><vh>class importExportTestCase</vh>
<v t="ekr.20040303062846.30"><vh>__init__</vh></v>
<v t="ekr.20040303062846.31"><vh>importExport</vh></v>
<v t="ekr.20040303062846.32"><vh>runTest</vh></v>
<v t="ekr.20040303062846.33"><vh>setUp</vh></v>
<v t="ekr.20040303062846.34"><vh>shortDescription</vh></v>
<v t="ekr.20040303062846.35"><vh>tearDown</vh></v>
</v>
</v>
<v t="ekr.20040303062846.36"><vh>LeoFiles tests</vh>
<v t="ekr.20040303062846.37"><vh>makeTestLeoFilesSuite</vh></v>
<v t="ekr.20040303062846.38"><vh>class leoFileTestCase</vh>
<v t="ekr.20040303062846.39"><vh>__init__</vh></v>
<v t="ekr.20040303062846.40"><vh>runTest</vh></v>
<v t="ekr.20040303062846.41"><vh>setUp</vh></v>
<v t="ekr.20040303062846.42"><vh>tearDown</vh></v>
</v>
</v>
<v t="ekr.20040303062846.63"><vh>Outline tests</vh>
<v t="ekr.20040303062846.64"><vh> makeOutlineSuite</vh></v>
<v t="ekr.20040303062846.65"><vh>class outlineTestCase</vh>
<v t="ekr.20040303062846.66"><vh>__init__</vh></v>
<v t="ekr.20040303062846.67"><vh>outlineCommand</vh></v>
<v t="ekr.20040303062846.68"><vh>runTest</vh></v>
<v t="ekr.20040303062846.69"><vh>setUp</vh></v>
<v t="ekr.20040303062846.70"><vh>tearDown</vh></v>
<v t="ekr.20040303062846.71"><vh> makePluginsSuite</vh></v>
</v>
</v>
<v t="ekr.20040303062846.72"><vh>Plugin tests</vh>
<v t="ekr.20040303062846.73"><vh>class pluginTestCase</vh>
<v t="ekr.20040303062846.74"><vh>__init__</vh></v>
<v t="ekr.20040303062846.75"><vh>pluginTest</vh></v>
<v t="ekr.20040303062846.76"><vh>runTest</vh></v>
<v t="ekr.20040303062846.77"><vh>setUp</vh></v>
<v t="ekr.20040303062846.78"><vh>shortDescription</vh></v>
<v t="ekr.20040303062846.79"><vh>tearDown</vh></v>
</v>
</v>
<v t="ekr.20040303063644"><vh>Position tests</vh>
<v t="ekr.20040303064013"><vh> makePositionSuite</vh></v>
<v t="ekr.20040303063118"><vh>class positionTestCase</vh>
<v t="ekr.20040303063118.4"><vh>setUp</vh></v>
<v t="ekr.20040303064020.1"><vh>testFullTraverse</vh></v>
<v t="ekr.20040303064020.2"><vh>testParentChildLinks</vh>
<v t="ekr.20040303064020.3"><vh>&lt;&lt; check that the parent of p's first child is p &gt;&gt;</vh></v>
<v t="ekr.20040303064020.4"><vh>&lt;&lt; check that the parent of all parent's children is parent &gt;&gt;</vh></v>
</v>
<v t="ekr.20040303064020.5"><vh>testNextBack</vh></v>
<v t="ekr.20040303064020.6"><vh>testVnodeList</vh></v>
<v t="ekr.20040303064020.7"><vh>test threadNextBack</vh></v>
<v t="ekr.20040303064020.8"><vh>testParentChildLevel</vh></v>
<v t="ekr.20040303091606"><vh>testHasNextBack</vh></v>
<v t="ekr.20040303092153"><vh>testHasParentChild</vh></v>
<v t="ekr.20040303092153.1"><vh>testHasThreadNextBack</vh></v>
</v>
</v>
<v t="ekr.20040303062846.80"><vh>Reformat Paragraph tests</vh>
<v t="ekr.20040303062846.81"><vh>makeReformatParagraphSuite</vh></v>
<v t="ekr.20040303062846.82"><vh>class reformatParagraphTestCase</vh>
<v t="ekr.20040303062846.83"><vh>setUp</vh></v>
<v t="ekr.20040303062846.84"><vh>tearDown</vh></v>
<v t="ekr.20040303062846.85"><vh>testNoTrailingNewline</vh></v>
<v t="ekr.20040303062846.86"><vh>testTrailingNewline</vh></v>
<v t="ekr.20040303062846.87"><vh>testMixedLineLengths</vh></v>
<v t="ekr.20040303062846.88"><vh>testMixedLinesWithLeadingWS</vh></v>
<v t="ekr.20040303062846.89"><vh>testNoChangeRequired</vh></v>
<v t="ekr.20040303062846.90"><vh>testHonorLeadingWS</vh></v>
<v t="ekr.20040303062846.91"><vh>testHonorLeadingWSVar1</vh></v>
<v t="ekr.20040303062846.92"><vh>testSimpleHangingIndent</vh></v>
<v t="ekr.20040303062846.93"><vh>testSimpleHangingIndentVar1</vh></v>
<v t="ekr.20040303062846.94"><vh>testSimpleHangingIndentVar2</vh></v>
<v t="ekr.20040303062846.95"><vh>testMultiParagraph</vh></v>
<v t="ekr.20040303062846.96"><vh>testMultiParagraphWithList</vh></v>
<v t="ekr.20040303062846.97"><vh>testDirectiveBreaksParagraph</vh></v>
<v t="ekr.20040303062846.98"><vh>testWithLeadingWSOnEmptyLines</vh></v>
<v t="ekr.20040303062846.99"><vh>singleParagraphTest</vh></v>
<v t="ekr.20040303062846.100"><vh>checkPosition</vh></v>
<v t="ekr.20040303062846.101"><vh>checkText</vh></v>
<v t="ekr.20040303062846.102"><vh>copyBeforeToTemp</vh></v>
<v t="ekr.20040303062846.103"><vh>getCaseDataNodes</vh></v>
<v t="ekr.20040303062846.104"><vh>getRowCol</vh></v>
</v>
</v>
</v>
<v t="ekr.20040303071432"><vh>Mini tests</vh>
<v t="ekr.20040302091705"><vh>Test of moving positions</vh></v>
<v t="ekr.20040301162657"><vh>Mini tests of position class</vh>
<v t="ekr.20040301203156"><vh>test p.level</vh></v>
<v t="ekr.20040302103704"><vh>test test parent/child links</vh>
<v t="ekr.20040302110220"><vh>&lt;&lt; check that the parent of p's first child is p &gt;&gt;</vh></v>
<v t="ekr.20040302110220.1"><vh>&lt;&lt; check that the parent of all parent's children is parent &gt;&gt;</vh></v>
</v>
<v t="ekr.20040302110925"><vh>test next/back links</vh></v>
<v t="ekr.20040302113435"><vh>test vnodeList</vh></v>
<v t="ekr.20040302114642"><vh>test threadNext/threadBack</vh></v>
<v t="ekr.20040302142502" a="M"><vh>test p.level/p.parent/p.child</vh></v>
</v>
</v>
<v t="ekr.20040126105605"><vh>Clone test data</vh>
<v t="ekr.20040302092753"><vh>aa</vh></v>
<v t="ekr.20040126105605.2"><vh>a</vh>
<v t="ekr.20040126105605.3"><vh>b</vh>
<v t="ekr.20040301191933"><vh>c</vh>
<v t="ekr.20040302092753.1"><vh>c2</vh>
<v t="ekr.20040302092753.2"><vh>c3</vh></v>
<v t="ekr.20040302092753.3"><vh>c4</vh></v>
</v>
</v>
</v>
<v t="ekr.20040126105605.3"><vh>b</vh>
<v t="ekr.20040301191933"><vh>c</vh>
<v t="ekr.20040302092753.1"><vh>c2</vh>
<v t="ekr.20040302092753.2"><vh>c3</vh></v>
<v t="ekr.20040302092753.3"><vh>c4</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20040301191933.1"><vh>d</vh>
<v t="ekr.20040126105605.2"><vh>a</vh>
<v t="ekr.20040126105605.3"><vh>b</vh>
<v t="ekr.20040301191933"><vh>c</vh>
<v t="ekr.20040302092753.1"><vh>c2</vh>
<v t="ekr.20040302092753.2"><vh>c3</vh></v>
<v t="ekr.20040302092753.3"><vh>c4</vh></v>
</v>
</v>
</v>
<v t="ekr.20040126105605.3"><vh>b</vh>
<v t="ekr.20040301191933"><vh>c</vh>
<v t="ekr.20040302092753.1"><vh>c2</vh>
<v t="ekr.20040302092753.2"><vh>c3</vh></v>
<v t="ekr.20040302092753.3"><vh>c4</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20040301191933.2"><vh>e</vh></v>
<v t="ekr.20040302092753.4"><vh>z</vh></v>
</v>
</v>
<v t="ekr.20040303063644"><vh>Position tests</vh>
<v t="ekr.20040303064013"><vh> makePositionSuite</vh></v>
<v t="ekr.20040303063118"><vh>class positionTestCase</vh>
<v t="ekr.20040303063118.4"><vh>setUp</vh></v>
<v t="ekr.20040303064020.1"><vh>testFullTraverse</vh></v>
<v t="ekr.20040303064020.2"><vh>testParentChildLinks</vh>
<v t="ekr.20040303064020.3"><vh>&lt;&lt; check that the parent of p's first child is p &gt;&gt;</vh></v>
<v t="ekr.20040303064020.4"><vh>&lt;&lt; check that the parent of all parent's children is parent &gt;&gt;</vh></v>
</v>
<v t="ekr.20040303064020.5"><vh>testNextBack</vh></v>
<v t="ekr.20040303064020.6"><vh>testVnodeList</vh></v>
<v t="ekr.20040303064020.7"><vh>test threadNextBack</vh></v>
<v t="ekr.20040303064020.8"><vh>testParentChildLevel</vh></v>
<v t="ekr.20040303091606"><vh>testHasNextBack</vh></v>
<v t="ekr.20040303092153"><vh>testHasParentChild</vh></v>
<v t="ekr.20040303092153.1"><vh>testHasThreadNextBack</vh></v>
</v>
</v>
<v t="ekr.20040303063549"><vh>Unit Tests</vh>
<v t="ekr.20040303063549.1"><vh>tempNode</vh></v>
<v t="ekr.20040303063549.45"><vh>colorizerTests</vh>
<v t="ekr.20040303063549.46"><vh>Actionscript</vh></v>
<v t="ekr.20040303063549.47"><vh>C</vh></v>
<v t="ekr.20040303063549.48"><vh>C#</vh></v>
<v t="ekr.20040303063549.49"><vh>CWEB</vh>
<v t="ekr.20040303063549.50"><vh>&lt;&lt; section ref &gt;&gt;</vh></v>
</v>
<v t="ekr.20040303063549.51"><vh>elisp</vh></v>
<v t="ekr.20040303063549.52"><vh>HTML1</vh></v>
<v t="ekr.20040303063549.53"><vh>HTML2</vh></v>
<v t="ekr.20040303063549.54"><vh>LaTex</vh></v>
<v t="ekr.20040303063549.55"><vh>Mixed</vh></v>
<v t="ekr.20040303063549.56"><vh>PHP</vh></v>
<v t="ekr.20040303063549.57"><vh>Python1</vh></v>
<v t="ekr.20040303063549.58"><vh>Python2</vh></v>
<v t="ekr.20040303063549.59"><vh>Rebol</vh></v>
<v t="ekr.20040303063549.60"><vh>wikiTest1</vh></v>
<v t="ekr.20040303063549.61"><vh>wikiTest2</vh></v>
<v t="ekr.20040303063549.62"><vh>wikiTest3</vh></v>
</v>
<v t="ekr.20040303063549.63"><vh>editBodyTests</vh>
<v t="ekr.20040303063549.64"><vh>dedentBody</vh>
<v t="ekr.20040303063549.65"><vh>before</vh></v>
<v t="ekr.20040303063549.66"><vh>after</vh></v>
<v t="ekr.20040303063549.67"><vh>selection</vh></v>
</v>
<v t="ekr.20040303063549.68"><vh>indentBody</vh>
<v t="ekr.20040303063549.69"><vh>before</vh></v>
<v t="ekr.20040303063549.70"><vh>after</vh></v>
<v t="ekr.20040303063549.71"><vh>selection</vh></v>
</v>
<v t="ekr.20040303063549.72"><vh>extractSection</vh>
<v t="ekr.20040303063549.73"><vh>before</vh></v>
<v t="ekr.20040303063549.74"><vh>after</vh>
<v t="ekr.20040303063549.75"><vh>&lt;&lt; section &gt;&gt;</vh></v>
</v>
<v t="ekr.20040303063549.76"><vh>selection</vh></v>
</v>
</v>
<v t="ekr.20040303063549.77"><vh>exportTests</vh>
<v t="ekr.20040303063549.78"><vh>exportHeadlines</vh>
<v t="ekr.20040303063549.79"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.80"><vh>flattenOutline</vh>
<v t="ekr.20040303063549.81"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.82"><vh>weave</vh>
<v t="ekr.20040303063549.83"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.84"><vh>outlineToNoweb</vh>
<v t="ekr.20040303063549.85"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.86"><vh>outlineToCWEB</vh>
<v t="ekr.20040303063549.87"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.88"><vh>removeSentinels</vh>
<v t="ekr.20040303063549.89"><vh>dialog</vh></v>
</v>
</v>
<v t="ekr.20040303063549.90"><vh>importTests</vh>
<v t="ekr.20040303063549.91"><vh>importAtRoot</vh>
<v t="ekr.20040303063549.92"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.93"><vh>importAtFile</vh>
<v t="ekr.20040303063549.94"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.95"><vh>importNowebFiles</vh>
<v t="ekr.20040303063549.96"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.97"><vh>importFlattenedOutline</vh>
<v t="ekr.20040303063549.98"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.99"><vh>importCWEBFiles</vh>
<v t="ekr.20040303063549.100"><vh>dialog</vh></v>
</v>
</v>
<v t="ekr.20040303063549.101"><vh>outlineTests</vh>
<v t="ekr.20040303063549.102"><vh>moveOutlineDown</vh>
<v t="ekr.20040303063549.103"><vh>before</vh>
<v t="ekr.20040303063549.104"><vh>a</vh></v>
<v t="ekr.20040303063549.105"><vh>move</vh></v>
<v t="ekr.20040303063549.106"><vh>b</vh></v>
</v>
<v t="ekr.20040303063549.107"><vh>after</vh>
<v t="ekr.20040303063549.108"><vh>a</vh></v>
<v t="ekr.20040303063549.109"><vh>b</vh></v>
<v t="ekr.20040303063549.110"><vh>move</vh></v>
</v>
<v t="ekr.20040303063549.111"><vh>ref</vh>
<v t="ekr.20040303063549.112"><vh>a</vh></v>
<v t="ekr.20040303063549.113"><vh>move</vh></v>
<v t="ekr.20040303063549.114"><vh>b</vh></v>
</v>
</v>
<v t="ekr.20040303063549.115"><vh>moveOutlineLeft</vh></v>
<v t="ekr.20040303063549.116"><vh>moveOutlineRight</vh></v>
<v t="ekr.20040303063549.117"><vh>moveOutlineUp</vh></v>
</v>
<v t="ekr.20040303063549.118"><vh>pluginsTests</vh></v>
<v t="ekr.20040303063549.119" a="M"><vh>positionTests</vh></v>
<v t="ekr.20040303063549.2"><vh>reformatParagraphsTests</vh>
<v t="ekr.20040303063549.3"><vh>testNoTrailingNewline</vh>
<v t="ekr.20040303063549.4"><vh>before</vh></v>
<v t="ekr.20040303063549.5"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.6"><vh>testTrailingNewline</vh>
<v t="ekr.20040303063549.7"><vh>before</vh></v>
<v t="ekr.20040303063549.8"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.9"><vh>testMixedLineLengths</vh>
<v t="ekr.20040303063549.10"><vh>before</vh></v>
<v t="ekr.20040303063549.11"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.12"><vh>testMixedLinesWithLeadingWS</vh>
<v t="ekr.20040303063549.13"><vh>before</vh></v>
<v t="ekr.20040303063549.14"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.15"><vh>testNoChangeRequired</vh>
<v t="ekr.20040303063549.16"><vh>before</vh></v>
<v t="ekr.20040303063549.17"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.18"><vh>testHonorLeadingWS</vh>
<v t="ekr.20040303063549.19"><vh>before</vh></v>
<v t="ekr.20040303063549.20"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.21"><vh>testHonorLeadingWSVar1</vh>
<v t="ekr.20040303063549.22"><vh>before</vh></v>
<v t="ekr.20040303063549.23"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.24"><vh>testSimpleHangingIndent</vh>
<v t="ekr.20040303063549.25"><vh>before</vh></v>
<v t="ekr.20040303063549.26"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.27"><vh>testSimpleHangingIndentVar1</vh>
<v t="ekr.20040303063549.28"><vh>before</vh></v>
<v t="ekr.20040303063549.29"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.30"><vh>testSimpleHangingIndentVar2</vh>
<v t="ekr.20040303063549.31"><vh>before</vh></v>
<v t="ekr.20040303063549.32"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.33"><vh>testMultiParagraph</vh>
<v t="ekr.20040303063549.34"><vh>before</vh></v>
<v t="ekr.20040303063549.35"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.36"><vh>testMultiParagraphWithList</vh>
<v t="ekr.20040303063549.37"><vh>before</vh></v>
<v t="ekr.20040303063549.38"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.39"><vh>testDirectiveBreaksParagraph</vh>
<v t="ekr.20040303063549.40"><vh>before</vh></v>
<v t="ekr.20040303063549.41"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.42"><vh>testWithLeadingWSOnEmptyLines</vh>
<v t="ekr.20040303063549.43"><vh>before</vh></v>
<v t="ekr.20040303063549.44"><vh>after</vh></v>
</v>
</v>
<v t="ekr.20040303063549.120"><vh>testLeoFiles</vh>
<v t="ekr.20040303063549.121"><vh>c:\prog\leoCvs\leo\test\test.leo</vh></v>
<v t="ekr.20040303063549.122"><vh>c:\prog\leoCvs\leo\src\LeoPy.leo</vh></v>
<v t="ekr.20040303063549.123"><vh>c:\prog\leoCvs\leo\plugins\leoPlugins.leo</vh></v>
<v t="ekr.20040303063549.124"><vh>c:\prog\leoCvs\leo\doc\LeoDocs.leo</vh></v>
</v>
<v t="ekr.20040303063549.125"><vh>Run all tests</vh></v>
<v t="ekr.20040303080010"><vh>Run all tests except files tests</vh></v>
</v>
<v t="ekr.20040303215834"><vh>Test of position  comparisons</vh></v>
<v t="ekr.20040305165016" a="ETV"><vh>new iter tests</vh>
<v t="ekr.20040305165846"><vh>class position (for testing only)</vh>
<v t="ekr.20040305165846.1"><vh> ctor &amp; other special methods...</vh>
<v t="ekr.20040305165846.2"><vh>p.__init__</vh></v>
<v t="ekr.20040305165846.3"><vh>p.__cmp__</vh></v>
<v t="ekr.20040305165846.4"><vh>p.__getattr__ (not used)</vh></v>
<v t="ekr.20040305165846.5"><vh>p.__nonzero__</vh></v>
<v t="ekr.20040305165846.6"><vh>p.__str__ and p.__repr__</vh></v>
</v>
<v t="ekr.20040305165846.7"><vh>&lt;&lt; about the position class &gt;&gt;</vh></v>
<v t="ekr.20040305165846.8"><vh>Dirty bits</vh>
<v t="ekr.20040305165846.9"><vh>p.isDirty</vh></v>
<v t="ekr.20040305165846.10"><vh>p.setAllAncestorAtFileNodesDirty</vh></v>
<v t="ekr.20040305165846.11"><vh>p.setAncestorAtFileNodeDirty</vh></v>
<v t="ekr.20040305165846.12"><vh>p.setAncestorsOfClonedNodesInTreeDirty</vh></v>
<v t="ekr.20040305165846.13"><vh>p.setDirty</vh></v>
</v>
<v t="ekr.20040305174003"><vh>Iterators</vh>
<v t="ekr.20040305174003.1"><vh>allNodes_iter</vh>
<v t="ekr.20040305174003.2"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305174003.3"><vh>next</vh></v>
</v>
<v t="ekr.20040305174003.4"><vh>subtree_iter</vh>
<v t="ekr.20040305174003.5"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305174003.6"><vh>next</vh></v>
</v>
<v t="ekr.20040305174003.7"><vh>children_iter</vh>
<v t="ekr.20040305174003.8"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305174003.9"><vh>next</vh></v>
</v>
<v t="ekr.20040305174003.10"><vh>parents_iter</vh>
<v t="ekr.20040305174003.11"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305174003.12"><vh>next</vh></v>
</v>
<v t="ekr.20040305174003.13"><vh>siblings_iter</vh>
<v t="ekr.20040305174003.14"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305174003.15"><vh>next</vh></v>
</v>
</v>
<v t="ekr.20040305165846.19"><vh>Moving, Inserting, Deleting, Cloning, Sorting (position)  TEST</vh>
<v t="ekr.20040305165846.20"><vh>Entry Points (positon)</vh>
<v t="ekr.20040305165846.21"><vh>p.doDelete TEST</vh></v>
<v t="ekr.20040305165846.22"><vh>p.insertAfter TEST</vh></v>
<v t="ekr.20040305165846.23"><vh>p.insertAsLastChild</vh></v>
<v t="ekr.20040305165846.24"><vh>p.insertAsNthChild TEST</vh></v>
<v t="ekr.20040305165846.25"><vh>p.moveToRoot TEST</vh></v>
<v t="ekr.20040305165846.26"><vh>p.clone TEST</vh></v>
<v t="ekr.20040305165846.27"><vh>p.copyTreeWithNewTnodes: used by unit tests TO DO</vh></v>
<v t="ekr.20040305165846.28"><vh>p.moveAfter TEST</vh></v>
<v t="ekr.20040305165846.29"><vh>p.moveToNthChildOf TEST</vh></v>
<v t="ekr.20040305165846.30"><vh>p.sortChildren TEST</vh></v>
<v t="ekr.20040305165846.31"><vh>p.validateOutlineWithParent</vh>
<v t="ekr.20040305165846.32"><vh>&lt;&lt; validate parent ivar &gt;&gt;</vh></v>
<v t="ekr.20040305165846.33"><vh>&lt;&lt; validate childIndex ivar &gt;&gt;</vh></v>
<v t="ekr.20040305165846.34"><vh>&lt;&lt; validate x ivar &gt;&gt;</vh></v>
</v>
<v t="ekr.20040305165846.35"><vh>p.invalidOutline</vh></v>
</v>
<v t="ekr.20040305165846.36"><vh>position dummy methods: TO BE DELETED</vh></v>
</v>
<v t="ekr.20040305165846.37"><vh>p.childIndex</vh></v>
<v t="ekr.20040305165846.38"><vh>p.getX</vh></v>
<v t="ekr.20040305165846.39"><vh>p.hasX </vh>
<v t="ekr.20040305165846.40"><vh>hasThreadNext (the only complex hasX method)</vh></v>
</v>
<v t="ekr.20040305165846.41"><vh>p.moveToX</vh>
<v t="ekr.20040305165846.42"><vh>p.moveToBack</vh></v>
<v t="ekr.20040305165846.43"><vh>p.moveToFirstChild (pushes stack for cloned nodes)</vh></v>
<v t="ekr.20040305165846.44"><vh>p.moveToLastChild (pushes stack for cloned nodes)</vh></v>
<v t="ekr.20040305165846.45"><vh>p.moveToLastNode (new cheap code)</vh>
<v t="ekr.20040305165846.46"><vh>&lt;&lt; simulate repeated "lookahead" calls to p.moveToThreadNext() &gt;&gt;</vh></v>
</v>
<v t="ekr.20040305165846.47"><vh>p.moveToNext</vh></v>
<v t="ekr.20040305165846.48"><vh>p.moveToNodeAfterTree</vh></v>
<v t="ekr.20040305165846.49"><vh>p.moveToNthChild (pushes stack for cloned nodes)</vh></v>
<v t="ekr.20040305165846.50"><vh>p.moveToParent (pops stack when multiple parents)</vh></v>
<v t="ekr.20040305165846.51"><vh>p.moveToThreadBack (new cheap code)</vh>
<v t="ekr.20040305165846.52"><vh>p.checkNextThreadNextLevel</vh></v>
</v>
<v t="ekr.20040305165846.53"><vh>p.moveToThreadNext</vh></v>
<v t="ekr.20040305165846.54"><vh>p.moveToVisBack</vh></v>
<v t="ekr.20040305165846.55"><vh>p.moveToVisNext</vh></v>
</v>
<v t="ekr.20040305165846.56"><vh>p.utils...</vh>
<v t="ekr.20040305165846.57"><vh>p.copy</vh></v>
<v t="ekr.20040305165846.58"><vh>p.isVisible</vh></v>
<v t="ekr.20040305165846.59"><vh>p.level</vh></v>
<v t="ekr.20040305165846.60" a="E"><vh>p.vParentWithStack</vh>
<v t="ekr.20040305165846.61"><vh>&lt;&lt; about the vParentWithStack utility method &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20040305171318"><vh>last node</vh></v>
</vnodes>
<tnodes>
<t tx="ekr.20040126105605"></t>
<t tx="ekr.20040126105605.2"></t>
<t tx="ekr.20040126105605.3"></t>
<t tx="ekr.20040301162657"></t>
<t tx="ekr.20040301191933"></t>
<t tx="ekr.20040301191933.1"></t>
<t tx="ekr.20040301191933.2"></t>
<t tx="ekr.20040301203156">from leoGlobals import *

c = top()
c.convertTreeToSharedNodes()
c.disableSaveCommands()

print ; print "start"

p = c.rootPosition()
while p and p.v.headString().strip().lower() != "clone test":
	p.moveToThreadNext()
	
after = p.getNodeAfterTree()
while p and p != after:
	print p.level(), p.v.headString()
	p.moveToThreadNext()
		
print ; print "done"</t>
<t tx="ekr.20040302091705">from leoGlobals import *

class position:
	def __init__(self):
		self.v = "a"
	def move(self):
		self.v = "b"

p = position()
v = p.v
print "before", v, p.v, v is p.v
p.move()
print "after ", v, p.v, v is p.v</t>
<t tx="ekr.20040302092753"></t>
<t tx="ekr.20040302092753.1"></t>
<t tx="ekr.20040302092753.2"></t>
<t tx="ekr.20040302092753.3"></t>
<t tx="ekr.20040302092753.4"></t>
<t tx="ekr.20040302103704">from leoGlobals import *

c = top()
c.convertTreeToSharedNodes()
c.disableSaveCommands()

print ; print "checking parent/child relationships"

p = c.rootPosition() ; count = 0
while p:
	count += 1
	&lt;&lt; check that the parent of p's first child is p &gt;&gt;
	parent = p.getParent()
	if parent:
		&lt;&lt; check that the parent of all parent's children is parent &gt;&gt;
	p.moveToThreadNext()
		
print ; print "checked %d nodes" % count</t>
<t tx="ekr.20040302110220">firstChild = p.getFirstChild()
if firstChild:
	parent = firstChild.getParent()
	if p != parent:
		print "mismatch:p,parent,child",p,parent,firstChild</t>
<t tx="ekr.20040302110220.1">found = false
child = parent.getFirstChild()
if not child:
	print "parent has no children"
while child:
	if child == p: found
	childParent = child.getParent()
	if childParent != parent:
		print "mismatch:parent,childParent",parent,childParent
	child = child.moveToNext()</t>
<t tx="ekr.20040302110925">from leoGlobals import *

c = top()
c.convertTreeToSharedNodes()
c.disableSaveCommands()

print ; print "checking next/back links"

p = c.rootPosition() ; count = 0
while p:
	back = p.getBack()
	next = p.getNext()
	if back:
		count += 1
		assert(back.getNext() == p)
	if next:
		count += 1
		assert(next.getBack() == p)
	p.moveToThreadNext()
		
print ; print "checked %d nodes" % count</t>
<t tx="ekr.20040302113435">from leoGlobals import *

c = top()
c.convertTreeToSharedNodes()
c.disableSaveCommands()

print ; print "checking consistency of vnodeList"

p = c.rootPosition() ; count = 0
while p:
	vnodeList = p.v.t.vnodeList
	for v in vnodeList:
		count += 1
		assert(v.t == p.v.t)
		if p.v.isCloned():
			assert(v.isCloned())
			assert(len(vnodeList) &gt; 1)
		else:
			assert(not v.isCloned())
			assert(len(vnodeList) == 1)
	
	p.moveToThreadNext()
		
print ; print "checked %d cloned nodes" % count</t>
<t tx="ekr.20040302114642">from leoGlobals import *

c = top()
c.convertTreeToSharedNodes()
c.disableSaveCommands()

print ; print "checking threadBack/threadNext"

p = c.rootPosition() ; count = 0

while p:
	count += 1
	threadBack = p.getThreadBack()
	threadNext = p.getThreadNext()
	if threadBack:
		if threadBack.getThreadNext() != p:
			print "p.threadBack.threadNext != p"
			print "p,threadBack,threadBack.threadNext:"
			print p,threadBack,threadBack.getThreadNext()
		assert(threadBack.getThreadNext()==p)
	if threadNext:
		if threadNext.getThreadBack() != p:
			print "p.threadNext.threadBack != p"
			print "p,threadNext,threadNext.threadBack:"
			print p,threadNext,threadNext.getThreadBack()
		assert(threadNext.getThreadBack()==p)
	p.moveToThreadNext()

print ; print "checked %d nodes" % count</t>
<t tx="ekr.20040302142502"></t>
<t tx="ekr.20040303062846"># Run the unit tests in test.leo using the Execute Script command.</t>
<t tx="ekr.20040303062846.1">@nocolor

- Have log classes increment a count.
	Can be used to ensure that messages did or did not occcur.

- Have the nullGui create a nullUndoer by default
	But allow the possibility of leaving the full undoer in place.

- More checks in CheckOutline command.

- (done by hand) batch mode.
	Have script create a file, fail if the file does not exist.

- Unit tests for read/write commands.</t>
<t tx="ekr.20040303062846.2">"""

Unit tests for Leo.

Run the unit tests in test.leo using the Execute Script command.

"""

from leoGlobals import *

import leoColor,leoCommands,leoFrame,leoGui,leoNodes,leoTkinterGui

import glob,os,sys,unittest

@others</t>
<t tx="ekr.20040303062846.3">class testUtils:
	
	"""Common utility routines used by unit tests."""

	@others</t>
<t tx="ekr.20040303062846.4">def compareOutlines (self,root1,root2):
	
	"""Compares two outlines, making sure that their topologies,
	content and join lists are equivent"""
	
	v1,v2 = root1,root2
	after1 = v1.nodeAfterTree()
	after2 = v2.nodeAfterTree()
	v1 = v1.firstChild()
	v2 = v2.firstChild()
	ok = true
	while v2 and v1 != after1 and v2 != after2:
		ok = (
		v1.numberOfChildren() == v2.numberOfChildren() and
		v1.headString() == v2.headString() and
		v1.bodyString() == v2.bodyString() and
		v1.isCloned()   == v2.isCloned()   )
		if not ok: break
		v1 = v1.threadNext()
		v2 = v2.threadNext()

	ok = ok and v1 == after1 and v2 == after2
	if not ok:
		trace(v1,v2)
	return ok</t>
<t tx="ekr.20040303062846.5">def findChildrenOf (self,headline):
	
	u = self ; c = top() ; v = c.currentVnode()
	root = u.findRootNode(v)
	parent = u.findNodeInTree(root,headline)
	v = parent.firstChild()
	vList = []
	while v:
		vList.append(v)
		v = v.next()
	return vList

def findSubnodesOf (self,headline):
	
	u = self ; c = top() ; v = c.currentVnode()
	root = u.findRootNode(v)
	parent = u.findNodeInTree(root,headline)
	v = parent.firstChild()
	vList = []
	after = parent.nodeAfterTree()
	while v and v != after:
		vList.append(v)
		v = v.threadNext()
	return vList</t>
<t tx="ekr.20040303062846.6">def findRootNode (self,v):

	"""Return the root of v's tree."""
	while v and v.parent():
		v = v.parent()
	return v
	
def findNodeInTree(self,v,headline):

	"""Search for a node in v's tree matching the given headline."""
	if not headline: return None # This is valid.
	after = v.nodeAfterTree()
	while v and v != after:
		if v.headString().strip() == headline.strip():
			return v
		v = v.threadNext()
	return None

def findNodeAnywhere(self,c,headline):
	
	if not headline: return None # This is valid.
	v = c.rootVnode()
	while v:
		if v.headString().strip() == headline.strip():
			return v
		v = v.threadNext()
	return None</t>
<t tx="ekr.20040303062846.7">def numberOfNodesInOutline (self,root):
	
	"""Returns the total number of nodes in an outline"""
	
	n = 0 ; v = root
	while v:
		n +=1
		v = v.threadNext()
	return n
	
def numberOfClonesInOutline (self,root):
	
	"""Returns the number of cloned nodes in an outline"""

	n = 0 ; v = root
	while v:
		if v.isCloned():
			n += 1
		v = v.threadNext()</t>
<t tx="ekr.20040303062846.8">def replaceOutline (self,c,outline1,outline2):
	
	u = self
	
	"""Replace outline1 by a copy of outline 2 if not equal."""
	
	trace()
	
	copy = outline2.copyTreeWithNewTnodes()
	copy.linkAfter(outline1)
	outline1.doDelete(newVnode=copy)
</t>
<t tx="ekr.20040303062846.9">def validateOutline (self,root):
	
	"""Checks an outline for consistency"""
	pass</t>
<t tx="ekr.20040303062846.10">def fail ():
	
	"""Mark a unit test as having failed."""
	
	app.unitTestDict["fail"] = callerName(2)</t>
<t tx="ekr.20040303062846.11"></t>
<t tx="ekr.20040303062846.12">def makeColorSuite(testParentHeadline,tempHeadline):
	
	"""Create a colorizer test for every descendant of testParentHeadline.."""
	
	u = testUtils() ; c = top() ; v = c.currentVnode()
	root = u.findRootNode(v)
	temp_v = u.findNodeInTree(root,tempHeadline)
	vList = u.findSubnodesOf(testParentHeadline)
	
	# Create the suite and add all test cases.
	suite = unittest.makeSuite(unittest.TestCase)
	for v in vList:
		test = colorTestCase(c,v,temp_v)
		suite.addTest(test)

	return suite</t>
<t tx="ekr.20040303062846.13">class colorTestCase(unittest.TestCase):
	
	"""Data-driven unit tests for Leo's colorizer."""
	
	@others</t>
<t tx="ekr.20040303062846.14">def __init__ (self,c,v,temp_v):
	
	# Init the base class.
	unittest.TestCase.__init__(self)

	self.c = c
	self.v = v
	self.temp_v = temp_v
	
	self.old_v = c.currentVnode()</t>
<t tx="ekr.20040303062846.15">def color (self):
	
	c = self.c
	val = c.frame.body.colorizer.colorize(self.temp_v,incremental=false)
	assert(val=="ok")</t>
<t tx="ekr.20040303062846.16">def setUp(self,*args,**keys):

	# trace(args,keys)

	# Initialize the text in the temp node.
	text = self.v.bodyString()
	self.c.selectVnode(self.temp_v)
	self.temp_v.t.setTnodeText(text,app.tkEncoding)
	self.c.frame.body.setSelectionAreas(None,text,None)</t>
<t tx="ekr.20040303062846.17">def tearDown (self):
	
	self.temp_v.t.setTnodeText("",app.tkEncoding)
	self.c.selectVnode(self.old_v)</t>
<t tx="ekr.20040303062846.18">def runTest(self):

	self.color()</t>
<t tx="ekr.20040303062846.19"></t>
<t tx="ekr.20040303062846.20">def makeEditBodySuite(testParentHeadline,tempHeadline):
	
	"""Create an Edit Body test for every descendant of testParentHeadline.."""
	
	u = testUtils() ; c = top() ; v = c.currentVnode()
	root = u.findRootNode(v)
	temp_v = u.findNodeInTree(root,tempHeadline)
	vList = u.findChildrenOf(testParentHeadline)

	# Create the suite and add all test cases.
	suite = unittest.makeSuite(unittest.TestCase)
	for v in vList:
		before = u.findNodeInTree(v,"before")
		after  = u.findNodeInTree(v,"after")
		sel    = u.findNodeInTree(v,"selection")
		ins    = u.findNodeInTree(v,"insert")
		if before and after:
			test = editBodyTestCase(c,v,before,after,sel,ins,temp_v)
			suite.addTest(test)
		else:
			print 'missing "before" or "after" for', v.headString()

	return suite</t>
<t tx="ekr.20040303062846.21">class editBodyTestCase(unittest.TestCase):
	
	"""Data-driven unit tests for Leo's edit body commands."""
	
	@others</t>
<t tx="ekr.20040303062846.22">def __init__ (self,c,parent,before,after,sel,ins,temp_v):
	
	# Init the base class.
	unittest.TestCase.__init__(self)

	self.c = c
	self.parent = parent
	self.before = before
	self.after  = after
	self.sel    = sel # Two lines giving the selection range in tk coordinates.
	self.ins    = ins # One line giveing the insert point in tk coordinate.
	self.temp_v = temp_v
	
	self.old_v = c.currentVnode()
	
	self.wasChanged = c.changed</t>
<t tx="ekr.20040303062846.23">def editBody (self):
	
	c = self.c ; temp_v = self.temp_v ; after = self.after

	# Compute the result in temp_v.bodyString()
	commandName = self.parent.headString()
	command = getattr(c,commandName)
	command()
	
	# Compare the computed result to the reference result.
	new_text = temp_v.bodyString().rstrip()
	ref_text = after.bodyString().rstrip()

	if new_text != ref_text:
		print ; print "test failed", commandName
		trace("new",new_text)
		trace("ref",ref_text)
		
	assert(new_text == ref_text)
	
	# Compare subtrees.
	
	assert(temp_v.numberOfChildren() == after.numberOfChildren())
	
	ref_child = after.firstChild()
	new_child = temp_v.firstChild()
	
	while new_child:
		new_text = new_child.bodyString().rstrip()
		ref_text = ref_child.bodyString().rstrip()

		if new_text != ref_text:
			print ; print "test failed", commandName
			trace("new",new_text)
			trace("ref",ref_text)
		
		assert(new_text == ref_text)
		
		new_child = new_child.next()
		ref_child = ref_child.next()</t>
<t tx="ekr.20040303062846.24">def tearDown (self):
	
	c = self.c ; temp_v = self.temp_v
	
	temp_v.t.setTnodeText("",app.tkEncoding)
	temp_v.clearDirty()
	
	if not self.wasChanged:
		c.setChanged (false)
		
	# Delete all children of temp node.
	while temp_v.firstChild():
		temp_v.firstChild().doDelete(temp_v)

	c.selectVnode(self.old_v)</t>
<t tx="ekr.20040303062846.25"># Warning: this is Tk-specific code.

def setUp(self,*args,**keys):
	
	c = self.c ; temp_v = self.temp_v
	
	# Delete all children of temp node.
	while temp_v.firstChild():
		temp_v.firstChild().doDelete(temp_v)

	text = self.before.bodyString()
	
	temp_v.t.setTnodeText(text,app.tkEncoding)
	c.selectVnode(self.temp_v)
	
	t = c.frame.body.bodyCtrl
	if self.sel:
		s = self.sel.bodyString()
		lines = s.split('\n')
		app.gui.setTextSelection(t,lines[0],lines[1])

	if self.ins:
		s = self.ins.bodyString()
		lines = s.split('\n')
		app.gui.setInsertPoint(t,lines[0])
		
	if not self.sel and not self.ins:
		app.gui.setInsertPoint(t,"1.0")
		app.gui.setTextSelection(t,"1.0","1.0")
</t>
<t tx="ekr.20040303062846.26">def runTest(self):

	self.editBody()</t>
<t tx="ekr.20040303062846.27"></t>
<t tx="ekr.20040303062846.28">def makeImportExportSuite(testParentHeadline,tempHeadline):
	
	"""Create an Import/Export test for every descendant of testParentHeadline.."""
	
	u = testUtils() ; c = top() ; v = c.currentVnode()
	root = u.findRootNode(v)
	temp_v = u.findNodeInTree(root,tempHeadline)
	vList = u.findChildrenOf(testParentHeadline)

	# Create the suite and add all test cases.
	suite = unittest.makeSuite(unittest.TestCase)
	for v in vList:
		dialog = u.findNodeInTree(v,"dialog")
		test = importExportTestCase(c,v,dialog,temp_v)
		suite.addTest(test)

	return suite</t>
<t tx="ekr.20040303062846.29">class importExportTestCase(unittest.TestCase):
	
	"""Data-driven unit tests for Leo's edit body commands."""
	
	@others</t>
<t tx="ekr.20040303062846.30">def __init__ (self,c,v,dialog,temp_v):
	
	# Init the base class.
	unittest.TestCase.__init__(self)
	
	self.c = c
	self.dialog = dialog
	self.v = v
	self.temp_v = temp_v
	
	self.gui = None
	self.wasChanged = c.changed
	self.fileName = ""

	self.old_v = c.currentVnode()

</t>
<t tx="ekr.20040303062846.31">def importExport (self):
	
	c = self.c ; v = self.v
	
	app.unitTestDict = {}

	commandName = v.headString()
	command = getattr(c,commandName) # Will fail if command does not exist.
	command()

	failedMethod = app.unitTestDict.get("fail")
	self.failIf(failedMethod,failedMethod)</t>
<t tx="ekr.20040303062846.32">def runTest(self):
	
	# """Import Export Test Case"""

	self.importExport()</t>
<t tx="ekr.20040303062846.33">def setUp(self,*args,**keys):
	
	c = self.c ; temp_v = self.temp_v ; d = self.dialog
	
	temp_v.t.setTnodeText('',app.tkEncoding)

	# Create a node under temp_v.
	child = temp_v.insertAsLastChild()
	assert(child)
	child.setHeadString("import test: " + self.v.headString())
	c.selectVnode(child)

	assert(d)
	s = d.bodyString()
	lines = s.split('\n')
	name = lines[0]
	val = lines[1]
	self.fileName = val
	dict = {name: val}
	self.gui = leoGui.unitTestGui(dict,trace=false)
	
	</t>
<t tx="ekr.20040303062846.34">def shortDescription (self):
	
	try:
		return "ImportExportTestCase: %s %s" % (self.v.headString(),self.fileName)
	except:
		return "ImportExportTestCase"</t>
<t tx="ekr.20040303062846.35">def tearDown (self):
	
	c = self.c ; temp_v = self.temp_v
	
	if self.gui:
		self.gui.destroySelf()
		self.gui = None
	
	temp_v.t.setTnodeText("",app.tkEncoding)
	temp_v.clearDirty()
	
	if not self.wasChanged:
		c.setChanged (false)
		
	if 1: # Delete all children of temp node.
		while temp_v.firstChild():
			temp_v.firstChild().doDelete(temp_v)

	c.selectVnode(self.old_v)</t>
<t tx="ekr.20040303062846.36"></t>
<t tx="ekr.20040303062846.37">def makeTestLeoFilesSuite(testParentHeadline,unused=None):
	
	"""Create a .leo file test for every descendant of testParentHeadline.."""
	
	u = testUtils() ; c = top()
	
	vList = u.findChildrenOf(testParentHeadline)

	# Create the suite and add all test cases.
	suite = unittest.makeSuite(unittest.TestCase)
	for v in vList:
		test = leoFileTestCase(c,v.headString().strip())
		suite.addTest(test)

	return suite
</t>
<t tx="ekr.20040303062846.38">class leoFileTestCase(unittest.TestCase):
	
	"""Data-driven unit tests to test .leo files."""
	
	@others</t>
<t tx="ekr.20040303062846.39">def __init__ (self,c,fileName):
	
	# Init the base class.
	unittest.TestCase.__init__(self)

	self.old_c = c
	self.c = None # set by setUp.
	self.fileName = fileName
	self.gui = None # set by setUp
	self.openFrames = app.windowList[:]</t>
<t tx="ekr.20040303062846.40">def runTest(self):
	
	"""Run the Check Outline command."""

	errors = self.c.checkOutline()
	assert(errors == 0)</t>
<t tx="ekr.20040303062846.41">def setUp(self):

	"""Open the .leo file."""
	

	c = self.old_c ; fileName = self.fileName
	assert(os_path_exists(fileName))
	
	self.oldGui = app.gui
	# app.gui = leoGui.nullGui("nullGui")

	ok, frame = openWithFileName(fileName,c,enableLog=false)
	assert(ok)
	self.c = frame.c</t>
<t tx="ekr.20040303062846.42">def tearDown (self):

	"""Close the .leo file if it was not already open."""

	frame = self.c.frame
	if frame not in self.openFrames:
		app.closeLeoWindow(frame)

	app.gui = self.oldGui</t>
<t tx="ekr.20040303062846.63"></t>
<t tx="ekr.20040303062846.64">def makeOutlineSuite(testParentHeadline,unused=None):
	
	"""Create an outline test for every descendant of testParentHeadline.."""
	
	u = testUtils() ; c = top() ; v = c.currentVnode()
	
	vList = u.findChildrenOf(testParentHeadline)

	# Create the suite and add all test cases.
	suite = unittest.makeSuite(unittest.TestCase)
	for v in vList:
		before = u.findNodeInTree(v,"before")
		after  = u.findNodeInTree(v,"after")
		ref    = u.findNodeInTree(v,"ref")
		if before and after and ref:
			test = outlineTestCase(c,v,before,after,ref)
			suite.addTest(test)

	return suite
</t>
<t tx="ekr.20040303062846.65">class outlineTestCase(unittest.TestCase):
	
	"""Data-driven unit tests for Leo's outline commands."""
	
	@others</t>
<t tx="ekr.20040303062846.66">def __init__ (self,c,parent,before,after,ref):
	
	# Init the base class.
	unittest.TestCase.__init__(self)

	self.c = c
	self.parent = parent
	self.before = before
	self.after = after
	self.ref    = ref
	
	self.old_v = c.currentVnode()
	
	self.u = testUtils()</t>
<t tx="ekr.20040303062846.67">def outlineCommand (self):
	
	c = self.c ; u = self.u ; tree = c.frame.tree
	
	move = u.findNodeInTree(self.before,"move")
	assert(move)
	
	c.selectVnode(move)
	
	commandName = self.parent.headString()
	command = getattr(c,commandName)
	command()

	assert(u.compareOutlines(self.before,self.after))
	c.undoer.undo()
	assert(u.compareOutlines(self.before,self.ref))
	c.undoer.redo()
	assert(u.compareOutlines(self.before,self.after))
	c.undoer.undo()
	assert(u.compareOutlines(self.before,self.ref))</t>
<t tx="ekr.20040303062846.68">def runTest(self):

	self.outlineCommand()</t>
<t tx="ekr.20040303062846.69">def setUp(self,*args,**keys):

	assert(self.before)
	assert(self.after)
	assert(self.ref)
	assert(self.u.compareOutlines(self.before,self.ref))
	
	# Batch mode bugs: meaning of move may depend on visibility.
	self.parent.parent().expand()
	self.parent.expand()
	self.before.expand()
	self.after.expand()</t>
<t tx="ekr.20040303062846.70">def tearDown (self):

	c = self.c ; u = self.u

	if not u.compareOutlines(self.before,self.ref):
		u.replaceOutline(c,self.before,self.ref)

	self.before.contract()
	self.after.contract()
	self.parent.contract()
	self.parent.parent().contract()

	self.c.selectVnode(self.old_v)</t>
<t tx="ekr.20040303062846.71">def makePluginsSuite(verbose=false,*args,**keys):
	
	"""Create an plugins test for every .py file in the plugins directory."""
	
	plugins_path = os_path_join(app.loadDir,"..","plugins")
	
	files = glob.glob(os_path_join(plugins_path,"*.py"))
	files = [os_path_abspath(file) for file in files]
	files.sort()

	# Create the suite and add all test cases.
	suite = unittest.makeSuite(unittest.TestCase)
	
	for file in files:
		test = pluginTestCase(file,verbose)
		suite.addTest(test)

	return suite
</t>
<t tx="ekr.20040303062846.72"></t>
<t tx="ekr.20040303062846.73">class pluginTestCase(unittest.TestCase):
	
	"""Unit tests for one Leo plugin."""
	
	@others</t>
<t tx="ekr.20040303062846.74">def __init__ (self,fileName,verbose):
	
	# Init the base class.
	unittest.TestCase.__init__(self)

	self.fileName = fileName
	self.oldGui = None
	self.verbose = verbose</t>
<t tx="ekr.20040303062846.75">def pluginTest (self):
	
	# Duplicate the import logic in leoPlugins.py.
	
	fileName = toUnicode(self.fileName,app.tkEncoding)
	path = os_path_join(app.loadDir,"..","plugins")
	
	if self.verbose:
		trace(str(shortFileName(fileName)))

	module = importFromPath(fileName,path)
	assert(module)
	
	# Run any unit tests in the module itself.
	if hasattr(module,"unitTest"):
		
		if self.verbose:
			trace("Executing unitTest in %s..." % str(shortFileName(fileName)))

		module.unitTest()</t>
<t tx="ekr.20040303062846.76">def runTest(self):

	self.pluginTest()</t>
<t tx="ekr.20040303062846.77">def setUp(self,*args,**keys):

	self.oldGui = app.gui
	# app.gui = leoTkinterGui.tkinterGui()</t>
<t tx="ekr.20040303062846.78">def shortDescription (self):
	
	return "pluginTestCase: " + self.fileName</t>
<t tx="ekr.20040303062846.79">def tearDown (self):

	app.gui = self.oldGui</t>
<t tx="ekr.20040303062846.80"># DTHEIN 2004.01.11: Added unit tests for reformatParagraph</t>
<t tx="ekr.20040303062846.81"># DTHEIN 2004.01.11: Added method
def makeReformatParagraphSuite():
	
	"""makeReformatParagraphSuite() -&gt; suite
	
	Create a Reformat Paragraph test for each of the 
	unit tests in the reformatParagraphTestCase class."""
	
	suite = unittest.TestSuite()
	suite.addTest(reformatParagraphTestCase("testNoTrailingNewline"))
	suite.addTest(reformatParagraphTestCase("testTrailingNewline"))
	suite.addTest(reformatParagraphTestCase("testMixedLineLengths"))
	suite.addTest(reformatParagraphTestCase("testMixedLinesWithLeadingWS"))
	suite.addTest(reformatParagraphTestCase("testNoChangeRequired"))
	suite.addTest(reformatParagraphTestCase("testHonorLeadingWS"))
	suite.addTest(reformatParagraphTestCase("testHonorLeadingWSVar1"))
	suite.addTest(reformatParagraphTestCase("testSimpleHangingIndent"))
	suite.addTest(reformatParagraphTestCase("testSimpleHangingIndentVar1"))
	suite.addTest(reformatParagraphTestCase("testSimpleHangingIndentVar2"))
	suite.addTest(reformatParagraphTestCase("testMultiParagraph"))
	suite.addTest(reformatParagraphTestCase("testMultiParagraphWithList"))
	suite.addTest(reformatParagraphTestCase("testDirectiveBreaksParagraph"))
	suite.addTest(reformatParagraphTestCase("testWithLeadingWSOnEmptyLines"))
	return suite
	#	suite = reformatParagraphTestCase().suite();
	#return suite</t>
<t tx="ekr.20040303062846.82"># DTHEIN 2004.01.11: Added class
class reformatParagraphTestCase(unittest.TestCase):
	
	"""Unit tests for Leo's reformat paragraph command."""
	
	@others</t>
<t tx="ekr.20040303062846.83"># DTHEIN 2004.01.11: Added method
def setUp(self):

	self.u = testUtils()
	self.c = top()
	self.current_v = self.c.currentVnode()
	self.old_v = self.c.currentVnode()
	root = self.u.findRootNode(self.current_v)
	self.temp_v = self.u.findNodeInTree(root,"tempNode")
	self.tempChild_v = None
	self.dataParent_v = self.u.findNodeInTree(root,"reformatParagraphsTests")
	self.before_v = None
	self.after_v = None
	self.case_v = None
	self.wasChanged = self.c.changed
	

</t>
<t tx="ekr.20040303062846.84"># DTHEIN 2004.01.11: Added method
def tearDown(self):
	
	# local variables for class fields, for ease
	# of reading and ease of typeing.
	#	
	c = self.c ; temp_v = self.temp_v
	
	# clear the temp node and mark it unchanged
	#
	temp_v.t.setTnodeText("",app.tkEncoding)
	temp_v.clearDirty()
	
	if not self.wasChanged:
		c.setChanged (false)
		
	# Delete all children of temp node.
	#
	while temp_v.firstChild():
		temp_v.firstChild().doDelete(temp_v)

	# make the original node the current node
	#
	c.selectVnode(self.old_v)</t>
<t tx="ekr.20040303062846.85"># DTHEIN 2004.01.11: Added method
def testNoTrailingNewline(self):
	
	self.singleParagraphTest("testNoTrailingNewline",2,24)
</t>
<t tx="ekr.20040303062846.86"># DTHEIN 2004.01.11: Added method
def testTrailingNewline(self):
	
	self.singleParagraphTest("testTrailingNewline",3,0)
</t>
<t tx="ekr.20040303062846.87"># DTHEIN 2004.01.11: Added method
def testMixedLineLengths(self):
	
	self.singleParagraphTest("testMixedLineLengths",4,10)
</t>
<t tx="ekr.20040303062846.88"># DTHEIN 2004.01.11: Added method
def testMixedLinesWithLeadingWS(self):
	
	self.singleParagraphTest("testMixedLinesWithLeadingWS",4,12)
</t>
<t tx="ekr.20040303062846.89"># DTHEIN 2004.01.11: Added method
def testNoChangeRequired(self):
	
	self.singleParagraphTest("testNoChangeRequired",1,28)
</t>
<t tx="ekr.20040303062846.90"># DTHEIN 2004.01.11: Added method
def testHonorLeadingWS(self):
	
	self.singleParagraphTest("testHonorLeadingWS",5,16)
</t>
<t tx="ekr.20040303062846.91"># DTHEIN 2004.01.11: Added method
def testHonorLeadingWSVar1(self):
	
	self.singleParagraphTest("testHonorLeadingWSVar1",5,16)
</t>
<t tx="ekr.20040303062846.92"># DTHEIN 2004.01.11: Added method
def testSimpleHangingIndent(self):
	
	self.singleParagraphTest("testSimpleHangingIndent",5,8)
</t>
<t tx="ekr.20040303062846.93"># DTHEIN 2004.01.11: Added method
def testSimpleHangingIndentVar1(self):
	
	self.singleParagraphTest("testSimpleHangingIndentVar1",5,8)
</t>
<t tx="ekr.20040303062846.94"># DTHEIN 2004.01.11: Added method
def testSimpleHangingIndentVar2(self):
	
	self.singleParagraphTest("testSimpleHangingIndentVar2",5,8)
</t>
<t tx="ekr.20040303062846.95"># DTHEIN 2004.01.11: Added method
def testMultiParagraph(self):
	
	# Locate the test data
	#
	self.getCaseDataNodes("testMultiParagraph")
	
	# Setup the temp node
	#
	self.copyBeforeToTemp()
	
	# reformat the paragraph and check insertion cursor position
	#
	self.c.reformatParagraph()
	self.checkPosition(13,0)
	
	# Keep going, in the same manner
	#
	self.c.reformatParagraph()
	self.checkPosition(25,0)
	self.c.reformatParagraph()
	self.checkPosition(32,11)
	
	# Compare the computed result to the reference result.
	self.checkText()
</t>
<t tx="ekr.20040303062846.96"># DTHEIN 2004.01.11: Added method
def testMultiParagraphWithList(self):
	
	# Locate the test data
	#
	self.getCaseDataNodes("testMultiParagraphWithList")
	
	# Setup the temp node
	#
	self.copyBeforeToTemp()
	
	# reformat the paragraph and check insertion cursor position
	#
	self.c.reformatParagraph()
	self.checkPosition(4,0)
	
	# Keep going, in the same manner
	#
	self.c.reformatParagraph()
	self.checkPosition(7,0)
	self.c.reformatParagraph()
	self.checkPosition(10,0)
	self.c.reformatParagraph()
	self.checkPosition(13,0)
	self.c.reformatParagraph()
	self.checkPosition(14,18)
	
	# Compare the computed result to the reference result.
	self.checkText()
</t>
<t tx="ekr.20040303062846.97"># DTHEIN 2004.01.11: Added method
def testDirectiveBreaksParagraph(self):
	
	# Locate the test data
	#
	self.getCaseDataNodes("testDirectiveBreaksParagraph")
	
	# Setup the temp node
	#
	self.copyBeforeToTemp()
	
	# reformat the paragraph and check insertion cursor position
	#
	self.c.reformatParagraph()
	self.checkPosition(13,0) # at next paragraph
	
	# Keep going, in the same manner
	#
	self.c.reformatParagraph()
	self.checkPosition(25,0) # at next paragraph

	self.c.reformatParagraph()
	self.checkPosition(32,11)
	
	# Compare the computed result to the reference result.
	self.checkText()
</t>
<t tx="ekr.20040303062846.98"># DTHEIN 2004.01.11: Added method
def testWithLeadingWSOnEmptyLines(self):
	
	# Locate the test data
	#
	self.getCaseDataNodes("testWithLeadingWSOnEmptyLines")
	
	# Setup the temp node
	#
	self.copyBeforeToTemp()
	
	# reformat the paragraph and check insertion cursor position
	#
	self.c.reformatParagraph()
	self.checkPosition(4,0)
	
	# Keep going, in the same manner
	#
	self.c.reformatParagraph()
	self.checkPosition(7,0)
	self.c.reformatParagraph()
	self.checkPosition(10,0)
	self.c.reformatParagraph()
	self.checkPosition(13,0)
	self.c.reformatParagraph()
	self.checkPosition(14,18)
	
	# Compare the computed result to the reference result.
	self.checkText()
</t>
<t tx="ekr.20040303062846.99"># DTHEIN 2004.01.11: Added method
def singleParagraphTest(self,caseName,finalRow,finalCol):
	
	# Locate the test data
	#
	self.getCaseDataNodes(caseName)
	
	# Setup the temp node
	#
	self.copyBeforeToTemp()
	
	# reformat the paragraph
	#
	self.c.reformatParagraph()
	
	# Compare the computed result to the reference result.
	self.checkText()
	self.checkPosition(finalRow,finalCol)

</t>
<t tx="ekr.20040303062846.100"># DTHEIN 2004.01.11: Added method
def checkPosition(self,expRow,expCol):

	row,col = self.getRowCol()
	self.failUnlessEqual(expCol,col,
		"Current position is (" + str(row) + "," + str(col) 
		+ ");  expected cursor to be at column " + str(expCol) + ".")
	self.failUnlessEqual(expRow,row,
		"Current position is (" + str(row) + "," + str(col) 
		+ ");  expected cursor to be at line " + str(expRow) + ".")
</t>
<t tx="ekr.20040303062846.101"># DTHEIN 2004.01.11: Added method
def checkText(self):

	new_text = self.tempChild_v.bodyString()
	ref_text = self.after_v.bodyString()
	newLines = new_text.splitlines(1)
	refLines = ref_text.splitlines(1)
	newLinesCount = len(newLines)
	refLinesCount = len(refLines)
	for i in range(min(newLinesCount,refLinesCount)):
		self.failUnlessEqual(newLines[i],refLines[i],
			"Mismatch on line " + str(i) + "."
			+ "\nExpected text: " + `refLines[i]`
			+ "\n  Actual text: "	+ `newLines[i]`)
	self.failUnlessEqual(newLinesCount,refLinesCount,
		"Expected " + str(refLinesCount) + " lines, but "
		+ "received " + str(newLinesCount) + " lines.")</t>
<t tx="ekr.20040303062846.102"># DTHEIN 2004.01.11: Added method
# Warning: this is Tk-specific code.
#
def copyBeforeToTemp(self):

	# local variables for class fields, for ease
	# of reading and ease of typeing.
	#	
	c = self.c ; temp_v = self.temp_v

	# Delete all children of temp node.
	#
	while temp_v.firstChild():
		temp_v.firstChild().doDelete(temp_v)

	# Copy the test case node text to the temp node
	#
	text = self.case_v.bodyString()
	temp_v.t.setTnodeText(text,app.tkEncoding)
	
	# create the child node that holds the text
	#
	t = leoNodes.tnode(headString="tempChildNode")
	self.tempChild_v = self.temp_v.insertAsNthChild(0,t)

	# copy the before text to the temp text
	#
	text = self.before_v.bodyString()
	self.tempChild_v.t.setTnodeText(text,app.tkEncoding)
	
	# make the temp child node current, and put the
	# cursor at the beginning
	#
	c.selectVnode(self.tempChild_v)
	c.frame.body.setInsertPointToStartOfLine( 0 )
	c.frame.body.setTextSelection(None,None)
	#app.gui.setInsertPoint(t,"1.0")
	#app.gui.setTextSelection(t,"1.0","1.0")
</t>
<t tx="ekr.20040303062846.103"># DTHEIN 2004.01.11: Added method
def getCaseDataNodes(self,caseNodeName):

	self.case_v = self.u.findNodeInTree(self.dataParent_v,caseNodeName)
	self.before_v = self.u.findNodeInTree(self.case_v,"before")
	self.after_v  = self.u.findNodeInTree(self.case_v,"after")
</t>
<t tx="ekr.20040303062846.104"># DTHEIN 2004.01.11: Added method
def getRowCol(self):
	
	# local variables for class fields, for ease
	# of reading and ease of typeing.
	#	
	c = self.c ; body = c.frame.body.bodyCtrl ; gui = app.gui
	tab_width = c.frame.tab_width

	# Get the Tkinter row col position of the insert cursor
	#	
	index = body.index("insert")
	row,col = gui.getindex(body,index)
	
	# Adjust col position for tabs
	#
	if col &gt; 0:
		s = body.get("%d.0" % (row),index)
		s = toUnicode(s,app.tkEncoding)
		col = computeWidth(s,tab_width)

	return (row,col)
</t>
<t tx="ekr.20040303063118">class positionTestCase(unittest.TestCase):
	
	"""Unit tests for Leo's position class."""
	
	@others</t>
<t tx="ekr.20040303063118.4">def setUp(self,*args,**keys):
	
	self.c = c = top()
	self.verbose = true

	c.convertTreeToSharedNodes()
	c.disableSaveCommands()</t>
<t tx="ekr.20040303063549"></t>
<t tx="ekr.20040303063549.1"></t>
<t tx="ekr.20040303063549.2">@ 
# DTHEIN 2004.01.11: Added script

Each child node will in turn have two or more children:
	
- a "before" node
- an "after" node

The parent to before and after nodes will contain pagewidth
and language formatting directives
@c

import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

suite = leoTest.makeReformatParagraphSuite()
result = unittest.TestResult()
runner = unittest.TextTestRunner()
runner.run(suite)</t>
<t tx="ekr.20040303063549.3">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Wrap a long line, no trailing newline.
</t>
<t tx="ekr.20040303063549.4">This line is over forty characters long, at least it seems to be.</t>
<t tx="ekr.20040303063549.5">This line is over forty characters long,
at least it seems to be.</t>
<t tx="ekr.20040303063549.6">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Wrap a long line, with trailing newline.
</t>
<t tx="ekr.20040303063549.7">This line is over forty characters long, at least it seems to be.
</t>
<t tx="ekr.20040303063549.8">This line is over forty characters long,
at least it seems to be.
</t>
<t tx="ekr.20040303063549.9">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Wrap a long line and some short ones.</t>
<t tx="ekr.20040303063549.10">This line is over forty characters long, at least it seems to be.
This is shorter, 
but should be part of the same
paragraph.</t>
<t tx="ekr.20040303063549.11">This line is over forty characters long,
at least it seems to be. This is
shorter, but should be part of the same
paragraph.</t>
<t tx="ekr.20040303063549.12">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Wrap a paragraph with interior lines that have leading white space.</t>
<t tx="ekr.20040303063549.13">This line is over forty characters long, at least it seems to be.
  This indented line should be merged into the same
paragraph.</t>
<t tx="ekr.20040303063549.14">This line is over forty characters long,
  at least it seems to be. This indented
  line should be merged into the same
  paragraph.</t>
<t tx="ekr.20040303063549.15">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

No wrapping required, so don't change a thing.</t>
<t tx="ekr.20040303063549.16">This line is under 40 chars.</t>
<t tx="ekr.20040303063549.17">This line is under 40 chars.</t>
<t tx="ekr.20040303063549.18">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Honor the first line's leading whitespace.</t>
<t tx="ekr.20040303063549.19">   This line is over forty characters long, at least it seems to be.
   This is shorter, 
but should be part of the same
paragraph.  And this is indented 3 characters.</t>
<t tx="ekr.20040303063549.20">   This line is over forty characters
   long, at least it seems to be. This
   is shorter, but should be part of the
   same paragraph. And this is indented
   3 characters.</t>
<t tx="ekr.20040303063549.21">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Honor the first and second line's leading whitespace.</t>
<t tx="ekr.20040303063549.22">   This line is over forty characters long, at least it seems to be.
   This is shorter, 
     but should be part of the same
     paragraph.  And this is indented 3 characters.</t>
<t tx="ekr.20040303063549.23">   This line is over forty characters
   long, at least it seems to be. This
   is shorter, but should be part of the
   same paragraph. And this is indented
   3 characters.</t>
<t tx="ekr.20040303063549.24">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Single paragraph, hanging indentation.</t>
<t tx="ekr.20040303063549.25">Honor this line that has a hanging indentation, please.  Hanging
  indentation is valuable for lists of all kinds.  But it is tricky to get right.</t>
<t tx="ekr.20040303063549.26">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.</t>
<t tx="ekr.20040303063549.27">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Single paragraph, hanging indentation with other indentation beyond line 2.</t>
<t tx="ekr.20040303063549.28">Honor this line that has
  a hanging indentation, please.  Hanging
    indentation is valuable for lists of all kinds.  But it is tricky to get right.</t>
<t tx="ekr.20040303063549.29">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.</t>
<t tx="ekr.20040303063549.30">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Single paragraph, hanging indentation, short lines, extraneous indentation, and last line uses a tab for whitespace.</t>
<t tx="ekr.20040303063549.31">Honor this line that 
  has a hanging indentation, 
  please.  Hanging
   indentation is valuable
    for lists of all kinds.  But 
	it is tricky to get right.</t>
<t tx="ekr.20040303063549.32">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.</t>
<t tx="ekr.20040303063549.33">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Mutliple long lined paragraphs.  Cursor should move to next paragraph after formatting a paragraph.</t>
<t tx="ekr.20040303063549.34">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20040303063549.35">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?</t>
<t tx="ekr.20040303063549.36">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

A regular paragraph, plus a numbered list of several items, plus a final regular paragraph.  Cursor should move to next paragraph after formatting a paragraph.
</t>
<t tx="ekr.20040303063549.37">This paragraph leads of this test.  It is the "lead"
paragraph.

  1. This is item 
     number 1.  It is the first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.</t>
<t tx="ekr.20040303063549.38">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test. It is the
"final" paragraph.</t>
<t tx="ekr.20040303063549.39">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Test to make sure that reformatting treats directives as a new paragraph and doesn't wrap directive lines.
</t>
<t tx="ekr.20040303063549.40">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.
@unknownDirective
Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.
@unknownDirective
StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20040303063549.41">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.
@unknownDirective
Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.
@unknownDirective
StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?</t>
<t tx="ekr.20040303063549.42">@language plain
@pagewidth 40
@tabwidth 8

Ran into a problem with the wrapping
eating blank lines that delimit
paragraphs if those blank lines have any
leading whitespace. This test is to make
sure that still works.

If you "show invisibles" you'll see the
leading whitespace in the blank lines --
which is different from the
"testMultiParagraphWithList" test.</t>
<t tx="ekr.20040303063549.43">This paragraph leads of this test.  It is the "lead"
paragraph.
  
  1. This is item 
     number 1.  It is the first item in the list.
  
  2. This is item 
     number 2.  It is the second item in the list.
  
  3. This is item 
     number 3.  It is the third item in the list.
  
This paragraph ends the test.  It is the "final"
paragraph.</t>
<t tx="ekr.20040303063549.44">This paragraph leads of this test. It is
the "lead" paragraph.
  
  1. This is item number 1. It is the
     first item in the list.
  
  2. This is item number 2. It is the
     second item in the list.
  
  3. This is item number 3. It is the
     third item in the list.
  
This paragraph ends the test. It is the
"final" paragraph.</t>
<t tx="ekr.20040303063549.45">@color

import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

suite = leoTest.makeColorSuite("colorizerTests","tempNode")
runner = unittest.TextTestRunner()
runner.run(suite)</t>
<t tx="ekr.20040303063549.46">@language actionscript

break
call, continue
delete, do
else
false, for, function
goto
if, in
new, null
return
true, typeof
undefined
var, void, while, with
#include
catch, constructor
prototype
this, try
_parent, _root, __proto__
// Jeeze hasn't anyone ever heard of namespaces??
ASnative, abs, acos, appendChild, asfunction, asin, atan, atan2, attachMovie, attachSound, attributes
BACKSPACE
CAPSLOCK, CONTROL, ceil, charAt, charCodeAt, childNodes, chr, cloneNode, close, concat, connect, cos, createElement, createTextNode
DELETEKEY, DOWN, docTypeDecl, duplicateMovieClip
END, ENTER, ESCAPE, enterFrame, entry, equal, eval, evaluate, exp
firstChild, floor, fromCharCode, fscommand, getAscii
getBeginIndex, getBounds, getBytesLoaded, getBytesTotal, getCaretIndex, getCode, getDate, getDay, getEndIndex, getFocus, getFullYear, getHours, getMilliseconds, getMinutes, getMonth, getPan, getProperty, getRGB, getSeconds, getTime, getTimer, getTimezoneOffset, getTransform, getURL, getUTCDate, getUTCDay, getUTCFullYear, getUTCHours, getUTCMilliseconds, getUTCMinutes, getUTCMonth, getUTCSeconds, getVersion, getVolume, getYear, globalToLocal, gotoAndPlay, gotoAndStop
HOME, haschildNodes, hide, hitTest
INSERT, Infinity, ifFrameLoaded, ignoreWhite, indexOf, insertBefore, int, isDown, isFinite, isNaN, isToggled
join
keycode, keyDown, keyUp
LEFT, LN10, LN2, LOG10E, LOG2E, lastChild, lastIndexOf, length, load, loaded, loadMovie, loadMovieNum, loadVariables, loadVariablesNum, localToGlobal, log
MAX_VALUE, MIN_VALUE, max, maxscroll, mbchr, mblength, mbord, mbsubstring, min, 
NEGATIVE_INFINITY, NaN, newline, nextFrame, nextScene, nextSibling, nodeName, nodeType, nodeValue
on, onClipEvent, onClose, onConnect, onData, onLoad, onXML, ord
PGDN, PGUP, PI, POSITIVE_INFINITY, parentNode, parseFloat, parseInt, parseXML, play, pop, pow, press, prevFrame, previousSibling, prevScene, print, printAsBitmap, printAsBitmapNum, printNum, push
RIGHT, random, release, removeMovieClip, removeNode, reverse, round
SPACE, SQRT1_2, SQRT2, scroll, send, sendAndLoad, set, setDate, setFocus, setFullYear, setHours, setMilliseconds, setMinutes, setMonth, setPan, setProperty, setRGB, setSeconds, setSelection, setTime, setTransform, setUTCDate, setUTCFullYear, setUTCHours, setUTCMilliseconds, setUTCMinutes, setUTCMonth, setUTCSeconds, setVolume, setYear, shift, show, sin, slice, sort, start, startDrag, status, stop, stopAllSounds, stopDrag, substr, substring, swapDepths, splice, split, sqrt
TAB, tan, targetPath, tellTarget, toggleHighQuality, toLowerCase, toString, toUpperCase, trace
UP, UTC, unescape, unloadMovie, unLoadMovieNum, unshift, updateAfterEvent
valueOf
xmlDecl, _alpha
_currentframe
_droptarget
_focusrect, _framesloaded
_height, _highquality
_name
_quality
_rotation
_soundbuftime
_target, _totalframes
_url
_visible
_width
_x, _xmouse, _xscale
_y, _ymouse, _yscale
and, add, eq, ge, gt, le, lt, ne, not, or, Array, Boolean, Color, Date, Key, Math, MovieClip, Mouse, Number, Object, Selection, Sound, String, XML, XMLSocket</t>
<t tx="ekr.20040303063549.47">@language c
@comment /* */

@
@c

#define WIPEOUT 0 /* 
                   * Causes database card number &amp; flags to be set to zero. 
                   * This is so I don't need an infinite supply of cards!
                   */
// Not colored (because of @language /* */)
#include "equ.h"
#include "cmn.h"
#include "ramdef.h"
#include "eeprom.h"
#include &lt;hpc_ram.h&gt;
#include &lt;rlydef.h&gt;</t>
<t tx="ekr.20040303063549.48">@language csharp
@ comment
@c

/* block
comment */

// test

id // not a keyword

abstract as 
base bool break byte 
case catch char checked class const continue 
decimal default delegate do double 
else enum event explicit extern 
false finally fixed float for foreach 
get goto 
if implicit in int interface internal is 
lock long 
namespace new null 
object operator out override 
params partial private protected public 
readonly ref return 
sbyte sealed set short sizeof stackalloc 
static string struct switch 
this throw true try typeof 
uint ulong unchecked unsafe ushort using 
value virtual void volatile 
where while
yield</t>
<t tx="ekr.20040303063549.49">@language cweb

% This is limbo in cweb mode... It should be in \LaTeX mode, not \c mode.
% The following should not be colorized: class,if,else.

@* this is a _cweb_ comment.  Code is written in \c.
"strings" should not be colorized.
It should be colored in \LaTeX mode.
The following are not keywords in latex mode: if, else, etc.
Noweb section referencs are _valid_ in cweb comments!
&lt;&lt; section ref &gt;&gt;
&lt;&lt; missing ref &gt;&gt;
@c

and this is C code. // It is colored in \LaTeX mode by default.
/* This is a C block comment.  It may also be colored in restricted \LaTeX mode. */

// Section refs are valid in code too, of course.
&lt;&lt; section ref &gt;&gt;
&lt;&lt; missing ref &gt;&gt;

\LaTeX and \c should not be colored.
if else, while, do // C keywords.</t>
<t tx="ekr.20040303063549.50">&lt;&lt; section def &gt;&gt;=

	my \c code goes here // This is \LaTeX text
	/* This is also \LaTeX text */</t>
<t tx="ekr.20040303063549.51">@language elisp

; Maybe...
error princ 

; More typical of other lisps...
and apply
car cdr cons cond
defconst defun defvar 
eq equal eval
gt ge
if 
let le lt
mapcar 
ne nil 
or not 
prog progn 
set setq 
t type-of 
unless 
when while</t>
<t tx="ekr.20040303063549.52">@language html

&lt;HTML&gt;
&lt;!-- Author: Edward K. Ream, edream@tds.net --&gt;
&lt;HEAD&gt;
  &lt;META NAME="GENERATOR" CONTENT="Microsoft FrontPage 4.0"&gt;
  &lt;TITLE&gt; Leo's Home Page &lt;/TITLE&gt;
  &lt;META NAME="description" CONTENT="This page describes Leo.
Leo adds powerful outlines to the noweb and CWEB literate programming languages."&gt;
  &lt;META NAME="keywords" CONTENT="LEO, LITERATE PROGRAMMING, OUTLINES, CWEB,
NOWEB, OUTLINES, EDWARD K. REAM, DONALD E. KNUTH, SILVIO LEVY, OPEN SOFTWARE"&gt;
&lt;/HEAD&gt;
&lt;!-- Last Modified: May 12, 2002 --&gt;
&lt;BODY BGCOLOR="#fffbdc"&gt;

&lt;H1 ALIGN=CENTER&gt;&lt;a NAME="top"&gt;&lt;/a&gt;&lt;IMG SRC="Blank.gif" width=
"32" height="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;IMG SRC="leo.gif" 
WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;a href="leo_TOC.html#top"&gt;&lt;IMG SRC=
"arrow_rt.gif" WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;/a&gt; &amp;nbsp;&lt;/H1&gt;

&lt;H1 ALIGN=CENTER&gt; Leo's Home Page&lt;/H1&gt;

&lt;p align="center"&gt;&lt;a href="http://www.python.org/"&gt;&lt;img border="0" src="PythonPowered.gif" width="110" height="44"&gt; &lt;/a&gt; &lt;A HREF="http://sourceforge.net/"&gt;&lt;IMG SRC="http://sourceforge.net/sflogo.php?group_id=3458&amp;type=1" NATURALSIZEFLAG="0" ALT="SourceForge Logo"&gt;&lt;/A&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;
&lt;A HREF="http://sourceforge.net/project/?group_id=3458"&gt;Leo at SourceForge&lt;/A&gt;&amp;nbsp;&amp;nbsp;
&lt;a href="icons.html"&gt;&lt;img border="0" src="LeoCodeGray.gif" width="77" height="42"&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;
&lt;a href="icons.html"&gt;&lt;img border="0" src="LeoProse.gif" width="81" height="42"&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;

&lt;H3&gt;&lt;A NAME="anchor127554"&gt;&lt;/A&gt;Summary&lt;/H3&gt;

&lt;UL&gt;
  &lt;LI&gt;Leo is a &lt;i&gt; programmer's editor&lt;/i&gt;  and a flexible &lt;i&gt;browser&lt;/i&gt; for
	projects, programs, classes or data. Leo clarifies design, coding, debugging, testing
  and maintenance.
  &lt;LI&gt;Leo is an &lt;i&gt;outlining editor&lt;/i&gt;. Outlines clarify the big picture while
	providing unlimited space for details.
  &lt;LI&gt;Leo
	is a &lt;a HREF="http://www.literateprogramming.com/"&gt;&lt;i&gt;literate
	programming&lt;/i&gt;&lt;/a&gt; tool, compatible with &lt;A HREF="http://www.eecs.harvard.edu/~nr/noweb/"&gt;noweb&lt;/A&gt;
	and &lt;a HREF="http://www-cs-faculty.stanford.edu/~knuth/cweb.html"&gt;CWEB&lt;/a&gt;.
	Leo enhances any text-based
programming language, from assembly language and C to Java, Python and XML.
  &lt;LI&gt;Leo is also a &lt;i&gt;data organizer&lt;/i&gt;. A single Leo outline can generate complex
	data spanning many different files.&amp;nbsp; Leo has been used to manage web sites.
  &lt;LI&gt;Leo is a &lt;i&gt; project manager&lt;/i&gt;. Leo provides multiple views
of a project within a single outline. Leo naturally represents tasks that remain
	up-to-date.
  &lt;LI&gt;Leo is fully &lt;i&gt; scriptable&lt;/i&gt; using &lt;A HREF="http://www.python.org/"&gt;Python&lt;/A&gt;
  and saves its files in &lt;A HREF="http://www.w3.org/XML/"&gt;XML&lt;/A&gt; format.
  &lt;LI&gt;Leo is &lt;i&gt;portable&lt;/i&gt;.&amp;nbsp; Leo.py is 100% pure Python and will run on
	any platform supporting &lt;A HREF="http://www.python.org/"&gt;Python&lt;/A&gt;
	and &lt;a href="http://tcl.activestate.com/"&gt;Tk/tcl&lt;/a&gt;, including Windows,
	Linux and MacOS X.&amp;nbsp; Leo.exe runs on any Windows platform.
  &lt;LI&gt;Leo is &lt;a href="http://www.opensource.org/"&gt; &lt;i&gt; Open Software&lt;/i&gt;&lt;/a&gt;, distributed under
	the &lt;a href="http://www.python.org/doc/Copyright.html"&gt; Python License&lt;/a&gt;.
&lt;/UL&gt;

&lt;H3&gt;More Information and downloads&lt;/H3&gt;

&lt;ul&gt;
  &lt;LI&gt;An excellent &lt;a href="http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm"&gt;online
	tutorial&lt;/a&gt; and &lt;A HREF="http://www.jserv.com/jk_orr/xml/leo.htm"&gt;Leo resource
  page&lt;/A&gt;, both written by &lt;a href="http://www.jserv.com/jk_orr"&gt;Joe Orr&lt;/a&gt;.
  &lt;LI&gt;My brother's &lt;a href="SpeedReam.html"&gt;slashdot
	article about Leo&lt;/a&gt;, the best description about why Leo is special.
  &lt;LI&gt;&lt;A HREF="testimonials.html#anchor104391"&gt;What people are saying about Leo&lt;/A&gt;
  &lt;LI&gt;&lt;A HREF="leo_TOC.html#anchor964914"&gt;Complete users guide&lt;/A&gt;
	and
	&lt;A HREF="intro.html#anchor887874"&gt;tutorial introduction&lt;/A&gt;  with
  screen shots.
  &lt;li&gt;&lt;a href="FAQ.html"&gt;FAQ&lt;/a&gt; and &lt;a href="http://sourceforge.net/forum/?group_id=3458"&gt;help and discussion
	forums&lt;/a&gt;, preferable to &lt;A HREF="mailto:edream@tds.net"&gt;email&lt;/A&gt; so others may join
	in.&lt;/li&gt;
  &lt;li&gt;&lt;a href="icons.html"&gt;Icons&lt;/a&gt; for bragging about Leo.&lt;/li&gt;
&lt;/ul&gt;

&lt;a href="http://sourceforge.net/project/showfiles.php?group_id=3458"&gt;Download
	Leo&lt;/a&gt; from &lt;A HREF="http://sourceforge.net/project/?group_id=3458"&gt;Leo's SourceForge
site&lt;/A&gt;.

&lt;P ALIGN=left&gt;Leo's author is &lt;A HREF="http://personalpages.tds.net/~edream/index.html"&gt;Edward
  K. Ream&lt;/A&gt; email: &lt;A HREF="mailto:edream@tds.net"&gt;edream@tds.net&lt;/A&gt; voice: (608) 231-0766

&lt;HR ALIGN=LEFT&gt;

&lt;p align="center"&gt;

&lt;IMG SRC="Blank.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="34" height="34"&gt;&lt;IMG SRC="leo.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="32" height="32"&gt;&lt;a HREF="leo_TOC.html"&gt;&lt;IMG SRC="arrow_rt.gif" WIDTH="32"
HEIGHT="32" ALIGN="left" NATURALSIZEFLAG="3"&gt;

&lt;/BODY&gt;
&lt;/HTML&gt;</t>
<t tx="ekr.20040303063549.53">@language html

&lt;? xml version="1.0"&gt;
&lt;!-- test --&gt;
&lt;project name="Converter" default="dist"&gt;
&lt;/project&gt;"""</t>
<t tx="ekr.20040303063549.54">@language latex

% This is a \LaTeX mode comment.

This is a test of \LaTeX mode.

@ blah blah blah
@c

\c and \LaTeX are latex keywords.

This is a keyword \% not the start of a comment.

More keywords: \@ and \( and \) and \{ and \}</t>
<t tx="ekr.20040303063549.55">@ignore
@ doc
@c
@language c
	@others

abc
for # comment
# pp
@q comment @&gt; after
// comment
&lt;!-- comment --&gt; after
/* java comment */
{ pascal comment }
% latex comment
xor php keyword
fblocked tcl keyword
synchronized java keyword
\acute latex keyword
alarm perl keyword

# Python single-line comment
// C single-line comment
xx /* C block comment */ yy
xxx """ triple string """ zzz
a 'string' b
c "string" d
// C keywords
switch, case
</t>
<t tx="ekr.20040303063549.56">@language php
@ doc
This is a doc part.
@c

and or
array
array()
this is a test.
__CLASS__
&lt;?php and or array() ?&gt;"""</t>
<t tx="ekr.20040303063549.57">@language python

"""python
string"""d

'this\
is'''</t>
<t tx="ekr.20040303063549.58">"""This creates a free-floating copy of v's tree for undo.
The copied trees must use different tnodes than the original."""
	
def copyTree(self,root):

	c = self
	# Create the root vnode.
	result = v = leoNodes.vnode(c,root.t)
	# Copy the headline and icon values v.copyNode(root,v)
	# Copy the rest of tree.
	v.copyTree(root,v)
	# Replace all tnodes in v by copies.
	assert(v.nodeAfterTree() == None)
	while v:
		v.t = leoNodes.tnode(0, v.t.bodyString)
		v = v.threadNext()
	return result</t>
<t tx="ekr.20040303063549.59">@language rebol

; a comment
about abs absolute add alert alias all alter and and~ any append arccosine arcsine arctangent array ask at  
back bind boot-prefs break browse build-port build-tag  
call caret-to-offset catch center-face change change-dir charset checksum choose clean-path clear clear-fields close comment complement compose compress confirm continue-post context copy cosine create-request crypt cvs-date cvs-version  
debase decode-cgi decode-url decompress deflag-face dehex delete demo desktop detab dh-compute-key dh-generate-key dh-make-key difference dirize disarm dispatch divide do do-boot do-events do-face do-face-alt does dsa-generate-key dsa-make-key dsa-make-signature dsa-verify-signature  
echo editor either else emailer enbase entab exclude exit exp extract 
fifth find find-key-face find-window flag-face first flash focus for forall foreach forever form forskip fourth free func function  
get get-modes get-net-info get-style  
halt has head help hide hide-popup  
if import-email in inform input insert insert-event-func intersect 
join 
last launch launch-thru layout license list-dir load load-image load-prefs load-thru log-10 log-2 log-e loop lowercase  
make make-dir make-face max maximum maximum-of min minimum minimum-of mold multiply  
negate net-error next not now  
offset-to-caret open open-events or or~ 
parse parse-email-addrs parse-header parse-header-date parse-xml path-thru pick poke power prin print probe protect protect-system  
q query quit  
random read read-io read-net read-thru reboot recycle reduce reform rejoin remainder remold remove remove-event-func rename repeat repend replace request request-color request-date request-download request-file request-list request-pass request-text resend return reverse rsa-encrypt rsa-generate-key rsa-make-key 
save save-prefs save-user scroll-para second secure select send send-and-check set set-modes set-font set-net set-para set-style set-user set-user-name show show-popup sine size-text skip sort source split-path square-root stylize subtract switch  
tail tangent textinfo third throw throw-on-error to to-binary to-bitset to-block to-char to-date to-decimal to-email to-event to-file to-get-word to-hash to-hex to-idate to-image to-integer to-issue to-list to-lit-path to-lit-word to-local-file to-logic to-money to-none to-pair to-paren to-path to-rebol-file to-refinement to-set-path to-set-word to-string to-tag to-time to-tuple to-url to-word trace trim try  
unfocus union unique uninstall unprotect unset until unview update upgrade uppercase usage use  
vbug view view-install view-prefs  
wait what what-dir while write write-io  
xor xor~  
action! any-block! any-function! any-string! any-type! any-word!  
binary! bitset! block!  
char!  
datatype! date! decimal! 
email! error! event!  
file! function!  
get-word!  
hash!  
image! integer! issue!  
library! list! lit-path! lit-word! logic!  
money!  
native! none! number!  
object! op!  
pair! paren! path! port!  
refinement! routine!  
series! set-path! set-word! string! struct! symbol!  
tag! time! tuple!  
unset! url!  
word!  
any-block? any-function? any-string? any-type? any-word?  
binary? bitset? block?  
char? connected? crypt-strength? 
datatype? date? decimal? dir?  
email? empty? equal? error? even? event? exists? exists-key?
file? flag-face? found? function?  
get-word? greater-or-equal? greater?  
hash? head?  
image? in-window? index? info? input? inside? integer? issue?  
length? lesser-or-equal? lesser? library? link-app? link? list? lit-path? lit-word? logic?  
modified? money?  
native? negative? none? not-equal? number?  
object? odd? offset? op? outside?  
pair? paren? path? port? positive?  
refinement? routine?  
same? screen-offset? script? series? set-path? set-word? size? span? strict-equal? strict-not-equal? string? struct?  
tag? tail? time? tuple? type?  
unset? url?  
value? view? 
within? word?  
zero?</t>
<t tx="ekr.20040303063549.60"># both color_markup &amp; add_directives plugins must be enabled.

@markup wiki
@language python

""" {picture file=../Icons/Leoapp.GIF}this """ # Problems with correct indexing following a graphic.

""" {picture file=../Icons/Leoapp.GIF}this """ # two copies work.

abc

""" {picture file=../Icons/Leodoc.GIF} """ # xyz

""" continued
string"""

@ ''ab'' __xxx__ ''wx'' __xyz__
@c

# /* ''ab'' __xxx__ ''wx'' __xyz__ */

# Test

""" ''' """ ''' """'''  # Leo handles the common cases correctly.

''' ''ab'' __xxx__ ''wx'' __xyz__ ''' # No wiki markup in ''' strings.

""" ''ab'' __xxx__ ''wx'' __xyz__ """

# ''ab'' __xxx__ ''wx'' __xyz__

""" ''y'' """

""" text~~#ff00ff:some text~~more text""

and if

from leoGlobals import * ; print app().loadDir</t>
<t tx="ekr.20040303063549.61"># both color_markup &amp; add_directives plugins must be enabled.
@markup wiki

""" continued
string"""

@ ''ab'' __xxx__ ''wx'' __xyz__  __''bolditalic''__ and ''__italicbold__''
@c

# /* ''ab'' __xxx__ ''wx'' __xyz__ */

__abc__ 

# Test

""" ''' """ ''' """'''  # Leo handles the __b__ common cases correctly.

''' ''ab'' __xxx__ ''wx'' __xyz__ ''' # No wiki markup in ''' strings.

""" ''ab'' __xxx__ ''wx'' __xyz__ """

# ''ab'' __xxx__ ''wx'' __xyz__

""" ''y'' """

""" text~~#ee00ff:some text~~more text"""



and if

from leoGlobals import * ; print app().loadDir
</t>
<t tx="ekr.20040303063549.62"># both color_markup &amp; add_directives plugins must be enabled.

@markup wiki

""" text~~red:some text~~more text"""

""" text~~#ee0ff:some text~~more text"""</t>
<t tx="ekr.20040303063549.63">@ The names of child nodes are the names of commander methods to be called to do the test.

Each child node will in turn have two or more children:
	
- a "before" node
- an "after" node
- an optional selection node containing two lines giving the selection range in Tk coordinates.
- An optional insert node containing one line giving the insert point in Tk coordinates.
@c

import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

suite = leoTest.makeEditBodySuite("editBodyTests","tempNode")
runner = unittest.TextTestRunner()
runner.run(suite)
</t>
<t tx="ekr.20040303063549.64"></t>
<t tx="ekr.20040303063549.65">line 1
	line 2
	line 3
line 4</t>
<t tx="ekr.20040303063549.66">line 1
line 2
line 3
line 4</t>
<t tx="ekr.20040303063549.67">2.0
3.0 lineend - 1c</t>
<t tx="ekr.20040303063549.68"></t>
<t tx="ekr.20040303063549.69">line 1
line 2
line 3
line 4</t>
<t tx="ekr.20040303063549.70">line 1
	line 2
	line 3
line 4</t>
<t tx="ekr.20040303063549.71">2.0
3.0 lineend - 1c</t>
<t tx="ekr.20040303063549.72"></t>
<t tx="ekr.20040303063549.73">before
&lt;&lt; section &gt;&gt;
sec line 1
	sec line 2 indented
sec line 3
after</t>
<t tx="ekr.20040303063549.74">before
&lt;&lt; section &gt;&gt;
after</t>
<t tx="ekr.20040303063549.75">sec line 1
	sec line 2 indented
sec line 3</t>
<t tx="ekr.20040303063549.76">2.0
5.0 lineend -1c</t>
<t tx="ekr.20040303063549.77">import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

suite = leoTest.makeImportExportSuite("exportTests","tempNode")
runner = unittest.TextTestRunner()
runner.run(suite)</t>
<t tx="ekr.20040303063549.78"></t>
<t tx="ekr.20040303063549.79">saveFileDialog
c:\\prog\\test\\unittest\\output\\exportHeadlines.txt</t>
<t tx="ekr.20040303063549.80"></t>
<t tx="ekr.20040303063549.81">saveFileDialog
c:\\prog\\test\\unittest\\output\\flattenOutline.txt</t>
<t tx="ekr.20040303063549.82"></t>
<t tx="ekr.20040303063549.83">saveFileDialog
c:\\prog\\test\\unittest\\output\\weave.txt</t>
<t tx="ekr.20040303063549.84"></t>
<t tx="ekr.20040303063549.85">saveFileDialog
c:\\prog\\test\\unittest\\output\\outlineToNoweb.txt</t>
<t tx="ekr.20040303063549.86"></t>
<t tx="ekr.20040303063549.87">saveFileDialog
c:\\prog\\test\\unittest\\output\\outlineToCweb.txt</t>
<t tx="ekr.20040303063549.88"></t>
<t tx="ekr.20040303063549.89">openFileDialog
c:\\prog\\test\\unittest\\input\\leoAtFile.py</t>
<t tx="ekr.20040303063549.90"># To do: at present this creates a copy of this node as the next sib of tempNode!

import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

suite = leoTest.makeImportExportSuite("importTests","tempNode")
runner = unittest.TextTestRunner()
runner.run(suite)</t>
<t tx="ekr.20040303063549.91"></t>
<t tx="ekr.20040303063549.92">openFileDialog
c:\\prog\\test\\unittest\\input\\leoAtFile.py</t>
<t tx="ekr.20040303063549.93"></t>
<t tx="ekr.20040303063549.94">openFileDialog
c:\\prog\\test\\unittest\\input\\leoAtFile.py</t>
<t tx="ekr.20040303063549.95"></t>
<t tx="ekr.20040303063549.96">openFileDialog
c:\\prog\\test\\unittest\\input\\noweave.nw.txt</t>
<t tx="ekr.20040303063549.97"></t>
<t tx="ekr.20040303063549.98">openFileDialog
c:\\prog\\test\\unittest\\input\\flat.txt</t>
<t tx="ekr.20040303063549.99"></t>
<t tx="ekr.20040303063549.100">openFileDialog
c:\\prog\\test\\unittest\\input\\cweave.w</t>
<t tx="ekr.20040303063549.101">import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

suite = leoTest.makeOutlineSuite("outlineTests")
runner = unittest.TextTestRunner()
runner.run(suite)</t>
<t tx="ekr.20040303063549.102"></t>
<t tx="ekr.20040303063549.103"></t>
<t tx="ekr.20040303063549.104"></t>
<t tx="ekr.20040303063549.105"></t>
<t tx="ekr.20040303063549.106"></t>
<t tx="ekr.20040303063549.107"></t>
<t tx="ekr.20040303063549.108"></t>
<t tx="ekr.20040303063549.109"></t>
<t tx="ekr.20040303063549.110"></t>
<t tx="ekr.20040303063549.111"></t>
<t tx="ekr.20040303063549.112"></t>
<t tx="ekr.20040303063549.113"></t>
<t tx="ekr.20040303063549.114"></t>
<t tx="ekr.20040303063549.115"></t>
<t tx="ekr.20040303063549.116"></t>
<t tx="ekr.20040303063549.117"></t>
<t tx="ekr.20040303063549.118">import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

suite = leoTest.makePluginsSuite(verbose=True)
runner = unittest.TextTestRunner()
runner.run(suite)</t>
<t tx="ekr.20040303063549.119">import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

suite = leoTest.makePositionSuite(all=1)
runner = unittest.TextTestRunner()
runner.run(suite)</t>
<t tx="ekr.20040303063549.120">import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

suite = testLeoFilesSuite = leoTest.makeTestLeoFilesSuite("testLeoFiles")
runner = unittest.TextTestRunner()
runner.run(suite)</t>
<t tx="ekr.20040303063549.121"></t>
<t tx="ekr.20040303063549.122"></t>
<t tx="ekr.20040303063549.123"></t>
<t tx="ekr.20040303063549.124"></t>
<t tx="ekr.20040303063549.125">from leoGlobals import *
import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

mainSuite = unittest.makeSuite(unittest.TestCase)

suite = leoTest.makeReformatParagraphSuite()
mainSuite.addTest(suite)

for f,arg in (
	(leoTest.makeColorSuite,"colorizerTests"),
	(leoTest.makeEditBodySuite,"editBodyTests"),
	(leoTest.makeImportExportSuite,"exportTests"),
	(leoTest.makeImportExportSuite,"importTests"),
	(leoTest.makeTestLeoFilesSuite,"testLeoFiles"),
	(leoTest.makePositionSuite,None),
	# (leoTest.makeOutlineSuite,"outlineTests")
	# These tests presently have problem with the gui when run with other tests...
	# (leoTest.makePluginsSuite,false) # verbose
):
	suite = f(arg,"tempNode")
	mainSuite.addTest(suite)

runner = unittest.TextTestRunner()
runner.run(mainSuite)</t>
<t tx="ekr.20040303063644"></t>
<t tx="ekr.20040303064013">def makePositionSuite(arg=None,all=true,verbose=false):
	
	if all: # Include everything.
	
		suite = unittest.makeSuite(positionTestCase,'test')
		
	else: # Include listed testss.

		names = (
			"testFullTraverse",
			"testParentChildLinks",
			"testNextBack",
			"testVnodeList",
			"testThreadBackNext",
			"testParentChildLevel")
		
		suite = unittest.makeSuite(unittest.TestCase)
		for name in names:
			suite.addTest(positionTestCase(name))

	return suite</t>
<t tx="ekr.20040303064020.1">def testFullTraverse(self):
	
	c = top() ; p = c.rootPosition()

	while p:
		assert(p)
		p.moveToThreadNext()</t>
<t tx="ekr.20040303064020.2">def testParentChildLinks (self):
	
	c = self.c ; p = c.rootPosition()
	while p:
		&lt;&lt; check that the parent of p's first child is p &gt;&gt;
		parent = p.getParent()
		if parent:
			&lt;&lt; check that the parent of all parent's children is parent &gt;&gt;
		p.moveToThreadNext()</t>
<t tx="ekr.20040303064020.3">firstChild = p.getFirstChild()
if firstChild:
	parent = firstChild.getParent()
	if p != parent:
		print "mismatch:p,parent,child",p,parent,firstChild</t>
<t tx="ekr.20040303064020.4">found = false
child = parent.getFirstChild()
if not child:
	print "parent has no children"
while child:
	if child == p: found
	childParent = child.getParent()
	if childParent != parent:
		print "mismatch:parent,childParent",parent,childParent
	child = child.moveToNext()</t>
<t tx="ekr.20040303064020.5">def testNextBack (self):
	
	c = self.c ; p = c.rootPosition()

	while p:
		back = p.getBack()
		next = p.getNext()
		if back: assert(back.getNext() == p)
		if next: assert(next.getBack() == p)
		p.moveToThreadNext()</t>
<t tx="ekr.20040303064020.6">def testVnodeList (self):
	
	c = self.c ; p = c.rootPosition()

	while p:
		vnodeList = p.v.t.vnodeList
		for v in vnodeList:
			assert(v.t == p.v.t)
			if p.v.isCloned():
				assert(v.isCloned())
				assert(len(vnodeList) &gt; 1)
			else:
				assert(not v.isCloned())
				assert(len(vnodeList) == 1)
	
		p.moveToThreadNext()</t>
<t tx="ekr.20040303064020.7">def testThreadBackNext (self):

	c = self.c ; p = c.rootPosition()

	while p:
		threadBack = p.getThreadBack()
		threadNext = p.getThreadNext()

		if threadBack:
			if threadBack.getThreadNext() != p:
				print "p.threadBack.threadNext != p"
				print "p,threadBack,threadBack.threadNext:"
				print p,threadBack,threadBack.getThreadNext()
			assert(threadBack.getThreadNext()==p)
	
		if threadNext:
			if threadNext.getThreadBack() != p:
				print "p.threadNext.threadBack != p"
				print "p,threadNext,threadNext.threadBack:"
				print p,threadNext,threadNext.getThreadBack()
			assert(threadNext.getThreadBack()==p)

		p.moveToThreadNext()
</t>
<t tx="ekr.20040303064020.8">def testParentChildLevel (self):
	
	c = self.c ; p = c.rootPosition()
	
	level = 0 ; count = 0
	while p:
		count += 1
		if level != p.level():
			print level,p.level(),p
		assert(level == p.level())
		if p.getFirstChild():
			level += 1
			assert(p.getFirstChild().level() == level)
		elif p.getNext():
			assert(p.getNext().level() == level)
		else:
			p2 = p.copy().moveToParent()
			level -= 1
			while p2:
				if p2.getNext(): break
				p2.moveToParent()
				level -= 1
			assert(p2 or level == -1)

		p.moveToThreadNext()</t>
<t tx="ekr.20040303071432"></t>
<t tx="ekr.20040303080010">from leoGlobals import *
import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

mainSuite = unittest.makeSuite(unittest.TestCase)

suite = leoTest.makeReformatParagraphSuite()
mainSuite.addTest(suite)

for f,arg in (
	(leoTest.makeColorSuite,"colorizerTests"),
	(leoTest.makeEditBodySuite,"editBodyTests"),
	(leoTest.makePositionSuite,None),
	# (leoTest.makeOutlineSuite,"outlineTests")
	# These tests presently have problem with the gui when run with other tests...
	# (leoTest.makePluginsSuite,false) # verbose
):
	suite = f(arg,"tempNode")
	mainSuite.addTest(suite)

runner = unittest.TextTestRunner()
runner.run(mainSuite)</t>
<t tx="ekr.20040303080938"></t>
<t tx="ekr.20040303080938.1"></t>
<t tx="ekr.20040303091606">def testHasNextBack (self):
	
	c = self.c ; p = c.rootPosition()

	while p:

		back = p.getBack()
		next = p.getNext()

		assert(
			(back and p.hasBack()) or
			(not back and not p.hasBack()))
				
		assert(
			(next and p.hasNext()) or
			(not next and not p.hasNext()))
		
		p.moveToThreadNext()</t>
<t tx="ekr.20040303092153">def testHasParentChild (self):
	
	c = self.c ; p = c.rootPosition()

	while p:

		child = p.getFirstChild()
		parent = p.getParent()

		assert(
			(child and p.hasFirstChild()) or
			(not child and not p.hasFirstChild()))
				
		assert(
			(parent and p.hasParent()) or
			(not parent and not p.hasParent()))
		
		p.moveToThreadNext()</t>
<t tx="ekr.20040303092153.1">def testHasThreadNextBack(self):
	
	c = self.c ; p = c.rootPosition()

	while p:

		threadBack = p.getThreadBack()
		threadNext = p.getThreadNext()

		assert(
			(threadBack and p.hasThreadBack()) or
			(not threadBack and not p.hasThreadBack()))
				
		assert(
			(threadNext and p.hasThreadNext()) or
			(not threadNext and not p.hasThreadNext()))
		
		p.moveToThreadNext()</t>
<t tx="ekr.20040303215834">from leoGlobals import *

import leoNodes

c = top()

t = leoNodes.tnode()
v = leoNodes.vnode(c,t)
p = leoNodes.position(v,[])
p2 = p.copy()
print p == p2
</t>
<t tx="ekr.20040305165016">try: True;False
except NameError: True,False = 1,0
import leoGlobals as g
import leoNodes
position = leoNodes.position
g.sharedNodes = False

@others

current = g.top().currentVnode()
child1 = current.firstChild()
child2 = child1.firstChild()
pos = position(current,[]) # default position.

if 1:
	print '-'*10, "parents"
	pos = position(child2,[]) # a hack.
	for v in pos.parents_iter(): print v
if 0:
	print '-'*10, "subtree"
	for v in pos.subtree_iter(): print v
if 0:
	print '-'*10, "children"
	pos = position(child1,[]) # a hack.
	for v in pos.children_iter(): print v
if 0:
	print '-'*10, "siblings"
	for v in pos.siblings_iter(): print v
if 0:
	print '-'*10, "all nodes"
	for v in pos.allNodes_iter(): print v</t>
<t tx="ekr.20040305165846"># Warning: this code implies substantial changes to code that uses them, both core and scripts.

class position:
	
	"""A class representing a position in a traversal of a tree containing shared tnodes."""

	&lt;&lt; about the position class &gt;&gt;
	
	@others</t>
<t tx="ekr.20040305165846.1"></t>
<t tx="ekr.20040305165846.2">def __init__ (self,v,stack):

	"""Create a new position."""
	
	if v: self.c = v.c
	else: self.c = g.top()

	self.v = v
	self.stack = stack[:] # Creating a copy here is safest and best.</t>
<t tx="ekr.20040305165846.3">def __cmp__(self,other):
	
	"""Return True if two postions are equivalent."""

	p1 = self ; p2 = other
	
	assert(p1 is not None)
	
	# g.trace(repr(p1),repr(p2))
	
	if p2 == None: return 1 # Special case. Not equal.
	
	if p1.v != p2.v or len(p1.stack) != len(p2.stack):
		return 1 # Not equal
		
	for i in xrange(len(p1.stack)):
		if p1.stack[i] != p2.stack[i]:
			return 1 # Not equal
			
	return 0 # Equal</t>
<t tx="ekr.20040305165846.4"># Most position methods are simply proxies for the corresponding vnode method.

# This is safe and saves a _lot_ of code.

if 0: # The position class is no longer a proxy for the vnode class.

	def __getattr__ (self,attr):
		return getattr(self.v,attr)</t>
<t tx="ekr.20040305165846.5">@
The test "if p" is the _only_ correct way to test whether a position p is valid.
In particular, tests like "if p is None" or "if p is not None" will not work properly.
@c

def __nonzero__ ( self):
	
	"""Return True if a position is valid."""

	return self.v is not None</t>
<t tx="ekr.20040305165846.6">def __str__ (self):
	
	p = self
	
	if p.v:
		return "&lt;pos(%d) %s&gt;" % (len(p.stack),p.v.headString())
	else:
		return "&lt;pos None&gt;"
		
__repr__ = __str__</t>
<t tx="ekr.20040305165846.7">@ This class provides tree traversal methods that operate on positions, not vnodes.  Positions encapsulate the notion of present position within a traversal.

Positions consist of a vnode and a stack of parent nodes used to determine the next parent when a vnode has mutliple parents.

Calling, e.g., p.moveToThreadNext() results in p being an invalid position.  That is, p represents the position following the last node of the outline.  The test "if p" is the _only_ correct way to test whether a position p is valid.  In particular, tests like "if p is None" or "if p is not None" will not work properly.

The only changes to vnodes and tnodes needed to implement shared tnodes are:

- The firstChild field becomes part of tnodes.
- t.vnodes contains a list of all vnodes sharing the tnode.

The advantages of using shared tnodes:

- Leo no longer needs to create or destroy "dependent" trees when changing descendents of cloned trees.
- There is no need for join links and no such things as joined nodes.

These advantages are extremely important: Leo is now scalable to very large outlines.

An important complication is the need to avoid creating temporary positions while traversing trees:
- Several routines use p.vParentWithStack to avoid having to call tempPosition.moveToParent().
  These include p.level, p.isVisible, p.hasThreadNext and p.vThreadNext.
- p.moveToLastNode and p.moveToThreadBack use new algorithms that don't use temporary data.
- Several lookahead routines compute whether a position exists without computing the actual position.</t>
<t tx="ekr.20040305165846.8"></t>
<t tx="ekr.20040305165846.9">def isDirty (self):
	
	p = self
	return p.v and p.v.isDirty()
</t>
<t tx="ekr.20040305165846.10">def setAllAncestorAtFileNodesDirty (self):

	p = self ; c = p.c
	changed = False
	c.beginUpdate()
	if p.setAncestorAtFileNodeDirty():
		changed = True
	c.endUpdate(changed)
	return changed</t>
<t tx="ekr.20040305165846.11">@ This is called from the key-event handler, so we must not force a redraw of the screen here. We avoid redraw in most cases by passing redraw_flag to c.endUpdate().

This is called from v.setDirty, so we avoid further calls to v.setDirty here.  The caller, that is, v.setDirty itself, handles all clones.

@c
def setAncestorAtFileNodeDirty(self):

	# Look up the tree for an ancestor @file node.
	p = self.copy() ; c = p.c
	redraw_flag = False
	c.beginUpdate()
	if 1: # update...
		while p:
			if not p.v.isDirty() and p.v.isAnyAtFileNode():
				redraw_flag = True
				p.v.t.setDirty() # Do not call v.setDirty here!
			p.moveToParent()
	c.endUpdate(redraw_flag) # A crucial optimization: does nothing if inside nested begin/endUpdate.
	return redraw_flag # Allow caller to do the same optimization.</t>
<t tx="ekr.20040305165846.12">def setAncestorsOfClonedNodesInTreeDirty(self):

	"""This marks v dirty and all cloned nodes in v's tree."""

	p = self
	
	if not p:
		return False
	else:
		return p.setAncestorAtFileNodeDirty()</t>
<t tx="ekr.20040305165846.13"># Ensures that all ancestor @file nodes are marked dirty.
# It is much safer to do it this way.

def setDirty (self):

	p = self ; c = p.c
	changed = False
	
	c.beginUpdate()
	if 1: # update...
		if not p.v.t.isDirty():
			p.v.t.setDirty()
			changed = True
		# This must be called even if p.v is already dirty.
		if p.setAncestorAtFileNodeDirty():
			changed = True
	c.endUpdate(changed)

	return changed</t>
<t tx="ekr.20040305165846.19">if g.sharedNodes:
	
	@others</t>
<t tx="ekr.20040305165846.20"></t>
<t tx="ekr.20040305165846.21">@ This is the main delete routine.  It deletes the receiver's entire tree from the screen.  Because of the undo command we never actually delete vnodes or tnodes.
@c

def doDelete (self,newPosition):

	"""Unlinks p.v from the outline.  May be undone.
	
	Returns newPosition."""

	p = self ; c = p.c

	p.setDirty() # Mark @file nodes dirty!
	p.v.unlink()
	c.selectVnode(newPosition)
	
	return newPosition</t>
<t tx="ekr.20040305165846.22">def insertAfter (self,t=None):

	"""Inserts a new vnode after self.
	
	Returns the newly created position."""
	
	p = self.copy() ; c = p.c

	if not t:
		t = tnode(headString="NewHeadline")

	v = vnode(c,t)
	v.iconVal = 0
	v.linkAfter(p.v)

	p.v = v
	return p</t>
<t tx="ekr.20040305165846.23">def insertAsLastChild (self,t=None):

	"""Inserts a new vnode as the last child of self.
	
	Returns the newly created position."""
	
	p = self
	n = p.numberOfChildren()

	if not t:
		t = tnode(headString="NewHeadline")
	
	return p.insertAsNthChild(n,t)</t>
<t tx="ekr.20040305165846.24">def insertAsNthChild (self,n,t=None):

	"""Inserts a new node as the the nth child of self.
	self must have at least n-1 children.
	
	Returns the newly created position."""
	
	p = self.copy()

	if not t:
		t = tnode(headString="NewHeadline")
	
	v = vnode(self.c,t)
	v.iconVal = 0
	v.linkAsNthChild(p.v,n)
	
	p.v = v
	return p
</t>
<t tx="ekr.20040305165846.25">def moveToRoot (self, oldRoot = None):

	"""Moves self to the root position.
	
	Returns the root position."""

	p = self.copy()
	p.v.unlink()
	p.v.linkAsRoot(oldRoot)
	
	return p</t>
<t tx="ekr.20040305165846.26"># Creates a clone of back and insert it as the next sibling of back.

def clone (self,back):
	
	"""Create a clone of back.
	
	Returns the newly created position."""
	
	p = self.copy()
	
	clone = vnode(self.c,back.v.t)
	clone.linkAfter(back.v)
	
	p.v = clone
	return p
</t>
<t tx="ekr.20040305165846.27">def copyTreeWithNewTnodes (self):
	
	"""Return a copy of self with all new tnodes"""
	
	c = self.c
	
	# Create the root node.
	old_v = self
	new_v = vnode(c,tnode())
	new_v.t.headString = old_v.t.headString
	new_v.t.bodyString = old_v.t.bodyString
	
	# Recursively create all descendents.
	old_child = old_v.firstChild() ; n = 0
	while old_child:
		new_child = old_child.copyTreeWithNewTnodes()
		new_child.linkAsNthChild (new_v, n)
		n += 1
		old_child = old_child.next()
		
	# Return the root of the new tree.
	return new_v</t>
<t tx="ekr.20040305165846.28"># Used by scripts

def moveAfter (self,a):

	"""Moves self after position a.
	
	Returns the newly created position."""

	p = self.copy() ; c = p.c

	p.v.unlink()
	p.v.linkAfter(a.v)
	
	# Moving a node after another node can create a new root node.
	if not a.hasParent() and not a.hasBack():
		c.frame.tree.setRootPosition(a)
		
	return p</t>
<t tx="ekr.20040305165846.29"># Compatibility routine for scripts

def moveToNthChildOf (self, pv, n):

	"""Moves the receiver to the nth child of vnode pv.
	
	Returns the newly created position."""

	p = self.copy() ; c = p.c

	p.v.unlink()
	p.v.linkAsNthChild(pv, n)
	
	# Moving a node can create a new root node.
	if not pv.parent() and not pv.back():
		c.frame.tree.setRootVnode(pv)
		
	return p</t>
<t tx="ekr.20040305165846.30">def sortChildren (self):

	# Create a list of (headline,position) tuples
	p = self.copy() ; pairs = []
	if not p.hasFirstChild(): return
	child = p.getFirstChild()
	while child:
		pairs.append((string.lower(child.headString()),child))
		child.moveToNext()

	# Sort the list on the headlines.
	pairs.sort()

	# Move the children.
	index = 0
	for headline,child in pairs:
		child.moveToNthChildOf(p,index)
		index += 1</t>
<t tx="ekr.20040305165846.31"># This routine checks the structure of the receiver's tree.

def validateOutlineWithParent (self,pv):
	
	p = self
	result = True # optimists get only unpleasant surprises.
	parent = p.getParent()
	childIndex = p.childIndex()
	&lt;&lt; validate parent ivar &gt;&gt;
	&lt;&lt; validate childIndex ivar &gt;&gt;
	&lt;&lt; validate x ivar &gt;&gt;

	# Recursively validate all the children.
	child = p.getFirstChild()
	while child:
		r = child.validateOutlineWithParent(p)
		if not r: result = False
		child.moveToNext()
	return result</t>
<t tx="ekr.20040305165846.32">if parent != pv:
	p.invalidOutline( "Invalid parent link: " + parent.v.description() )</t>
<t tx="ekr.20040305165846.33">if pv:
	if childIndex &lt; 0:
		p.invalidOutline ( "missing childIndex" + childIndex )
	elif childIndex &gt;= pv.numberOfChildren():
		p.invalidOutline ( "missing children entry for index: " + childIndex )
elif childIndex &lt; 0:
	p.invalidOutline ( "negative childIndex" + childIndex )</t>
<t tx="ekr.20040305165846.34">if not p.v.t and pv:
	self.invalidOutline ( "Empty t" )</t>
<t tx="ekr.20040305165846.35">def invalidOutline (self, message):

	s = "invalid outline: " + message + "\n"
	parent = self.getParent()

	if parent:
		s += repr(parent)
	else:
		s += repr(self)

	g.alert(s)</t>
<t tx="ekr.20040305165846.36">if 1: # These will eventually go away.

	# Called from undo...
	def addTreeToJoinLists (self): pass
	def joinTreeTo  (self, tree2): pass
	def unjoinTree         (self): pass
	
	# Called only from commands...
	def createDependents   (self): pass
	def destroyDependents  (self): pass</t>
<t tx="ekr.20040305165846.37">def childIndex(self):
	
	p = self
	
	if not p.hasParent(): return 0
	
	# Point v at the first sibling
	v = p.v
	while v and v._back:
		v = v._back
		
	# Now count.
	n = 0
	while v:
		if v == p.v: return n
		v = v._next
		n += 1
	assert(False)</t>
<t tx="ekr.20040305165846.38"># These methods are useful abbreviations.
# Warning: they make copies of positions, so they should be used _sparingly_

def getBack          (self): return self.copy().moveToBack()
def getFirstChild    (self): return self.copy().moveToFirstChild()
def getLastChild     (self): return self.copy().moveToLastChild()
def getLastNode      (self): return self.copy().moveToLastNode()
def getNext          (self): return self.copy().moveToNext()
def getNodeAfterTree (self): return self.copy().moveToNodeAfterTree()
def getNthChild    (self,n): return self.copy().moveToNthChild(n)
def getParent        (self): return self.copy().moveToParent()
def getThreadBack    (self): return self.copy().moveToThreadBack()
def getThreadNext    (self): return self.copy().moveToThreadNext()
def getVisBack       (self): return self.copy().moveToVisBack()
def getVisNext       (self): return self.copy().moveToVisNext()

@
It might be feasible to use these methods during the transition to 4.2.
However, using these routines is in general a bad idea.
@c

if 0: # WARNING: defining the "old" names here is dangerous!
	back          = getBack
	firstChild    = getFirstChild
	lastChild     = getLastChild
	lastNode      = getLastNode
	next          = getNext
	nodeAfterTree = getNodeAfterTree
	nthChild      = getNthChild
	parent        = getParent
	threadBack    = getThreadBack
	threadNext    = getThreadNext
	visBack       = getVisBack
	visNext       = getVisNext</t>
<t tx="ekr.20040305165846.39">def hasBack(self):
	return self.v and self.v._back
	
def hasChildren(self):
	return self.v and self.v.t and self.v.t._firstChild
	
hasFirstChild = hasChildren
	
def hasNext(self):
	return self.v and self.v._next
	
def hasParent(self):
	return self.v and (self.v._parent or len(self.stack) &gt; 0)
	
def hasThreadBack(self):
	return self.hasParent() or self.hasBack() # Much cheaper than computing the actual value.
	
hasVisBack = hasThreadBack</t>
<t tx="ekr.20040305165846.40">def hasThreadNext(self):

	p = self ; v = p.v
	if not p.v: return False

	if v.t._firstChild or v._next:
		return True
	else:
		n = len(p.stack)-1
		v,n = p.vParentWithStack(v,p.stack,n)
		while v:
			if v._next:
				return True
			v,n = p.vParentWithStack(v,p.stack,n)
		return False

hasVisNext = hasThreadNext</t>
<t tx="ekr.20040305165846.41">@
These routines change self to a new position "in place".
That is, these methods must _never_ call p.copy().

When moving to a nonexistent position, these routines simply set p.v = None,
leaving the p.stack unchanged. This allows the caller to "undo" the effect of
the invalid move by simply restoring the previous value of p.v.

These routines all return self on exit so the following kind of code will work:
	after = p.copy().moveToNodeAfterTree()</t>
<t tx="ekr.20040305165846.42">def moveToBack (self):
	
	"""Move self to its previous sibling."""
	
	p = self

	p.v = p.v and p.v._back
	
	return p</t>
<t tx="ekr.20040305165846.43">def moveToFirstChild (self):

	"""Move a position to it's first child's position."""
	
	p = self

	if p:
		child = p.v.t._firstChild
		if child:
			if p.v.isCloned():
				p.stack.append(p.v)
			p.v = child
		else:
			p.v = None
		
	return p</t>
<t tx="ekr.20040305165846.44">def moveToLastChild (self):
	
	"""Move a position to it's last child's position."""
	
	p = self

	if p:
		if p.v.t._firstChild:
			child = p.v.lastChild()
			if p.v.isCloned():
				p.stack.append(p.v)
			p.v = child
		else:
			p.v = None
			
	return p</t>
<t tx="ekr.20040305165846.45">def moveToLastNode (self):
	
	"""Move a position to last node of its tree without calling p.copy()."""
	
	p = self

	if p:
		if p.v._next:
			# Let p.moveToThreadBack do the heavy lifting.
			p.moveToNext()
			p.moveToThreadBack()
		else:
			&lt;&lt; simulate repeated "lookahead" calls to p.moveToThreadNext() &gt;&gt;
				
	return p</t>
<t tx="ekr.20040305165846.46">while 1:
	assert(p)
	if p.v.t._firstChild:
		p.moveToFirstChild()
	elif p.v._next:
		p.moveToNext()
	else:
		# Look ahead. We are about to call p.moveToParent().
		if p.level() == 1:
			break
		p.moveToParent()</t>
<t tx="ekr.20040305165846.47">def moveToNext (self):
	
	"""Move a position to its next sibling."""
	
	p = self
	
	p.v = p.v and p.v._next
	
	return p</t>
<t tx="ekr.20040305165846.48">def moveToNodeAfterTree (self):
	
	"""Move a position to the node after the position's tree."""
	
	p = self
	
	while p:
		if p.v._next:
			p.moveToNext()
			break
		p.moveToParent()

	return p</t>
<t tx="ekr.20040305165846.49">def moveToNthChild (self, n):
	
	p = self
	
	if p:
		child = p.v.nthChild(n)
		if child:
			if p.v.isCloned():
				p.stack.append(p.v)
			p.v = child
		else:
			p.v = None
			
	return p</t>
<t tx="ekr.20040305165846.50">def moveToParent (self):
	
	"""Move a position to its parent position."""
	
	p = self

	if p.v._parent:
		p.v = p.v._parent
	elif p.stack:
		p.v = p.stack.pop()
	else:
		p.v = None
		
	return p</t>
<t tx="ekr.20040305165846.51">def moveToThreadBack (self):
	
	"""Move a position to it's threadBack position without calling p.copy()."""

	p = self

	if p:
		if p.v._back:
			p.moveToBack()
			if p.v.t._firstChild:
				level1 = p.level()
				p.moveToFirstChild()
				assert(p.level() == level1 + 1)
				while p.checkNextThreadNextLevel(level1):
					p.moveToThreadNext()
		else:
			p.moveToParent()

	return p</t>
<t tx="ekr.20040305165846.52">def checkNextThreadNextLevel(self,level1):
	
	"""Return True if p.getThreadNext().level() &gt; level1.

	Do not alter p or call p.copy()."""

	p = self ; level = p.level()
	assert(p)
	assert(level &gt; level1)

	if p.v.t._firstChild:
		return True # Level increasing.
	elif p.v._next:
		return True # Level unchanged.
	else:
		n = len(p.stack)-1
		v,n = p.vParentWithStack(p.v,p.stack,n)
		assert(v)
		level -= 1
		if level == level1: return False 
		while v:
			assert(level &gt; level1)
			if v._next: return True
			v,n = p.vParentWithStack(v,p.stack,n)
			assert(v)
			level -= 1
			if level == level1: return False</t>
<t tx="ekr.20040305165846.53">def moveToThreadNext (self):
	
	"""Move a position to the next a position in threading order."""
	
	p = self

	if p:
		if p.v.t._firstChild:
			p.moveToFirstChild()
		elif p.v._next:
			p.moveToNext()
		else:
			p.moveToParent()
			while p:
				if p.v._next:
					p.moveToNext()
					break #found
				p.moveToParent()
			# not found found.
				
	return p</t>
<t tx="ekr.20040305165846.54">def moveToVisBack (self):
	
	"""Move a position to the position of the previous visible node."""

	p = self
	
	if p:
		p.moveToThreadBack()
		while p and not p.isVisible(): # v.isVisible no longer exists.
			p.moveToThreadBack()
			
	return p</t>
<t tx="ekr.20040305165846.55">def moveToVisNext (self):
	
	"""Move a position to the position of the next visible node."""

	p = self
	
	if p:
		p.moveToThreadNext()
		while p and not p.isVisible(): # v.isVisible no longer exists.
			p.moveToThreadNext()
			
	return p</t>
<t tx="ekr.20040305165846.56"></t>
<t tx="ekr.20040305165846.57"># Using this routine can generate huge numbers of temporary positions during a tree traversal.

def copy (self):
	
	""""Return an independent copy of a position."""

	return position(self.v,self.stack)</t>
<t tx="ekr.20040305165846.58">def isVisible (self):
	
	"""Return True if all of a position's parents are expanded."""
	
	# Note: v.isVisible no longer exists.
	
	p = self
	if not p:
		return False
		
	# Avoid calling p.copy() or copying the stack.
	v = p.v ; n = len(p.stack)-1

	v,n = p.vParentWithStack(v,p.stack,n)
	while v:
		if not v.isExpanded():
			return False
		v,n = p.vParentWithStack(v,p.stack,n)

	return True</t>
<t tx="ekr.20040305165846.59">def level(self):
	
	p = self ; level = 0
	
	if not p:
		return level
	
	# Avoid calling p.copy() or copying the stack.
	v = p.v ; n = len(p.stack)-1

	while 1:
		assert(p)
		v,n = p.vParentWithStack(v,p.stack,n)
		# g.trace(level,"len(stack): %2d" % n,v)
		if v:
			level += 1
		else:
			return level</t>
<t tx="ekr.20040305165846.60"># A crucial utility method.
# The p.level(), p.isVisible() and p.hasThreadNext() methods show how to use this method.

&lt;&lt; about the vParentWithStack utility method &gt;&gt;

def vParentWithStack(self,v,stack,n):
	
	"""A utility that allows the computation of p.v without calling p.copy().
	
	v,stack[:n] correspond to p.v,p.stack for some intermediate position p.

	Returns (v,n) such that v,stack[:n] correpond to the parent position of p."""

	if not v:
		return None,n
	elif v._parent:
		return v._parent,n # don't change stack.
	elif stack and n &gt;= 0:
		return self.stack[n],n-1 # simulate popping the stack.
	else:
		return None,n</t>
<t tx="ekr.20040305165846.61">@ 
This method allows us to simulate calls to p.parent() without generating any intermediate data.

For example, the code below will compute the same values for list1 and list2:

# The first way depends on the call to p.copy:
list1 = []
p=p.copy() # odious.
while p:
	p = p.moveToParent()
	if p: list1.append(p.v)
# The second way uses p.vParentWithStack to avoid all odious intermediate data.

list2 = []
n = len(p.stack)-1
v,n = p.vParentWithStack(v,p.stack,n)
while v:
	list2.append(v)
	v,n = p.vParentWithStack(v,p.stack,n)

</t>
<t tx="ekr.20040305171318"></t>
<t tx="ekr.20040305174003">@others</t>
<t tx="ekr.20040305174003.1">class allNodes_iter_class:

	"""Returns a list of positions in the entire outline."""

	@others

def allNodes_iter (self):
	return self.allNodes_iter_class(self)</t>
<t tx="ekr.20040305174003.2">def __init__(self,p):

	if g.sharedNodes:
		self.first = p.c.rootPosition()
	else:
		self.first = p.c.rootVnode()

	self.p = None
	
def __iter__(self):
	return self</t>
<t tx="ekr.20040305174003.3">def next(self):
	
	if self.first:
		self.p = self.first
		self.first = None

	elif self.p:
		if g.sharedNodes:
			self.p.moveToThreadNext()
		else:
			self.p = self.p.threadNext()

	if self.p: return self.p
	else: raise StopIteration</t>
<t tx="ekr.20040305174003.4">class subtree_iter_class:

	"""Returns a list of positions in a subtree, including the root of the subtree."""

	@others

def subtree_iter (self):
	return self.subtree_iter_class(self)</t>
<t tx="ekr.20040305174003.5">def __init__(self,p):
	
	if g.sharedNodes:
		self.first = p.copy()
		self.after = p.copy().moveToNodeAfterTree()
	else:
		self.first = p.v
		self.after = p.v and p.v.nodeAfterTree()

	self.p = None
	
def __iter__(self):
	return self
</t>
<t tx="ekr.20040305174003.6">def next(self):
	
	if self.first:
		self.p = self.first
		self.first = None

	elif self.p:
		if g.sharedNodes:
			self.p.moveToThreadNext()
		else:
			self.p = self.p.threadNext()

	if self.p and self.p != self.after:
		return self.p
	else:
		raise StopIteration
</t>
<t tx="ekr.20040305174003.7">class children_iter_class:

	"""Returns a list of positions in the entire outline."""

	@others

def children_iter (self):
	return self.children_iter_class(self)</t>
<t tx="ekr.20040305174003.8">def __init__(self,p):

	if g.sharedNodes:
		self.first = p.copy().moveToFirstChild()
	else:
		self.first = p.v and p.v.firstChild()

	self.p = None

def __iter__(self):
	return self</t>
<t tx="ekr.20040305174003.9">def next(self):
	
	if self.first:
		self.p = self.first
		self.first = None

	elif self.p:
		if g.sharedNodes:
			self.p.moveToNext()
		else:
			self.p = self.p.next()

	if self.p: return self.p
	else: raise StopIteration</t>
<t tx="ekr.20040305174003.10">class parents_iter_class:

	"""Returns a list of positions in the entire outline."""

	@others

def parents_iter (self):
	return self.parents_iter_class(self)</t>
<t tx="ekr.20040305174003.11">def __init__(self,p):

	if g.sharedNodes:
		self.first = p.copy().moveToParent()
	else:
		self.first = p.v and p.v.parent()
		
	self.p = None

def __iter__(self):
	return self</t>
<t tx="ekr.20040305174003.12">def next(self):
	
	if self.first:
		self.p = self.first
		self.first = None

	elif self.p:
		if g.sharedNodes:
			self.p.moveToParent()
		else:
			self.p = self.p.parent()

	if self.p: return self.p
	else: raise StopIteration</t>
<t tx="ekr.20040305174003.13">class siblings_iter_class:

	"""Returns a list of positions in the entire outline."""

	@others

def siblings_iter (self):
	return self.siblings_iter_class(self)</t>
<t tx="ekr.20040305174003.14">def __init__(self,p):

	if g.sharedNodes:
		p = p.copy()
		while p.hasBack():
			p.moveToBack()
		self.first = p
	else:
		v = p.v
		while v.back():
			v = v.back()
		self.first = v

	self.p = None

def __iter__(self):
	return self</t>
<t tx="ekr.20040305174003.15">def next(self):
	
	if self.first:
		self.p = self.first
		self.first = None

	elif self.p:
		if g.sharedNodes:
			self.p.moveToNext()
		else:
			self.p = self.p.next()

	if self.p: return self.p
	else: raise StopIteration</t>
</tnodes>
</leo_file>
