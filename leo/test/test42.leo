<?xml version="1.0" encoding="UTF-8"?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="2821" clone_windows="0"/>
<globals body_outline_ratio="0.4370860927152318">
	<global_window_position top="54" left="366" height="755" width="891"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences>
</preferences>
<find_panel_settings>
	<find_string></find_string>
	<change_string></change_string>
</find_panel_settings>
<vnodes>
<v t="ekr.20040303080938"><vh>Diary</vh>
<v t="ekr.20040315210314"><vh>March 2004</vh>
<v t="ekr.20040315210314.1"><vh>3/15: Created stubs for Find Commands tests</vh></v>
<v t="ekr.20040315210314.2"><vh>3/15: Convert this file to 4.2 format</vh></v>
<v t="ekr.20040309095121"><vh>3/9: created more position mini tests</vh></v>
<v t="ekr.20040303080938.1"><vh>3/3: created position tests</vh></v>
</v>
</v>
<v t="ekr.20040303062846"><vh>Unit Testing</vh>
<v t="ekr.20040303062846.1"><vh>To do</vh></v>
<v t="ekr.20040126105605"><vh>Clone test data</vh>
<v t="ekr.20040302092753"><vh>aa</vh></v>
<v t="ekr.20040126105605.2"><vh>a</vh>
<v t="ekr.20040126105605.3"><vh>b</vh>
<v t="ekr.20040301191933"><vh>c</vh>
<v t="ekr.20040302092753.1"><vh>c2</vh>
<v t="ekr.20040302092753.2"><vh>c3</vh></v>
<v t="ekr.20040302092753.3"><vh>c4</vh></v>
</v>
</v>
</v>
<v t="ekr.20040126105605.3"><vh>b</vh>
<v t="ekr.20040301191933"><vh>c</vh>
<v t="ekr.20040302092753.1"><vh>c2</vh>
<v t="ekr.20040302092753.2"><vh>c3</vh></v>
<v t="ekr.20040302092753.3"><vh>c4</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20040301191933.1"><vh>d</vh>
<v t="ekr.20040126105605.2"><vh>a</vh>
<v t="ekr.20040126105605.3"><vh>b</vh>
<v t="ekr.20040301191933"><vh>c</vh>
<v t="ekr.20040302092753.1"><vh>c2</vh>
<v t="ekr.20040302092753.2"><vh>c3</vh></v>
<v t="ekr.20040302092753.3"><vh>c4</vh></v>
</v>
</v>
</v>
<v t="ekr.20040126105605.3"><vh>b</vh>
<v t="ekr.20040301191933"><vh>c</vh>
<v t="ekr.20040302092753.1"><vh>c2</vh>
<v t="ekr.20040302092753.2"><vh>c3</vh></v>
<v t="ekr.20040302092753.3"><vh>c4</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20040301191933.2"><vh>e</vh></v>
<v t="ekr.20040302092753.4"><vh>z</vh></v>
</v>
<v t="ekr.20040303062846.2" tnodeList="ekr.20040303062846.2,ekr.20040303062846.3,ekr.20040303062846.4,ekr.20040303062846.5,ekr.20040303062846.6,ekr.20040303062846.7,ekr.20040303062846.8,ekr.20040303062846.10,ekr.20040303062846.12,ekr.20040303062846.13,ekr.20040303062846.14,ekr.20040303062846.15,ekr.20040303062846.16,ekr.20040303062846.17,ekr.20040303062846.18,ekr.20040303062846.20,ekr.20040303062846.21,ekr.20040303062846.22,ekr.20040303062846.23,ekr.20040303062846.24,ekr.20040303062846.25,ekr.20040303062846.26,ekr.20040315202250,ekr.20040315202314,ekr.20040315202314.1,ekr.20040315202347,ekr.20040315202718,ekr.20040315202718.1,ekr.20040303062846.28,ekr.20040303062846.29,ekr.20040303062846.30,ekr.20040303062846.31,ekr.20040303062846.32,ekr.20040303062846.33,ekr.20040303062846.34,ekr.20040303062846.35,ekr.20040303062846.37,ekr.20040303062846.38,ekr.20040303062846.39,ekr.20040303062846.40,ekr.20040303062846.41,ekr.20040303062846.42,ekr.20040303062846.64,ekr.20040303062846.65,ekr.20040303062846.66,ekr.20040303062846.67,ekr.20040303062846.68,ekr.20040303062846.69,ekr.20040303062846.70,ekr.20040303062846.71,ekr.20040303062846.73,ekr.20040303062846.74,ekr.20040303062846.75,ekr.20040303062846.76,ekr.20040303062846.77,ekr.20040303062846.78,ekr.20040303062846.79,ekr.20040303064013,ekr.20040303063118,ekr.20040303063118.4,ekr.20040309105731,ekr.20040309101454.15,ekr.20040309101454.17,ekr.20040309101454.13,ekr.20040303064020.5,ekr.20040309101454.16,ekr.20040309101454.14,ekr.20040303064020.7,ekr.20040303091606,ekr.20040303092153,ekr.20040303092153.1,ekr.20040303064020.6,ekr.20040303062846.80,ekr.20040303062846.81,ekr.20040303062846.82,ekr.20040303062846.83,ekr.20040303062846.84,ekr.20040303062846.85,ekr.20040303062846.86,ekr.20040303062846.87,ekr.20040303062846.88,ekr.20040303062846.89,ekr.20040303062846.90,ekr.20040303062846.91,ekr.20040303062846.92,ekr.20040303062846.93,ekr.20040303062846.94,ekr.20040303062846.95,ekr.20040303062846.96,ekr.20040303062846.97,ekr.20040303062846.98,ekr.20040303062846.99,ekr.20040303062846.100,ekr.20040303062846.101,ekr.20040303062846.102,ekr.20040303062846.103,ekr.20040303062846.104"><vh>@file ..\src\leoTest.py</vh>
<v t="ekr.20040303062846.3"><vh> class testUtils</vh>
<v t="ekr.20040303062846.4"><vh>compareOutlines</vh></v>
<v t="ekr.20040303062846.5"><vh>findChildrenOf &amp; findSubnodesOf (revise)</vh></v>
<v t="ekr.20040303062846.6"><vh>findNodeInRootTree, findNodeInTree, findNodeAnywhere</vh></v>
<v t="ekr.20040303062846.7"><vh>numberOfNodesInOutline, numberOfClonesInOutline</vh></v>
<v t="ekr.20040303062846.8"><vh>replaceOutline</vh></v>
</v>
<v t="ekr.20040303062846.10"><vh> fail</vh></v>
<v t="ekr.20040303062846.11"><vh>Colorizer tests</vh>
<v t="ekr.20040303062846.12"><vh> makeColorSuite</vh></v>
<v t="ekr.20040303062846.13"><vh>class colorTestCase</vh>
<v t="ekr.20040303062846.14"><vh>__init__</vh></v>
<v t="ekr.20040303062846.15"><vh>color</vh></v>
<v t="ekr.20040303062846.16"><vh>setUp</vh></v>
<v t="ekr.20040303062846.17"><vh>tearDown</vh></v>
<v t="ekr.20040303062846.18"><vh>runTest</vh></v>
</v>
</v>
<v t="ekr.20040303062846.19"><vh>Edit body tests</vh>
<v t="ekr.20040303062846.20"><vh> makeEditBodySuite</vh></v>
<v t="ekr.20040303062846.21"><vh>class editBodyTestCase</vh>
<v t="ekr.20040303062846.22"><vh>__init__</vh></v>
<v t="ekr.20040303062846.23"><vh>editBody</vh></v>
<v t="ekr.20040303062846.24"><vh>tearDown</vh></v>
<v t="ekr.20040303062846.25" a="M"><vh>setUp</vh></v>
<v t="ekr.20040303062846.26"><vh>runTest</vh></v>
</v>
</v>
<v t="ekr.20040315202201"><vh>Find Command tests</vh>
<v t="ekr.20040315202250"><vh> makeFindCommandSuite</vh></v>
<v t="ekr.20040315202314"><vh>class findCommandTestCase</vh>
<v t="ekr.20040315202314.1"><vh>setUp</vh></v>
<v t="ekr.20040315202347"><vh>testFindCommand</vh></v>
<v t="ekr.20040315202718"><vh>testFindWordCommand</vh></v>
<v t="ekr.20040315202718.1"><vh>testFindIgnoreCaseCommand</vh></v>
</v>
</v>
<v t="ekr.20040303062846.27"><vh>Import/Export tests</vh>
<v t="ekr.20040303062846.28"><vh>makeImportExportSuite</vh></v>
<v t="ekr.20040303062846.29"><vh>class importExportTestCase</vh>
<v t="ekr.20040303062846.30"><vh>__init__</vh></v>
<v t="ekr.20040303062846.31"><vh>importExport</vh></v>
<v t="ekr.20040303062846.32"><vh>runTest</vh></v>
<v t="ekr.20040303062846.33"><vh>setUp</vh></v>
<v t="ekr.20040303062846.34"><vh>shortDescription</vh></v>
<v t="ekr.20040303062846.35"><vh>tearDown</vh></v>
</v>
</v>
<v t="ekr.20040303062846.36"><vh>LeoFiles tests</vh>
<v t="ekr.20040303062846.37"><vh>makeTestLeoFilesSuite</vh></v>
<v t="ekr.20040303062846.38"><vh>class leoFileTestCase</vh>
<v t="ekr.20040303062846.39"><vh>__init__</vh></v>
<v t="ekr.20040303062846.40"><vh>runTest</vh></v>
<v t="ekr.20040303062846.41"><vh>setUp</vh></v>
<v t="ekr.20040303062846.42"><vh>tearDown</vh></v>
</v>
</v>
<v t="ekr.20040303062846.63"><vh>Outline tests</vh>
<v t="ekr.20040303062846.64"><vh> makeOutlineSuite</vh></v>
<v t="ekr.20040303062846.65"><vh>class outlineTestCase</vh>
<v t="ekr.20040303062846.66"><vh>__init__</vh></v>
<v t="ekr.20040303062846.67"><vh>outlineCommand</vh></v>
<v t="ekr.20040303062846.68"><vh>runTest</vh></v>
<v t="ekr.20040303062846.69"><vh>setUp</vh></v>
<v t="ekr.20040303062846.70"><vh>tearDown</vh></v>
<v t="ekr.20040303062846.71"><vh> makePluginsSuite</vh></v>
</v>
</v>
<v t="ekr.20040303062846.72"><vh>Plugin tests</vh>
<v t="ekr.20040303062846.73"><vh>class pluginTestCase</vh>
<v t="ekr.20040303062846.74"><vh>__init__</vh></v>
<v t="ekr.20040303062846.75"><vh>pluginTest</vh></v>
<v t="ekr.20040303062846.76"><vh>runTest</vh></v>
<v t="ekr.20040303062846.77"><vh>setUp</vh></v>
<v t="ekr.20040303062846.78"><vh>shortDescription</vh></v>
<v t="ekr.20040303062846.79"><vh>tearDown</vh></v>
</v>
</v>
<v t="ekr.20040303063644"><vh>Position tests</vh>
<v t="ekr.20040303064013"><vh> makePositionSuite</vh></v>
<v t="ekr.20040303063118"><vh>class positionTestCase</vh>
<v t="ekr.20040303063118.4"><vh>setUp</vh></v>
<v t="ekr.20040309105731"><vh>testComparisons</vh></v>
<v t="ekr.20040312101853"><vh>Consistency tests...</vh>
<v t="ekr.20040309101454.15"><vh>testConsistencyOfAllNodesThreadNext</vh></v>
<v t="ekr.20040309101454.17"><vh>testConsistencyOfFirstChildAndChildrenIter</vh></v>
<v t="ekr.20040309101454.13"><vh>testConsistencyOfLevel</vh></v>
<v t="ekr.20040303064020.5"><vh>testConsistencyOfNextBack</vh></v>
<v t="ekr.20040309101454.16"><vh>testConsistencyOfParentAndParentsIter</vh></v>
<v t="ekr.20040309101454.14"><vh>testConsistencyOfParentChild</vh></v>
<v t="ekr.20040303064020.7"><vh>testConsistencyOfThreadBackNext</vh></v>
<v t="ekr.20040303091606"><vh>testHasNextBack</vh></v>
<v t="ekr.20040303092153"><vh>testHasParentChild</vh></v>
<v t="ekr.20040303092153.1"><vh>testHasThreadNextBack</vh></v>
<v t="ekr.20040303064020.6"><vh>testVnodeList</vh></v>
</v>
</v>
</v>
<v t="ekr.20040303062846.80"><vh>Reformat Paragraph tests</vh>
<v t="ekr.20040303062846.81"><vh>makeReformatParagraphSuite</vh></v>
<v t="ekr.20040303062846.82"><vh>class reformatParagraphTestCase</vh>
<v t="ekr.20040303062846.83"><vh>setUp</vh></v>
<v t="ekr.20040303062846.84"><vh>tearDown</vh></v>
<v t="ekr.20040303062846.85"><vh>testNoTrailingNewline</vh></v>
<v t="ekr.20040303062846.86"><vh>testTrailingNewline</vh></v>
<v t="ekr.20040303062846.87"><vh>testMixedLineLengths</vh></v>
<v t="ekr.20040303062846.88"><vh>testMixedLinesWithLeadingWS</vh></v>
<v t="ekr.20040303062846.89"><vh>testNoChangeRequired</vh></v>
<v t="ekr.20040303062846.90"><vh>testHonorLeadingWS</vh></v>
<v t="ekr.20040303062846.91"><vh>testHonorLeadingWSVar1</vh></v>
<v t="ekr.20040303062846.92"><vh>testSimpleHangingIndent</vh></v>
<v t="ekr.20040303062846.93"><vh>testSimpleHangingIndentVar1</vh></v>
<v t="ekr.20040303062846.94"><vh>testSimpleHangingIndentVar2</vh></v>
<v t="ekr.20040303062846.95"><vh>testMultiParagraph</vh></v>
<v t="ekr.20040303062846.96"><vh>testMultiParagraphWithList</vh></v>
<v t="ekr.20040303062846.97"><vh>testDirectiveBreaksParagraph</vh></v>
<v t="ekr.20040303062846.98"><vh>testWithLeadingWSOnEmptyLines</vh></v>
<v t="ekr.20040303062846.99"><vh>singleParagraphTest</vh></v>
<v t="ekr.20040303062846.100"><vh>checkPosition</vh></v>
<v t="ekr.20040303062846.101"><vh>checkText</vh></v>
<v t="ekr.20040303062846.102"><vh>copyBeforeToTemp</vh></v>
<v t="ekr.20040303062846.103"><vh>getCaseDataNodes</vh></v>
<v t="ekr.20040303062846.104"><vh>getRowCol</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20040303063549"><vh>Unit Tests (Tests must be run from inside this tree!)</vh>
<v t="ekr.20040309101454"><vh> To do</vh></v>
<v t="ekr.20040303063549.1"><vh>tempNode</vh></v>
<v t="ekr.20040303063549.45"><vh>colorizerTests</vh>
<v t="ekr.20040303063549.46"><vh>Actionscript</vh></v>
<v t="ekr.20040303063549.47"><vh>C</vh></v>
<v t="ekr.20040303063549.48"><vh>C#</vh></v>
<v t="ekr.20040303063549.49"><vh>CWEB</vh>
<v t="ekr.20040303063549.50"><vh>&lt;&lt; section ref &gt;&gt;</vh></v>
</v>
<v t="ekr.20040303063549.51"><vh>elisp</vh></v>
<v t="ekr.20040303063549.52"><vh>HTML1</vh></v>
<v t="ekr.20040303063549.53"><vh>HTML2</vh></v>
<v t="ekr.20040303063549.54"><vh>LaTex</vh></v>
<v t="ekr.20040303063549.55"><vh>Mixed</vh></v>
<v t="ekr.20040303063549.56"><vh>PHP</vh></v>
<v t="ekr.20040303063549.57"><vh>Python1</vh></v>
<v t="ekr.20040303063549.58"><vh>Python2</vh></v>
<v t="ekr.20040303063549.59"><vh>Rebol</vh></v>
<v t="ekr.20040303063549.60"><vh>wikiTest1</vh></v>
<v t="ekr.20040303063549.61"><vh>wikiTest2</vh></v>
<v t="ekr.20040303063549.62"><vh>wikiTest3</vh></v>
</v>
<v t="ekr.20040303063549.63"><vh>editBodyTests</vh>
<v t="ekr.20040303063549.64"><vh>dedentBody</vh>
<v t="ekr.20040303063549.65"><vh>before</vh></v>
<v t="ekr.20040303063549.66"><vh>after</vh></v>
<v t="ekr.20040303063549.67"><vh>selection</vh></v>
</v>
<v t="ekr.20040303063549.68"><vh>indentBody</vh>
<v t="ekr.20040303063549.69"><vh>before</vh></v>
<v t="ekr.20040303063549.70"><vh>after</vh></v>
<v t="ekr.20040303063549.71"><vh>selection</vh></v>
</v>
<v t="ekr.20040303063549.72"><vh>extractSection</vh>
<v t="ekr.20040303063549.73"><vh>before</vh></v>
<v t="ekr.20040303063549.74"><vh>after</vh>
<v t="ekr.20040303063549.75"><vh>&lt;&lt; section &gt;&gt;</vh></v>
</v>
<v t="ekr.20040303063549.76"><vh>selection</vh></v>
</v>
</v>
<v t="ekr.20040303063549.77"><vh>exportTests</vh>
<v t="ekr.20040303063549.78"><vh>exportHeadlines</vh>
<v t="ekr.20040303063549.79"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.80"><vh>flattenOutline</vh>
<v t="ekr.20040303063549.81"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.82"><vh>weave</vh>
<v t="ekr.20040303063549.83"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.84"><vh>outlineToNoweb</vh>
<v t="ekr.20040303063549.85"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.86"><vh>outlineToCWEB</vh>
<v t="ekr.20040303063549.87"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.88"><vh>removeSentinels</vh>
<v t="ekr.20040303063549.89"><vh>dialog</vh></v>
</v>
</v>
<v t="ekr.20040303063549.120" a="M"><vh>fileTests</vh>
<v t="ekr.20040303063549.121"><vh>c:\prog\leoCvs\leo\test\test.leo</vh></v>
<v t="ekr.20040303063549.122"><vh>c:\prog\leoCvs\leo\src\LeoPy.leo</vh></v>
<v t="ekr.20040303063549.123"><vh>c:\prog\leoCvs\leo\plugins\leoPlugins.leo</vh></v>
<v t="ekr.20040303063549.124"><vh>c:\prog\leoCvs\leo\doc\LeoDocs.leo</vh></v>
</v>
<v t="ekr.20040315202718.2" a="M"><vh>findTests</vh></v>
<v t="ekr.20040303063549.90"><vh>importTests</vh>
<v t="ekr.20040303063549.91"><vh>importAtRoot</vh>
<v t="ekr.20040303063549.92"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.93"><vh>importAtFile</vh>
<v t="ekr.20040303063549.94"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.95"><vh>importNowebFiles</vh>
<v t="ekr.20040303063549.96"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.97"><vh>importFlattenedOutline</vh>
<v t="ekr.20040303063549.98"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.99"><vh>importCWEBFiles</vh>
<v t="ekr.20040303063549.100"><vh>dialog</vh></v>
</v>
</v>
<v t="ekr.20040303063549.101"><vh>outlineTests</vh>
<v t="ekr.20040303063549.102"><vh>moveOutlineDown</vh>
<v t="ekr.20040303063549.103"><vh>before</vh>
<v t="ekr.20040303063549.104"><vh>a</vh></v>
<v t="ekr.20040303063549.105"><vh>move</vh></v>
<v t="ekr.20040303063549.106"><vh>b</vh></v>
</v>
<v t="ekr.20040303063549.107"><vh>after</vh>
<v t="ekr.20040303063549.108"><vh>a</vh></v>
<v t="ekr.20040303063549.109"><vh>b</vh></v>
<v t="ekr.20040303063549.110"><vh>move</vh></v>
</v>
<v t="ekr.20040303063549.111"><vh>ref</vh>
<v t="ekr.20040303063549.112"><vh>a</vh></v>
<v t="ekr.20040303063549.113"><vh>move</vh></v>
<v t="ekr.20040303063549.114"><vh>b</vh></v>
</v>
</v>
<v t="ekr.20040303063549.115"><vh>moveOutlineLeft</vh></v>
<v t="ekr.20040303063549.116"><vh>moveOutlineRight</vh></v>
<v t="ekr.20040303063549.117"><vh>moveOutlineUp</vh></v>
</v>
<v t="ekr.20040303063549.118"><vh>pluginsTests</vh></v>
<v t="ekr.20040303063549.119" a="M"><vh>positionTests</vh></v>
<v t="ekr.20040303063549.2"><vh>reformatParagraphsTests</vh>
<v t="ekr.20040303063549.3"><vh>testNoTrailingNewline</vh>
<v t="ekr.20040303063549.4"><vh>before</vh></v>
<v t="ekr.20040303063549.5"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.6"><vh>testTrailingNewline</vh>
<v t="ekr.20040303063549.7"><vh>before</vh></v>
<v t="ekr.20040303063549.8"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.9"><vh>testMixedLineLengths</vh>
<v t="ekr.20040303063549.10"><vh>before</vh></v>
<v t="ekr.20040303063549.11"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.12"><vh>testMixedLinesWithLeadingWS</vh>
<v t="ekr.20040303063549.13"><vh>before</vh></v>
<v t="ekr.20040303063549.14"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.15"><vh>testNoChangeRequired</vh>
<v t="ekr.20040303063549.16"><vh>before</vh></v>
<v t="ekr.20040303063549.17"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.18"><vh>testHonorLeadingWS</vh>
<v t="ekr.20040303063549.19"><vh>before</vh></v>
<v t="ekr.20040303063549.20"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.21"><vh>testHonorLeadingWSVar1</vh>
<v t="ekr.20040303063549.22"><vh>before</vh></v>
<v t="ekr.20040303063549.23"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.24"><vh>testSimpleHangingIndent</vh>
<v t="ekr.20040303063549.25"><vh>before</vh></v>
<v t="ekr.20040303063549.26"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.27"><vh>testSimpleHangingIndentVar1</vh>
<v t="ekr.20040303063549.28"><vh>before</vh></v>
<v t="ekr.20040303063549.29"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.30"><vh>testSimpleHangingIndentVar2</vh>
<v t="ekr.20040303063549.31"><vh>before</vh></v>
<v t="ekr.20040303063549.32"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.33"><vh>testMultiParagraph</vh>
<v t="ekr.20040303063549.34"><vh>before</vh></v>
<v t="ekr.20040303063549.35"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.36"><vh>testMultiParagraphWithList</vh>
<v t="ekr.20040303063549.37"><vh>before</vh></v>
<v t="ekr.20040303063549.38"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.39"><vh>testDirectiveBreaksParagraph</vh>
<v t="ekr.20040303063549.40"><vh>before</vh></v>
<v t="ekr.20040303063549.41"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.42"><vh>testWithLeadingWSOnEmptyLines</vh>
<v t="ekr.20040303063549.43"><vh>before</vh></v>
<v t="ekr.20040303063549.44"><vh>after</vh></v>
</v>
</v>
<v t="ekr.20040303063549.125"><vh>Run all tests</vh></v>
<v t="ekr.20040303080010" a="M"><vh>Run all tests except files tests</vh></v>
</v>
<v t="ekr.20040311111734" a="M" tnodeList="ekr.20040311111734,ekr.20040311111734.1,ekr.20040311111734.2,ekr.20040311111734.3"><vh>@file c:\prog\test\leo42test.txt</vh>
<v t="ekr.20040311111734.1"><vh>&lt;&lt; node one &gt;&gt;</vh></v>
<v t="ekr.20040311111734.2"><vh>node a</vh></v>
<v t="ekr.20040311111734.3"><vh>node b</vh></v>
</v>
<v t="ekr.20040303071432"><vh>Mini tests, scripts &amp; experiments</vh>
<v t="ekr.20040309091917"><vh>To do</vh></v>
<v t="ekr.20040312101720"><vh>Experiments</vh>
<v t="ekr.20040302091705"><vh>Test of moving positions</vh></v>
</v>
<v t="ekr.20040312101720.1"><vh>Mini tests</vh>
<v t="ekr.20040309111054"><vh>Print iterations: do not delete</vh>
<v t="ekr.20040309111102"><vh>Clone test data</vh>
<v t="ekr.20040309111102.1"><vh>aa</vh></v>
<v t="ekr.20040309111102.2"><vh>a</vh>
<v t="ekr.20040309111102.3"><vh>b</vh>
<v t="ekr.20040309111102.4"><vh>c</vh>
<v t="ekr.20040309111102.5"><vh>c2</vh>
<v t="ekr.20040309111102.6"><vh>c3</vh></v>
<v t="ekr.20040309111102.7"><vh>c4</vh></v>
</v>
</v>
</v>
<v t="ekr.20040309111102.3"><vh>b</vh>
<v t="ekr.20040309111102.4"><vh>c</vh>
<v t="ekr.20040309111102.5"><vh>c2</vh>
<v t="ekr.20040309111102.6"><vh>c3</vh></v>
<v t="ekr.20040309111102.7"><vh>c4</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20040309111102.8"><vh>d</vh>
<v t="ekr.20040309111102.2"><vh>a</vh>
<v t="ekr.20040309111102.3"><vh>b</vh>
<v t="ekr.20040309111102.4"><vh>c</vh>
<v t="ekr.20040309111102.5"><vh>c2</vh>
<v t="ekr.20040309111102.6"><vh>c3</vh></v>
<v t="ekr.20040309111102.7"><vh>c4</vh></v>
</v>
</v>
</v>
<v t="ekr.20040309111102.3"><vh>b</vh>
<v t="ekr.20040309111102.4"><vh>c</vh>
<v t="ekr.20040309111102.5"><vh>c2</vh>
<v t="ekr.20040309111102.6"><vh>c3</vh></v>
<v t="ekr.20040309111102.7"><vh>c4</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20040309111102.9"><vh>e</vh></v>
<v t="ekr.20040309111102.10"><vh>z</vh></v>
</v>
<v t="ekr.20040309111232"><vh>last node</vh></v>
</v>
<v t="ekr.20040311125054"><vh>Test that p.t == p.v.t</vh></v>
<v t="ekr.20040310145919"><vh>Change python keywords</vh></v>
</v>
<v t="ekr.20040312021734"><vh>Testing scripts</vh>
<v t="ekr.20040311090054"><vh>Dump fileIndex</vh></v>
<v t="ekr.20040312021734.1"><vh>Script to clean unused tnodeLists</vh></v>
</v>
<v t="ekr.20040315030123"><vh>test convertTreeToString and allies</vh>
<v t="ekr.20040315025315"><vh>File Conversion</vh>
<v t="ekr.20040315025315.1"><vh>convertTreeToString</vh></v>
<v t="ekr.20040315025315.2"><vh>moreHead</vh></v>
<v t="ekr.20040315025315.3"><vh>moreBody</vh></v>
</v>
</v>
</v>
<v t="ekr.20040317101155" a="TV"><vh>Test of user icons</vh></v>
<v t="ekr.20040317173327"><vh>Delete user icons</vh></v>
</vnodes>
<tnodes>
<t tx="ekr.20040126105605"></t>
<t tx="ekr.20040126105605.2"></t>
<t tx="ekr.20040126105605.3"></t>
<t tx="ekr.20040301191933"></t>
<t tx="ekr.20040301191933.1"></t>
<t tx="ekr.20040301191933.2"></t>
<t tx="ekr.20040302091705">from leoGlobals import *

class position:
	def __init__(self):
		self.v = "a"
	def move(self):
		self.v = "b"

p = position()
v = p.v
print "before", v, p.v, v is p.v
p.move()
print "after ", v, p.v, v is p.v</t>
<t tx="ekr.20040302092753"></t>
<t tx="ekr.20040302092753.1"></t>
<t tx="ekr.20040302092753.2"></t>
<t tx="ekr.20040302092753.3"></t>
<t tx="ekr.20040302092753.4"></t>
<t tx="ekr.20040303062846"># Run the unit tests in test.leo using the Execute Script command.</t>
<t tx="ekr.20040303062846.1">@nocolor

- Have log classes increment a count.
	Can be used to ensure that messages did or did not occcur.

- Have the nullGui create a nullUndoer by default
	But allow the possibility of leaving the full undoer in place.

- More checks in CheckOutline command.

- (done by hand) batch mode.
	Have script create a file, fail if the file does not exist.

- Unit tests for read/write commands.</t>
<t tx="ekr.20040303062846.2">"""

Unit tests for Leo.

Run the unit tests in test.leo using the Execute Script command.

"""

import leoGlobals as g
from leoGlobals import true,false

import leoColor,leoCommands,leoFrame,leoGui,leoNodes,leoTkinterGui

import glob,os,sys,unittest

@others</t>
<t tx="ekr.20040303062846.3">class testUtils:
	
	"""Common utility routines used by unit tests."""

	@others</t>
<t tx="ekr.20040303062846.4">def compareOutlines (self,root1,root2):
	
	"""Compares two outlines, making sure that their topologies,
	content and join lists are equivent"""
	
	v1,v2 = root1,root2
	after1 = v1.nodeAfterTree()
	after2 = v2.nodeAfterTree()
	v1 = v1.firstChild()
	v2 = v2.firstChild()
	ok = true
	while v2 and v1 != after1 and v2 != after2:
		ok = (
		v1.numberOfChildren() == v2.numberOfChildren() and
		v1.headString() == v2.headString() and
		v1.bodyString() == v2.bodyString() and
		v1.isCloned()   == v2.isCloned()   )
		if not ok: break
		v1 = v1.threadNext()
		v2 = v2.threadNext()

	ok = ok and v1 == after1 and v2 == after2
	if not ok:
		g.trace(v1,v2)
	return ok</t>
<t tx="ekr.20040303062846.5">def findChildrenOf (self,headline):
	
	u = self ; c = g.top() ; v = c.currentVnode()
	root = u.findRootNode(v)
	parent = u.findNodeInTree(root,headline)
	v = parent.firstChild()
	vList = []
	while v:
		vList.append(v)
		v = v.next()
	return vList

def findSubnodesOf (self,headline):
	
	u = self ; c = g.top() ; v = c.currentVnode()
	root = u.findRootNode(v)
	parent = u.findNodeInTree(root,headline)
	v = parent.firstChild()
	vList = []
	after = parent.nodeAfterTree()
	while v and v != after:
		vList.append(v)
		v = v.threadNext()
	return vList
</t>
<t tx="ekr.20040303062846.6">def findRootNode (self,p):

	"""Return the root of v's tree."""

	while p and p.hasParent():
		p.moveToParent()
	return p

def findNodeInTree(self,p,headline):

	"""Search for a node in v's tree matching the given headline."""
	
	c = p.c
	for p in p.subtree_iter():
		if p.headString().strip() == headline.strip():
			return p
	return c.nullPosition()

def findNodeAnywhere(self,c,headline):
	
	for p in c.allNodes_iter():
		if p.headString().strip() == headline.strip():
			return p.copy()
	return c.nullPosition()</t>
<t tx="ekr.20040303062846.7">def numberOfNodesInOutline (self):
	
	"""Returns the total number of nodes in an outline"""
	
	c = g.top() ; n = 0
	for p in c.allNodes_iter():
		n += 1
	return n
	
def numberOfClonesInOutline (self):
	
	"""Returns the number of cloned nodes in an outline"""

	c = g.top() ; n = 0
	for p in c.allNodes_iter():
		if v.isCloned():
			n += 1
	return n</t>
<t tx="ekr.20040303062846.8">def replaceOutline (self,c,outline1,outline2):
	
	u = self
	
	"""Replace outline1 by a copy of outline 2 if not equal."""
	
	g.trace()
	
	copy = outline2.copyTreeWithNewTnodes()
	copy.linkAfter(outline1)
	outline1.doDelete(newVnode=copy)</t>
<t tx="ekr.20040303062846.10">def fail ():
	
	"""Mark a unit test as having failed."""
	
	g.app.unitTestDict["fail"] = callerName(2)</t>
<t tx="ekr.20040303062846.11"></t>
<t tx="ekr.20040303062846.12">def makeColorSuite(testParentHeadline,tempHeadline):
	
	"""Create a colorizer test for every descendant of testParentHeadline.."""
	
	u = testUtils() ; c = g.top() ; v = c.currentVnode()
	root = u.findRootNode(v)
	temp_v = u.findNodeInTree(root,tempHeadline)
	vList = u.findSubnodesOf(testParentHeadline)
	
	# Create the suite and add all test cases.
	suite = unittest.makeSuite(unittest.TestCase)
	for v in vList:
		test = colorTestCase(c,v,temp_v)
		suite.addTest(test)

	return suite
</t>
<t tx="ekr.20040303062846.13">class colorTestCase(unittest.TestCase):
	
	"""Data-driven unit tests for Leo's colorizer."""
	
	@others</t>
<t tx="ekr.20040303062846.14">def __init__ (self,c,v,temp_v):
	
	# Init the base class.
	unittest.TestCase.__init__(self)

	self.c = c
	self.v = v
	self.temp_v = temp_v
	
	self.old_v = c.currentVnode()</t>
<t tx="ekr.20040303062846.15">def color (self):
	
	c = self.c
	val = c.frame.body.colorizer.colorize(self.temp_v,incremental=false)
	assert(val=="ok")</t>
<t tx="ekr.20040303062846.16">def setUp(self,*args,**keys):

	# g.trace(args,keys)

	# Initialize the text in the temp node.
	text = self.v.bodyString()
	self.c.selectVnode(self.temp_v)
	self.temp_v.setTnodeText(text,g.app.tkEncoding)
	self.c.frame.body.setSelectionAreas(None,text,None)</t>
<t tx="ekr.20040303062846.17">def tearDown (self):
	
	self.temp_v.setTnodeText("",g.app.tkEncoding)
	self.c.selectVnode(self.old_v)</t>
<t tx="ekr.20040303062846.18">def runTest(self):

	self.color()</t>
<t tx="ekr.20040303062846.19"></t>
<t tx="ekr.20040303062846.20">def makeEditBodySuite(testParentHeadline,tempHeadline):
	
	"""Create an Edit Body test for every descendant of testParentHeadline.."""
	
	u = testUtils() ; c = g.top() ; v = c.currentVnode()
	root = u.findRootNode(v)
	temp_v = u.findNodeInTree(root,tempHeadline)
	vList = u.findChildrenOf(testParentHeadline)

	# Create the suite and add all test cases.
	suite = unittest.makeSuite(unittest.TestCase)
	for v in vList:
		before = u.findNodeInTree(v,"before")
		after  = u.findNodeInTree(v,"after")
		sel    = u.findNodeInTree(v,"selection")
		ins    = u.findNodeInTree(v,"insert")
		if before and after:
			test = editBodyTestCase(c,v,before,after,sel,ins,temp_v)
			suite.addTest(test)
		else:
			print 'missing "before" or "after" for', v.headString()

	return suite
</t>
<t tx="ekr.20040303062846.21">class editBodyTestCase(unittest.TestCase):
	
	"""Data-driven unit tests for Leo's edit body commands."""
	
	@others</t>
<t tx="ekr.20040303062846.22">def __init__ (self,c,parent,before,after,sel,ins,temp_v):
	
	# Init the base class.
	unittest.TestCase.__init__(self)

	self.c = c
	self.parent = parent
	self.before = before
	self.after  = after
	self.sel    = sel # Two lines giving the selection range in tk coordinates.
	self.ins    = ins # One line giveing the insert point in tk coordinate.
	self.temp_v = temp_v
	
	self.old_v = c.currentVnode()
	
	self.wasChanged = c.changed</t>
<t tx="ekr.20040303062846.23">def editBody (self):
	
	c = self.c ; temp_v = self.temp_v ; after = self.after

	# Compute the result in temp_v.bodyString()
	commandName = self.parent.headString()
	command = getattr(c,commandName)
	command()
	
	# Compare the computed result to the reference result.
	new_text = temp_v.bodyString().rstrip()
	ref_text = after.bodyString().rstrip()

	if new_text != ref_text:
		print ; print "test failed", commandName
		g.trace("new",new_text)
		g.trace("ref",ref_text)
		
	assert(new_text == ref_text)
	
	# Compare subtrees.
	
	assert(temp_v.numberOfChildren() == after.numberOfChildren())
	
	ref_child = after.firstChild()
	new_child = temp_v.firstChild()
	
	while new_child:
		new_text = new_child.bodyString().rstrip()
		ref_text = ref_child.bodyString().rstrip()

		if new_text != ref_text:
			print ; print "test failed", commandName
			g.trace("new",new_text)
			g.trace("ref",ref_text)
		
		assert(new_text == ref_text)
		
		new_child = new_child.next()
		ref_child = ref_child.next()</t>
<t tx="ekr.20040303062846.24">def tearDown (self):
	
	c = self.c ; temp_v = self.temp_v
	
	temp_v.setTnodeText("",g.app.tkEncoding)
	temp_v.clearDirty()
	
	if not self.wasChanged:
		c.setChanged (false)
		
	# Delete all children of temp node.
	while temp_v.firstChild():
		temp_v.firstChild().doDelete(temp_v)

	c.selectVnode(self.old_v)</t>
<t tx="ekr.20040303062846.25"># Warning: this is Tk-specific code.

def setUp(self,*args,**keys):
	
	c = self.c ; temp_v = self.temp_v
	
	# Delete all children of temp node.
	while temp_v.firstChild():
		temp_v.firstChild().doDelete(temp_v)

	text = self.before.bodyString()
	
	temp_v.setTnodeText(text,g.app.tkEncoding)
	c.selectVnode(self.temp_v)
	
	t = c.frame.body.bodyCtrl
	if self.sel:
		s = str(self.sel.bodyString()) # Can't be unicode.
		lines = s.split('\n')
		g.app.gui.setTextSelection(t,lines[0],lines[1])

	if self.ins:
		s = str(self.ins.bodyString()) # Can't be unicode.
		lines = s.split('\n')
		g.trace(lines)
		g.app.gui.setInsertPoint(t,lines[0])
		
	if not self.sel and not self.ins:
		g.app.gui.setInsertPoint(t,"1.0")
		g.app.gui.setTextSelection(t,"1.0","1.0")</t>
<t tx="ekr.20040303062846.26">def runTest(self):

	self.editBody()</t>
<t tx="ekr.20040303062846.27"></t>
<t tx="ekr.20040303062846.28">def makeImportExportSuite(testParentHeadline,tempHeadline):
	
	"""Create an Import/Export test for every descendant of testParentHeadline.."""
	
	u = testUtils() ; c = g.top() ; v = c.currentVnode()
	root = u.findRootNode(v)
	temp_v = u.findNodeInTree(root,tempHeadline)
	vList = u.findChildrenOf(testParentHeadline)

	# Create the suite and add all test cases.
	suite = unittest.makeSuite(unittest.TestCase)
	for v in vList:
		dialog = u.findNodeInTree(v,"dialog")
		test = importExportTestCase(c,v,dialog,temp_v)
		suite.addTest(test)

	return suite
</t>
<t tx="ekr.20040303062846.29">class importExportTestCase(unittest.TestCase):
	
	"""Data-driven unit tests for Leo's edit body commands."""
	
	@others</t>
<t tx="ekr.20040303062846.30">def __init__ (self,c,v,dialog,temp_v):
	
	# Init the base class.
	unittest.TestCase.__init__(self)
	
	self.c = c
	self.dialog = dialog
	self.v = v
	self.temp_v = temp_v
	
	self.gui = None
	self.wasChanged = c.changed
	self.fileName = ""

	self.old_v = c.currentVnode()

</t>
<t tx="ekr.20040303062846.31">def importExport (self):
	
	c = self.c ; v = self.v
	
	g.app.unitTestDict = {}

	commandName = v.headString()
	command = getattr(c,commandName) # Will fail if command does not exist.
	command()

	failedMethod = g.app.unitTestDict.get("fail")
	self.failIf(failedMethod,failedMethod)</t>
<t tx="ekr.20040303062846.32">def runTest(self):
	
	# """Import Export Test Case"""

	self.importExport()</t>
<t tx="ekr.20040303062846.33">def setUp(self,*args,**keys):
	
	c = self.c ; temp_v = self.temp_v ; d = self.dialog
	
	temp_v.setTnodeText('',g.app.tkEncoding)

	# Create a node under temp_v.
	child = temp_v.insertAsLastChild()
	assert(child)
	child.setHeadString("import test: " + self.v.headString())
	c.selectVnode(child)

	assert(d)
	s = d.bodyString()
	lines = s.split('\n')
	name = lines[0]
	val = lines[1]
	self.fileName = val
	dict = {name: val}
	self.gui = leoGui.unitTestGui(dict,trace=false)
	
	</t>
<t tx="ekr.20040303062846.34">def shortDescription (self):
	
	try:
		return "ImportExportTestCase: %s %s" % (self.v.headString(),self.fileName)
	except:
		return "ImportExportTestCase"</t>
<t tx="ekr.20040303062846.35">def tearDown (self):
	
	c = self.c ; temp_v = self.temp_v
	
	if self.gui:
		self.gui.destroySelf()
		self.gui = None
	
	temp_v.setTnodeText("",g.app.tkEncoding)
	temp_v.clearDirty()
	
	if not self.wasChanged:
		c.setChanged (false)
		
	if 1: # Delete all children of temp node.
		while temp_v.firstChild():
			temp_v.firstChild().doDelete(temp_v)

	c.selectVnode(self.old_v)</t>
<t tx="ekr.20040303062846.36"></t>
<t tx="ekr.20040303062846.37">def makeTestLeoFilesSuite(testParentHeadline,unused=None):
	
	"""Create a .leo file test for every descendant of testParentHeadline.."""
	
	u = testUtils() ; c = g.top()
	
	vList = u.findChildrenOf(testParentHeadline)

	# Create the suite and add all test cases.
	suite = unittest.makeSuite(unittest.TestCase)
	for v in vList:
		test = leoFileTestCase(c,v.headString().strip())
		suite.addTest(test)

	return suite

</t>
<t tx="ekr.20040303062846.38">class leoFileTestCase(unittest.TestCase):
	
	"""Data-driven unit tests to test .leo files."""
	
	@others</t>
<t tx="ekr.20040303062846.39">def __init__ (self,c,fileName):
	
	# Init the base class.
	unittest.TestCase.__init__(self)

	self.old_c = c
	self.c = None # set by setUp.
	self.fileName = fileName
	self.gui = None # set by setUp
	self.openFrames = g.app.windowList[:]</t>
<t tx="ekr.20040303062846.40">def runTest(self):
	
	"""Run the Check Outline command."""

	errors = self.c.checkOutline(verbose=false,unittest=true)
	assert(errors == 0)</t>
<t tx="ekr.20040303062846.41">def setUp(self):

	"""Open the .leo file."""
	

	c = self.old_c ; fileName = self.fileName
	assert(g.os_path_exists(fileName))
	
	self.oldGui = g.app.gui
	# g.app.gui = leoGui.nullGui("nullGui")

	ok, frame = g.openWithFileName(fileName,c,enableLog=false)
	assert(ok)
	self.c = frame.c</t>
<t tx="ekr.20040303062846.42">def tearDown (self):

	"""Close the .leo file if it was not already open."""

	frame = self.c.frame
	if frame not in self.openFrames:
		g.app.closeLeoWindow(frame)

	g.app.gui = self.oldGui</t>
<t tx="ekr.20040303062846.63"></t>
<t tx="ekr.20040303062846.64">def makeOutlineSuite(testParentHeadline,unused=None):
	
	"""Create an outline test for every descendant of testParentHeadline.."""
	
	u = testUtils() ; c = g.top() ; v = c.currentVnode()
	
	vList = u.findChildrenOf(testParentHeadline)

	# Create the suite and add all test cases.
	suite = unittest.makeSuite(unittest.TestCase)
	for v in vList:
		before = u.findNodeInTree(v,"before")
		after  = u.findNodeInTree(v,"after")
		ref    = u.findNodeInTree(v,"ref")
		if before and after and ref:
			test = outlineTestCase(c,v,before,after,ref)
			suite.addTest(test)

	return suite
</t>
<t tx="ekr.20040303062846.65">class outlineTestCase(unittest.TestCase):
	
	"""Data-driven unit tests for Leo's outline commands."""
	
	@others</t>
<t tx="ekr.20040303062846.66">def __init__ (self,c,parent,before,after,ref):
	
	# Init the base class.
	unittest.TestCase.__init__(self)

	self.c = c
	self.parent = parent
	self.before = before
	self.after = after
	self.ref    = ref
	
	self.old_v = c.currentVnode()
	
	self.u = testUtils()</t>
<t tx="ekr.20040303062846.67">def outlineCommand (self):
	
	c = self.c ; u = self.u ; tree = c.frame.tree
	
	move = u.findNodeInTree(self.before,"move")
	assert(move)
	
	c.selectVnode(move)
	
	commandName = self.parent.headString()
	command = getattr(c,commandName)
	command()

	assert(u.compareOutlines(self.before,self.after))
	c.undoer.undo()
	assert(u.compareOutlines(self.before,self.ref))
	c.undoer.redo()
	assert(u.compareOutlines(self.before,self.after))
	c.undoer.undo()
	assert(u.compareOutlines(self.before,self.ref))</t>
<t tx="ekr.20040303062846.68">def runTest(self):

	self.outlineCommand()</t>
<t tx="ekr.20040303062846.69">def setUp(self,*args,**keys):

	assert(self.before)
	assert(self.after)
	assert(self.ref)
	assert(self.u.compareOutlines(self.before,self.ref))
	
	# Batch mode bugs: meaning of move may depend on visibility.
	self.parent.parent().expand()
	self.parent.expand()
	self.before.expand()
	self.after.expand()</t>
<t tx="ekr.20040303062846.70">def tearDown (self):

	c = self.c ; u = self.u

	if not u.compareOutlines(self.before,self.ref):
		u.replaceOutline(c,self.before,self.ref)

	self.before.contract()
	self.after.contract()
	self.parent.contract()
	self.parent.parent().contract()

	self.c.selectVnode(self.old_v)</t>
<t tx="ekr.20040303062846.71">def makePluginsSuite(verbose=false,*args,**keys):
	
	"""Create an plugins test for every .py file in the plugins directory."""
	
	plugins_path = g.os_path_join(g.app.loadDir,"..","plugins")
	
	files = glob.glob(g.os_path_join(plugins_path,"*.py"))
	files = [g.os_path_abspath(file) for file in files]
	files.sort()

	# Create the suite and add all test cases.
	suite = unittest.makeSuite(unittest.TestCase)
	
	for file in files:
		test = pluginTestCase(file,verbose)
		suite.addTest(test)

	return suite
</t>
<t tx="ekr.20040303062846.72"></t>
<t tx="ekr.20040303062846.73">class pluginTestCase(unittest.TestCase):
	
	"""Unit tests for one Leo plugin."""
	
	@others</t>
<t tx="ekr.20040303062846.74">def __init__ (self,fileName,verbose):
	
	# Init the base class.
	unittest.TestCase.__init__(self)

	self.fileName = fileName
	self.oldGui = None
	self.verbose = verbose</t>
<t tx="ekr.20040303062846.75">def pluginTest (self):
	
	# Duplicate the import logic in leoPlugins.py.
	
	fileName = g.toUnicode(self.fileName,g.app.tkEncoding)
	path = g.os_path_join(g.app.loadDir,"..","plugins")
	
	if self.verbose:
		g.trace(str(shortFileName(fileName)))

	module = importFromPath(fileName,path)
	assert(module)
	
	# Run any unit tests in the module itself.
	if hasattr(module,"unitTest"):
		
		if self.verbose:
			g.trace("Executing unitTest in %s..." % str(shortFileName(fileName)))

		module.unitTest()</t>
<t tx="ekr.20040303062846.76">def runTest(self):

	self.pluginTest()</t>
<t tx="ekr.20040303062846.77">def setUp(self,*args,**keys):

	self.oldGui = g.app.gui
	# g.app.gui = leoTkinterGui.tkinterGui()</t>
<t tx="ekr.20040303062846.78">def shortDescription (self):
	
	return "pluginTestCase: " + self.fileName</t>
<t tx="ekr.20040303062846.79">def tearDown (self):

	g.app.gui = self.oldGui</t>
<t tx="ekr.20040303062846.80"># DTHEIN 2004.01.11: Added unit tests for reformatParagraph</t>
<t tx="ekr.20040303062846.81"># DTHEIN 2004.01.11: Added method
def makeReformatParagraphSuite():
	
	"""makeReformatParagraphSuite() -&gt; suite
	
	Create a Reformat Paragraph test for each of the 
	unit tests in the reformatParagraphTestCase class."""
	
	suite = unittest.TestSuite()
	suite.addTest(reformatParagraphTestCase("testNoTrailingNewline"))
	suite.addTest(reformatParagraphTestCase("testTrailingNewline"))
	suite.addTest(reformatParagraphTestCase("testMixedLineLengths"))
	suite.addTest(reformatParagraphTestCase("testMixedLinesWithLeadingWS"))
	suite.addTest(reformatParagraphTestCase("testNoChangeRequired"))
	suite.addTest(reformatParagraphTestCase("testHonorLeadingWS"))
	suite.addTest(reformatParagraphTestCase("testHonorLeadingWSVar1"))
	suite.addTest(reformatParagraphTestCase("testSimpleHangingIndent"))
	suite.addTest(reformatParagraphTestCase("testSimpleHangingIndentVar1"))
	suite.addTest(reformatParagraphTestCase("testSimpleHangingIndentVar2"))
	suite.addTest(reformatParagraphTestCase("testMultiParagraph"))
	suite.addTest(reformatParagraphTestCase("testMultiParagraphWithList"))
	suite.addTest(reformatParagraphTestCase("testDirectiveBreaksParagraph"))
	suite.addTest(reformatParagraphTestCase("testWithLeadingWSOnEmptyLines"))
	return suite
	#	suite = reformatParagraphTestCase().suite();
	#return suite</t>
<t tx="ekr.20040303062846.82"># DTHEIN 2004.01.11: Added class
class reformatParagraphTestCase(unittest.TestCase):
	
	"""Unit tests for Leo's reformat paragraph command."""
	
	@others</t>
<t tx="ekr.20040303062846.83"># DTHEIN 2004.01.11: Added method
def setUp(self):

	self.u = testUtils()
	self.c = g.top()
	self.current_v = self.c.currentVnode()
	self.old_v = self.c.currentVnode()
	root = self.u.findRootNode(self.current_v)
	self.temp_v = self.u.findNodeInTree(root,"tempNode")
	self.tempChild_v = None
	self.dataParent_v = self.u.findNodeInTree(root,"reformatParagraphsTests")
	self.before_v = None
	self.after_v = None
	self.case_v = None
	self.wasChanged = self.c.changed
	


</t>
<t tx="ekr.20040303062846.84"># DTHEIN 2004.01.11: Added method
def tearDown(self):
	
	# local variables for class fields, for ease
	# of reading and ease of typeing.
	#	
	c = self.c ; temp_v = self.temp_v
	
	# clear the temp node and mark it unchanged
	#
	temp_v.setTnodeText("",g.app.tkEncoding)
	temp_v.clearDirty()
	
	if not self.wasChanged:
		c.setChanged (false)
		
	# Delete all children of temp node.
	#
	while temp_v.firstChild():
		temp_v.firstChild().doDelete(temp_v)

	# make the original node the current node
	#
	c.selectVnode(self.old_v)</t>
<t tx="ekr.20040303062846.85"># DTHEIN 2004.01.11: Added method
def testNoTrailingNewline(self):
	
	self.singleParagraphTest("testNoTrailingNewline",2,24)
</t>
<t tx="ekr.20040303062846.86"># DTHEIN 2004.01.11: Added method
def testTrailingNewline(self):
	
	self.singleParagraphTest("testTrailingNewline",3,0)
</t>
<t tx="ekr.20040303062846.87"># DTHEIN 2004.01.11: Added method
def testMixedLineLengths(self):
	
	self.singleParagraphTest("testMixedLineLengths",4,10)
</t>
<t tx="ekr.20040303062846.88"># DTHEIN 2004.01.11: Added method
def testMixedLinesWithLeadingWS(self):
	
	self.singleParagraphTest("testMixedLinesWithLeadingWS",4,12)
</t>
<t tx="ekr.20040303062846.89"># DTHEIN 2004.01.11: Added method
def testNoChangeRequired(self):
	
	self.singleParagraphTest("testNoChangeRequired",1,28)
</t>
<t tx="ekr.20040303062846.90"># DTHEIN 2004.01.11: Added method
def testHonorLeadingWS(self):
	
	self.singleParagraphTest("testHonorLeadingWS",5,16)
</t>
<t tx="ekr.20040303062846.91"># DTHEIN 2004.01.11: Added method
def testHonorLeadingWSVar1(self):
	
	self.singleParagraphTest("testHonorLeadingWSVar1",5,16)
</t>
<t tx="ekr.20040303062846.92"># DTHEIN 2004.01.11: Added method
def testSimpleHangingIndent(self):
	
	self.singleParagraphTest("testSimpleHangingIndent",5,8)
</t>
<t tx="ekr.20040303062846.93"># DTHEIN 2004.01.11: Added method
def testSimpleHangingIndentVar1(self):
	
	self.singleParagraphTest("testSimpleHangingIndentVar1",5,8)
</t>
<t tx="ekr.20040303062846.94"># DTHEIN 2004.01.11: Added method
def testSimpleHangingIndentVar2(self):
	
	self.singleParagraphTest("testSimpleHangingIndentVar2",5,8)
</t>
<t tx="ekr.20040303062846.95"># DTHEIN 2004.01.11: Added method
def testMultiParagraph(self):
	
	# Locate the test data
	#
	self.getCaseDataNodes("testMultiParagraph")
	
	# Setup the temp node
	#
	self.copyBeforeToTemp()
	
	# reformat the paragraph and check insertion cursor position
	#
	self.c.reformatParagraph()
	self.checkPosition(13,0)
	
	# Keep going, in the same manner
	#
	self.c.reformatParagraph()
	self.checkPosition(25,0)
	self.c.reformatParagraph()
	self.checkPosition(32,11)
	
	# Compare the computed result to the reference result.
	self.checkText()
</t>
<t tx="ekr.20040303062846.96"># DTHEIN 2004.01.11: Added method
def testMultiParagraphWithList(self):
	
	# Locate the test data
	#
	self.getCaseDataNodes("testMultiParagraphWithList")
	
	# Setup the temp node
	#
	self.copyBeforeToTemp()
	
	# reformat the paragraph and check insertion cursor position
	#
	self.c.reformatParagraph()
	self.checkPosition(4,0)
	
	# Keep going, in the same manner
	#
	self.c.reformatParagraph()
	self.checkPosition(7,0)
	self.c.reformatParagraph()
	self.checkPosition(10,0)
	self.c.reformatParagraph()
	self.checkPosition(13,0)
	self.c.reformatParagraph()
	self.checkPosition(14,18)
	
	# Compare the computed result to the reference result.
	self.checkText()
</t>
<t tx="ekr.20040303062846.97"># DTHEIN 2004.01.11: Added method
def testDirectiveBreaksParagraph(self):
	
	# Locate the test data
	#
	self.getCaseDataNodes("testDirectiveBreaksParagraph")
	
	# Setup the temp node
	#
	self.copyBeforeToTemp()
	
	# reformat the paragraph and check insertion cursor position
	#
	self.c.reformatParagraph()
	self.checkPosition(13,0) # at next paragraph
	
	# Keep going, in the same manner
	#
	self.c.reformatParagraph()
	self.checkPosition(25,0) # at next paragraph

	self.c.reformatParagraph()
	self.checkPosition(32,11)
	
	# Compare the computed result to the reference result.
	self.checkText()
</t>
<t tx="ekr.20040303062846.98"># DTHEIN 2004.01.11: Added method
def testWithLeadingWSOnEmptyLines(self):
	
	# Locate the test data
	#
	self.getCaseDataNodes("testWithLeadingWSOnEmptyLines")
	
	# Setup the temp node
	#
	self.copyBeforeToTemp()
	
	# reformat the paragraph and check insertion cursor position
	#
	self.c.reformatParagraph()
	self.checkPosition(4,0)
	
	# Keep going, in the same manner
	#
	self.c.reformatParagraph()
	self.checkPosition(7,0)
	self.c.reformatParagraph()
	self.checkPosition(10,0)
	self.c.reformatParagraph()
	self.checkPosition(13,0)
	self.c.reformatParagraph()
	self.checkPosition(14,18)
	
	# Compare the computed result to the reference result.
	self.checkText()
</t>
<t tx="ekr.20040303062846.99"># DTHEIN 2004.01.11: Added method
def singleParagraphTest(self,caseName,finalRow,finalCol):
	
	# Locate the test data
	#
	self.getCaseDataNodes(caseName)
	
	# Setup the temp node
	#
	self.copyBeforeToTemp()
	
	# reformat the paragraph
	#
	self.c.reformatParagraph()
	
	# Compare the computed result to the reference result.
	self.checkText()
	self.checkPosition(finalRow,finalCol)

</t>
<t tx="ekr.20040303062846.100"># DTHEIN 2004.01.11: Added method
def checkPosition(self,expRow,expCol):

	row,col = self.getRowCol()
	self.failUnlessEqual(expCol,col,
		"Current position is (" + str(row) + "," + str(col) 
		+ ");  expected cursor to be at column " + str(expCol) + ".")
	self.failUnlessEqual(expRow,row,
		"Current position is (" + str(row) + "," + str(col) 
		+ ");  expected cursor to be at line " + str(expRow) + ".")
</t>
<t tx="ekr.20040303062846.101"># DTHEIN 2004.01.11: Added method
def checkText(self):

	new_text = self.tempChild_v.bodyString()
	ref_text = self.after_v.bodyString()
	newLines = new_text.splitlines(1)
	refLines = ref_text.splitlines(1)
	newLinesCount = len(newLines)
	refLinesCount = len(refLines)
	for i in range(min(newLinesCount,refLinesCount)):
		self.failUnlessEqual(newLines[i],refLines[i],
			"Mismatch on line " + str(i) + "."
			+ "\nExpected text: " + `refLines[i]`
			+ "\n  Actual text: "	+ `newLines[i]`)
	self.failUnlessEqual(newLinesCount,refLinesCount,
		"Expected " + str(refLinesCount) + " lines, but "
		+ "received " + str(newLinesCount) + " lines.")</t>
<t tx="ekr.20040303062846.102"># DTHEIN 2004.01.11: Added method
# Warning: this is Tk-specific code.
#
def copyBeforeToTemp(self):

	# local variables for class fields, for ease
	# of reading and ease of typeing.
	#	
	c = self.c ; temp_v = self.temp_v

	# Delete all children of temp node.
	#
	while temp_v.firstChild():
		temp_v.firstChild().doDelete(temp_v)

	# Copy the test case node text to the temp node
	#
	text = self.case_v.bodyString()
	temp_v.setTnodeText(text,g.app.tkEncoding)
	
	# create the child node that holds the text
	#
	t = leoNodes.tnode(headString="tempChildNode")
	self.tempChild_v = self.temp_v.insertAsNthChild(0,t)

	# copy the before text to the temp text
	#
	text = self.before_v.bodyString()
	self.tempChild_v.setTnodeText(text,g.app.tkEncoding)
	
	# make the temp child node current, and put the
	# cursor at the beginning
	#
	c.selectVnode(self.tempChild_v)
	c.frame.body.setInsertPointToStartOfLine( 0 )
	c.frame.body.setTextSelection(None,None)
	#g.app.gui.setInsertPoint(t,"1.0")
	#g.app.gui.setTextSelection(t,"1.0","1.0")
</t>
<t tx="ekr.20040303062846.103"># DTHEIN 2004.01.11: Added method
def getCaseDataNodes(self,caseNodeName):

	self.case_v = self.u.findNodeInTree(self.dataParent_v,caseNodeName)
	self.before_v = self.u.findNodeInTree(self.case_v,"before")
	self.after_v  = self.u.findNodeInTree(self.case_v,"after")
</t>
<t tx="ekr.20040303062846.104"># DTHEIN 2004.01.11: Added method
def getRowCol(self):
	
	# local variables for class fields, for ease
	# of reading and ease of typeing.
	#	
	c = self.c ; body = c.frame.body.bodyCtrl ; gui = g.app.gui
	tab_width = c.frame.tab_width

	# Get the Tkinter row col position of the insert cursor
	#	
	index = body.index("insert")
	row,col = gui.getindex(body,index)
	
	# Adjust col position for tabs
	#
	if col &gt; 0:
		s = body.get("%d.0" % (row),index)
		s = g.toUnicode(s,g.app.tkEncoding)
		col = g.computeWidth(s,tab_width)

	return (row,col)
</t>
<t tx="ekr.20040303063118">class positionTestCase(unittest.TestCase):
	
	"""Unit tests for Leo's position class."""
	
	@others</t>
<t tx="ekr.20040303063118.4">def setUp(self,*args,**keys):
	
	import leoGlobals as g
	
	self.c = c = g.top()

	self.verbose = true
	
	self.root = c.rootPosition()</t>
<t tx="ekr.20040303063549"></t>
<t tx="ekr.20040303063549.1"></t>
<t tx="ekr.20040303063549.2">@ 
# DTHEIN 2004.01.11: Added script

Each child node will in turn have two or more children:
	
- a "before" node
- an "after" node

The parent to before and after nodes will contain pagewidth
and language formatting directives
@c

import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

suite = leoTest.makeReformatParagraphSuite()
result = unittest.TestResult()
runner = unittest.TextTestRunner()
runner.run(suite)</t>
<t tx="ekr.20040303063549.3">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Wrap a long line, no trailing newline.
</t>
<t tx="ekr.20040303063549.4">This line is over forty characters long, at least it seems to be.</t>
<t tx="ekr.20040303063549.5">This line is over forty characters long,
at least it seems to be.</t>
<t tx="ekr.20040303063549.6">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Wrap a long line, with trailing newline.
</t>
<t tx="ekr.20040303063549.7">This line is over forty characters long, at least it seems to be.
</t>
<t tx="ekr.20040303063549.8">This line is over forty characters long,
at least it seems to be.
</t>
<t tx="ekr.20040303063549.9">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Wrap a long line and some short ones.</t>
<t tx="ekr.20040303063549.10">This line is over forty characters long, at least it seems to be.
This is shorter, 
but should be part of the same
paragraph.</t>
<t tx="ekr.20040303063549.11">This line is over forty characters long,
at least it seems to be. This is
shorter, but should be part of the same
paragraph.</t>
<t tx="ekr.20040303063549.12">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Wrap a paragraph with interior lines that have leading white space.</t>
<t tx="ekr.20040303063549.13">This line is over forty characters long, at least it seems to be.
  This indented line should be merged into the same
paragraph.</t>
<t tx="ekr.20040303063549.14">This line is over forty characters long,
  at least it seems to be. This indented
  line should be merged into the same
  paragraph.</t>
<t tx="ekr.20040303063549.15">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

No wrapping required, so don't change a thing.</t>
<t tx="ekr.20040303063549.16">This line is under 40 chars.</t>
<t tx="ekr.20040303063549.17">This line is under 40 chars.</t>
<t tx="ekr.20040303063549.18">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Honor the first line's leading whitespace.</t>
<t tx="ekr.20040303063549.19">   This line is over forty characters long, at least it seems to be.
   This is shorter, 
but should be part of the same
paragraph.  And this is indented 3 characters.</t>
<t tx="ekr.20040303063549.20">   This line is over forty characters
   long, at least it seems to be. This
   is shorter, but should be part of the
   same paragraph. And this is indented
   3 characters.</t>
<t tx="ekr.20040303063549.21">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Honor the first and second line's leading whitespace.</t>
<t tx="ekr.20040303063549.22">   This line is over forty characters long, at least it seems to be.
   This is shorter, 
     but should be part of the same
     paragraph.  And this is indented 3 characters.</t>
<t tx="ekr.20040303063549.23">   This line is over forty characters
   long, at least it seems to be. This
   is shorter, but should be part of the
   same paragraph. And this is indented
   3 characters.</t>
<t tx="ekr.20040303063549.24">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Single paragraph, hanging indentation.</t>
<t tx="ekr.20040303063549.25">Honor this line that has a hanging indentation, please.  Hanging
  indentation is valuable for lists of all kinds.  But it is tricky to get right.</t>
<t tx="ekr.20040303063549.26">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.</t>
<t tx="ekr.20040303063549.27">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Single paragraph, hanging indentation with other indentation beyond line 2.</t>
<t tx="ekr.20040303063549.28">Honor this line that has
  a hanging indentation, please.  Hanging
    indentation is valuable for lists of all kinds.  But it is tricky to get right.</t>
<t tx="ekr.20040303063549.29">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.</t>
<t tx="ekr.20040303063549.30">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Single paragraph, hanging indentation, short lines, extraneous indentation, and last line uses a tab for whitespace.</t>
<t tx="ekr.20040303063549.31">Honor this line that 
  has a hanging indentation, 
  please.  Hanging
   indentation is valuable
    for lists of all kinds.  But 
	it is tricky to get right.</t>
<t tx="ekr.20040303063549.32">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.</t>
<t tx="ekr.20040303063549.33">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Mutliple long lined paragraphs.  Cursor should move to next paragraph after formatting a paragraph.</t>
<t tx="ekr.20040303063549.34">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20040303063549.35">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property– before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?</t>
<t tx="ekr.20040303063549.36">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

A regular paragraph, plus a numbered list of several items, plus a final regular paragraph.  Cursor should move to next paragraph after formatting a paragraph.
</t>
<t tx="ekr.20040303063549.37">This paragraph leads of this test.  It is the "lead"
paragraph.

  1. This is item 
     number 1.  It is the first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.</t>
<t tx="ekr.20040303063549.38">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test. It is the
"final" paragraph.</t>
<t tx="ekr.20040303063549.39">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Test to make sure that reformatting treats directives as a new paragraph and doesn't wrap directive lines.
</t>
<t tx="ekr.20040303063549.40">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.
@unknownDirective
Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.
@unknownDirective
StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20040303063549.41">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.
@unknownDirective
Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property– before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.
@unknownDirective
StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?</t>
<t tx="ekr.20040303063549.42">@language plain
@pagewidth 40
@tabwidth 8

Ran into a problem with the wrapping
eating blank lines that delimit
paragraphs if those blank lines have any
leading whitespace. This test is to make
sure that still works.

If you "show invisibles" you'll see the
leading whitespace in the blank lines --
which is different from the
"testMultiParagraphWithList" test.</t>
<t tx="ekr.20040303063549.43">This paragraph leads of this test.  It is the "lead"
paragraph.
  
  1. This is item 
     number 1.  It is the first item in the list.
  
  2. This is item 
     number 2.  It is the second item in the list.
  
  3. This is item 
     number 3.  It is the third item in the list.
  
This paragraph ends the test.  It is the "final"
paragraph.</t>
<t tx="ekr.20040303063549.44">This paragraph leads of this test. It is
the "lead" paragraph.
  
  1. This is item number 1. It is the
     first item in the list.
  
  2. This is item number 2. It is the
     second item in the list.
  
  3. This is item number 3. It is the
     third item in the list.
  
This paragraph ends the test. It is the
"final" paragraph.</t>
<t tx="ekr.20040303063549.45">@color

import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

suite = leoTest.makeColorSuite("colorizerTests","tempNode")
runner = unittest.TextTestRunner()
runner.run(suite)</t>
<t tx="ekr.20040303063549.46">@language actionscript

break
call, continue
delete, do
else
false, for, function
goto
if, in
new, null
return
true, typeof
undefined
var, void, while, with
#include
catch, constructor
prototype
this, try
_parent, _root, __proto__
// Jeeze hasn't anyone ever heard of namespaces??
ASnative, abs, acos, appendChild, asfunction, asin, atan, atan2, attachMovie, attachSound, attributes
BACKSPACE
CAPSLOCK, CONTROL, ceil, charAt, charCodeAt, childNodes, chr, cloneNode, close, concat, connect, cos, createElement, createTextNode
DELETEKEY, DOWN, docTypeDecl, duplicateMovieClip
END, ENTER, ESCAPE, enterFrame, entry, equal, eval, evaluate, exp
firstChild, floor, fromCharCode, fscommand, getAscii
getBeginIndex, getBounds, getBytesLoaded, getBytesTotal, getCaretIndex, getCode, getDate, getDay, getEndIndex, getFocus, getFullYear, getHours, getMilliseconds, getMinutes, getMonth, getPan, getProperty, getRGB, getSeconds, getTime, getTimer, getTimezoneOffset, getTransform, getURL, getUTCDate, getUTCDay, getUTCFullYear, getUTCHours, getUTCMilliseconds, getUTCMinutes, getUTCMonth, getUTCSeconds, getVersion, getVolume, getYear, globalToLocal, gotoAndPlay, gotoAndStop
HOME, haschildNodes, hide, hitTest
INSERT, Infinity, ifFrameLoaded, ignoreWhite, indexOf, insertBefore, int, isDown, isFinite, isNaN, isToggled
join
keycode, keyDown, keyUp
LEFT, LN10, LN2, LOG10E, LOG2E, lastChild, lastIndexOf, length, load, loaded, loadMovie, loadMovieNum, loadVariables, loadVariablesNum, localToGlobal, log
MAX_VALUE, MIN_VALUE, max, maxscroll, mbchr, mblength, mbord, mbsubstring, min, 
NEGATIVE_INFINITY, NaN, newline, nextFrame, nextScene, nextSibling, nodeName, nodeType, nodeValue
on, onClipEvent, onClose, onConnect, onData, onLoad, onXML, ord
PGDN, PGUP, PI, POSITIVE_INFINITY, parentNode, parseFloat, parseInt, parseXML, play, pop, pow, press, prevFrame, previousSibling, prevScene, print, printAsBitmap, printAsBitmapNum, printNum, push
RIGHT, random, release, removeMovieClip, removeNode, reverse, round
SPACE, SQRT1_2, SQRT2, scroll, send, sendAndLoad, set, setDate, setFocus, setFullYear, setHours, setMilliseconds, setMinutes, setMonth, setPan, setProperty, setRGB, setSeconds, setSelection, setTime, setTransform, setUTCDate, setUTCFullYear, setUTCHours, setUTCMilliseconds, setUTCMinutes, setUTCMonth, setUTCSeconds, setVolume, setYear, shift, show, sin, slice, sort, start, startDrag, status, stop, stopAllSounds, stopDrag, substr, substring, swapDepths, splice, split, sqrt
TAB, tan, targetPath, tellTarget, toggleHighQuality, toLowerCase, toString, toUpperCase, trace
UP, UTC, unescape, unloadMovie, unLoadMovieNum, unshift, updateAfterEvent
valueOf
xmlDecl, _alpha
_currentframe
_droptarget
_focusrect, _framesloaded
_height, _highquality
_name
_quality
_rotation
_soundbuftime
_target, _totalframes
_url
_visible
_width
_x, _xmouse, _xscale
_y, _ymouse, _yscale
and, add, eq, ge, gt, le, lt, ne, not, or, Array, Boolean, Color, Date, Key, Math, MovieClip, Mouse, Number, Object, Selection, Sound, String, XML, XMLSocket</t>
<t tx="ekr.20040303063549.47">@language c
@comment /* */

@
@c

#define WIPEOUT 0 /* 
                   * Causes database card number &amp; flags to be set to zero. 
                   * This is so I don't need an infinite supply of cards!
                   */
// Not colored (because of @language /* */)
#include "equ.h"
#include "cmn.h"
#include "ramdef.h"
#include "eeprom.h"
#include &lt;hpc_ram.h&gt;
#include &lt;rlydef.h&gt;</t>
<t tx="ekr.20040303063549.48">@language csharp
@ comment
@c

/* block
comment */

// test

id // not a keyword

abstract as 
base bool break byte 
case catch char checked class const continue 
decimal default delegate do double 
else enum event explicit extern 
false finally fixed float for foreach 
get goto 
if implicit in int interface internal is 
lock long 
namespace new null 
object operator out override 
params partial private protected public 
readonly ref return 
sbyte sealed set short sizeof stackalloc 
static string struct switch 
this throw true try typeof 
uint ulong unchecked unsafe ushort using 
value virtual void volatile 
where while
yield</t>
<t tx="ekr.20040303063549.49">@language cweb

% This is limbo in cweb mode... It should be in \LaTeX mode, not \c mode.
% The following should not be colorized: class,if,else.

@* this is a _cweb_ comment.  Code is written in \c.
"strings" should not be colorized.
It should be colored in \LaTeX mode.
The following are not keywords in latex mode: if, else, etc.
Noweb section referencs are _valid_ in cweb comments!
&lt;&lt; section ref &gt;&gt;
&lt;&lt; missing ref &gt;&gt;
@c

and this is C code. // It is colored in \LaTeX mode by default.
/* This is a C block comment.  It may also be colored in restricted \LaTeX mode. */

// Section refs are valid in code too, of course.
&lt;&lt; section ref &gt;&gt;
&lt;&lt; missing ref &gt;&gt;

\LaTeX and \c should not be colored.
if else, while, do // C keywords.</t>
<t tx="ekr.20040303063549.50">&lt;&lt; section def &gt;&gt;=

	my \c code goes here // This is \LaTeX text
	/* This is also \LaTeX text */</t>
<t tx="ekr.20040303063549.51">@language elisp

; Maybe...
error princ 

; More typical of other lisps...
and apply
car cdr cons cond
defconst defun defvar 
eq equal eval
gt ge
if 
let le lt
mapcar 
ne nil 
or not 
prog progn 
set setq 
t type-of 
unless 
when while</t>
<t tx="ekr.20040303063549.52">@language html

&lt;HTML&gt;
&lt;!-- Author: Edward K. Ream, edream@tds.net --&gt;
&lt;HEAD&gt;
  &lt;META NAME="GENERATOR" CONTENT="Microsoft FrontPage 4.0"&gt;
  &lt;TITLE&gt; Leo's Home Page &lt;/TITLE&gt;
  &lt;META NAME="description" CONTENT="This page describes Leo.
Leo adds powerful outlines to the noweb and CWEB literate programming languages."&gt;
  &lt;META NAME="keywords" CONTENT="LEO, LITERATE PROGRAMMING, OUTLINES, CWEB,
NOWEB, OUTLINES, EDWARD K. REAM, DONALD E. KNUTH, SILVIO LEVY, OPEN SOFTWARE"&gt;
&lt;/HEAD&gt;
&lt;!-- Last Modified: May 12, 2002 --&gt;
&lt;BODY BGCOLOR="#fffbdc"&gt;

&lt;H1 ALIGN=CENTER&gt;&lt;a NAME="top"&gt;&lt;/a&gt;&lt;IMG SRC="Blank.gif" width=
"32" height="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;IMG SRC="leo.gif" 
WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;a href="leo_TOC.html#top"&gt;&lt;IMG SRC=
"arrow_rt.gif" WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;/a&gt; &amp;nbsp;&lt;/H1&gt;

&lt;H1 ALIGN=CENTER&gt; Leo's Home Page&lt;/H1&gt;

&lt;p align="center"&gt;&lt;a href="http://www.python.org/"&gt;&lt;img border="0" src="PythonPowered.gif" width="110" height="44"&gt; &lt;/a&gt; &lt;A HREF="http://sourceforge.net/"&gt;&lt;IMG SRC="http://sourceforge.net/sflogo.php?group_id=3458&amp;type=1" NATURALSIZEFLAG="0" ALT="SourceForge Logo"&gt;&lt;/A&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;
&lt;A HREF="http://sourceforge.net/project/?group_id=3458"&gt;Leo at SourceForge&lt;/A&gt;&amp;nbsp;&amp;nbsp;
&lt;a href="icons.html"&gt;&lt;img border="0" src="LeoCodeGray.gif" width="77" height="42"&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;
&lt;a href="icons.html"&gt;&lt;img border="0" src="LeoProse.gif" width="81" height="42"&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;

&lt;H3&gt;&lt;A NAME="anchor127554"&gt;&lt;/A&gt;Summary&lt;/H3&gt;

&lt;UL&gt;
  &lt;LI&gt;Leo is a &lt;i&gt; programmer's editor&lt;/i&gt;  and a flexible &lt;i&gt;browser&lt;/i&gt; for
	projects, programs, classes or data. Leo clarifies design, coding, debugging, testing
  and maintenance.
  &lt;LI&gt;Leo is an &lt;i&gt;outlining editor&lt;/i&gt;. Outlines clarify the big picture while
	providing unlimited space for details.
  &lt;LI&gt;Leo
	is a &lt;a HREF="http://www.literateprogramming.com/"&gt;&lt;i&gt;literate
	programming&lt;/i&gt;&lt;/a&gt; tool, compatible with &lt;A HREF="http://www.eecs.harvard.edu/~nr/noweb/"&gt;noweb&lt;/A&gt;
	and &lt;a HREF="http://www-cs-faculty.stanford.edu/~knuth/cweb.html"&gt;CWEB&lt;/a&gt;.
	Leo enhances any text-based
programming language, from assembly language and C to Java, Python and XML.
  &lt;LI&gt;Leo is also a &lt;i&gt;data organizer&lt;/i&gt;. A single Leo outline can generate complex
	data spanning many different files.&amp;nbsp; Leo has been used to manage web sites.
  &lt;LI&gt;Leo is a &lt;i&gt; project manager&lt;/i&gt;. Leo provides multiple views
of a project within a single outline. Leo naturally represents tasks that remain
	up-to-date.
  &lt;LI&gt;Leo is fully &lt;i&gt; scriptable&lt;/i&gt; using &lt;A HREF="http://www.python.org/"&gt;Python&lt;/A&gt;
  and saves its files in &lt;A HREF="http://www.w3.org/XML/"&gt;XML&lt;/A&gt; format.
  &lt;LI&gt;Leo is &lt;i&gt;portable&lt;/i&gt;.&amp;nbsp; Leo.py is 100% pure Python and will run on
	any platform supporting &lt;A HREF="http://www.python.org/"&gt;Python&lt;/A&gt;
	and &lt;a href="http://tcl.activestate.com/"&gt;Tk/tcl&lt;/a&gt;, including Windows,
	Linux and MacOS X.&amp;nbsp; Leo.exe runs on any Windows platform.
  &lt;LI&gt;Leo is &lt;a href="http://www.opensource.org/"&gt; &lt;i&gt; Open Software&lt;/i&gt;&lt;/a&gt;, distributed under
	the &lt;a href="http://www.python.org/doc/Copyright.html"&gt; Python License&lt;/a&gt;.
&lt;/UL&gt;

&lt;H3&gt;More Information and downloads&lt;/H3&gt;

&lt;ul&gt;
  &lt;LI&gt;An excellent &lt;a href="http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm"&gt;online
	tutorial&lt;/a&gt; and &lt;A HREF="http://www.jserv.com/jk_orr/xml/leo.htm"&gt;Leo resource
  page&lt;/A&gt;, both written by &lt;a href="http://www.jserv.com/jk_orr"&gt;Joe Orr&lt;/a&gt;.
  &lt;LI&gt;My brother's &lt;a href="SpeedReam.html"&gt;slashdot
	article about Leo&lt;/a&gt;, the best description about why Leo is special.
  &lt;LI&gt;&lt;A HREF="testimonials.html#anchor104391"&gt;What people are saying about Leo&lt;/A&gt;
  &lt;LI&gt;&lt;A HREF="leo_TOC.html#anchor964914"&gt;Complete users guide&lt;/A&gt;
	and
	&lt;A HREF="intro.html#anchor887874"&gt;tutorial introduction&lt;/A&gt;  with
  screen shots.
  &lt;li&gt;&lt;a href="FAQ.html"&gt;FAQ&lt;/a&gt; and &lt;a href="http://sourceforge.net/forum/?group_id=3458"&gt;help and discussion
	forums&lt;/a&gt;, preferable to &lt;A HREF="mailto:edream@tds.net"&gt;email&lt;/A&gt; so others may join
	in.&lt;/li&gt;
  &lt;li&gt;&lt;a href="icons.html"&gt;Icons&lt;/a&gt; for bragging about Leo.&lt;/li&gt;
&lt;/ul&gt;

&lt;a href="http://sourceforge.net/project/showfiles.php?group_id=3458"&gt;Download
	Leo&lt;/a&gt; from &lt;A HREF="http://sourceforge.net/project/?group_id=3458"&gt;Leo's SourceForge
site&lt;/A&gt;.

&lt;P ALIGN=left&gt;Leo's author is &lt;A HREF="http://personalpages.tds.net/~edream/index.html"&gt;Edward
  K. Ream&lt;/A&gt; email: &lt;A HREF="mailto:edream@tds.net"&gt;edream@tds.net&lt;/A&gt; voice: (608) 231-0766

&lt;HR ALIGN=LEFT&gt;

&lt;p align="center"&gt;

&lt;IMG SRC="Blank.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="34" height="34"&gt;&lt;IMG SRC="leo.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="32" height="32"&gt;&lt;a HREF="leo_TOC.html"&gt;&lt;IMG SRC="arrow_rt.gif" WIDTH="32"
HEIGHT="32" ALIGN="left" NATURALSIZEFLAG="3"&gt;

&lt;/BODY&gt;
&lt;/HTML&gt;</t>
<t tx="ekr.20040303063549.53">@language html

&lt;? xml version="1.0"&gt;
&lt;!-- test --&gt;
&lt;project name="Converter" default="dist"&gt;
&lt;/project&gt;"""</t>
<t tx="ekr.20040303063549.54">@language latex

% This is a \LaTeX mode comment.

This is a test of \LaTeX mode.

@ blah blah blah
@c

\c and \LaTeX are latex keywords.

This is a keyword \% not the start of a comment.

More keywords: \@ and \( and \) and \{ and \}</t>
<t tx="ekr.20040303063549.55">@ignore
@ doc
@c
@language c
	@others

abc
for # comment
# pp
@q comment @&gt; after
// comment
&lt;!-- comment --&gt; after
/* java comment */
{ pascal comment }
% latex comment
xor php keyword
fblocked tcl keyword
synchronized java keyword
\acute latex keyword
alarm perl keyword

# Python single-line comment
// C single-line comment
xx /* C block comment */ yy
xxx """ triple string """ zzz
a 'string' b
c "string" d
// C keywords
switch, case
</t>
<t tx="ekr.20040303063549.56">@language php
@ doc
This is a doc part.
@c

and or
array
array()
this is a test.
__CLASS__
&lt;?php and or array() ?&gt;"""</t>
<t tx="ekr.20040303063549.57">@language python

"""python
string"""d

'this\
is'''</t>
<t tx="ekr.20040303063549.58">"""This creates a free-floating copy of v's tree for undo.
The copied trees must use different tnodes than the original."""
	
def copyTree(self,root):

	c = self
	# Create the root vnode.
	result = v = leoNodes.vnode(c,root.t)
	# Copy the headline and icon values v.copyNode(root,v)
	# Copy the rest of tree.
	v.copyTree(root,v)
	# Replace all tnodes in v by copies.
	assert(v.nodeAfterTree() == None)
	while v:
		v.t = leoNodes.tnode(0, v.t.bodyString)
		v = v.threadNext()
	return result</t>
<t tx="ekr.20040303063549.59">@language rebol

; a comment
about abs absolute add alert alias all alter and and~ any append arccosine arcsine arctangent array ask at  
back bind boot-prefs break browse build-port build-tag  
call caret-to-offset catch center-face change change-dir charset checksum choose clean-path clear clear-fields close comment complement compose compress confirm continue-post context copy cosine create-request crypt cvs-date cvs-version  
debase decode-cgi decode-url decompress deflag-face dehex delete demo desktop detab dh-compute-key dh-generate-key dh-make-key difference dirize disarm dispatch divide do do-boot do-events do-face do-face-alt does dsa-generate-key dsa-make-key dsa-make-signature dsa-verify-signature  
echo editor either else emailer enbase entab exclude exit exp extract 
fifth find find-key-face find-window flag-face first flash focus for forall foreach forever form forskip fourth free func function  
get get-modes get-net-info get-style  
halt has head help hide hide-popup  
if import-email in inform input insert insert-event-func intersect 
join 
last launch launch-thru layout license list-dir load load-image load-prefs load-thru log-10 log-2 log-e loop lowercase  
make make-dir make-face max maximum maximum-of min minimum minimum-of mold multiply  
negate net-error next not now  
offset-to-caret open open-events or or~ 
parse parse-email-addrs parse-header parse-header-date parse-xml path-thru pick poke power prin print probe protect protect-system  
q query quit  
random read read-io read-net read-thru reboot recycle reduce reform rejoin remainder remold remove remove-event-func rename repeat repend replace request request-color request-date request-download request-file request-list request-pass request-text resend return reverse rsa-encrypt rsa-generate-key rsa-make-key 
save save-prefs save-user scroll-para second secure select send send-and-check set set-modes set-font set-net set-para set-style set-user set-user-name show show-popup sine size-text skip sort source split-path square-root stylize subtract switch  
tail tangent textinfo third throw throw-on-error to to-binary to-bitset to-block to-char to-date to-decimal to-email to-event to-file to-get-word to-hash to-hex to-idate to-image to-integer to-issue to-list to-lit-path to-lit-word to-local-file to-logic to-money to-none to-pair to-paren to-path to-rebol-file to-refinement to-set-path to-set-word to-string to-tag to-time to-tuple to-url to-word trace trim try  
unfocus union unique uninstall unprotect unset until unview update upgrade uppercase usage use  
vbug view view-install view-prefs  
wait what what-dir while write write-io  
xor xor~  
action! any-block! any-function! any-string! any-type! any-word!  
binary! bitset! block!  
char!  
datatype! date! decimal! 
email! error! event!  
file! function!  
get-word!  
hash!  
image! integer! issue!  
library! list! lit-path! lit-word! logic!  
money!  
native! none! number!  
object! op!  
pair! paren! path! port!  
refinement! routine!  
series! set-path! set-word! string! struct! symbol!  
tag! time! tuple!  
unset! url!  
word!  
any-block? any-function? any-string? any-type? any-word?  
binary? bitset? block?  
char? connected? crypt-strength? 
datatype? date? decimal? dir?  
email? empty? equal? error? even? event? exists? exists-key?
file? flag-face? found? function?  
get-word? greater-or-equal? greater?  
hash? head?  
image? in-window? index? info? input? inside? integer? issue?  
length? lesser-or-equal? lesser? library? link-app? link? list? lit-path? lit-word? logic?  
modified? money?  
native? negative? none? not-equal? number?  
object? odd? offset? op? outside?  
pair? paren? path? port? positive?  
refinement? routine?  
same? screen-offset? script? series? set-path? set-word? size? span? strict-equal? strict-not-equal? string? struct?  
tag? tail? time? tuple? type?  
unset? url?  
value? view? 
within? word?  
zero?</t>
<t tx="ekr.20040303063549.60"># both color_markup &amp; add_directives plugins must be enabled.

@markup wiki
@language python

""" {picture file=../Icons/Leoapp.GIF}this """ # Problems with correct indexing following a graphic.

""" {picture file=../Icons/Leoapp.GIF}this """ # two copies work.

abc

""" {picture file=../Icons/Leodoc.GIF} """ # xyz

""" continued
string"""

@ ''ab'' __xxx__ ''wx'' __xyz__
@c

# /* ''ab'' __xxx__ ''wx'' __xyz__ */

# Test

""" ''' """ ''' """'''  # Leo handles the common cases correctly.

''' ''ab'' __xxx__ ''wx'' __xyz__ ''' # No wiki markup in ''' strings.

""" ''ab'' __xxx__ ''wx'' __xyz__ """

# ''ab'' __xxx__ ''wx'' __xyz__

""" ''y'' """

""" text~~#ff00ff:some text~~more text""

and if

from leoGlobals import * ; print g.app().loadDir</t>
<t tx="ekr.20040303063549.61"># both color_markup &amp; add_directives plugins must be enabled.
@markup wiki

""" continued
string"""

@ ''ab'' __xxx__ ''wx'' __xyz__  __''bolditalic''__ and ''__italicbold__''
@c

# /* ''ab'' __xxx__ ''wx'' __xyz__ */

__abc__ 

# Test

""" ''' """ ''' """'''  # Leo handles the __b__ common cases correctly.

''' ''ab'' __xxx__ ''wx'' __xyz__ ''' # No wiki markup in ''' strings.

""" ''ab'' __xxx__ ''wx'' __xyz__ """

# ''ab'' __xxx__ ''wx'' __xyz__

""" ''y'' """

""" text~~#ee00ff:some text~~more text"""



and if

from leoGlobals import * ; print g.app().loadDir
</t>
<t tx="ekr.20040303063549.62"># both color_markup &amp; add_directives plugins must be enabled.

@markup wiki

""" text~~red:some text~~more text"""

""" text~~#ee0ff:some text~~more text"""</t>
<t tx="ekr.20040303063549.63">@ The names of child nodes are the names of commander methods to be called to do the test.

Each child node will in turn have two or more children:
	
- a "before" node
- an "after" node
- an optional selection node containing two lines giving the selection range in Tk coordinates.
- An optional insert node containing one line giving the insert point in Tk coordinates.
@c

import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

suite = leoTest.makeEditBodySuite("editBodyTests","tempNode")
runner = unittest.TextTestRunner()
runner.run(suite)
</t>
<t tx="ekr.20040303063549.64"></t>
<t tx="ekr.20040303063549.65">line 1
	line 2
	line 3
line 4</t>
<t tx="ekr.20040303063549.66">line 1
line 2
line 3
line 4</t>
<t tx="ekr.20040303063549.67">2.0
3.0 lineend - 1c</t>
<t tx="ekr.20040303063549.68"></t>
<t tx="ekr.20040303063549.69">line 1
line 2
line 3
line 4</t>
<t tx="ekr.20040303063549.70">line 1
	line 2
	line 3
line 4</t>
<t tx="ekr.20040303063549.71">2.0
3.0 lineend - 1c</t>
<t tx="ekr.20040303063549.72"></t>
<t tx="ekr.20040303063549.73">before
&lt;&lt; section &gt;&gt;
sec line 1
	sec line 2 indented
sec line 3
after</t>
<t tx="ekr.20040303063549.74">before
&lt;&lt; section &gt;&gt;
after</t>
<t tx="ekr.20040303063549.75">sec line 1
	sec line 2 indented
sec line 3</t>
<t tx="ekr.20040303063549.76">2.0
5.0 lineend -1c</t>
<t tx="ekr.20040303063549.77">import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

suite = leoTest.makeImportExportSuite("exportTests","tempNode")
runner = unittest.TextTestRunner()
runner.run(suite)</t>
<t tx="ekr.20040303063549.78"></t>
<t tx="ekr.20040303063549.79">saveFileDialog
c:\\prog\\test\\unittest\\output\\exportHeadlines.txt</t>
<t tx="ekr.20040303063549.80"></t>
<t tx="ekr.20040303063549.81">saveFileDialog
c:\\prog\\test\\unittest\\output\\flattenOutline.txt</t>
<t tx="ekr.20040303063549.82"></t>
<t tx="ekr.20040303063549.83">saveFileDialog
c:\\prog\\test\\unittest\\output\\weave.txt</t>
<t tx="ekr.20040303063549.84"></t>
<t tx="ekr.20040303063549.85">saveFileDialog
c:\\prog\\test\\unittest\\output\\outlineToNoweb.txt</t>
<t tx="ekr.20040303063549.86"></t>
<t tx="ekr.20040303063549.87">saveFileDialog
c:\\prog\\test\\unittest\\output\\outlineToCweb.txt</t>
<t tx="ekr.20040303063549.88"></t>
<t tx="ekr.20040303063549.89">openFileDialog
c:\\prog\\test\\unittest\\input\\leoAtFile.py</t>
<t tx="ekr.20040303063549.90"># To do: at present this creates a copy of this node as the next sib of tempNode!

import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

suite = leoTest.makeImportExportSuite("importTests","tempNode")
runner = unittest.TextTestRunner()
runner.run(suite)</t>
<t tx="ekr.20040303063549.91"></t>
<t tx="ekr.20040303063549.92">openFileDialog
c:\\prog\\test\\unittest\\input\\leoAtFile.py</t>
<t tx="ekr.20040303063549.93"></t>
<t tx="ekr.20040303063549.94">openFileDialog
c:\\prog\\test\\unittest\\input\\leoAtFile.py</t>
<t tx="ekr.20040303063549.95"></t>
<t tx="ekr.20040303063549.96">openFileDialog
c:\\prog\\test\\unittest\\input\\noweave.nw.txt</t>
<t tx="ekr.20040303063549.97"></t>
<t tx="ekr.20040303063549.98">openFileDialog
c:\\prog\\test\\unittest\\input\\flat.txt</t>
<t tx="ekr.20040303063549.99"></t>
<t tx="ekr.20040303063549.100">openFileDialog
c:\\prog\\test\\unittest\\input\\cweave.w</t>
<t tx="ekr.20040303063549.101">import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

suite = leoTest.makeOutlineSuite("outlineTests")
runner = unittest.TextTestRunner()
runner.run(suite)</t>
<t tx="ekr.20040303063549.102"></t>
<t tx="ekr.20040303063549.103"></t>
<t tx="ekr.20040303063549.104"></t>
<t tx="ekr.20040303063549.105"></t>
<t tx="ekr.20040303063549.106"></t>
<t tx="ekr.20040303063549.107"></t>
<t tx="ekr.20040303063549.108"></t>
<t tx="ekr.20040303063549.109"></t>
<t tx="ekr.20040303063549.110"></t>
<t tx="ekr.20040303063549.111"></t>
<t tx="ekr.20040303063549.112"></t>
<t tx="ekr.20040303063549.113"></t>
<t tx="ekr.20040303063549.114"></t>
<t tx="ekr.20040303063549.115"></t>
<t tx="ekr.20040303063549.116"></t>
<t tx="ekr.20040303063549.117"></t>
<t tx="ekr.20040303063549.118">import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

suite = leoTest.makePluginsSuite(verbose=True)
runner = unittest.TextTestRunner()
runner.run(suite)</t>
<t tx="ekr.20040303063549.119">import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

suite = leoTest.makePositionSuite(all=1)
runner = unittest.TextTestRunner()
runner.run(suite)</t>
<t tx="ekr.20040303063549.120">import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

suite = testLeoFilesSuite = leoTest.makeTestLeoFilesSuite("fileTests")
runner = unittest.TextTestRunner()
runner.run(suite)</t>
<t tx="ekr.20040303063549.121"></t>
<t tx="ekr.20040303063549.122"></t>
<t tx="ekr.20040303063549.123"></t>
<t tx="ekr.20040303063549.124"></t>
<t tx="ekr.20040303063549.125">from leoGlobals import *
import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

mainSuite = unittest.makeSuite(unittest.TestCase)

suite = leoTest.makeReformatParagraphSuite()
mainSuite.addTest(suite)

for f,arg in (
	(leoTest.makeColorSuite,"colorizerTests"),
	(leoTest.makeEditBodySuite,"editBodyTests"),
	(leoTest.makeImportExportSuite,"exportTests"),
	(leoTest.makeImportExportSuite,"importTests"),
	(leoTest.makeOutlineSuite,"outlineTests"),
	(leoTest.makeTestLeoFilesSuite,"fileTests"),
	(leoTest.makePositionSuite,None),
	# 
	# These tests presently have problem with the gui when run with other tests...
	# (leoTest.makePluginsSuite,false) # verbose
):
	suite = f(arg,"tempNode")
	mainSuite.addTest(suite)

runner = unittest.TextTestRunner()
runner.run(mainSuite)</t>
<t tx="ekr.20040303063644"></t>
<t tx="ekr.20040303064013">def makePositionSuite(arg=None,all=true,verbose=false):
	
	if all: # Include everything.
	
		suite = unittest.makeSuite(positionTestCase,'test')
		
	else: # Include listed testss.

		names = (
			"testFullTraverse",
			"testParentChildLinks",
			"testNextBack",
			"testVnodeList",
			"testThreadBackNext",
			"testParentChildLevel")
		
		suite = unittest.makeSuite(unittest.TestCase)
		for name in names:
			suite.addTest(positionTestCase(name))

	return suite</t>
<t tx="ekr.20040303064020.5">def testConsistencyOfNextBack (self):
	
	"""Test consistency of p.next and p.back."""

	for p in self.root.allNodes_iter():
		
		back = p.back()
		next = p.next()
		if back: assert(back.getNext() == p)
		if next: assert(next.getBack() == p)</t>
<t tx="ekr.20040303064020.6">def testVnodeList (self):
	
	for p in self.root.allNodes_iter():

		vnodeList = p.v.t.vnodeList
	
		for v in vnodeList:

			assert(v.t == p.v.t)
			if p.v.isCloned():
				assert(v.isCloned())
				assert(len(vnodeList) &gt; 1)
			else:
				assert(not v.isCloned())
				assert(len(vnodeList) == 1)</t>
<t tx="ekr.20040303064020.7">def testConsistencyOfThreadBackNext (self):

	for p in self.root.allNodes_iter():

		threadBack = p.threadBack()
		threadNext = p.threadNext()

		if threadBack:
			assert(p == threadBack.getThreadNext())
	
		if threadNext:
			assert(p == threadNext.getThreadBack())</t>
<t tx="ekr.20040303071432"></t>
<t tx="ekr.20040303080010">from leoGlobals import *
import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

mainSuite = unittest.makeSuite(unittest.TestCase)

suite = leoTest.makeReformatParagraphSuite()
mainSuite.addTest(suite)

for f,arg in (
	(leoTest.makeColorSuite,"colorizerTests"),
	(leoTest.makeEditBodySuite,"editBodyTests"),
	(leoTest.makePositionSuite,None),
	# (leoTest.makeOutlineSuite,"outlineTests")
	# These tests presently have problem with the gui when run with other tests...
	# (leoTest.makePluginsSuite,false) # verbose
):
	suite = f(arg,"tempNode")
	mainSuite.addTest(suite)

runner = unittest.TextTestRunner()
runner.run(mainSuite)</t>
<t tx="ekr.20040303080938"></t>
<t tx="ekr.20040303080938.1"></t>
<t tx="ekr.20040303091606">def testHasNextBack (self):
	
	for p in self.root.allNodes_iter():

		back = p.back()
		next = p.next()

		assert(
			(back and p.hasBack()) or
			(not back and not p.hasBack()))
				
		assert(
			(next and p.hasNext()) or
			(not next and not p.hasNext()))</t>
<t tx="ekr.20040303092153">def testHasParentChild (self):
	
	for p in self.root.allNodes_iter():

		child = p.firstChild()
		parent = p.parent()

		assert(
			(child and p.hasFirstChild()) or
			(not child and not p.hasFirstChild()))
				
		assert(
			(parent and p.hasParent()) or
			(not parent and not p.hasParent()))</t>
<t tx="ekr.20040303092153.1">def testHasThreadNextBack(self):

	for p in self.root.allNodes_iter():

		threadBack = p.getThreadBack()
		threadNext = p.getThreadNext()

		assert(
			(threadBack and p.hasThreadBack()) or
			(not threadBack and not p.hasThreadBack()))
				
		assert(
			(threadNext and p.hasThreadNext()) or
			(not threadNext and not p.hasThreadNext()))</t>
<t tx="ekr.20040309091917">@nocolor

- Test read logic: test created tree against already existing tree.

- Test isExpanded.
- For related Commands methods.
- Menu enablers
- Test new p and v routines.
- Test undo/redo for all commands.
</t>
<t tx="ekr.20040309095121"></t>
<t tx="ekr.20040309101454">@
	
- Tests for c.rootPosition, c.currentPosition, c.setCurrentPosition.
- Menu enablers
- Test new p and v routines.
- Test undo/redo for all commands.</t>
<t tx="ekr.20040309101454.13">def testConsistencyOfLevel (self):
	
	"""Test consistency of p.level."""

	for p in self.root.allNodes_iter():
		
		if p.hasParent():
			assert(p.parent().level() == p.level() - 1)
	
		if p.hasChildren():
			assert(p.firstChild().level() == p.level() + 1)
			
		if p.hasNext():
			assert(p.next().level() == p.level())
	
		if p.hasBack():
			assert(p.back().level() == p.level())
</t>
<t tx="ekr.20040309101454.14">def testConsistencyOfParentChild (self):
	
	"""Test consistency of p.parent, p.next, p.back and p.firstChild."""
	
	root = self.c.rootPosition()

	for p in root.allNodes_iter():
		
		if p.hasParent():
			n = p.childIndex()
			assert(p == p.parent().moveToNthChild(n))
			
		for child in p.children_iter():
			assert(p == child.parent())
	
		if p.hasNext():
			assert(p.next().parent() == p.parent())
			
		if p.hasBack():
			assert(p.back().parent() == p.parent())</t>
<t tx="ekr.20040309101454.15">def testConsistencyOfAllNodesThreadNextWithCopy(self):
	self.doConsistencyOfAllNodesThreadNext(true)
	
def testConsistencyOfAllNodesThreadNext(self):
	self.doConsistencyOfAllNodesThreadNext(false)

def doConsistencyOfAllNodesThreadNext (self,copy):
	
	"""Test consistency of p.moveToThreadNext and p.allNodes_iter."""

	root = self.c.rootPosition()
	p2 = root.copy()

	for p in root.allNodes_iter(copy=copy):

		if p != p2: print p,p2
		assert(p==p2)
		p2.moveToThreadNext()
		
	if p2: print p2
	assert(not p2)
</t>
<t tx="ekr.20040309101454.16">def testConsistencyOfParentAndParentsIterWithCopy(self):
	self.doConsistencyOfParentAndParentsIter(true)
	
def testConsistencyOfParentAndParentsIter(self):
	self.doConsistencyOfParentAndParentsIter(false)

def doConsistencyOfParentAndParentsIter (self,copy):
	
	"""Test consistency of p.parent and p.parents_iter."""

	root = self.c.rootPosition()

	for p in root.allNodes_iter():
		
		p2 = p.parent()
		for p3 in p.parents_iter(copy=copy):
			
			if p3 != p2: print p3,p2
			assert(p3==p2)
			p2.moveToParent()
	
		if p2: print p2
		assert(not p2)</t>
<t tx="ekr.20040309101454.17">def testConsistencyOfFirstChildAndChildrenIterWithCopy(self):
	self.doConsistencyOfFirstChildAndChildrenIter(true)
	
def testConsistencyOfFirstChildAndChildrenIter(self):
	self.doConsistencyOfFirstChildAndChildrenIter(false)

def doConsistencyOfFirstChildAndChildrenIter (self,copy):
	
	"""Test consistency of p.moveToFirstChild/Next and p.children_iter."""

	root = self.c.rootPosition()

	for p in root.allNodes_iter(copy=copy):
		
		p2 = p.firstChild()
		for p3 in p.children_iter(copy=copy):
			
			if p3 != p2: print p3,p2
			assert(p3==p2)
			p2.moveToNext()

	if p2: print p2
	assert(not p2)</t>
<t tx="ekr.20040309105731">def testComparisons (self):
	
	p = self.root
	assert(p == p.copy())
	assert(p != p.threadNext())</t>
<t tx="ekr.20040309111054">import leoGlobals as g
from leoGlobals import true,false
import leoNodes

c = g.top()
position = leoNodes.position

@others

assert(g.sharedNodes)
if g.sharedNodes:
	current = pos = c.currentPosition()
else: # no longer used.
	current = c.currentVnode()
	pos = position(current,[]) # default position.

child1 = current.firstChild()
child2 = child1.firstChild()

if 1:
	print '-'*10, "parents"
	for porv in child2.parents_iter(): print porv
if 1:
	print '-'*10, "subtree"
	for porv in pos.subtree_iter(): print porv
if 1:
	print '-'*10, "children"
	for porv in child1.children_iter(): print porv
if 1:
	print '-'*10, "siblings"
	for porv in pos.siblings_iter(): print porv
if 1:
	print '-'*10, "all nodes"
	for porv in pos.allNodes_iter(): print porv</t>
<t tx="ekr.20040309111102"></t>
<t tx="ekr.20040309111102.1"></t>
<t tx="ekr.20040309111102.2"></t>
<t tx="ekr.20040309111102.3"></t>
<t tx="ekr.20040309111102.4"></t>
<t tx="ekr.20040309111102.5"></t>
<t tx="ekr.20040309111102.6"></t>
<t tx="ekr.20040309111102.7"></t>
<t tx="ekr.20040309111102.8"></t>
<t tx="ekr.20040309111102.9"></t>
<t tx="ekr.20040309111102.10"></t>
<t tx="ekr.20040309111232"></t>
<t tx="ekr.20040310145919">import leoGlobals as g
c = g.top()
c.frame.body.colorizer.python_keywords.append("as")
</t>
<t tx="ekr.20040311090054">import leoGlobals as g
import leoNodes

c = g.top() ; root = c.rootPosition()

for p in root.allNodes_iter():
	print p.v.t.fileIndex</t>
<t tx="ekr.20040311111734">@language python
@encoding iso-8859-1

# Test of Leo 42 derived files.

changed2

&lt;&lt; node one &gt;&gt;

@others</t>
<t tx="ekr.20040311111734.1">node one text</t>
<t tx="ekr.20040311111734.2">node a text</t>
<t tx="ekr.20040311111734.3">node b text</t>
<t tx="ekr.20040311125054">import leoGlobals as g
c = g.top()
root = c.rootPosition()

# NOTE: p.__getattr__ must be enabled for this test to work.

for p in root.allNodes_iter():
	assert(p.t == p.v.t)
	
print "done"</t>
<t tx="ekr.20040312021734"></t>
<t tx="ekr.20040312021734.1">import leoGlobals as g
from leoGlobals import true,false

c = g.top()

count = 0
for p in c.rootPosition().allNodes_iter():
	count += 1
	# Empty tnodeLists are not errors because they never get written to the .leo file.
	v = p.v
	if hasattr(v,"tnodeList") and len(v.tnodeList) &gt; 0 and not v.isAnyAtFileNode():
		g.es("deleting tnodeList for " + `v`,color="blue")
		delattr(v,"tnodeList")
		c.setChanged(true)

s = "%d nodes" % count
print s ; g.es(s)</t>
<t tx="ekr.20040312101720"></t>
<t tx="ekr.20040312101720.1"></t>
<t tx="ekr.20040312101853"></t>
<t tx="ekr.20040315025315">@
- convertTreeToString and moreHead can't be vnode methods because they uses level().
- moreBody could be anywhere: it may as well be a postion method.
</t>
<t tx="ekr.20040315025315.1">def convertTreeToString (self):
	
	"""Convert a positions  suboutline to a string in MORE format."""

	p = self ; level1 = p.level()
	
	array = []
	for p in p.subtree_iter()
		array.append(p.moreHead(level1)+'\n')
		body = p.moreBody()
		if body:
			array.append(body +'\n')

	return ''.join(array)</t>
<t tx="ekr.20040315025315.2">def moreHead (self, firstLevel,useVerticalBar=false):
	
	"""Return the headline string in MORE format."""

	p = self

	level = self.level() - firstLevel
	plusMinus = g.choose(p.hasChildren(), "+", "-")
	
	return "%s%s %s" % ('\t'*level,plusMinus,p.headString())</t>
<t tx="ekr.20040315025315.3">@ 
	+ test line
	- test line
	\ test line
	test line +
	test line -
	test line \
	More lines...
@c

def moreBody (self):

	"""Returns the body string in MORE format.  
	
	Inserts a backslash before any leading plus, minus or backslash."""

	p = self ; list = []
	
	# Only escape the first non-blank character of the line.
	s =  p.bodyString() ; result = []
	lines = string.split(s,'\n')
	for s in lines:
		i = g.skip_ws(s,0)
		if i &lt; len(s):
			ch = s[i]
			if ch == '+' or ch == '-' or ch == '\\':
				s = s[:i] + '\\' + s[i:]
		result.append(s)
	return string.join(result,'\n')
</t>
<t tx="ekr.20040315030123">import leoGlobals as g
from leoGlobals import true,false

c = g.top() ; p = c.currentPosition()

p = p.firstChild()
assert(p.headString()=="File Conversion")
print p.convertTreeToString()</t>
<t tx="ekr.20040315202201"></t>
<t tx="ekr.20040315202250">def makeFindCommandSuite(arg=None,all=true,verbose=false):
	
	return unittest.makeSuite(findCommandTestCase,'test')</t>
<t tx="ekr.20040315202314">class findCommandTestCase(unittest.TestCase):
	
	"""Unit tests for Leo's find commands."""
	
	@others</t>
<t tx="ekr.20040315202314.1">def setUp(self,*args,**keys):
	
	import leoGlobals as g
	
	u = testUtils()
	
	self.c = c = g.top()

	self.verbose = true
	
	self.root = c.rootPosition()
	
	self.find_p = u.findNodeAnywhere(c,"findTests")
	
	assert(self.find_p)
	
	c.selectPosition(self.find_p)
</t>
<t tx="ekr.20040315202347">def testFindCommand (self):
	
	g.trace(self.find_p)</t>
<t tx="ekr.20040315202718">def testFindWordCommand (self):
	
	pass</t>
<t tx="ekr.20040315202718.1">def testFindIgnoreCaseCommand (self):
	
	pass</t>
<t tx="ekr.20040315202718.2">import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

suite = leoTest.makeFindCommandSuite()
runner = unittest.TextTestRunner()
runner.run(suite)
</t>
<t tx="ekr.20040315210314"></t>
<t tx="ekr.20040315210314.1"></t>
<t tx="ekr.20040315210314.2">@nocolor

- Used iterators in test utils.
- Used "import leoGlobals as g" style.</t>
<t tx="ekr.20040317101155">import leoGlobals as g
from leoGlobals import true,false
c = g.top()

p = c.currentPosition()
p.v.t.unknownAttributes = {}
a = p.v.t.unknownAttributes

path = r"c:\prog\leoCVS\leo\Icons"
icon1 = g.os_path_join(path,"lt_arrow_enabled.gif")
icon2 = g.os_path_join(path,"rt_arrow_enabled.gif")

d1 = {
"type" : "file", "file" : icon1,
"where" : "beforeIcon",
"yoffset" : -3,
# "yoffset" : 5, "ypad" : -5,
# "height" : 40, # automatically adjust headline y position.
"xpad": 2 } # "yoffset" : -5, , "ypad": 5}

d2 = {
"type" : "file", "file" : icon2,
"where" : "beforeHeadline",
"yoffset" : -3,
"xoffset" : 2, "xpad" : -2 }

a["icons"] = [d1,d2] # [d1,d2]
a["lineYOffset"] = 3

c.redraw()</t>
<t tx="ekr.20040317173327">import leoGlobals as g
from leoGlobals import true,false
c = g.top()

for p in c.allNodes_iter():
	
	if hasattr(p.v.t,"unknownAttributes"):
		a = p.v.t.unknownAttributes
		iconsList = a.get("icons")
		if dict:
			a["icons"] = []
			a["lineYOffset"] = 0
			
c.redraw() </t>
</tnodes>
</leo_file>
