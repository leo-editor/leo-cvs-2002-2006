<?xml version="1.0" encoding="UTF-8"?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="2596" clone_windows="0"/>
<globals body_outline_ratio="0.38383838383838381">
	<global_window_position top="37" left="164" height="755" width="1071"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences>
</preferences>
<find_panel_settings>
	<find_string></find_string>
	<change_string></change_string>
</find_panel_settings>
<vnodes>
<v t="ekr.20040303080938"><vh>Diary</vh>
<v t="ekr.20040303080938.1"><vh>3/3/04: created position tests</vh></v>
</v>
<v t="ekr.20040303062846"><vh>Unit Testing</vh>
<v t="ekr.20040303062846.1"><vh>To do</vh></v>
<v t="ekr.20040303062846.2" tnodeList="ekr.20040303062846.2,ekr.20040303062846.3,ekr.20040303062846.4,ekr.20040303062846.5,ekr.20040303062846.6,ekr.20040303062846.7,ekr.20040303062846.8,ekr.20040303062846.9,ekr.20040303062846.10,ekr.20040303062846.12,ekr.20040303062846.13,ekr.20040303062846.14,ekr.20040303062846.15,ekr.20040303062846.16,ekr.20040303062846.17,ekr.20040303062846.18,ekr.20040303062846.20,ekr.20040303062846.21,ekr.20040303062846.22,ekr.20040303062846.23,ekr.20040303062846.24,ekr.20040303062846.25,ekr.20040303062846.26,ekr.20040303062846.28,ekr.20040303062846.29,ekr.20040303062846.30,ekr.20040303062846.31,ekr.20040303062846.32,ekr.20040303062846.33,ekr.20040303062846.34,ekr.20040303062846.35,ekr.20040303062846.37,ekr.20040303062846.38,ekr.20040303062846.39,ekr.20040303062846.40,ekr.20040303062846.41,ekr.20040303062846.42,ekr.20040303062846.64,ekr.20040303062846.65,ekr.20040303062846.66,ekr.20040303062846.67,ekr.20040303062846.68,ekr.20040303062846.69,ekr.20040303062846.70,ekr.20040303062846.71,ekr.20040303062846.73,ekr.20040303062846.74,ekr.20040303062846.75,ekr.20040303062846.76,ekr.20040303062846.77,ekr.20040303062846.78,ekr.20040303062846.79,ekr.20040303064013,ekr.20040303063118,ekr.20040303063118.4,ekr.20040303064020.1,ekr.20040303064020.2,ekr.20040303064020.3,ekr.20040303064020.4,ekr.20040303064020.5,ekr.20040303064020.6,ekr.20040303064020.7,ekr.20040303064020.8,ekr.20040303091606,ekr.20040303092153,ekr.20040303092153.1,ekr.20040303062846.80,ekr.20040303062846.81,ekr.20040303062846.82,ekr.20040303062846.83,ekr.20040303062846.84,ekr.20040303062846.85,ekr.20040303062846.86,ekr.20040303062846.87,ekr.20040303062846.88,ekr.20040303062846.89,ekr.20040303062846.90,ekr.20040303062846.91,ekr.20040303062846.92,ekr.20040303062846.93,ekr.20040303062846.94,ekr.20040303062846.95,ekr.20040303062846.96,ekr.20040303062846.97,ekr.20040303062846.98,ekr.20040303062846.99,ekr.20040303062846.100,ekr.20040303062846.101,ekr.20040303062846.102,ekr.20040303062846.103,ekr.20040303062846.104"><vh>@file ..\src\leoTest.py</vh>
<v t="ekr.20040303062846.3"><vh> class testUtils</vh>
<v t="ekr.20040303062846.4"><vh>compareOutlines</vh></v>
<v t="ekr.20040303062846.5"><vh>findChildrenOf &amp; findSubnodesOf</vh></v>
<v t="ekr.20040303062846.6"><vh>findNodeInRootTree, findNodeInTree, findNodeAnywhere</vh></v>
<v t="ekr.20040303062846.7"><vh>numberOfNodesInOutline, numberOfClonesInOutline</vh></v>
<v t="ekr.20040303062846.8"><vh>replaceOutline</vh></v>
<v t="ekr.20040303062846.9"><vh>validateOutline TODO</vh></v>
</v>
<v t="ekr.20040303062846.10"><vh> fail</vh></v>
<v t="ekr.20040303062846.11"><vh>Colorizer tests</vh>
<v t="ekr.20040303062846.12"><vh> makeColorSuite</vh></v>
<v t="ekr.20040303062846.13"><vh>class colorTestCase</vh>
<v t="ekr.20040303062846.14"><vh>__init__</vh></v>
<v t="ekr.20040303062846.15"><vh>color</vh></v>
<v t="ekr.20040303062846.16"><vh>setUp</vh></v>
<v t="ekr.20040303062846.17"><vh>tearDown</vh></v>
<v t="ekr.20040303062846.18"><vh>runTest</vh></v>
</v>
</v>
<v t="ekr.20040303062846.19"><vh>Edit body tests</vh>
<v t="ekr.20040303062846.20"><vh> makeEditBodySuite</vh></v>
<v t="ekr.20040303062846.21"><vh>class editBodyTestCase</vh>
<v t="ekr.20040303062846.22"><vh>__init__</vh></v>
<v t="ekr.20040303062846.23"><vh>editBody</vh></v>
<v t="ekr.20040303062846.24"><vh>tearDown</vh></v>
<v t="ekr.20040303062846.25"><vh>setUp</vh></v>
<v t="ekr.20040303062846.26"><vh>runTest</vh></v>
</v>
</v>
<v t="ekr.20040303062846.27"><vh>Import/Export tests</vh>
<v t="ekr.20040303062846.28"><vh>makeImportExportSuite</vh></v>
<v t="ekr.20040303062846.29"><vh>class importExportTestCase</vh>
<v t="ekr.20040303062846.30"><vh>__init__</vh></v>
<v t="ekr.20040303062846.31"><vh>importExport</vh></v>
<v t="ekr.20040303062846.32"><vh>runTest</vh></v>
<v t="ekr.20040303062846.33"><vh>setUp</vh></v>
<v t="ekr.20040303062846.34"><vh>shortDescription</vh></v>
<v t="ekr.20040303062846.35"><vh>tearDown</vh></v>
</v>
</v>
<v t="ekr.20040303062846.36"><vh>LeoFiles tests</vh>
<v t="ekr.20040303062846.37"><vh>makeTestLeoFilesSuite</vh></v>
<v t="ekr.20040303062846.38"><vh>class leoFileTestCase</vh>
<v t="ekr.20040303062846.39"><vh>__init__</vh></v>
<v t="ekr.20040303062846.40"><vh>runTest</vh></v>
<v t="ekr.20040303062846.41"><vh>setUp</vh></v>
<v t="ekr.20040303062846.42"><vh>tearDown</vh></v>
</v>
</v>
<v t="ekr.20040303062846.63"><vh>Outline tests</vh>
<v t="ekr.20040303062846.64"><vh> makeOutlineSuite</vh></v>
<v t="ekr.20040303062846.65"><vh>class outlineTestCase</vh>
<v t="ekr.20040303062846.66"><vh>__init__</vh></v>
<v t="ekr.20040303062846.67"><vh>outlineCommand</vh></v>
<v t="ekr.20040303062846.68"><vh>runTest</vh></v>
<v t="ekr.20040303062846.69"><vh>setUp</vh></v>
<v t="ekr.20040303062846.70"><vh>tearDown</vh></v>
<v t="ekr.20040303062846.71"><vh> makePluginsSuite</vh></v>
</v>
</v>
<v t="ekr.20040303062846.72"><vh>Plugin tests</vh>
<v t="ekr.20040303062846.73"><vh>class pluginTestCase</vh>
<v t="ekr.20040303062846.74"><vh>__init__</vh></v>
<v t="ekr.20040303062846.75"><vh>pluginTest</vh></v>
<v t="ekr.20040303062846.76"><vh>runTest</vh></v>
<v t="ekr.20040303062846.77"><vh>setUp</vh></v>
<v t="ekr.20040303062846.78"><vh>shortDescription</vh></v>
<v t="ekr.20040303062846.79"><vh>tearDown</vh></v>
</v>
</v>
<v t="ekr.20040303063644"><vh>Position tests</vh>
<v t="ekr.20040303064013"><vh> makePositionSuite</vh></v>
<v t="ekr.20040303063118"><vh>class positionTestCase</vh>
<v t="ekr.20040303063118.4"><vh>setUp</vh></v>
<v t="ekr.20040303064020.1"><vh>testFullTraverse</vh></v>
<v t="ekr.20040303064020.2"><vh>testParentChildLinks</vh>
<v t="ekr.20040303064020.3"><vh>&lt;&lt; check that the parent of p's first child is p &gt;&gt;</vh></v>
<v t="ekr.20040303064020.4"><vh>&lt;&lt; check that the parent of all parent's children is parent &gt;&gt;</vh></v>
</v>
<v t="ekr.20040303064020.5"><vh>testNextBack</vh></v>
<v t="ekr.20040303064020.6"><vh>testVnodeList</vh></v>
<v t="ekr.20040303064020.7"><vh>test threadNextBack</vh></v>
<v t="ekr.20040303064020.8"><vh>testParentChildLevel</vh></v>
<v t="ekr.20040303091606"><vh>testHasNextBack</vh></v>
<v t="ekr.20040303092153"><vh>testHasParentChild</vh></v>
<v t="ekr.20040303092153.1"><vh>testHasThreadNextBack</vh></v>
</v>
</v>
<v t="ekr.20040303062846.80"><vh>Reformat Paragraph tests</vh>
<v t="ekr.20040303062846.81"><vh>makeReformatParagraphSuite</vh></v>
<v t="ekr.20040303062846.82"><vh>class reformatParagraphTestCase</vh>
<v t="ekr.20040303062846.83"><vh>setUp</vh></v>
<v t="ekr.20040303062846.84"><vh>tearDown</vh></v>
<v t="ekr.20040303062846.85"><vh>testNoTrailingNewline</vh></v>
<v t="ekr.20040303062846.86"><vh>testTrailingNewline</vh></v>
<v t="ekr.20040303062846.87"><vh>testMixedLineLengths</vh></v>
<v t="ekr.20040303062846.88"><vh>testMixedLinesWithLeadingWS</vh></v>
<v t="ekr.20040303062846.89"><vh>testNoChangeRequired</vh></v>
<v t="ekr.20040303062846.90"><vh>testHonorLeadingWS</vh></v>
<v t="ekr.20040303062846.91"><vh>testHonorLeadingWSVar1</vh></v>
<v t="ekr.20040303062846.92"><vh>testSimpleHangingIndent</vh></v>
<v t="ekr.20040303062846.93"><vh>testSimpleHangingIndentVar1</vh></v>
<v t="ekr.20040303062846.94"><vh>testSimpleHangingIndentVar2</vh></v>
<v t="ekr.20040303062846.95"><vh>testMultiParagraph</vh></v>
<v t="ekr.20040303062846.96"><vh>testMultiParagraphWithList</vh></v>
<v t="ekr.20040303062846.97"><vh>testDirectiveBreaksParagraph</vh></v>
<v t="ekr.20040303062846.98"><vh>testWithLeadingWSOnEmptyLines</vh></v>
<v t="ekr.20040303062846.99"><vh>singleParagraphTest</vh></v>
<v t="ekr.20040303062846.100"><vh>checkPosition</vh></v>
<v t="ekr.20040303062846.101"><vh>checkText</vh></v>
<v t="ekr.20040303062846.102"><vh>copyBeforeToTemp</vh></v>
<v t="ekr.20040303062846.103"><vh>getCaseDataNodes</vh></v>
<v t="ekr.20040303062846.104"><vh>getRowCol</vh></v>
</v>
</v>
</v>
<v t="ekr.20040303071432"><vh>Mini tests</vh>
<v t="ekr.20040302091705"><vh>Test of moving positions</vh></v>
<v t="ekr.20040301162657"><vh>Mini tests of position class</vh>
<v t="ekr.20040301203156"><vh>test p.level</vh></v>
<v t="ekr.20040302103704"><vh>test test parent/child links</vh>
<v t="ekr.20040302110220"><vh>&lt;&lt; check that the parent of p's first child is p &gt;&gt;</vh></v>
<v t="ekr.20040302110220.1"><vh>&lt;&lt; check that the parent of all parent's children is parent &gt;&gt;</vh></v>
</v>
<v t="ekr.20040302110925"><vh>test next/back links</vh></v>
<v t="ekr.20040302113435"><vh>test vnodeList</vh></v>
<v t="ekr.20040302114642"><vh>test threadNext/threadBack</vh></v>
<v t="ekr.20040302142502" a="M"><vh>test p.level/p.parent/p.child</vh></v>
</v>
</v>
<v t="ekr.20040126105605"><vh>Clone test data</vh>
<v t="ekr.20040302092753"><vh>aa</vh></v>
<v t="ekr.20040126105605.2"><vh>a</vh>
<v t="ekr.20040126105605.3"><vh>b</vh>
<v t="ekr.20040301191933"><vh>c</vh>
<v t="ekr.20040302092753.1"><vh>c2</vh>
<v t="ekr.20040302092753.2"><vh>c3</vh></v>
<v t="ekr.20040302092753.3"><vh>c4</vh></v>
</v>
</v>
</v>
<v t="ekr.20040126105605.3"><vh>b</vh>
<v t="ekr.20040301191933"><vh>c</vh>
<v t="ekr.20040302092753.1"><vh>c2</vh>
<v t="ekr.20040302092753.2"><vh>c3</vh></v>
<v t="ekr.20040302092753.3"><vh>c4</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20040301191933.1"><vh>d</vh>
<v t="ekr.20040126105605.2"><vh>a</vh>
<v t="ekr.20040126105605.3"><vh>b</vh>
<v t="ekr.20040301191933"><vh>c</vh>
<v t="ekr.20040302092753.1"><vh>c2</vh>
<v t="ekr.20040302092753.2"><vh>c3</vh></v>
<v t="ekr.20040302092753.3"><vh>c4</vh></v>
</v>
</v>
</v>
<v t="ekr.20040126105605.3"><vh>b</vh>
<v t="ekr.20040301191933"><vh>c</vh>
<v t="ekr.20040302092753.1"><vh>c2</vh>
<v t="ekr.20040302092753.2"><vh>c3</vh></v>
<v t="ekr.20040302092753.3"><vh>c4</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20040301191933.2"><vh>e</vh></v>
<v t="ekr.20040302092753.4"><vh>z</vh></v>
</v>
</v>
<v t="ekr.20040303063644"><vh>Position tests</vh>
<v t="ekr.20040303064013"><vh> makePositionSuite</vh></v>
<v t="ekr.20040303063118"><vh>class positionTestCase</vh>
<v t="ekr.20040303063118.4"><vh>setUp</vh></v>
<v t="ekr.20040303064020.1"><vh>testFullTraverse</vh></v>
<v t="ekr.20040303064020.2"><vh>testParentChildLinks</vh>
<v t="ekr.20040303064020.3"><vh>&lt;&lt; check that the parent of p's first child is p &gt;&gt;</vh></v>
<v t="ekr.20040303064020.4"><vh>&lt;&lt; check that the parent of all parent's children is parent &gt;&gt;</vh></v>
</v>
<v t="ekr.20040303064020.5"><vh>testNextBack</vh></v>
<v t="ekr.20040303064020.6"><vh>testVnodeList</vh></v>
<v t="ekr.20040303064020.7"><vh>test threadNextBack</vh></v>
<v t="ekr.20040303064020.8"><vh>testParentChildLevel</vh></v>
<v t="ekr.20040303091606"><vh>testHasNextBack</vh></v>
<v t="ekr.20040303092153"><vh>testHasParentChild</vh></v>
<v t="ekr.20040303092153.1"><vh>testHasThreadNextBack</vh></v>
</v>
</v>
<v t="ekr.20040303063549"><vh>Unit Tests</vh>
<v t="ekr.20040303063549.1"><vh>tempNode</vh></v>
<v t="ekr.20040303063549.45"><vh>colorizerTests</vh>
<v t="ekr.20040303063549.46"><vh>Actionscript</vh></v>
<v t="ekr.20040303063549.47"><vh>C</vh></v>
<v t="ekr.20040303063549.48"><vh>C#</vh></v>
<v t="ekr.20040303063549.49"><vh>CWEB</vh>
<v t="ekr.20040303063549.50"><vh>&lt;&lt; section ref &gt;&gt;</vh></v>
</v>
<v t="ekr.20040303063549.51"><vh>elisp</vh></v>
<v t="ekr.20040303063549.52"><vh>HTML1</vh></v>
<v t="ekr.20040303063549.53"><vh>HTML2</vh></v>
<v t="ekr.20040303063549.54"><vh>LaTex</vh></v>
<v t="ekr.20040303063549.55"><vh>Mixed</vh></v>
<v t="ekr.20040303063549.56"><vh>PHP</vh></v>
<v t="ekr.20040303063549.57"><vh>Python1</vh></v>
<v t="ekr.20040303063549.58"><vh>Python2</vh></v>
<v t="ekr.20040303063549.59"><vh>Rebol</vh></v>
<v t="ekr.20040303063549.60"><vh>wikiTest1</vh></v>
<v t="ekr.20040303063549.61"><vh>wikiTest2</vh></v>
<v t="ekr.20040303063549.62"><vh>wikiTest3</vh></v>
</v>
<v t="ekr.20040303063549.63"><vh>editBodyTests</vh>
<v t="ekr.20040303063549.64"><vh>dedentBody</vh>
<v t="ekr.20040303063549.65"><vh>before</vh></v>
<v t="ekr.20040303063549.66"><vh>after</vh></v>
<v t="ekr.20040303063549.67"><vh>selection</vh></v>
</v>
<v t="ekr.20040303063549.68"><vh>indentBody</vh>
<v t="ekr.20040303063549.69"><vh>before</vh></v>
<v t="ekr.20040303063549.70"><vh>after</vh></v>
<v t="ekr.20040303063549.71"><vh>selection</vh></v>
</v>
<v t="ekr.20040303063549.72"><vh>extractSection</vh>
<v t="ekr.20040303063549.73"><vh>before</vh></v>
<v t="ekr.20040303063549.74"><vh>after</vh>
<v t="ekr.20040303063549.75"><vh>&lt;&lt; section &gt;&gt;</vh></v>
</v>
<v t="ekr.20040303063549.76"><vh>selection</vh></v>
</v>
</v>
<v t="ekr.20040303063549.77"><vh>exportTests</vh>
<v t="ekr.20040303063549.78"><vh>exportHeadlines</vh>
<v t="ekr.20040303063549.79"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.80"><vh>flattenOutline</vh>
<v t="ekr.20040303063549.81"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.82"><vh>weave</vh>
<v t="ekr.20040303063549.83"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.84"><vh>outlineToNoweb</vh>
<v t="ekr.20040303063549.85"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.86"><vh>outlineToCWEB</vh>
<v t="ekr.20040303063549.87"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.88"><vh>removeSentinels</vh>
<v t="ekr.20040303063549.89"><vh>dialog</vh></v>
</v>
</v>
<v t="ekr.20040303063549.90"><vh>importTests</vh>
<v t="ekr.20040303063549.91"><vh>importAtRoot</vh>
<v t="ekr.20040303063549.92"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.93"><vh>importAtFile</vh>
<v t="ekr.20040303063549.94"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.95"><vh>importNowebFiles</vh>
<v t="ekr.20040303063549.96"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.97"><vh>importFlattenedOutline</vh>
<v t="ekr.20040303063549.98"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.99"><vh>importCWEBFiles</vh>
<v t="ekr.20040303063549.100"><vh>dialog</vh></v>
</v>
</v>
<v t="ekr.20040303063549.101"><vh>outlineTests</vh>
<v t="ekr.20040303063549.102"><vh>moveOutlineDown</vh>
<v t="ekr.20040303063549.103"><vh>before</vh>
<v t="ekr.20040303063549.104"><vh>a</vh></v>
<v t="ekr.20040303063549.105"><vh>move</vh></v>
<v t="ekr.20040303063549.106"><vh>b</vh></v>
</v>
<v t="ekr.20040303063549.107"><vh>after</vh>
<v t="ekr.20040303063549.108"><vh>a</vh></v>
<v t="ekr.20040303063549.109"><vh>b</vh></v>
<v t="ekr.20040303063549.110"><vh>move</vh></v>
</v>
<v t="ekr.20040303063549.111"><vh>ref</vh>
<v t="ekr.20040303063549.112"><vh>a</vh></v>
<v t="ekr.20040303063549.113"><vh>move</vh></v>
<v t="ekr.20040303063549.114"><vh>b</vh></v>
</v>
</v>
<v t="ekr.20040303063549.115"><vh>moveOutlineLeft</vh></v>
<v t="ekr.20040303063549.116"><vh>moveOutlineRight</vh></v>
<v t="ekr.20040303063549.117"><vh>moveOutlineUp</vh></v>
</v>
<v t="ekr.20040303063549.118"><vh>pluginsTests</vh></v>
<v t="ekr.20040303063549.119" a="M"><vh>positionTests</vh></v>
<v t="ekr.20040303063549.2"><vh>reformatParagraphsTests</vh>
<v t="ekr.20040303063549.3"><vh>testNoTrailingNewline</vh>
<v t="ekr.20040303063549.4"><vh>before</vh></v>
<v t="ekr.20040303063549.5"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.6"><vh>testTrailingNewline</vh>
<v t="ekr.20040303063549.7"><vh>before</vh></v>
<v t="ekr.20040303063549.8"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.9"><vh>testMixedLineLengths</vh>
<v t="ekr.20040303063549.10"><vh>before</vh></v>
<v t="ekr.20040303063549.11"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.12"><vh>testMixedLinesWithLeadingWS</vh>
<v t="ekr.20040303063549.13"><vh>before</vh></v>
<v t="ekr.20040303063549.14"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.15"><vh>testNoChangeRequired</vh>
<v t="ekr.20040303063549.16"><vh>before</vh></v>
<v t="ekr.20040303063549.17"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.18"><vh>testHonorLeadingWS</vh>
<v t="ekr.20040303063549.19"><vh>before</vh></v>
<v t="ekr.20040303063549.20"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.21"><vh>testHonorLeadingWSVar1</vh>
<v t="ekr.20040303063549.22"><vh>before</vh></v>
<v t="ekr.20040303063549.23"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.24"><vh>testSimpleHangingIndent</vh>
<v t="ekr.20040303063549.25"><vh>before</vh></v>
<v t="ekr.20040303063549.26"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.27"><vh>testSimpleHangingIndentVar1</vh>
<v t="ekr.20040303063549.28"><vh>before</vh></v>
<v t="ekr.20040303063549.29"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.30"><vh>testSimpleHangingIndentVar2</vh>
<v t="ekr.20040303063549.31"><vh>before</vh></v>
<v t="ekr.20040303063549.32"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.33"><vh>testMultiParagraph</vh>
<v t="ekr.20040303063549.34"><vh>before</vh></v>
<v t="ekr.20040303063549.35"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.36"><vh>testMultiParagraphWithList</vh>
<v t="ekr.20040303063549.37"><vh>before</vh></v>
<v t="ekr.20040303063549.38"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.39"><vh>testDirectiveBreaksParagraph</vh>
<v t="ekr.20040303063549.40"><vh>before</vh></v>
<v t="ekr.20040303063549.41"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.42"><vh>testWithLeadingWSOnEmptyLines</vh>
<v t="ekr.20040303063549.43"><vh>before</vh></v>
<v t="ekr.20040303063549.44"><vh>after</vh></v>
</v>
</v>
<v t="ekr.20040303063549.120"><vh>testLeoFiles</vh>
<v t="ekr.20040303063549.121"><vh>c:\prog\leoCvs\leo\test\test.leo</vh></v>
<v t="ekr.20040303063549.122"><vh>c:\prog\leoCvs\leo\src\LeoPy.leo</vh></v>
<v t="ekr.20040303063549.123"><vh>c:\prog\leoCvs\leo\plugins\leoPlugins.leo</vh></v>
<v t="ekr.20040303063549.124"><vh>c:\prog\leoCvs\leo\doc\LeoDocs.leo</vh></v>
</v>
<v t="ekr.20040303063549.125"><vh>Run all tests</vh></v>
<v t="ekr.20040303080010"><vh>Run all tests except files tests</vh></v>
</v>
<v t="ekr.20040303215834"><vh>Test of position  comparisons</vh></v>
<v t="ekr.20040304082053" a="TV"><vh>__iter__ tests</vh>
<v t="ekr.20040304090931"><vh>__init__</vh></v>
<v t="ekr.20040304090931.1"><vh>__iter__</vh></v>
<v t="ekr.20040304091204"><vh>next</vh></v>
</v>
<v t="ekr.20040304091615"><vh>Node after tree</vh></v>
</vnodes>
<tnodes>
<t tx="ekr.20040126105605"></t>
<t tx="ekr.20040126105605.2"></t>
<t tx="ekr.20040126105605.3"></t>
<t tx="ekr.20040301162657"></t>
<t tx="ekr.20040301191933"></t>
<t tx="ekr.20040301191933.1"></t>
<t tx="ekr.20040301191933.2"></t>
<t tx="ekr.20040301203156">from leoGlobals import *

c = top()
c.convertTreeToSharedNodes()
c.disableSaveCommands()

print ; print "start"

p = c.rootPosition()
while p and p.v.headString().strip().lower() != "clone test":
	p.moveToThreadNext()
	
after = p.getNodeAfterTree()
while p and p != after:
	print p.level(), p.v.headString()
	p.moveToThreadNext()
		
print ; print "done"</t>
<t tx="ekr.20040302091705">from leoGlobals import *

class position:
	def __init__(self):
		self.v = "a"
	def move(self):
		self.v = "b"

p = position()
v = p.v
print "before", v, p.v, v is p.v
p.move()
print "after ", v, p.v, v is p.v</t>
<t tx="ekr.20040302092753"></t>
<t tx="ekr.20040302092753.1"></t>
<t tx="ekr.20040302092753.2"></t>
<t tx="ekr.20040302092753.3"></t>
<t tx="ekr.20040302092753.4"></t>
<t tx="ekr.20040302103704">from leoGlobals import *

c = top()
c.convertTreeToSharedNodes()
c.disableSaveCommands()

print ; print "checking parent/child relationships"

p = c.rootPosition() ; count = 0
while p:
	count += 1
	&lt;&lt; check that the parent of p's first child is p &gt;&gt;
	parent = p.getParent()
	if parent:
		&lt;&lt; check that the parent of all parent's children is parent &gt;&gt;
	p.moveToThreadNext()
		
print ; print "checked %d nodes" % count</t>
<t tx="ekr.20040302110220">firstChild = p.getFirstChild()
if firstChild:
	parent = firstChild.getParent()
	if p != parent:
		print "mismatch:p,parent,child",p,parent,firstChild</t>
<t tx="ekr.20040302110220.1">found = false
child = parent.getFirstChild()
if not child:
	print "parent has no children"
while child:
	if child == p: found
	childParent = child.getParent()
	if childParent != parent:
		print "mismatch:parent,childParent",parent,childParent
	child = child.moveToNext()</t>
<t tx="ekr.20040302110925">from leoGlobals import *

c = top()
c.convertTreeToSharedNodes()
c.disableSaveCommands()

print ; print "checking next/back links"

p = c.rootPosition() ; count = 0
while p:
	back = p.getBack()
	next = p.getNext()
	if back:
		count += 1
		assert(back.getNext() == p)
	if next:
		count += 1
		assert(next.getBack() == p)
	p.moveToThreadNext()
		
print ; print "checked %d nodes" % count</t>
<t tx="ekr.20040302113435">from leoGlobals import *

c = top()
c.convertTreeToSharedNodes()
c.disableSaveCommands()

print ; print "checking consistency of vnodeList"

p = c.rootPosition() ; count = 0
while p:
	vnodeList = p.v.t.vnodeList
	for v in vnodeList:
		count += 1
		assert(v.t == p.v.t)
		if p.v.isCloned():
			assert(v.isCloned())
			assert(len(vnodeList) &gt; 1)
		else:
			assert(not v.isCloned())
			assert(len(vnodeList) == 1)
	
	p.moveToThreadNext()
		
print ; print "checked %d cloned nodes" % count</t>
<t tx="ekr.20040302114642">from leoGlobals import *

c = top()
c.convertTreeToSharedNodes()
c.disableSaveCommands()

print ; print "checking threadBack/threadNext"

p = c.rootPosition() ; count = 0

while p:
	count += 1
	threadBack = p.getThreadBack()
	threadNext = p.getThreadNext()
	if threadBack:
		if threadBack.getThreadNext() != p:
			print "p.threadBack.threadNext != p"
			print "p,threadBack,threadBack.threadNext:"
			print p,threadBack,threadBack.getThreadNext()
		assert(threadBack.getThreadNext()==p)
	if threadNext:
		if threadNext.getThreadBack() != p:
			print "p.threadNext.threadBack != p"
			print "p,threadNext,threadNext.threadBack:"
			print p,threadNext,threadNext.getThreadBack()
		assert(threadNext.getThreadBack()==p)
	p.moveToThreadNext()

print ; print "checked %d nodes" % count</t>
<t tx="ekr.20040302142502"></t>
<t tx="ekr.20040303062846"># Run the unit tests in test.leo using the Execute Script command.</t>
<t tx="ekr.20040303062846.1">@nocolor

- Have log classes increment a count.
	Can be used to ensure that messages did or did not occcur.

- Have the nullGui create a nullUndoer by default
	But allow the possibility of leaving the full undoer in place.

- More checks in CheckOutline command.

- (done by hand) batch mode.
	Have script create a file, fail if the file does not exist.

- Unit tests for read/write commands.</t>
<t tx="ekr.20040303062846.2">"""

Unit tests for Leo.

Run the unit tests in test.leo using the Execute Script command.

"""

from leoGlobals import *

import leoColor,leoCommands,leoFrame,leoGui,leoNodes,leoTkinterGui

import glob,os,sys,unittest

@others</t>
<t tx="ekr.20040303062846.3">class testUtils:
	
	"""Common utility routines used by unit tests."""

	@others</t>
<t tx="ekr.20040303062846.4">def compareOutlines (self,root1,root2):
	
	"""Compares two outlines, making sure that their topologies,
	content and join lists are equivent"""
	
	v1,v2 = root1,root2
	after1 = v1.nodeAfterTree()
	after2 = v2.nodeAfterTree()
	v1 = v1.firstChild()
	v2 = v2.firstChild()
	ok = true
	while v2 and v1 != after1 and v2 != after2:
		ok = (
		v1.numberOfChildren() == v2.numberOfChildren() and
		v1.headString() == v2.headString() and
		v1.bodyString() == v2.bodyString() and
		v1.isCloned()   == v2.isCloned()   )
		if not ok: break
		v1 = v1.threadNext()
		v2 = v2.threadNext()

	ok = ok and v1 == after1 and v2 == after2
	if not ok:
		trace(v1,v2)
	return ok</t>
<t tx="ekr.20040303062846.5">def findChildrenOf (self,headline):
	
	u = self ; c = top() ; v = c.currentVnode()
	root = u.findRootNode(v)
	parent = u.findNodeInTree(root,headline)
	v = parent.firstChild()
	vList = []
	while v:
		vList.append(v)
		v = v.next()
	return vList

def findSubnodesOf (self,headline):
	
	u = self ; c = top() ; v = c.currentVnode()
	root = u.findRootNode(v)
	parent = u.findNodeInTree(root,headline)
	v = parent.firstChild()
	vList = []
	after = parent.nodeAfterTree()
	while v and v != after:
		vList.append(v)
		v = v.threadNext()
	return vList</t>
<t tx="ekr.20040303062846.6">def findRootNode (self,v):

	"""Return the root of v's tree."""
	while v and v.parent():
		v = v.parent()
	return v
	
def findNodeInTree(self,v,headline):

	"""Search for a node in v's tree matching the given headline."""
	if not headline: return None # This is valid.
	after = v.nodeAfterTree()
	while v and v != after:
		if v.headString().strip() == headline.strip():
			return v
		v = v.threadNext()
	return None

def findNodeAnywhere(self,c,headline):
	
	if not headline: return None # This is valid.
	v = c.rootVnode()
	while v:
		if v.headString().strip() == headline.strip():
			return v
		v = v.threadNext()
	return None</t>
<t tx="ekr.20040303062846.7">def numberOfNodesInOutline (self,root):
	
	"""Returns the total number of nodes in an outline"""
	
	n = 0 ; v = root
	while v:
		n +=1
		v = v.threadNext()
	return n
	
def numberOfClonesInOutline (self,root):
	
	"""Returns the number of cloned nodes in an outline"""

	n = 0 ; v = root
	while v:
		if v.isCloned():
			n += 1
		v = v.threadNext()</t>
<t tx="ekr.20040303062846.8">def replaceOutline (self,c,outline1,outline2):
	
	u = self
	
	"""Replace outline1 by a copy of outline 2 if not equal."""
	
	trace()
	
	copy = outline2.copyTreeWithNewTnodes()
	copy.linkAfter(outline1)
	outline1.doDelete(newVnode=copy)
</t>
<t tx="ekr.20040303062846.9">def validateOutline (self,root):
	
	"""Checks an outline for consistency"""
	pass</t>
<t tx="ekr.20040303062846.10">def fail ():
	
	"""Mark a unit test as having failed."""
	
	app.unitTestDict["fail"] = callerName(2)</t>
<t tx="ekr.20040303062846.11"></t>
<t tx="ekr.20040303062846.12">def makeColorSuite(testParentHeadline,tempHeadline):
	
	"""Create a colorizer test for every descendant of testParentHeadline.."""
	
	u = testUtils() ; c = top() ; v = c.currentVnode()
	root = u.findRootNode(v)
	temp_v = u.findNodeInTree(root,tempHeadline)
	vList = u.findSubnodesOf(testParentHeadline)
	
	# Create the suite and add all test cases.
	suite = unittest.makeSuite(unittest.TestCase)
	for v in vList:
		test = colorTestCase(c,v,temp_v)
		suite.addTest(test)

	return suite</t>
<t tx="ekr.20040303062846.13">class colorTestCase(unittest.TestCase):
	
	"""Data-driven unit tests for Leo's colorizer."""
	
	@others</t>
<t tx="ekr.20040303062846.14">def __init__ (self,c,v,temp_v):
	
	# Init the base class.
	unittest.TestCase.__init__(self)

	self.c = c
	self.v = v
	self.temp_v = temp_v
	
	self.old_v = c.currentVnode()</t>
<t tx="ekr.20040303062846.15">def color (self):
	
	c = self.c
	val = c.frame.body.colorizer.colorize(self.temp_v,incremental=false)
	assert(val=="ok")</t>
<t tx="ekr.20040303062846.16">def setUp(self,*args,**keys):

	# trace(args,keys)

	# Initialize the text in the temp node.
	text = self.v.bodyString()
	self.c.selectVnode(self.temp_v)
	self.temp_v.t.setTnodeText(text,app.tkEncoding)
	self.c.frame.body.setSelectionAreas(None,text,None)</t>
<t tx="ekr.20040303062846.17">def tearDown (self):
	
	self.temp_v.t.setTnodeText("",app.tkEncoding)
	self.c.selectVnode(self.old_v)</t>
<t tx="ekr.20040303062846.18">def runTest(self):

	self.color()</t>
<t tx="ekr.20040303062846.19"></t>
<t tx="ekr.20040303062846.20">def makeEditBodySuite(testParentHeadline,tempHeadline):
	
	"""Create an Edit Body test for every descendant of testParentHeadline.."""
	
	u = testUtils() ; c = top() ; v = c.currentVnode()
	root = u.findRootNode(v)
	temp_v = u.findNodeInTree(root,tempHeadline)
	vList = u.findChildrenOf(testParentHeadline)

	# Create the suite and add all test cases.
	suite = unittest.makeSuite(unittest.TestCase)
	for v in vList:
		before = u.findNodeInTree(v,"before")
		after  = u.findNodeInTree(v,"after")
		sel    = u.findNodeInTree(v,"selection")
		ins    = u.findNodeInTree(v,"insert")
		if before and after:
			test = editBodyTestCase(c,v,before,after,sel,ins,temp_v)
			suite.addTest(test)
		else:
			print 'missing "before" or "after" for', v.headString()

	return suite</t>
<t tx="ekr.20040303062846.21">class editBodyTestCase(unittest.TestCase):
	
	"""Data-driven unit tests for Leo's edit body commands."""
	
	@others</t>
<t tx="ekr.20040303062846.22">def __init__ (self,c,parent,before,after,sel,ins,temp_v):
	
	# Init the base class.
	unittest.TestCase.__init__(self)

	self.c = c
	self.parent = parent
	self.before = before
	self.after  = after
	self.sel    = sel # Two lines giving the selection range in tk coordinates.
	self.ins    = ins # One line giveing the insert point in tk coordinate.
	self.temp_v = temp_v
	
	self.old_v = c.currentVnode()
	
	self.wasChanged = c.changed</t>
<t tx="ekr.20040303062846.23">def editBody (self):
	
	c = self.c ; temp_v = self.temp_v ; after = self.after

	# Compute the result in temp_v.bodyString()
	commandName = self.parent.headString()
	command = getattr(c,commandName)
	command()
	
	# Compare the computed result to the reference result.
	new_text = temp_v.bodyString().rstrip()
	ref_text = after.bodyString().rstrip()

	if new_text != ref_text:
		print ; print "test failed", commandName
		trace("new",new_text)
		trace("ref",ref_text)
		
	assert(new_text == ref_text)
	
	# Compare subtrees.
	
	assert(temp_v.numberOfChildren() == after.numberOfChildren())
	
	ref_child = after.firstChild()
	new_child = temp_v.firstChild()
	
	while new_child:
		new_text = new_child.bodyString().rstrip()
		ref_text = ref_child.bodyString().rstrip()

		if new_text != ref_text:
			print ; print "test failed", commandName
			trace("new",new_text)
			trace("ref",ref_text)
		
		assert(new_text == ref_text)
		
		new_child = new_child.next()
		ref_child = ref_child.next()</t>
<t tx="ekr.20040303062846.24">def tearDown (self):
	
	c = self.c ; temp_v = self.temp_v
	
	temp_v.t.setTnodeText("",app.tkEncoding)
	temp_v.clearDirty()
	
	if not self.wasChanged:
		c.setChanged (false)
		
	# Delete all children of temp node.
	while temp_v.firstChild():
		temp_v.firstChild().doDelete(temp_v)

	c.selectVnode(self.old_v)</t>
<t tx="ekr.20040303062846.25"># Warning: this is Tk-specific code.

def setUp(self,*args,**keys):
	
	c = self.c ; temp_v = self.temp_v
	
	# Delete all children of temp node.
	while temp_v.firstChild():
		temp_v.firstChild().doDelete(temp_v)

	text = self.before.bodyString()
	
	temp_v.t.setTnodeText(text,app.tkEncoding)
	c.selectVnode(self.temp_v)
	
	t = c.frame.body.bodyCtrl
	if self.sel:
		s = self.sel.bodyString()
		lines = s.split('\n')
		app.gui.setTextSelection(t,lines[0],lines[1])

	if self.ins:
		s = self.ins.bodyString()
		lines = s.split('\n')
		app.gui.setInsertPoint(t,lines[0])
		
	if not self.sel and not self.ins:
		app.gui.setInsertPoint(t,"1.0")
		app.gui.setTextSelection(t,"1.0","1.0")
</t>
<t tx="ekr.20040303062846.26">def runTest(self):

	self.editBody()</t>
<t tx="ekr.20040303062846.27"></t>
<t tx="ekr.20040303062846.28">def makeImportExportSuite(testParentHeadline,tempHeadline):
	
	"""Create an Import/Export test for every descendant of testParentHeadline.."""
	
	u = testUtils() ; c = top() ; v = c.currentVnode()
	root = u.findRootNode(v)
	temp_v = u.findNodeInTree(root,tempHeadline)
	vList = u.findChildrenOf(testParentHeadline)

	# Create the suite and add all test cases.
	suite = unittest.makeSuite(unittest.TestCase)
	for v in vList:
		dialog = u.findNodeInTree(v,"dialog")
		test = importExportTestCase(c,v,dialog,temp_v)
		suite.addTest(test)

	return suite</t>
<t tx="ekr.20040303062846.29">class importExportTestCase(unittest.TestCase):
	
	"""Data-driven unit tests for Leo's edit body commands."""
	
	@others</t>
<t tx="ekr.20040303062846.30">def __init__ (self,c,v,dialog,temp_v):
	
	# Init the base class.
	unittest.TestCase.__init__(self)
	
	self.c = c
	self.dialog = dialog
	self.v = v
	self.temp_v = temp_v
	
	self.gui = None
	self.wasChanged = c.changed
	self.fileName = ""

	self.old_v = c.currentVnode()

</t>
<t tx="ekr.20040303062846.31">def importExport (self):
	
	c = self.c ; v = self.v
	
	app.unitTestDict = {}

	commandName = v.headString()
	command = getattr(c,commandName) # Will fail if command does not exist.
	command()

	failedMethod = app.unitTestDict.get("fail")
	self.failIf(failedMethod,failedMethod)</t>
<t tx="ekr.20040303062846.32">def runTest(self):
	
	# """Import Export Test Case"""

	self.importExport()</t>
<t tx="ekr.20040303062846.33">def setUp(self,*args,**keys):
	
	c = self.c ; temp_v = self.temp_v ; d = self.dialog
	
	temp_v.t.setTnodeText('',app.tkEncoding)

	# Create a node under temp_v.
	child = temp_v.insertAsLastChild()
	assert(child)
	child.setHeadString("import test: " + self.v.headString())
	c.selectVnode(child)

	assert(d)
	s = d.bodyString()
	lines = s.split('\n')
	name = lines[0]
	val = lines[1]
	self.fileName = val
	dict = {name: val}
	self.gui = leoGui.unitTestGui(dict,trace=false)
	
	</t>
<t tx="ekr.20040303062846.34">def shortDescription (self):
	
	try:
		return "ImportExportTestCase: %s %s" % (self.v.headString(),self.fileName)
	except:
		return "ImportExportTestCase"</t>
<t tx="ekr.20040303062846.35">def tearDown (self):
	
	c = self.c ; temp_v = self.temp_v
	
	if self.gui:
		self.gui.destroySelf()
		self.gui = None
	
	temp_v.t.setTnodeText("",app.tkEncoding)
	temp_v.clearDirty()
	
	if not self.wasChanged:
		c.setChanged (false)
		
	if 1: # Delete all children of temp node.
		while temp_v.firstChild():
			temp_v.firstChild().doDelete(temp_v)

	c.selectVnode(self.old_v)</t>
<t tx="ekr.20040303062846.36"></t>
<t tx="ekr.20040303062846.37">def makeTestLeoFilesSuite(testParentHeadline,unused=None):
	
	"""Create a .leo file test for every descendant of testParentHeadline.."""
	
	u = testUtils() ; c = top()
	
	vList = u.findChildrenOf(testParentHeadline)

	# Create the suite and add all test cases.
	suite = unittest.makeSuite(unittest.TestCase)
	for v in vList:
		test = leoFileTestCase(c,v.headString().strip())
		suite.addTest(test)

	return suite
</t>
<t tx="ekr.20040303062846.38">class leoFileTestCase(unittest.TestCase):
	
	"""Data-driven unit tests to test .leo files."""
	
	@others</t>
<t tx="ekr.20040303062846.39">def __init__ (self,c,fileName):
	
	# Init the base class.
	unittest.TestCase.__init__(self)

	self.old_c = c
	self.c = None # set by setUp.
	self.fileName = fileName
	self.gui = None # set by setUp
	self.openFrames = app.windowList[:]</t>
<t tx="ekr.20040303062846.40">def runTest(self):
	
	"""Run the Check Outline command."""

	errors = self.c.checkOutline()
	assert(errors == 0)</t>
<t tx="ekr.20040303062846.41">def setUp(self):

	"""Open the .leo file."""
	

	c = self.old_c ; fileName = self.fileName
	assert(os_path_exists(fileName))
	
	self.oldGui = app.gui
	# app.gui = leoGui.nullGui("nullGui")

	ok, frame = openWithFileName(fileName,c,enableLog=false)
	assert(ok)
	self.c = frame.c</t>
<t tx="ekr.20040303062846.42">def tearDown (self):

	"""Close the .leo file if it was not already open."""

	frame = self.c.frame
	if frame not in self.openFrames:
		app.closeLeoWindow(frame)

	app.gui = self.oldGui</t>
<t tx="ekr.20040303062846.63"></t>
<t tx="ekr.20040303062846.64">def makeOutlineSuite(testParentHeadline,unused=None):
	
	"""Create an outline test for every descendant of testParentHeadline.."""
	
	u = testUtils() ; c = top() ; v = c.currentVnode()
	
	vList = u.findChildrenOf(testParentHeadline)

	# Create the suite and add all test cases.
	suite = unittest.makeSuite(unittest.TestCase)
	for v in vList:
		before = u.findNodeInTree(v,"before")
		after  = u.findNodeInTree(v,"after")
		ref    = u.findNodeInTree(v,"ref")
		if before and after and ref:
			test = outlineTestCase(c,v,before,after,ref)
			suite.addTest(test)

	return suite
</t>
<t tx="ekr.20040303062846.65">class outlineTestCase(unittest.TestCase):
	
	"""Data-driven unit tests for Leo's outline commands."""
	
	@others</t>
<t tx="ekr.20040303062846.66">def __init__ (self,c,parent,before,after,ref):
	
	# Init the base class.
	unittest.TestCase.__init__(self)

	self.c = c
	self.parent = parent
	self.before = before
	self.after = after
	self.ref    = ref
	
	self.old_v = c.currentVnode()
	
	self.u = testUtils()</t>
<t tx="ekr.20040303062846.67">def outlineCommand (self):
	
	c = self.c ; u = self.u ; tree = c.frame.tree
	
	move = u.findNodeInTree(self.before,"move")
	assert(move)
	
	c.selectVnode(move)
	
	commandName = self.parent.headString()
	command = getattr(c,commandName)
	command()

	assert(u.compareOutlines(self.before,self.after))
	c.undoer.undo()
	assert(u.compareOutlines(self.before,self.ref))
	c.undoer.redo()
	assert(u.compareOutlines(self.before,self.after))
	c.undoer.undo()
	assert(u.compareOutlines(self.before,self.ref))</t>
<t tx="ekr.20040303062846.68">def runTest(self):

	self.outlineCommand()</t>
<t tx="ekr.20040303062846.69">def setUp(self,*args,**keys):

	assert(self.before)
	assert(self.after)
	assert(self.ref)
	assert(self.u.compareOutlines(self.before,self.ref))
	
	# Batch mode bugs: meaning of move may depend on visibility.
	self.parent.parent().expand()
	self.parent.expand()
	self.before.expand()
	self.after.expand()</t>
<t tx="ekr.20040303062846.70">def tearDown (self):

	c = self.c ; u = self.u

	if not u.compareOutlines(self.before,self.ref):
		u.replaceOutline(c,self.before,self.ref)

	self.before.contract()
	self.after.contract()
	self.parent.contract()
	self.parent.parent().contract()

	self.c.selectVnode(self.old_v)</t>
<t tx="ekr.20040303062846.71">def makePluginsSuite(verbose=false,*args,**keys):
	
	"""Create an plugins test for every .py file in the plugins directory."""
	
	plugins_path = os_path_join(app.loadDir,"..","plugins")
	
	files = glob.glob(os_path_join(plugins_path,"*.py"))
	files = [os_path_abspath(file) for file in files]
	files.sort()

	# Create the suite and add all test cases.
	suite = unittest.makeSuite(unittest.TestCase)
	
	for file in files:
		test = pluginTestCase(file,verbose)
		suite.addTest(test)

	return suite
</t>
<t tx="ekr.20040303062846.72"></t>
<t tx="ekr.20040303062846.73">class pluginTestCase(unittest.TestCase):
	
	"""Unit tests for one Leo plugin."""
	
	@others</t>
<t tx="ekr.20040303062846.74">def __init__ (self,fileName,verbose):
	
	# Init the base class.
	unittest.TestCase.__init__(self)

	self.fileName = fileName
	self.oldGui = None
	self.verbose = verbose</t>
<t tx="ekr.20040303062846.75">def pluginTest (self):
	
	# Duplicate the import logic in leoPlugins.py.
	
	fileName = toUnicode(self.fileName,app.tkEncoding)
	path = os_path_join(app.loadDir,"..","plugins")
	
	if self.verbose:
		trace(str(shortFileName(fileName)))

	module = importFromPath(fileName,path)
	assert(module)
	
	# Run any unit tests in the module itself.
	if hasattr(module,"unitTest"):
		
		if self.verbose:
			trace("Executing unitTest in %s..." % str(shortFileName(fileName)))

		module.unitTest()</t>
<t tx="ekr.20040303062846.76">def runTest(self):

	self.pluginTest()</t>
<t tx="ekr.20040303062846.77">def setUp(self,*args,**keys):

	self.oldGui = app.gui
	# app.gui = leoTkinterGui.tkinterGui()</t>
<t tx="ekr.20040303062846.78">def shortDescription (self):
	
	return "pluginTestCase: " + self.fileName</t>
<t tx="ekr.20040303062846.79">def tearDown (self):

	app.gui = self.oldGui</t>
<t tx="ekr.20040303062846.80"># DTHEIN 2004.01.11: Added unit tests for reformatParagraph</t>
<t tx="ekr.20040303062846.81"># DTHEIN 2004.01.11: Added method
def makeReformatParagraphSuite():
	
	"""makeReformatParagraphSuite() -&gt; suite
	
	Create a Reformat Paragraph test for each of the 
	unit tests in the reformatParagraphTestCase class."""
	
	suite = unittest.TestSuite()
	suite.addTest(reformatParagraphTestCase("testNoTrailingNewline"))
	suite.addTest(reformatParagraphTestCase("testTrailingNewline"))
	suite.addTest(reformatParagraphTestCase("testMixedLineLengths"))
	suite.addTest(reformatParagraphTestCase("testMixedLinesWithLeadingWS"))
	suite.addTest(reformatParagraphTestCase("testNoChangeRequired"))
	suite.addTest(reformatParagraphTestCase("testHonorLeadingWS"))
	suite.addTest(reformatParagraphTestCase("testHonorLeadingWSVar1"))
	suite.addTest(reformatParagraphTestCase("testSimpleHangingIndent"))
	suite.addTest(reformatParagraphTestCase("testSimpleHangingIndentVar1"))
	suite.addTest(reformatParagraphTestCase("testSimpleHangingIndentVar2"))
	suite.addTest(reformatParagraphTestCase("testMultiParagraph"))
	suite.addTest(reformatParagraphTestCase("testMultiParagraphWithList"))
	suite.addTest(reformatParagraphTestCase("testDirectiveBreaksParagraph"))
	suite.addTest(reformatParagraphTestCase("testWithLeadingWSOnEmptyLines"))
	return suite
	#	suite = reformatParagraphTestCase().suite();
	#return suite</t>
<t tx="ekr.20040303062846.82"># DTHEIN 2004.01.11: Added class
class reformatParagraphTestCase(unittest.TestCase):
	
	"""Unit tests for Leo's reformat paragraph command."""
	
	@others</t>
<t tx="ekr.20040303062846.83"># DTHEIN 2004.01.11: Added method
def setUp(self):

	self.u = testUtils()
	self.c = top()
	self.current_v = self.c.currentVnode()
	self.old_v = self.c.currentVnode()
	root = self.u.findRootNode(self.current_v)
	self.temp_v = self.u.findNodeInTree(root,"tempNode")
	self.tempChild_v = None
	self.dataParent_v = self.u.findNodeInTree(root,"reformatParagraphsTests")
	self.before_v = None
	self.after_v = None
	self.case_v = None
	self.wasChanged = self.c.changed
	

</t>
<t tx="ekr.20040303062846.84"># DTHEIN 2004.01.11: Added method
def tearDown(self):
	
	# local variables for class fields, for ease
	# of reading and ease of typeing.
	#	
	c = self.c ; temp_v = self.temp_v
	
	# clear the temp node and mark it unchanged
	#
	temp_v.t.setTnodeText("",app.tkEncoding)
	temp_v.clearDirty()
	
	if not self.wasChanged:
		c.setChanged (false)
		
	# Delete all children of temp node.
	#
	while temp_v.firstChild():
		temp_v.firstChild().doDelete(temp_v)

	# make the original node the current node
	#
	c.selectVnode(self.old_v)</t>
<t tx="ekr.20040303062846.85"># DTHEIN 2004.01.11: Added method
def testNoTrailingNewline(self):
	
	self.singleParagraphTest("testNoTrailingNewline",2,24)
</t>
<t tx="ekr.20040303062846.86"># DTHEIN 2004.01.11: Added method
def testTrailingNewline(self):
	
	self.singleParagraphTest("testTrailingNewline",3,0)
</t>
<t tx="ekr.20040303062846.87"># DTHEIN 2004.01.11: Added method
def testMixedLineLengths(self):
	
	self.singleParagraphTest("testMixedLineLengths",4,10)
</t>
<t tx="ekr.20040303062846.88"># DTHEIN 2004.01.11: Added method
def testMixedLinesWithLeadingWS(self):
	
	self.singleParagraphTest("testMixedLinesWithLeadingWS",4,12)
</t>
<t tx="ekr.20040303062846.89"># DTHEIN 2004.01.11: Added method
def testNoChangeRequired(self):
	
	self.singleParagraphTest("testNoChangeRequired",1,28)
</t>
<t tx="ekr.20040303062846.90"># DTHEIN 2004.01.11: Added method
def testHonorLeadingWS(self):
	
	self.singleParagraphTest("testHonorLeadingWS",5,16)
</t>
<t tx="ekr.20040303062846.91"># DTHEIN 2004.01.11: Added method
def testHonorLeadingWSVar1(self):
	
	self.singleParagraphTest("testHonorLeadingWSVar1",5,16)
</t>
<t tx="ekr.20040303062846.92"># DTHEIN 2004.01.11: Added method
def testSimpleHangingIndent(self):
	
	self.singleParagraphTest("testSimpleHangingIndent",5,8)
</t>
<t tx="ekr.20040303062846.93"># DTHEIN 2004.01.11: Added method
def testSimpleHangingIndentVar1(self):
	
	self.singleParagraphTest("testSimpleHangingIndentVar1",5,8)
</t>
<t tx="ekr.20040303062846.94"># DTHEIN 2004.01.11: Added method
def testSimpleHangingIndentVar2(self):
	
	self.singleParagraphTest("testSimpleHangingIndentVar2",5,8)
</t>
<t tx="ekr.20040303062846.95"># DTHEIN 2004.01.11: Added method
def testMultiParagraph(self):
	
	# Locate the test data
	#
	self.getCaseDataNodes("testMultiParagraph")
	
	# Setup the temp node
	#
	self.copyBeforeToTemp()
	
	# reformat the paragraph and check insertion cursor position
	#
	self.c.reformatParagraph()
	self.checkPosition(13,0)
	
	# Keep going, in the same manner
	#
	self.c.reformatParagraph()
	self.checkPosition(25,0)
	self.c.reformatParagraph()
	self.checkPosition(32,11)
	
	# Compare the computed result to the reference result.
	self.checkText()
</t>
<t tx="ekr.20040303062846.96"># DTHEIN 2004.01.11: Added method
def testMultiParagraphWithList(self):
	
	# Locate the test data
	#
	self.getCaseDataNodes("testMultiParagraphWithList")
	
	# Setup the temp node
	#
	self.copyBeforeToTemp()
	
	# reformat the paragraph and check insertion cursor position
	#
	self.c.reformatParagraph()
	self.checkPosition(4,0)
	
	# Keep going, in the same manner
	#
	self.c.reformatParagraph()
	self.checkPosition(7,0)
	self.c.reformatParagraph()
	self.checkPosition(10,0)
	self.c.reformatParagraph()
	self.checkPosition(13,0)
	self.c.reformatParagraph()
	self.checkPosition(14,18)
	
	# Compare the computed result to the reference result.
	self.checkText()
</t>
<t tx="ekr.20040303062846.97"># DTHEIN 2004.01.11: Added method
def testDirectiveBreaksParagraph(self):
	
	# Locate the test data
	#
	self.getCaseDataNodes("testDirectiveBreaksParagraph")
	
	# Setup the temp node
	#
	self.copyBeforeToTemp()
	
	# reformat the paragraph and check insertion cursor position
	#
	self.c.reformatParagraph()
	self.checkPosition(13,0) # at next paragraph
	
	# Keep going, in the same manner
	#
	self.c.reformatParagraph()
	self.checkPosition(25,0) # at next paragraph

	self.c.reformatParagraph()
	self.checkPosition(32,11)
	
	# Compare the computed result to the reference result.
	self.checkText()
</t>
<t tx="ekr.20040303062846.98"># DTHEIN 2004.01.11: Added method
def testWithLeadingWSOnEmptyLines(self):
	
	# Locate the test data
	#
	self.getCaseDataNodes("testWithLeadingWSOnEmptyLines")
	
	# Setup the temp node
	#
	self.copyBeforeToTemp()
	
	# reformat the paragraph and check insertion cursor position
	#
	self.c.reformatParagraph()
	self.checkPosition(4,0)
	
	# Keep going, in the same manner
	#
	self.c.reformatParagraph()
	self.checkPosition(7,0)
	self.c.reformatParagraph()
	self.checkPosition(10,0)
	self.c.reformatParagraph()
	self.checkPosition(13,0)
	self.c.reformatParagraph()
	self.checkPosition(14,18)
	
	# Compare the computed result to the reference result.
	self.checkText()
</t>
<t tx="ekr.20040303062846.99"># DTHEIN 2004.01.11: Added method
def singleParagraphTest(self,caseName,finalRow,finalCol):
	
	# Locate the test data
	#
	self.getCaseDataNodes(caseName)
	
	# Setup the temp node
	#
	self.copyBeforeToTemp()
	
	# reformat the paragraph
	#
	self.c.reformatParagraph()
	
	# Compare the computed result to the reference result.
	self.checkText()
	self.checkPosition(finalRow,finalCol)

</t>
<t tx="ekr.20040303062846.100"># DTHEIN 2004.01.11: Added method
def checkPosition(self,expRow,expCol):

	row,col = self.getRowCol()
	self.failUnlessEqual(expCol,col,
		"Current position is (" + str(row) + "," + str(col) 
		+ ");  expected cursor to be at column " + str(expCol) + ".")
	self.failUnlessEqual(expRow,row,
		"Current position is (" + str(row) + "," + str(col) 
		+ ");  expected cursor to be at line " + str(expRow) + ".")
</t>
<t tx="ekr.20040303062846.101"># DTHEIN 2004.01.11: Added method
def checkText(self):

	new_text = self.tempChild_v.bodyString()
	ref_text = self.after_v.bodyString()
	newLines = new_text.splitlines(1)
	refLines = ref_text.splitlines(1)
	newLinesCount = len(newLines)
	refLinesCount = len(refLines)
	for i in range(min(newLinesCount,refLinesCount)):
		self.failUnlessEqual(newLines[i],refLines[i],
			"Mismatch on line " + str(i) + "."
			+ "\nExpected text: " + `refLines[i]`
			+ "\n  Actual text: "	+ `newLines[i]`)
	self.failUnlessEqual(newLinesCount,refLinesCount,
		"Expected " + str(refLinesCount) + " lines, but "
		+ "received " + str(newLinesCount) + " lines.")</t>
<t tx="ekr.20040303062846.102"># DTHEIN 2004.01.11: Added method
# Warning: this is Tk-specific code.
#
def copyBeforeToTemp(self):

	# local variables for class fields, for ease
	# of reading and ease of typeing.
	#	
	c = self.c ; temp_v = self.temp_v

	# Delete all children of temp node.
	#
	while temp_v.firstChild():
		temp_v.firstChild().doDelete(temp_v)

	# Copy the test case node text to the temp node
	#
	text = self.case_v.bodyString()
	temp_v.t.setTnodeText(text,app.tkEncoding)
	
	# create the child node that holds the text
	#
	t = leoNodes.tnode(headString="tempChildNode")
	self.tempChild_v = self.temp_v.insertAsNthChild(0,t)

	# copy the before text to the temp text
	#
	text = self.before_v.bodyString()
	self.tempChild_v.t.setTnodeText(text,app.tkEncoding)
	
	# make the temp child node current, and put the
	# cursor at the beginning
	#
	c.selectVnode(self.tempChild_v)
	c.frame.body.setInsertPointToStartOfLine( 0 )
	c.frame.body.setTextSelection(None,None)
	#app.gui.setInsertPoint(t,"1.0")
	#app.gui.setTextSelection(t,"1.0","1.0")
</t>
<t tx="ekr.20040303062846.103"># DTHEIN 2004.01.11: Added method
def getCaseDataNodes(self,caseNodeName):

	self.case_v = self.u.findNodeInTree(self.dataParent_v,caseNodeName)
	self.before_v = self.u.findNodeInTree(self.case_v,"before")
	self.after_v  = self.u.findNodeInTree(self.case_v,"after")
</t>
<t tx="ekr.20040303062846.104"># DTHEIN 2004.01.11: Added method
def getRowCol(self):
	
	# local variables for class fields, for ease
	# of reading and ease of typeing.
	#	
	c = self.c ; body = c.frame.body.bodyCtrl ; gui = app.gui
	tab_width = c.frame.tab_width

	# Get the Tkinter row col position of the insert cursor
	#	
	index = body.index("insert")
	row,col = gui.getindex(body,index)
	
	# Adjust col position for tabs
	#
	if col &gt; 0:
		s = body.get("%d.0" % (row),index)
		s = toUnicode(s,app.tkEncoding)
		col = computeWidth(s,tab_width)

	return (row,col)
</t>
<t tx="ekr.20040303063118">class positionTestCase(unittest.TestCase):
	
	"""Unit tests for Leo's position class."""
	
	@others</t>
<t tx="ekr.20040303063118.4">def setUp(self,*args,**keys):
	
	self.c = c = top()
	self.verbose = true

	c.convertTreeToSharedNodes()
	c.disableSaveCommands()</t>
<t tx="ekr.20040303063549"></t>
<t tx="ekr.20040303063549.1"></t>
<t tx="ekr.20040303063549.2">@ 
# DTHEIN 2004.01.11: Added script

Each child node will in turn have two or more children:
	
- a "before" node
- an "after" node

The parent to before and after nodes will contain pagewidth
and language formatting directives
@c

import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

suite = leoTest.makeReformatParagraphSuite()
result = unittest.TestResult()
runner = unittest.TextTestRunner()
runner.run(suite)</t>
<t tx="ekr.20040303063549.3">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Wrap a long line, no trailing newline.
</t>
<t tx="ekr.20040303063549.4">This line is over forty characters long, at least it seems to be.</t>
<t tx="ekr.20040303063549.5">This line is over forty characters long,
at least it seems to be.</t>
<t tx="ekr.20040303063549.6">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Wrap a long line, with trailing newline.
</t>
<t tx="ekr.20040303063549.7">This line is over forty characters long, at least it seems to be.
</t>
<t tx="ekr.20040303063549.8">This line is over forty characters long,
at least it seems to be.
</t>
<t tx="ekr.20040303063549.9">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Wrap a long line and some short ones.</t>
<t tx="ekr.20040303063549.10">This line is over forty characters long, at least it seems to be.
This is shorter, 
but should be part of the same
paragraph.</t>
<t tx="ekr.20040303063549.11">This line is over forty characters long,
at least it seems to be. This is
shorter, but should be part of the same
paragraph.</t>
<t tx="ekr.20040303063549.12">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Wrap a paragraph with interior lines that have leading white space.</t>
<t tx="ekr.20040303063549.13">This line is over forty characters long, at least it seems to be.
  This indented line should be merged into the same
paragraph.</t>
<t tx="ekr.20040303063549.14">This line is over forty characters long,
  at least it seems to be. This indented
  line should be merged into the same
  paragraph.</t>
<t tx="ekr.20040303063549.15">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

No wrapping required, so don't change a thing.</t>
<t tx="ekr.20040303063549.16">This line is under 40 chars.</t>
<t tx="ekr.20040303063549.17">This line is under 40 chars.</t>
<t tx="ekr.20040303063549.18">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Honor the first line's leading whitespace.</t>
<t tx="ekr.20040303063549.19">   This line is over forty characters long, at least it seems to be.
   This is shorter, 
but should be part of the same
paragraph.  And this is indented 3 characters.</t>
<t tx="ekr.20040303063549.20">   This line is over forty characters
   long, at least it seems to be. This
   is shorter, but should be part of the
   same paragraph. And this is indented
   3 characters.</t>
<t tx="ekr.20040303063549.21">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Honor the first and second line's leading whitespace.</t>
<t tx="ekr.20040303063549.22">   This line is over forty characters long, at least it seems to be.
   This is shorter, 
     but should be part of the same
     paragraph.  And this is indented 3 characters.</t>
<t tx="ekr.20040303063549.23">   This line is over forty characters
   long, at least it seems to be. This
   is shorter, but should be part of the
   same paragraph. And this is indented
   3 characters.</t>
<t tx="ekr.20040303063549.24">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Single paragraph, hanging indentation.</t>
<t tx="ekr.20040303063549.25">Honor this line that has a hanging indentation, please.  Hanging
  indentation is valuable for lists of all kinds.  But it is tricky to get right.</t>
<t tx="ekr.20040303063549.26">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.</t>
<t tx="ekr.20040303063549.27">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Single paragraph, hanging indentation with other indentation beyond line 2.</t>
<t tx="ekr.20040303063549.28">Honor this line that has
  a hanging indentation, please.  Hanging
    indentation is valuable for lists of all kinds.  But it is tricky to get right.</t>
<t tx="ekr.20040303063549.29">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.</t>
<t tx="ekr.20040303063549.30">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Single paragraph, hanging indentation, short lines, extraneous indentation, and last line uses a tab for whitespace.</t>
<t tx="ekr.20040303063549.31">Honor this line that 
  has a hanging indentation, 
  please.  Hanging
   indentation is valuable
    for lists of all kinds.  But 
	it is tricky to get right.</t>
<t tx="ekr.20040303063549.32">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.</t>
<t tx="ekr.20040303063549.33">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Mutliple long lined paragraphs.  Cursor should move to next paragraph after formatting a paragraph.</t>
<t tx="ekr.20040303063549.34">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20040303063549.35">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?</t>
<t tx="ekr.20040303063549.36">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

A regular paragraph, plus a numbered list of several items, plus a final regular paragraph.  Cursor should move to next paragraph after formatting a paragraph.
</t>
<t tx="ekr.20040303063549.37">This paragraph leads of this test.  It is the "lead"
paragraph.

  1. This is item 
     number 1.  It is the first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.</t>
<t tx="ekr.20040303063549.38">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test. It is the
"final" paragraph.</t>
<t tx="ekr.20040303063549.39">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Test to make sure that reformatting treats directives as a new paragraph and doesn't wrap directive lines.
</t>
<t tx="ekr.20040303063549.40">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.
@unknownDirective
Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.
@unknownDirective
StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20040303063549.41">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.
@unknownDirective
Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.
@unknownDirective
StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?</t>
<t tx="ekr.20040303063549.42">@language plain
@pagewidth 40
@tabwidth 8

Ran into a problem with the wrapping
eating blank lines that delimit
paragraphs if those blank lines have any
leading whitespace. This test is to make
sure that still works.

If you "show invisibles" you'll see the
leading whitespace in the blank lines --
which is different from the
"testMultiParagraphWithList" test.</t>
<t tx="ekr.20040303063549.43">This paragraph leads of this test.  It is the "lead"
paragraph.
  
  1. This is item 
     number 1.  It is the first item in the list.
  
  2. This is item 
     number 2.  It is the second item in the list.
  
  3. This is item 
     number 3.  It is the third item in the list.
  
This paragraph ends the test.  It is the "final"
paragraph.</t>
<t tx="ekr.20040303063549.44">This paragraph leads of this test. It is
the "lead" paragraph.
  
  1. This is item number 1. It is the
     first item in the list.
  
  2. This is item number 2. It is the
     second item in the list.
  
  3. This is item number 3. It is the
     third item in the list.
  
This paragraph ends the test. It is the
"final" paragraph.</t>
<t tx="ekr.20040303063549.45">@color

import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

suite = leoTest.makeColorSuite("colorizerTests","tempNode")
runner = unittest.TextTestRunner()
runner.run(suite)</t>
<t tx="ekr.20040303063549.46">@language actionscript

break
call, continue
delete, do
else
false, for, function
goto
if, in
new, null
return
true, typeof
undefined
var, void, while, with
#include
catch, constructor
prototype
this, try
_parent, _root, __proto__
// Jeeze hasn't anyone ever heard of namespaces??
ASnative, abs, acos, appendChild, asfunction, asin, atan, atan2, attachMovie, attachSound, attributes
BACKSPACE
CAPSLOCK, CONTROL, ceil, charAt, charCodeAt, childNodes, chr, cloneNode, close, concat, connect, cos, createElement, createTextNode
DELETEKEY, DOWN, docTypeDecl, duplicateMovieClip
END, ENTER, ESCAPE, enterFrame, entry, equal, eval, evaluate, exp
firstChild, floor, fromCharCode, fscommand, getAscii
getBeginIndex, getBounds, getBytesLoaded, getBytesTotal, getCaretIndex, getCode, getDate, getDay, getEndIndex, getFocus, getFullYear, getHours, getMilliseconds, getMinutes, getMonth, getPan, getProperty, getRGB, getSeconds, getTime, getTimer, getTimezoneOffset, getTransform, getURL, getUTCDate, getUTCDay, getUTCFullYear, getUTCHours, getUTCMilliseconds, getUTCMinutes, getUTCMonth, getUTCSeconds, getVersion, getVolume, getYear, globalToLocal, gotoAndPlay, gotoAndStop
HOME, haschildNodes, hide, hitTest
INSERT, Infinity, ifFrameLoaded, ignoreWhite, indexOf, insertBefore, int, isDown, isFinite, isNaN, isToggled
join
keycode, keyDown, keyUp
LEFT, LN10, LN2, LOG10E, LOG2E, lastChild, lastIndexOf, length, load, loaded, loadMovie, loadMovieNum, loadVariables, loadVariablesNum, localToGlobal, log
MAX_VALUE, MIN_VALUE, max, maxscroll, mbchr, mblength, mbord, mbsubstring, min, 
NEGATIVE_INFINITY, NaN, newline, nextFrame, nextScene, nextSibling, nodeName, nodeType, nodeValue
on, onClipEvent, onClose, onConnect, onData, onLoad, onXML, ord
PGDN, PGUP, PI, POSITIVE_INFINITY, parentNode, parseFloat, parseInt, parseXML, play, pop, pow, press, prevFrame, previousSibling, prevScene, print, printAsBitmap, printAsBitmapNum, printNum, push
RIGHT, random, release, removeMovieClip, removeNode, reverse, round
SPACE, SQRT1_2, SQRT2, scroll, send, sendAndLoad, set, setDate, setFocus, setFullYear, setHours, setMilliseconds, setMinutes, setMonth, setPan, setProperty, setRGB, setSeconds, setSelection, setTime, setTransform, setUTCDate, setUTCFullYear, setUTCHours, setUTCMilliseconds, setUTCMinutes, setUTCMonth, setUTCSeconds, setVolume, setYear, shift, show, sin, slice, sort, start, startDrag, status, stop, stopAllSounds, stopDrag, substr, substring, swapDepths, splice, split, sqrt
TAB, tan, targetPath, tellTarget, toggleHighQuality, toLowerCase, toString, toUpperCase, trace
UP, UTC, unescape, unloadMovie, unLoadMovieNum, unshift, updateAfterEvent
valueOf
xmlDecl, _alpha
_currentframe
_droptarget
_focusrect, _framesloaded
_height, _highquality
_name
_quality
_rotation
_soundbuftime
_target, _totalframes
_url
_visible
_width
_x, _xmouse, _xscale
_y, _ymouse, _yscale
and, add, eq, ge, gt, le, lt, ne, not, or, Array, Boolean, Color, Date, Key, Math, MovieClip, Mouse, Number, Object, Selection, Sound, String, XML, XMLSocket</t>
<t tx="ekr.20040303063549.47">@language c
@comment /* */

@
@c

#define WIPEOUT 0 /* 
                   * Causes database card number &amp; flags to be set to zero. 
                   * This is so I don't need an infinite supply of cards!
                   */
// Not colored (because of @language /* */)
#include "equ.h"
#include "cmn.h"
#include "ramdef.h"
#include "eeprom.h"
#include &lt;hpc_ram.h&gt;
#include &lt;rlydef.h&gt;</t>
<t tx="ekr.20040303063549.48">@language csharp
@ comment
@c

/* block
comment */

// test

id // not a keyword

abstract as 
base bool break byte 
case catch char checked class const continue 
decimal default delegate do double 
else enum event explicit extern 
false finally fixed float for foreach 
get goto 
if implicit in int interface internal is 
lock long 
namespace new null 
object operator out override 
params partial private protected public 
readonly ref return 
sbyte sealed set short sizeof stackalloc 
static string struct switch 
this throw true try typeof 
uint ulong unchecked unsafe ushort using 
value virtual void volatile 
where while
yield</t>
<t tx="ekr.20040303063549.49">@language cweb

% This is limbo in cweb mode... It should be in \LaTeX mode, not \c mode.
% The following should not be colorized: class,if,else.

@* this is a _cweb_ comment.  Code is written in \c.
"strings" should not be colorized.
It should be colored in \LaTeX mode.
The following are not keywords in latex mode: if, else, etc.
Noweb section referencs are _valid_ in cweb comments!
&lt;&lt; section ref &gt;&gt;
&lt;&lt; missing ref &gt;&gt;
@c

and this is C code. // It is colored in \LaTeX mode by default.
/* This is a C block comment.  It may also be colored in restricted \LaTeX mode. */

// Section refs are valid in code too, of course.
&lt;&lt; section ref &gt;&gt;
&lt;&lt; missing ref &gt;&gt;

\LaTeX and \c should not be colored.
if else, while, do // C keywords.</t>
<t tx="ekr.20040303063549.50">&lt;&lt; section def &gt;&gt;=

	my \c code goes here // This is \LaTeX text
	/* This is also \LaTeX text */</t>
<t tx="ekr.20040303063549.51">@language elisp

; Maybe...
error princ 

; More typical of other lisps...
and apply
car cdr cons cond
defconst defun defvar 
eq equal eval
gt ge
if 
let le lt
mapcar 
ne nil 
or not 
prog progn 
set setq 
t type-of 
unless 
when while</t>
<t tx="ekr.20040303063549.52">@language html

&lt;HTML&gt;
&lt;!-- Author: Edward K. Ream, edream@tds.net --&gt;
&lt;HEAD&gt;
  &lt;META NAME="GENERATOR" CONTENT="Microsoft FrontPage 4.0"&gt;
  &lt;TITLE&gt; Leo's Home Page &lt;/TITLE&gt;
  &lt;META NAME="description" CONTENT="This page describes Leo.
Leo adds powerful outlines to the noweb and CWEB literate programming languages."&gt;
  &lt;META NAME="keywords" CONTENT="LEO, LITERATE PROGRAMMING, OUTLINES, CWEB,
NOWEB, OUTLINES, EDWARD K. REAM, DONALD E. KNUTH, SILVIO LEVY, OPEN SOFTWARE"&gt;
&lt;/HEAD&gt;
&lt;!-- Last Modified: May 12, 2002 --&gt;
&lt;BODY BGCOLOR="#fffbdc"&gt;

&lt;H1 ALIGN=CENTER&gt;&lt;a NAME="top"&gt;&lt;/a&gt;&lt;IMG SRC="Blank.gif" width=
"32" height="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;IMG SRC="leo.gif" 
WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;a href="leo_TOC.html#top"&gt;&lt;IMG SRC=
"arrow_rt.gif" WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;/a&gt; &amp;nbsp;&lt;/H1&gt;

&lt;H1 ALIGN=CENTER&gt; Leo's Home Page&lt;/H1&gt;

&lt;p align="center"&gt;&lt;a href="http://www.python.org/"&gt;&lt;img border="0" src="PythonPowered.gif" width="110" height="44"&gt; &lt;/a&gt; &lt;A HREF="http://sourceforge.net/"&gt;&lt;IMG SRC="http://sourceforge.net/sflogo.php?group_id=3458&amp;type=1" NATURALSIZEFLAG="0" ALT="SourceForge Logo"&gt;&lt;/A&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;
&lt;A HREF="http://sourceforge.net/project/?group_id=3458"&gt;Leo at SourceForge&lt;/A&gt;&amp;nbsp;&amp;nbsp;
&lt;a href="icons.html"&gt;&lt;img border="0" src="LeoCodeGray.gif" width="77" height="42"&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;
&lt;a href="icons.html"&gt;&lt;img border="0" src="LeoProse.gif" width="81" height="42"&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;

&lt;H3&gt;&lt;A NAME="anchor127554"&gt;&lt;/A&gt;Summary&lt;/H3&gt;

&lt;UL&gt;
  &lt;LI&gt;Leo is a &lt;i&gt; programmer's editor&lt;/i&gt;  and a flexible &lt;i&gt;browser&lt;/i&gt; for
	projects, programs, classes or data. Leo clarifies design, coding, debugging, testing
  and maintenance.
  &lt;LI&gt;Leo is an &lt;i&gt;outlining editor&lt;/i&gt;. Outlines clarify the big picture while
	providing unlimited space for details.
  &lt;LI&gt;Leo
	is a &lt;a HREF="http://www.literateprogramming.com/"&gt;&lt;i&gt;literate
	programming&lt;/i&gt;&lt;/a&gt; tool, compatible with &lt;A HREF="http://www.eecs.harvard.edu/~nr/noweb/"&gt;noweb&lt;/A&gt;
	and &lt;a HREF="http://www-cs-faculty.stanford.edu/~knuth/cweb.html"&gt;CWEB&lt;/a&gt;.
	Leo enhances any text-based
programming language, from assembly language and C to Java, Python and XML.
  &lt;LI&gt;Leo is also a &lt;i&gt;data organizer&lt;/i&gt;. A single Leo outline can generate complex
	data spanning many different files.&amp;nbsp; Leo has been used to manage web sites.
  &lt;LI&gt;Leo is a &lt;i&gt; project manager&lt;/i&gt;. Leo provides multiple views
of a project within a single outline. Leo naturally represents tasks that remain
	up-to-date.
  &lt;LI&gt;Leo is fully &lt;i&gt; scriptable&lt;/i&gt; using &lt;A HREF="http://www.python.org/"&gt;Python&lt;/A&gt;
  and saves its files in &lt;A HREF="http://www.w3.org/XML/"&gt;XML&lt;/A&gt; format.
  &lt;LI&gt;Leo is &lt;i&gt;portable&lt;/i&gt;.&amp;nbsp; Leo.py is 100% pure Python and will run on
	any platform supporting &lt;A HREF="http://www.python.org/"&gt;Python&lt;/A&gt;
	and &lt;a href="http://tcl.activestate.com/"&gt;Tk/tcl&lt;/a&gt;, including Windows,
	Linux and MacOS X.&amp;nbsp; Leo.exe runs on any Windows platform.
  &lt;LI&gt;Leo is &lt;a href="http://www.opensource.org/"&gt; &lt;i&gt; Open Software&lt;/i&gt;&lt;/a&gt;, distributed under
	the &lt;a href="http://www.python.org/doc/Copyright.html"&gt; Python License&lt;/a&gt;.
&lt;/UL&gt;

&lt;H3&gt;More Information and downloads&lt;/H3&gt;

&lt;ul&gt;
  &lt;LI&gt;An excellent &lt;a href="http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm"&gt;online
	tutorial&lt;/a&gt; and &lt;A HREF="http://www.jserv.com/jk_orr/xml/leo.htm"&gt;Leo resource
  page&lt;/A&gt;, both written by &lt;a href="http://www.jserv.com/jk_orr"&gt;Joe Orr&lt;/a&gt;.
  &lt;LI&gt;My brother's &lt;a href="SpeedReam.html"&gt;slashdot
	article about Leo&lt;/a&gt;, the best description about why Leo is special.
  &lt;LI&gt;&lt;A HREF="testimonials.html#anchor104391"&gt;What people are saying about Leo&lt;/A&gt;
  &lt;LI&gt;&lt;A HREF="leo_TOC.html#anchor964914"&gt;Complete users guide&lt;/A&gt;
	and
	&lt;A HREF="intro.html#anchor887874"&gt;tutorial introduction&lt;/A&gt;  with
  screen shots.
  &lt;li&gt;&lt;a href="FAQ.html"&gt;FAQ&lt;/a&gt; and &lt;a href="http://sourceforge.net/forum/?group_id=3458"&gt;help and discussion
	forums&lt;/a&gt;, preferable to &lt;A HREF="mailto:edream@tds.net"&gt;email&lt;/A&gt; so others may join
	in.&lt;/li&gt;
  &lt;li&gt;&lt;a href="icons.html"&gt;Icons&lt;/a&gt; for bragging about Leo.&lt;/li&gt;
&lt;/ul&gt;

&lt;a href="http://sourceforge.net/project/showfiles.php?group_id=3458"&gt;Download
	Leo&lt;/a&gt; from &lt;A HREF="http://sourceforge.net/project/?group_id=3458"&gt;Leo's SourceForge
site&lt;/A&gt;.

&lt;P ALIGN=left&gt;Leo's author is &lt;A HREF="http://personalpages.tds.net/~edream/index.html"&gt;Edward
  K. Ream&lt;/A&gt; email: &lt;A HREF="mailto:edream@tds.net"&gt;edream@tds.net&lt;/A&gt; voice: (608) 231-0766

&lt;HR ALIGN=LEFT&gt;

&lt;p align="center"&gt;

&lt;IMG SRC="Blank.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="34" height="34"&gt;&lt;IMG SRC="leo.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="32" height="32"&gt;&lt;a HREF="leo_TOC.html"&gt;&lt;IMG SRC="arrow_rt.gif" WIDTH="32"
HEIGHT="32" ALIGN="left" NATURALSIZEFLAG="3"&gt;

&lt;/BODY&gt;
&lt;/HTML&gt;</t>
<t tx="ekr.20040303063549.53">@language html

&lt;? xml version="1.0"&gt;
&lt;!-- test --&gt;
&lt;project name="Converter" default="dist"&gt;
&lt;/project&gt;"""</t>
<t tx="ekr.20040303063549.54">@language latex

% This is a \LaTeX mode comment.

This is a test of \LaTeX mode.

@ blah blah blah
@c

\c and \LaTeX are latex keywords.

This is a keyword \% not the start of a comment.

More keywords: \@ and \( and \) and \{ and \}</t>
<t tx="ekr.20040303063549.55">@ignore
@ doc
@c
@language c
	@others

abc
for # comment
# pp
@q comment @&gt; after
// comment
&lt;!-- comment --&gt; after
/* java comment */
{ pascal comment }
% latex comment
xor php keyword
fblocked tcl keyword
synchronized java keyword
\acute latex keyword
alarm perl keyword

# Python single-line comment
// C single-line comment
xx /* C block comment */ yy
xxx """ triple string """ zzz
a 'string' b
c "string" d
// C keywords
switch, case
</t>
<t tx="ekr.20040303063549.56">@language php
@ doc
This is a doc part.
@c

and or
array
array()
this is a test.
__CLASS__
&lt;?php and or array() ?&gt;"""</t>
<t tx="ekr.20040303063549.57">@language python

"""python
string"""d

'this\
is'''</t>
<t tx="ekr.20040303063549.58">"""This creates a free-floating copy of v's tree for undo.
The copied trees must use different tnodes than the original."""
	
def copyTree(self,root):

	c = self
	# Create the root vnode.
	result = v = leoNodes.vnode(c,root.t)
	# Copy the headline and icon values v.copyNode(root,v)
	# Copy the rest of tree.
	v.copyTree(root,v)
	# Replace all tnodes in v by copies.
	assert(v.nodeAfterTree() == None)
	while v:
		v.t = leoNodes.tnode(0, v.t.bodyString)
		v = v.threadNext()
	return result</t>
<t tx="ekr.20040303063549.59">@language rebol

; a comment
about abs absolute add alert alias all alter and and~ any append arccosine arcsine arctangent array ask at  
back bind boot-prefs break browse build-port build-tag  
call caret-to-offset catch center-face change change-dir charset checksum choose clean-path clear clear-fields close comment complement compose compress confirm continue-post context copy cosine create-request crypt cvs-date cvs-version  
debase decode-cgi decode-url decompress deflag-face dehex delete demo desktop detab dh-compute-key dh-generate-key dh-make-key difference dirize disarm dispatch divide do do-boot do-events do-face do-face-alt does dsa-generate-key dsa-make-key dsa-make-signature dsa-verify-signature  
echo editor either else emailer enbase entab exclude exit exp extract 
fifth find find-key-face find-window flag-face first flash focus for forall foreach forever form forskip fourth free func function  
get get-modes get-net-info get-style  
halt has head help hide hide-popup  
if import-email in inform input insert insert-event-func intersect 
join 
last launch launch-thru layout license list-dir load load-image load-prefs load-thru log-10 log-2 log-e loop lowercase  
make make-dir make-face max maximum maximum-of min minimum minimum-of mold multiply  
negate net-error next not now  
offset-to-caret open open-events or or~ 
parse parse-email-addrs parse-header parse-header-date parse-xml path-thru pick poke power prin print probe protect protect-system  
q query quit  
random read read-io read-net read-thru reboot recycle reduce reform rejoin remainder remold remove remove-event-func rename repeat repend replace request request-color request-date request-download request-file request-list request-pass request-text resend return reverse rsa-encrypt rsa-generate-key rsa-make-key 
save save-prefs save-user scroll-para second secure select send send-and-check set set-modes set-font set-net set-para set-style set-user set-user-name show show-popup sine size-text skip sort source split-path square-root stylize subtract switch  
tail tangent textinfo third throw throw-on-error to to-binary to-bitset to-block to-char to-date to-decimal to-email to-event to-file to-get-word to-hash to-hex to-idate to-image to-integer to-issue to-list to-lit-path to-lit-word to-local-file to-logic to-money to-none to-pair to-paren to-path to-rebol-file to-refinement to-set-path to-set-word to-string to-tag to-time to-tuple to-url to-word trace trim try  
unfocus union unique uninstall unprotect unset until unview update upgrade uppercase usage use  
vbug view view-install view-prefs  
wait what what-dir while write write-io  
xor xor~  
action! any-block! any-function! any-string! any-type! any-word!  
binary! bitset! block!  
char!  
datatype! date! decimal! 
email! error! event!  
file! function!  
get-word!  
hash!  
image! integer! issue!  
library! list! lit-path! lit-word! logic!  
money!  
native! none! number!  
object! op!  
pair! paren! path! port!  
refinement! routine!  
series! set-path! set-word! string! struct! symbol!  
tag! time! tuple!  
unset! url!  
word!  
any-block? any-function? any-string? any-type? any-word?  
binary? bitset? block?  
char? connected? crypt-strength? 
datatype? date? decimal? dir?  
email? empty? equal? error? even? event? exists? exists-key?
file? flag-face? found? function?  
get-word? greater-or-equal? greater?  
hash? head?  
image? in-window? index? info? input? inside? integer? issue?  
length? lesser-or-equal? lesser? library? link-app? link? list? lit-path? lit-word? logic?  
modified? money?  
native? negative? none? not-equal? number?  
object? odd? offset? op? outside?  
pair? paren? path? port? positive?  
refinement? routine?  
same? screen-offset? script? series? set-path? set-word? size? span? strict-equal? strict-not-equal? string? struct?  
tag? tail? time? tuple? type?  
unset? url?  
value? view? 
within? word?  
zero?</t>
<t tx="ekr.20040303063549.60"># both color_markup &amp; add_directives plugins must be enabled.

@markup wiki
@language python

""" {picture file=../Icons/Leoapp.GIF}this """ # Problems with correct indexing following a graphic.

""" {picture file=../Icons/Leoapp.GIF}this """ # two copies work.

abc

""" {picture file=../Icons/Leodoc.GIF} """ # xyz

""" continued
string"""

@ ''ab'' __xxx__ ''wx'' __xyz__
@c

# /* ''ab'' __xxx__ ''wx'' __xyz__ */

# Test

""" ''' """ ''' """'''  # Leo handles the common cases correctly.

''' ''ab'' __xxx__ ''wx'' __xyz__ ''' # No wiki markup in ''' strings.

""" ''ab'' __xxx__ ''wx'' __xyz__ """

# ''ab'' __xxx__ ''wx'' __xyz__

""" ''y'' """

""" text~~#ff00ff:some text~~more text""

and if

from leoGlobals import * ; print app().loadDir</t>
<t tx="ekr.20040303063549.61"># both color_markup &amp; add_directives plugins must be enabled.
@markup wiki

""" continued
string"""

@ ''ab'' __xxx__ ''wx'' __xyz__  __''bolditalic''__ and ''__italicbold__''
@c

# /* ''ab'' __xxx__ ''wx'' __xyz__ */

__abc__ 

# Test

""" ''' """ ''' """'''  # Leo handles the __b__ common cases correctly.

''' ''ab'' __xxx__ ''wx'' __xyz__ ''' # No wiki markup in ''' strings.

""" ''ab'' __xxx__ ''wx'' __xyz__ """

# ''ab'' __xxx__ ''wx'' __xyz__

""" ''y'' """

""" text~~#ee00ff:some text~~more text"""



and if

from leoGlobals import * ; print app().loadDir
</t>
<t tx="ekr.20040303063549.62"># both color_markup &amp; add_directives plugins must be enabled.

@markup wiki

""" text~~red:some text~~more text"""

""" text~~#ee0ff:some text~~more text"""</t>
<t tx="ekr.20040303063549.63">@ The names of child nodes are the names of commander methods to be called to do the test.

Each child node will in turn have two or more children:
	
- a "before" node
- an "after" node
- an optional selection node containing two lines giving the selection range in Tk coordinates.
- An optional insert node containing one line giving the insert point in Tk coordinates.
@c

import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

suite = leoTest.makeEditBodySuite("editBodyTests","tempNode")
runner = unittest.TextTestRunner()
runner.run(suite)
</t>
<t tx="ekr.20040303063549.64"></t>
<t tx="ekr.20040303063549.65">line 1
	line 2
	line 3
line 4</t>
<t tx="ekr.20040303063549.66">line 1
line 2
line 3
line 4</t>
<t tx="ekr.20040303063549.67">2.0
3.0 lineend - 1c</t>
<t tx="ekr.20040303063549.68"></t>
<t tx="ekr.20040303063549.69">line 1
line 2
line 3
line 4</t>
<t tx="ekr.20040303063549.70">line 1
	line 2
	line 3
line 4</t>
<t tx="ekr.20040303063549.71">2.0
3.0 lineend - 1c</t>
<t tx="ekr.20040303063549.72"></t>
<t tx="ekr.20040303063549.73">before
&lt;&lt; section &gt;&gt;
sec line 1
	sec line 2 indented
sec line 3
after</t>
<t tx="ekr.20040303063549.74">before
&lt;&lt; section &gt;&gt;
after</t>
<t tx="ekr.20040303063549.75">sec line 1
	sec line 2 indented
sec line 3</t>
<t tx="ekr.20040303063549.76">2.0
5.0 lineend -1c</t>
<t tx="ekr.20040303063549.77">import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

suite = leoTest.makeImportExportSuite("exportTests","tempNode")
runner = unittest.TextTestRunner()
runner.run(suite)</t>
<t tx="ekr.20040303063549.78"></t>
<t tx="ekr.20040303063549.79">saveFileDialog
c:\\prog\\test\\unittest\\output\\exportHeadlines.txt</t>
<t tx="ekr.20040303063549.80"></t>
<t tx="ekr.20040303063549.81">saveFileDialog
c:\\prog\\test\\unittest\\output\\flattenOutline.txt</t>
<t tx="ekr.20040303063549.82"></t>
<t tx="ekr.20040303063549.83">saveFileDialog
c:\\prog\\test\\unittest\\output\\weave.txt</t>
<t tx="ekr.20040303063549.84"></t>
<t tx="ekr.20040303063549.85">saveFileDialog
c:\\prog\\test\\unittest\\output\\outlineToNoweb.txt</t>
<t tx="ekr.20040303063549.86"></t>
<t tx="ekr.20040303063549.87">saveFileDialog
c:\\prog\\test\\unittest\\output\\outlineToCweb.txt</t>
<t tx="ekr.20040303063549.88"></t>
<t tx="ekr.20040303063549.89">openFileDialog
c:\\prog\\test\\unittest\\input\\leoAtFile.py</t>
<t tx="ekr.20040303063549.90"># To do: at present this creates a copy of this node as the next sib of tempNode!

import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

suite = leoTest.makeImportExportSuite("importTests","tempNode")
runner = unittest.TextTestRunner()
runner.run(suite)</t>
<t tx="ekr.20040303063549.91"></t>
<t tx="ekr.20040303063549.92">openFileDialog
c:\\prog\\test\\unittest\\input\\leoAtFile.py</t>
<t tx="ekr.20040303063549.93"></t>
<t tx="ekr.20040303063549.94">openFileDialog
c:\\prog\\test\\unittest\\input\\leoAtFile.py</t>
<t tx="ekr.20040303063549.95"></t>
<t tx="ekr.20040303063549.96">openFileDialog
c:\\prog\\test\\unittest\\input\\noweave.nw.txt</t>
<t tx="ekr.20040303063549.97"></t>
<t tx="ekr.20040303063549.98">openFileDialog
c:\\prog\\test\\unittest\\input\\flat.txt</t>
<t tx="ekr.20040303063549.99"></t>
<t tx="ekr.20040303063549.100">openFileDialog
c:\\prog\\test\\unittest\\input\\cweave.w</t>
<t tx="ekr.20040303063549.101">import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

suite = leoTest.makeOutlineSuite("outlineTests")
runner = unittest.TextTestRunner()
runner.run(suite)</t>
<t tx="ekr.20040303063549.102"></t>
<t tx="ekr.20040303063549.103"></t>
<t tx="ekr.20040303063549.104"></t>
<t tx="ekr.20040303063549.105"></t>
<t tx="ekr.20040303063549.106"></t>
<t tx="ekr.20040303063549.107"></t>
<t tx="ekr.20040303063549.108"></t>
<t tx="ekr.20040303063549.109"></t>
<t tx="ekr.20040303063549.110"></t>
<t tx="ekr.20040303063549.111"></t>
<t tx="ekr.20040303063549.112"></t>
<t tx="ekr.20040303063549.113"></t>
<t tx="ekr.20040303063549.114"></t>
<t tx="ekr.20040303063549.115"></t>
<t tx="ekr.20040303063549.116"></t>
<t tx="ekr.20040303063549.117"></t>
<t tx="ekr.20040303063549.118">import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

suite = leoTest.makePluginsSuite(verbose=True)
runner = unittest.TextTestRunner()
runner.run(suite)</t>
<t tx="ekr.20040303063549.119">import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

suite = leoTest.makePositionSuite(all=1)
runner = unittest.TextTestRunner()
runner.run(suite)</t>
<t tx="ekr.20040303063549.120">import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

suite = testLeoFilesSuite = leoTest.makeTestLeoFilesSuite("testLeoFiles")
runner = unittest.TextTestRunner()
runner.run(suite)</t>
<t tx="ekr.20040303063549.121"></t>
<t tx="ekr.20040303063549.122"></t>
<t tx="ekr.20040303063549.123"></t>
<t tx="ekr.20040303063549.124"></t>
<t tx="ekr.20040303063549.125">from leoGlobals import *
import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

mainSuite = unittest.makeSuite(unittest.TestCase)

suite = leoTest.makeReformatParagraphSuite()
mainSuite.addTest(suite)

for f,arg in (
	(leoTest.makeColorSuite,"colorizerTests"),
	(leoTest.makeEditBodySuite,"editBodyTests"),
	(leoTest.makeImportExportSuite,"exportTests"),
	(leoTest.makeImportExportSuite,"importTests"),
	(leoTest.makeTestLeoFilesSuite,"testLeoFiles"),
	(leoTest.makePositionSuite,None),
	# (leoTest.makeOutlineSuite,"outlineTests")
	# These tests presently have problem with the gui when run with other tests...
	# (leoTest.makePluginsSuite,false) # verbose
):
	suite = f(arg,"tempNode")
	mainSuite.addTest(suite)

runner = unittest.TextTestRunner()
runner.run(mainSuite)</t>
<t tx="ekr.20040303063644"></t>
<t tx="ekr.20040303064013">def makePositionSuite(arg=None,all=true,verbose=false):
	
	if all: # Include everything.
	
		suite = unittest.makeSuite(positionTestCase,'test')
		
	else: # Include listed testss.

		names = (
			"testFullTraverse",
			"testParentChildLinks",
			"testNextBack",
			"testVnodeList",
			"testThreadBackNext",
			"testParentChildLevel")
		
		suite = unittest.makeSuite(unittest.TestCase)
		for name in names:
			suite.addTest(positionTestCase(name))

	return suite</t>
<t tx="ekr.20040303064020.1">def testFullTraverse(self):
	
	c = top() ; p = c.rootPosition()

	while p:
		assert(p)
		p.moveToThreadNext()</t>
<t tx="ekr.20040303064020.2">def testParentChildLinks (self):
	
	c = self.c ; p = c.rootPosition()
	while p:
		&lt;&lt; check that the parent of p's first child is p &gt;&gt;
		parent = p.getParent()
		if parent:
			&lt;&lt; check that the parent of all parent's children is parent &gt;&gt;
		p.moveToThreadNext()</t>
<t tx="ekr.20040303064020.3">firstChild = p.getFirstChild()
if firstChild:
	parent = firstChild.getParent()
	if p != parent:
		print "mismatch:p,parent,child",p,parent,firstChild</t>
<t tx="ekr.20040303064020.4">found = false
child = parent.getFirstChild()
if not child:
	print "parent has no children"
while child:
	if child == p: found
	childParent = child.getParent()
	if childParent != parent:
		print "mismatch:parent,childParent",parent,childParent
	child = child.moveToNext()</t>
<t tx="ekr.20040303064020.5">def testNextBack (self):
	
	c = self.c ; p = c.rootPosition()

	while p:
		back = p.getBack()
		next = p.getNext()
		if back: assert(back.getNext() == p)
		if next: assert(next.getBack() == p)
		p.moveToThreadNext()</t>
<t tx="ekr.20040303064020.6">def testVnodeList (self):
	
	c = self.c ; p = c.rootPosition()

	while p:
		vnodeList = p.v.t.vnodeList
		for v in vnodeList:
			assert(v.t == p.v.t)
			if p.v.isCloned():
				assert(v.isCloned())
				assert(len(vnodeList) &gt; 1)
			else:
				assert(not v.isCloned())
				assert(len(vnodeList) == 1)
	
		p.moveToThreadNext()</t>
<t tx="ekr.20040303064020.7">def testThreadBackNext (self):

	c = self.c ; p = c.rootPosition()

	while p:
		threadBack = p.getThreadBack()
		threadNext = p.getThreadNext()

		if threadBack:
			if threadBack.getThreadNext() != p:
				print "p.threadBack.threadNext != p"
				print "p,threadBack,threadBack.threadNext:"
				print p,threadBack,threadBack.getThreadNext()
			assert(threadBack.getThreadNext()==p)
	
		if threadNext:
			if threadNext.getThreadBack() != p:
				print "p.threadNext.threadBack != p"
				print "p,threadNext,threadNext.threadBack:"
				print p,threadNext,threadNext.getThreadBack()
			assert(threadNext.getThreadBack()==p)

		p.moveToThreadNext()
</t>
<t tx="ekr.20040303064020.8">def testParentChildLevel (self):
	
	c = self.c ; p = c.rootPosition()
	
	level = 0 ; count = 0
	while p:
		count += 1
		if level != p.level():
			print level,p.level(),p
		assert(level == p.level())
		if p.getFirstChild():
			level += 1
			assert(p.getFirstChild().level() == level)
		elif p.getNext():
			assert(p.getNext().level() == level)
		else:
			p2 = p.copy().moveToParent()
			level -= 1
			while p2:
				if p2.getNext(): break
				p2.moveToParent()
				level -= 1
			assert(p2 or level == -1)

		p.moveToThreadNext()</t>
<t tx="ekr.20040303071432"></t>
<t tx="ekr.20040303080010">from leoGlobals import *
import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

mainSuite = unittest.makeSuite(unittest.TestCase)

suite = leoTest.makeReformatParagraphSuite()
mainSuite.addTest(suite)

for f,arg in (
	(leoTest.makeColorSuite,"colorizerTests"),
	(leoTest.makeEditBodySuite,"editBodyTests"),
	(leoTest.makePositionSuite,None),
	# (leoTest.makeOutlineSuite,"outlineTests")
	# These tests presently have problem with the gui when run with other tests...
	# (leoTest.makePluginsSuite,false) # verbose
):
	suite = f(arg,"tempNode")
	mainSuite.addTest(suite)

runner = unittest.TextTestRunner()
runner.run(mainSuite)</t>
<t tx="ekr.20040303080938"></t>
<t tx="ekr.20040303080938.1"></t>
<t tx="ekr.20040303091606">def testHasNextBack (self):
	
	c = self.c ; p = c.rootPosition()

	while p:

		back = p.getBack()
		next = p.getNext()

		assert(
			(back and p.hasBack()) or
			(not back and not p.hasBack()))
				
		assert(
			(next and p.hasNext()) or
			(not next and not p.hasNext()))
		
		p.moveToThreadNext()</t>
<t tx="ekr.20040303092153">def testHasParentChild (self):
	
	c = self.c ; p = c.rootPosition()

	while p:

		child = p.getFirstChild()
		parent = p.getParent()

		assert(
			(child and p.hasFirstChild()) or
			(not child and not p.hasFirstChild()))
				
		assert(
			(parent and p.hasParent()) or
			(not parent and not p.hasParent()))
		
		p.moveToThreadNext()</t>
<t tx="ekr.20040303092153.1">def testHasThreadNextBack(self):
	
	c = self.c ; p = c.rootPosition()

	while p:

		threadBack = p.getThreadBack()
		threadNext = p.getThreadNext()

		assert(
			(threadBack and p.hasThreadBack()) or
			(not threadBack and not p.hasThreadBack()))
				
		assert(
			(threadNext and p.hasThreadNext()) or
			(not threadNext and not p.hasThreadNext()))
		
		p.moveToThreadNext()</t>
<t tx="ekr.20040303215834">from leoGlobals import *

import leoNodes

c = top()

t = leoNodes.tnode()
v = leoNodes.vnode(c,t)
p = leoNodes.position(v,[])
p2 = p.copy()
print p == p2
</t>
<t tx="ekr.20040304082053">from leoGlobals import *
import leoNodes

# WARNING: only tested with sharedNodes = false
sharedNodes = false

# Many other iterator classes might be useful...
class all_vnodes_iter:
	"""Returns a list of all vnodes in the subtree passed to the ctor.
	
	Returns a list of all vnodes in the entire tree by default."""

	@others

c = top()
if sharedNodes: current = c.currentPosition() 
else:           current = c.currentVnode()

print '-'*20
for v in all_vnodes_iter(current):
	print v.headString()
	first = false</t>
<t tx="ekr.20040304090931">def __init__(self,porv=None):
	c = top()
	self. first = true # Hack so we return the first node properly.
	if porv is None:
		if sharedNodes:
			self.p = c.rootPosition()
			self.after = leoNodes.position(None,[])
		else:
			self.p = c.rootVnode()
			self.after = None
	else:
		self.p = porv
		if sharedNodes:
			self.after = porv.copy().moveToNodeAfterTree()
		else:
			self.after = self.p.nodeAfterTree()</t>
<t tx="ekr.20040304090931.1">def __iter__(self):
	return self</t>
<t tx="ekr.20040304091204">def next(self):
	if not self.p: raise StopIteration
	if self.first:
		self.first = false
		if sharedNodes: return self.p.v
		else:           return self.p
	if sharedNodes:
		self.p = self.p.moveToThreadNext()
		if not self.p or self.p == self.after:
			raise StopIteration
		return self.p.v
	else:
		self.p = self.p.threadNext()
		if not self.p or self.p == self.after:
			raise StopIteration
		return self.p</t>
<t tx="ekr.20040304091615"></t>
</tnodes>
</leo_file>
