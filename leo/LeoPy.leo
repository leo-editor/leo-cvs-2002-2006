<?xml version="1.0" encoding="UTF-8"?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="2745" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="31" left="222" height="26" width="77"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences allow_rich_text="0">
</preferences>
<find_panel_settings>
	<find_string></find_string>
	<change_string></change_string>
</find_panel_settings>
<vnodes>
<v t="T1"><vh>Diary</vh>
<v><vh>Dec 2002</vh>
<v><vh>12/4</vh>
<v><vh>Fixed path problem in paths passed to tangle_done.py</vh></v>
<v t="T2"><vh>Fixed Recent Files command</vh></v>
<v t="T3"><vh>Fixed problems with Open With code in customizeLeo.py</vh></v>
<v t="T4"><vh>Fixed crasher in colorizeAnyLanguage</vh></v>
<v t="T5"><vh>Fixed major memory leak</vh></v>
<v t="T6"><vh>Changed shortcut to Find Previous so Alt - F4 closes Leo</vh></v>
<v t="T7"><vh>Changed url of help file</vh></v>
<v><vh>Removed backquotes from most print statements</vh></v>
<v t="T8"><vh>Removed synonyms from leoImport.py and leoTangle.py</vh></v>
</v>
<v><vh>12/3</vh>
<v><vh>Converted leoConfig.py to use @root-code</vh></v>
<v t="T9"><vh>Added @file &amp; @root options</vh></v>
<v t="T10"><vh>Fixed a bug in Untangle</vh></v>
<v t="T11"><vh>Decided not to do utils_normpath</vh></v>
</v>
</v>
<v><vh>Nov 2002</vh>
<v><vh>11/25</vh>
<v t="T12"><vh>Improved Leo's window icon</vh></v>
<v t="T13"><vh>cleaned up config code relating to find settings</vh></v>
<v t="T14"><vh>Added Node only option to find menu</vh></v>
<v t="T15"><vh>Added Export Headlines command</vh></v>
<v t="T16"><vh>Implement control-drag to clone</vh></v>
<v><vh>Changed leoConfig.py so it silently ignores missing sections</vh></v>
<v t="T17"><vh>Fixed bug in Python importer</vh></v>
</v>
<v><vh>11/24</vh>
<v t="T18"><vh>Added Mark Clones and Go To Next Clone commands.</vh></v>
<v t="T19"><vh>Fixed bugs involving @nosentinelsfile</vh></v>
<v t="T20"><vh>Allowed abbreviated xml tags.</vh></v>
</v>
<v><vh>11/23 Release 3.9</vh></v>
<v><vh>11/22</vh>
<v t="T21"><vh>Corrected several bugs reported by PyChecker</vh></v>
</v>
<v><vh>11/21</vh>
<v t="T22"><vh>Fixed bug in colorizeAnyLine</vh></v>
<v t="T23"><vh>Improved undo for Edit Body commands</vh></v>
</v>
<v><vh>11/20</vh>
<v t="T24"><vh>Fixed unicode bugs</vh></v>
</v>
<v><vh>11/19</vh>
<v><vh>Changed use_configureLeo_dot_py to use_customizeLeo_dot_py</vh></v>
<v t="T25"><vh>Create all non-existent directories using makeAllNonExistentDirectories</vh></v>
<v><vh>Made sure all open calls are in try blocks.</vh></v>
<v t="T26"><vh>Recolor entire pane if @color or @nocolor change</vh></v>
<v t="T27"><vh>Changed the lamda used to define the Recent Files callback</vh></v>
<v><vh>Added "openwith", "recentfiles" and "@url" hooks</vh></v>
<v t="T28"><vh>Fixed big leak in undo</vh></v>
<v><vh>Properly save and restore selection range for undo.</vh></v>
<v><vh>Fixed bug that caused a backspace in an empty body text to insert a newline.</vh></v>
<v t="T29"><vh>Made Undo bulletproof</vh></v>
<v t="T30"><vh>Removed code in tree.select that removed trailing newlines</vh></v>
</v>
<v><vh>11/18</vh>
<v><vh>Added Open with entries to popup menus</vh></v>
<v><vh>Added David McNab's auto-indent patch (smart_auto_indent option)</vh></v>
</v>
<v><vh>11/17</vh>
<v><vh>Added "headkey1" and "headkey2" hooks</vh></v>
</v>
<v><vh>11/16</vh>
<v t="T31"><vh>added enableIdleTimeHook, disableIdleTimeHook, idleTimeHookHandler</vh></v>
<v t="T32"><vh>Completed first draft of Go To Line Number command</vh></v>
</v>
<v><vh>11/15</vh>
<v><vh>Added Go To Line Number command</vh></v>
<v t="T33"><vh>Rewrote syntax coloring for cweb</vh></v>
</v>
<v><vh>11/14</vh>
<v t="T34"><vh>Fixed bug in atFile.scanAllDirectives involving @language</vh></v>
</v>
<v><vh>11/13</vh>
<v t="T35"><vh>Added keywords parameter to customizeLeo</vh></v>
<v><vh>Implemented the use_configureLeo_dot_py option</vh></v>
<v><vh>Released first public draft of incremental undo</vh></v>
</v>
<v><vh>11/10</vh>
<v t="T36"><vh>Correctly colors Pascal's "private" and "uses" keywords</vh></v>
</v>
<v><vh>11/9</vh>
<v t="T37"><vh>Fixed blunder in undo/redraw code</vh></v>
<v><vh>Fixed Dave Hein's @language issue</vh></v>
<v t="T38"><vh>Completed incremental syntax coloring</vh></v>
</v>
<v><vh>11/8</vh>
<v><vh>Worked on incremental syntax coloring</vh></v>
<v><vh>Changed leoCustomize.py to customizeLeo.py to make distribution easier.</vh></v>
<v><vh>Warn if @node leoCustomize.py is not @ignored</vh></v>
<v t="T39"><vh>Execute script no longer supports @pythonscript</vh></v>
<v><vh>Added example of how to customize individual .leo files safely in leoCustomize.py</vh></v>
<v><vh>Added frame.longFileName and shortFileName methods</vh></v>
</v>
<v><vh>11/7</vh>
<v><vh>Prompt when writing leoCustomize.py</vh></v>
<v><vh>Disabled the "virus-word" in leCustomize.py</vh></v>
</v>
<v><vh>11/6</vh>
<v t="T40"><vh>Fixed a major bug in top()</vh>
<v t="T41" a="C"><vh>top</vh></v>
</v>
<v><vh>Implemented per-window hook scheme</vh></v>
</v>
<v><vh>11/5</vh>
<v t="T42"><vh>Fixed bug in cweb coloring, made latex work more like cweb</vh></v>
<v t="T43"><vh>Added app().realMenuName logic</vh></v>
<v t="T44"><vh>Added "open1", "open2", "menu1" and "menu2" hooks</vh></v>
<v t="T45"><vh>Completed generalization of menu code</vh></v>
</v>
<v><vh>11/4</vh>
<v t="T46"><vh>Replaced all frame menu ivars with frame.menus dict</vh></v>
<v t="T47"><vh>Generalized how commands are called</vh></v>
<v t="T48"><vh>Added general-purpose hook handling</vh></v>
<v><vh>Use original leading whitespace when reformatting paragraphs</vh></v>
<v><vh>Use scanDirectives in Convert All Blanks/Tabs commands</vh></v>
<v><vh>Incorporated Dave Hein's recent changes</vh></v>
</v>
<v><vh>11/3</vh>
<v t="T49"><vh>Implemented @pythonscript and Execute Script</vh></v>
</v>
<v><vh>11/2</vh>
<v t="T50"><vh>Fixed bugs when importing Java files.</vh></v>
<v t="T51"><vh>Fixed important bug in find_line_start</vh></v>
</v>
<v><vh>1/11</vh>
<v t="T52"><vh>Fixed cweb hack using Jonathon Gilligan's patches</vh></v>
</v>
<v t="T53"><vh>(reducing name polution)</vh></v>
</v>
<v><vh>Previous months</vh>
<v><vh>Oct 2002</vh>
<v><vh>10/30</vh>
<v t="T54"><vh>Applied cweb hack to all sentinels</vh></v>
<v><vh>raw cweb mode in @root trees</vh></v>
<v t="T55"><vh>simplified Reformat Paragraph command</vh></v>
</v>
<v><vh>10/29 Released 3.8</vh>
<v><vh>10/28</vh>
<v><vh>Don't recognize @*, @&lt; or @( in cweb mode</vh></v>
<v><vh>Completed documentation for 3.8</vh></v>
</v>
<v><vh>10/27</vh>
<v t="T56"><vh>Fixed problems report by Pychecker</vh></v>
<v t="T57"><vh>Fixed path bugs in tangle.scanAllDirectives</vh></v>
<v t="T58"><vh>Changed path_directive_creates_directories to create_nonexistent_directories</vh></v>
</v>
<v><vh>10/26</vh>
<v t="T59"><vh>Fixed foo.leo bug</vh></v>
<v t="T60"><vh>Worked around Control-T bug</vh></v>
<v><vh>Reset hand cursor after failed drag</vh></v>
</v>
<v><vh>10/25</vh>
<v t="T61"><vh>Used dicts to speed up checkMoveWithParentWithWarning</vh></v>
<v t="T62"><vh>Created reloadAll in leoGlobals.py</vh></v>
<v t="T63"><vh>Allow noweb section refs in @file cweb code</vh></v>
<v t="T64"><vh>Added support for &lt;?xml-stylesheet...?&gt; line</vh></v>
<v><vh>Documented @rawfile and @silentfile</vh></v>
</v>
<v><vh>10/24</vh>
<v t="T65"><vh>Fixed cweb sentinel bug</vh></v>
</v>
<v><vh>10/23</vh>
<v t="T66"><vh>Completed first draft of new @rawfile and @silentfile</vh></v>
<v t="T67"><vh>Discovered that gti's _are_ possible</vh></v>
<v t="T68"><vh>Finished cweb hack</vh></v>
<v t="T69"><vh>Fixed @delims "round trip" bug</vh></v>
<v t="T70"><vh>Fixed bug involving menu pastes in headlines</vh></v>
</v>
<v><vh>10/19</vh>
<v t="T71"><vh>Fixed import to @root problems</vh></v>
</v>
<v><vh>10/18</vh>
<v><vh>Completed handling of output_initial_comment option</vh></v>
<v t="T72"><vh>Fixed block-comment bug in Java and HTML</vh></v>
<v><vh>Use // as single-line comment in Java</vh></v>
</v>
<v><vh>10/17</vh>
<v t="T73"><vh>Allow @comment and @language to coexist</vh></v>
<v><vh>Match routines all return false if pattern is None or empty</vh></v>
<v><vh>Colorizer now recognizes comments after preprocessor directives</vh></v>
<v><vh>Corrected reversion in set_delims_from_string</vh></v>
</v>
<v><vh>10/16</vh>
<v><vh>Added support for forth language comments</vh></v>
<v t="T74"><vh>Fixed another crasher in scanAllDirectives</vh></v>
<v t="T75"><vh>Fixed assert failure in putBodyPart</vh></v>
<v t="T76"><vh>Fixed crasher in scanAllDirectives</vh></v>
</v>
<v><vh>10/15</vh>
<v><vh>Added @raw support</vh></v>
<v><vh>Changed names of commands in help menu and corresponding entries in leoConfig.leo</vh></v>
<v><vh>Updated docs for recent features</vh></v>
</v>
<v><vh>10/14</vh>
<v><vh>All export commands now use output_newline option</vh></v>
<v t="T77"><vh>Forced focus to body pane after ending headline edit</vh></v>
<v t="T78"><vh>wrote "finished" after write @file nodes command</vh></v>
<v t="T79"><vh>Use @@ sentinels only for real Leo directives</vh></v>
</v>
<v t="T80"><vh>10/13 Rewrote colorizer using dispatch dict</vh></v>
<v><vh>10/12</vh>
<v><vh>Added Configuration Options item to help menu</vh></v>
</v>
<v><vh>10/11</vh>
<v><vh>added code to support output_newline option</vh></v>
<v t="T81"><vh>Fixed reversion in file write code</vh></v>
<v t="T82"><vh>Greatly simplified leoConfig.py</vh></v>
<v t="T83"><vh>Completed support for @quiet</vh></v>
<v t="T84"><vh>Syntax color perl's alarm function</vh></v>
</v>
<v><vh>10/10</vh>
<v t="T85"><vh>Removed language bits</vh></v>
<v t="T86"><vh>Removed directive bits</vh></v>
<v><vh>Used @q and @&gt; as sentinels in cweb mode</vh></v>
</v>
<v><vh>10/9 (after 3.7 released)</vh>
<v><vh>fixed Unicode bug in setBodyStringOrPane</vh></v>
<v t="T87"><vh>Created es_exception</vh></v>
<v t="T88"><vh>Added support for @rawfile (fixed bug in endEditLabel)</vh></v>
</v>
</v>
<v><vh>10/09 Released 3.7</vh>
<v t="T89"><vh>10/8 Ran pychecker</vh></v>
<v><vh>10/7 Improved error messages for Unicode errors</vh></v>
<v t="T90"><vh>10/6 leoOpen sets file name if it doesn't exist</vh></v>
<v><vh>10/5 Leo now closes an empty window when opening a recent file</vh></v>
<v><vh>10/4</vh>
<v t="T91"><vh>Improved handling of Latin-1 encoding</vh></v>
<v t="T92"><vh>Initialize all "config" section params to valid values</vh></v>
</v>
<v><vh>10/3</vh>
<v t="T93"><vh>Removed all calls to decode</vh></v>
<v t="T94"><vh>Got information about encode/decode</vh>
<v t="T95" a="C"><vh>From  Martin v. Löwis</vh></v>
</v>
<v t="T96"><vh>Fixed Find previous bug</vh></v>
<v><vh>Retained file modes when tangling and writing derived files</vh></v>
<v t="T97"><vh>Added remove_sentinels_extension option</vh></v>
</v>
<v t="T98"><vh>10/2 Changed find to findr when scanning @@ sentinels</vh></v>
</v>
</v>
<v><vh>Sept 2002</vh>
<v><vh>9/27</vh>
<v t="T99"><vh>Removed extra newline following @+leo directive</vh></v>
</v>
<v><vh>9/26</vh>
<v t="T100"><vh>"Relative" node indices aren't</vh></v>
<v t="T101"><vh>Eliminated writing clone indices!</vh></v>
<v t="T102"><vh>Allowed reads and writes of cloned @file nodes</vh></v>
</v>
<v><vh>9/25</vh>
<v t="T103"><vh>Added perlpod hack</vh></v>
<v t="T104"><vh>Added getBaseDirectory and used it to resolve relative paths</vh></v>
<v t="T105"><vh>Removed bodyKeepsFocus logic in leoTree.py</vh></v>
<v><vh>Added code to various scanAllDirectives routines to create paths</vh></v>
<v><vh>Created "path_directive_creates_directories" option</vh></v>
</v>
<v><vh>9/24</vh>
<v><vh>"Mysterious" changes to files were due to setting Page Width = 80</vh></v>
<v><vh>Added code to configure headline colors</vh></v>
<v><vh>Made the About Leo dialog non-modal</vh></v>
<v><vh>Fixed bug that disabled all shortcuts</vh></v>
<v><vh>Added support for Esc in shortcuts</vh></v>
<v><vh>Added End Edit Headline and Abort Edit Headline commands</vh></v>
<v t="T106"><vh>Fixed undo cloned headline bug</vh></v>
</v>
<v t="T107"><vh>9/23 Finished user-configurable shortcuts</vh></v>
<v><vh>9/21</vh>
<v t="T108"><vh>Fixed colorizing for "while" in C</vh></v>
<v t="T109"><vh>Leo now remembers insert point always</vh></v>
</v>
<v t="T110"><vh>9/20 Fixed tab problems</vh></v>
<v t="T111"><vh>9/19 Removed setup.py from binary distribution</vh></v>
<v><vh>9/18 New file code: end of cursed newlines.</vh>
<v t="T112"><vh>Write only \n (Linux newlines) in derived files and .leo files</vh></v>
<v t="T113" a="C"><vh>Major change to atFile::read code</vh></v>
</v>
<v><vh>9/15</vh>
<v t="T114"><vh>Added self=self to lambda definitions to keep Python 2.1 happy</vh></v>
<v><vh>Folded all CVS changes into this file</vh></v>
</v>
<v><vh>9/14 Added secondary pane ratios to leoConfig.txt</vh></v>
<v><vh>9/13</vh>
<v><vh>Folded Steven P. Schaefer's @first in @root code.</vh></v>
<v t="T115"><vh>Fixed "Unselected Ctrl-[ four times" bug</vh></v>
<v t="T116"><vh>Investigated reported font settings bug: works for me</vh></v>
<v><vh>Incorporated Dave Heins code into getBodyLines</vh></v>
</v>
<v><vh>9/12</vh>
<v t="T117"><vh>Fixed bug in updateBodyPane affecting Edit Body commands</vh></v>
<v><vh>Suggested ISO-8859-15 instead of ISO-8859-1 in leoConfig.leo</vh></v>
<v t="T118"><vh>Generated PKG-INFO in Version Stuff section</vh></v>
<v><vh>Fixed @language plain # bug.</vh></v>
<v t="T119"><vh>Improved enabling of menu items in popup menus</vh></v>
<v t="T120"><vh>Fixed @language plain single-quote bug</vh></v>
<v><vh>Incorporated Dave Hein's "wrapping in doc part" bug fix</vh></v>
<v><vh>Changed accelerator of Go To Next Changed to Alt-D</vh></v>
</v>
<v><vh>9/11 Released 3.6</vh>
<v><vh>9/11 Hacked colorizeAnyLanguage to support all PHP constructs</vh></v>
<v><vh>9/11 Implemented @last</vh></v>
</v>
<v><vh>9/9</vh>
<v t="T121"><vh>Removed most error messages in atFile::read logic</vh></v>
<v t="T122"><vh>Integrated changes in PHP changes into this file</vh></v>
</v>
<v><vh>9/7</vh>
<v><vh>9/7 and later: started to design the "Resolve CVS Conflicts command"</vh></v>
<v><vh>Dave Hein: added new code to make Python window work on Linux.</vh></v>
</v>
<v t="T123"><vh>9/5 Fixed bugs in @path logic in tangle.scanAllDirectives</vh></v>
<v><vh>9/4</vh>
<v t="T124"><vh>Tomaz Ficko: Added support for MouseWheel (Linux only)</vh></v>
<v t="T125"><vh>Steven P. Schaefer: Fixed cursed newline bug for Linux</vh></v>
</v>
<v><vh>9/3</vh>
<v><vh>Experimented with CVS Revision keyword in About box.</vh></v>
<v><vh>Added Match Brackets command</vh></v>
<v><vh>Added shortcuts for Read/Write @file Nodes commands</vh></v>
</v>
<v><vh>9/2</vh>
<v t="T126"><vh>Steven P. Schaefer: Improved handling of directives in @root trees</vh></v>
<v t="T127"><vh>Dave Hein: added CheckVersion to leoUtils.py</vh></v>
<v t="T128"><vh>Dave Hein: fixed Tk 8.4 problem in Prefs Panel</vh></v>
<v t="T129"><vh>Body pane now gets focus after Go Back/Next</vh></v>
<v t="T130"><vh>Changed leoTangle.scanAllDirectives</vh></v>
<v t="T131"><vh>Leo now remembers scrollbar positions</vh></v>
<v><vh>Removed windows newlines in leoConfig.update</vh></v>
<v t="T132"><vh>Improved call to os.path.join in leoApp.finishCreate</vh></v>
</v>
<v><vh>9/1</vh>
<v t="T133"><vh>Saved edit position of tnodes</vh></v>
<v t="T134"><vh>Investigated @language for @root trees</vh></v>
<v t="T135"><vh>Fixed missing headline bug on startup</vh></v>
<v t="T136"><vh>Changed all os.rename to utils_rename</vh></v>
<v t="T137"><vh>Changed mode in leoConfig::update</vh></v>
</v>
</v>
<v><vh>Aug 2002</vh>
<v><vh>8/24</vh>
<v t="T138"><vh>Added version to url for online tutorial</vh></v>
<v t="T139"><vh>Improved About Leo dialog</vh></v>
<v t="T140"><vh>Improved dowloading of sbooks.chm</vh></v>
</v>
<v><vh>8/15</vh>
<v t="T141"><vh>prototyped window icons in Tk</vh></v>
<v t="T142"><vh>Attempted to make mouse wheel functional in tree pane</vh></v>
<v><vh>Rewrote About Leo dialog with icon &amp; hyperlinks</vh></v>
<v><vh>Improved download dialog in Help-Tutorial command</vh></v>
</v>
<v><vh>8/14 Released 3.5</vh>
<v><vh>Corrected wrapping in log window when horizontal scrollbar is present</vh></v>
<v><vh>Released 3.5</vh></v>
<v><vh>Added log_pane_wraps and outline_pane_scrolls_horizontally params</vh></v>
<v t="T143"><vh>Fixed Tangle logic</vh></v>
</v>
<v><vh>8/13 Bugs, bugs, bugs</vh>
<v><vh>called cf.flush in leoConfig.update</vh></v>
<v t="T144"><vh>Open url's from help menu</vh></v>
<v t="T145"><vh>Rewrote path logic</vh></v>
<v t="T146"><vh>Warn on read-only files</vh></v>
<v t="T147"><vh>Hacked on leoAtFile.scanAllDirectives to fix directory problem</vh></v>
<v t="T148"><vh>Fixed (?) cursed newline bug in leoAtFile</vh></v>
</v>
<v><vh>8/11 Released 3.4</vh>
<v><vh>Fixed crasher when leoConfig.txt does not exist</vh></v>
<v t="T149"><vh>Fixed bug in leoFileCommands.readOutlineOnly</vh></v>
<v t="T150"><vh>Wrote importFiles script in leoImport.leo</vh></v>
<v><vh>Released 3.4</vh></v>
<v><vh>Syntax colorer now honors @comment</vh></v>
</v>
<v><vh>8/10</vh>
<v><vh>Added save_clears_undo_buffer configuration option</vh></v>
<v t="T151"><vh>Improved Recent Files menu</vh></v>
</v>
<v t="T152"><vh>8/9 Fixed Unicode Bugs</vh></v>
<v><vh>8/6</vh>
<v t="T153"><vh>Corrected problems with find/prefs settings</vh></v>
<v t="T154"><vh>created leoConfig.leo</vh></v>
<v t="T155"><vh>Fixed a bug in config.setDict (!) (This fixes font problems)</vh></v>
<v><vh>Leo writes split direction to leoConfig.txt</vh></v>
<v t="T156"><vh>Leo writes prefs if leoConfig.txt is read-only</vh></v>
</v>
<v t="T157"><vh>8/5 Leo honors pane ratio stored in .leo files</vh></v>
<v><vh>8/4</vh>
<v t="T158"><vh>Improved highlighting of whitespace</vh></v>
<v t="T159"><vh>Fixed revert problems in font panel</vh></v>
<v t="T160"><vh>Added @ignore to "raw" imported files</vh></v>
<v t="T161"><vh>Remove Sentinels command now uses .txt extension instead of .tmp</vh></v>
<v><vh>Added log message for Remove Sentinels command</vh></v>
<v t="T162"><vh>Corrected spelling of limit_directory_search_extenstion </vh></v>
<v t="T163"><vh>Fixed wandering insertion point bug</vh></v>
</v>
<v><vh>8/3</vh>
<v t="T164"><vh>looked for backticks</vh></v>
<v t="T165"><vh>Cleaned up files using nested compares</vh></v>
<v t="T166"><vh>Fixed another clone bug: created setAncestorsOfClonedNodesInTreeDirty</vh></v>
<v><vh>Released 3.3</vh></v>
</v>
<v><vh>8/2</vh>
<v t="T167"><vh>Leo supports Unicode !!</vh></v>
<v t="T168"><vh>changed skip_long to handle negative values</vh></v>
<v t="T169"><vh>initialized atFile.default_directory to None</vh></v>
<v t="T170"><vh>eliminated both presentLanguage and targetLanguage ivars from leoAtFile</vh></v>
<v t="T171"><vh>Removed default param from set_language</vh></v>
</v>
<v><vh>8/1</vh>
<v t="T172"><vh>Fixed crasher in leoTangle.putDoc</vh></v>
<v t="T173"><vh>Fixed problems with negative tab widths</vh></v>
<v t="T174"><vh>Fixed the "delims botch"</vh></v>
<v t="T175"><vh>Made 'additional_body_text_border' setting functional</vh></v>
<v><vh>Made 'body_pane_wraps' setting functional</vh></v>
<v t="T176"><vh>Fixed config tables</vh></v>
<v t="T177"><vh>Initialized leoAtFile properly</vh></v>
</v>
</v>
<v><vh>July 2002</vh>
<v t="T178"><vh>7/30 Fixed many bugs in Color panel</vh></v>
<v t="T179"><vh>7/30 Proved that Leo handles nested @others directives properly</vh>
<v t="T180" a="C"><vh>Proof that nested @others directives are valid</vh></v>
</v>
<v><vh>7/29</vh>
<v t="T181"><vh>7/29 Fixed bug in skip_pp_if and added skip_pp_part</vh></v>
<v t="T182"><vh>7/29 Added @ignore to the root of all imported trees</vh></v>
<v t="T183"><vh>7/29 Fixed bug in scanPythonDef.&lt;&lt; skip the Python def &gt;&gt;</vh></v>
<v t="T184"><vh>7/29 Improved import of classes</vh></v>
<v t="T185"><vh>7/29 Relaxed the rules for @others: allowed @others within @others tree</vh></v>
<v t="T186"><vh>7/29 Added glossary entries</vh></v>
<v t="T187"><vh>7/29 Fixed crasher in Prefs onCancel</vh></v>
<v t="T188"><vh>7/29 Fixed problems with Outline/Move/Select Go commands</vh></v>
<v><vh>7/29 Added email address &amp; URL to About Leo dialog</vh></v>
<v t="T189"><vh>7/29 Fixed import bug</vh></v>
</v>
<v><vh>7/27 Continued comments for lines ending in \</vh></v>
<v t="T190"><vh>7/24 Added @file disStats.py</vh></v>
<v t="T191"><vh>7/24 Added leo.profile()</vh></v>
<v><vh>7/20 Released 3.1</vh>
<v><vh>7/20 Finished Compare panel code, including using leoConfig.txt params</vh></v>
</v>
<v><vh>7/19</vh>
<v t="T192"><vh>7/19 Leo now adds path to Idle automatically</vh></v>
<v t="T193"><vh>7/19 Fixed bug that caused leo.py not to run</vh></v>
<v t="T194"><vh>7/19 Completed the visual design of the Compare panel</vh></v>
</v>
<v><vh>7/18</vh>
<v t="T195"><vh>7/18 Revised leoCompare.py</vh></v>
<v t="T196" a="C"><vh>7/18 Changed precedence scheme for preferences</vh></v>
<v t="T197"><vh>7/18 Added support for @language tcl/tk</vh></v>
<v t="T198"><vh>7/18 Fixed major bugs in skip_long &amp; tangle.scanAllDirectives!</vh></v>
</v>
<v><vh>7/17</vh>
<v t="T199"><vh>7/17 v.moreBody now only escapes first non-blank character on a line</vh></v>
<v t="T200"><vh>7/17 Told where to download Python 2.2 and Tk 8.3 In 2.2 required dialog</vh>
<v><vh>7/17 Added optional text param to leoDialog.askOk</vh></v>
<v t="T201"><vh>7/17 Tried closing Leo window during a long write</vh></v>
<v t="T202"><vh>7/17 The compare window is important!</vh></v>
</v>
</v>
<v><vh>7/16 Released 3.0</vh>
<v><vh>7/16 Added leoConfig.txt to manifest</vh></v>
<v t="T203"><vh>7/16 Did spellcheck on LeoDocs.leo using MS Word</vh></v>
<v t="T204"><vh>7/16 Fixed autoscrolling so it can stop</vh></v>
<v t="T205"><vh>7/16 Ran pychecker</vh></v>
<v><vh>7/16 Called traceback.print_exc for all serious exceptions</vh></v>
</v>
<v><vh>7/15 Leo code complete</vh>
<v t="T206"><vh>7/15 Adjusted tree to handle larger font size</vh></v>
<v t="T207"><vh>7/15 Make Convert All Blanks and Convert All Tabs undoable</vh></v>
<v t="T208"><vh>7/15 ** Speeded up autoscrolling enough to be useful</vh></v>
<v t="T209"><vh>7/15 New windows now open using config params.</vh></v>
<v t="T210"><vh>7/15 Cleaned up how windows are opened</vh></v>
<v t="T211"><vh>7/15 Fixed bug that disabled window positioning!</vh></v>
<v t="T212"><vh>7/15 Changed config getters to get from defaults</vh></v>
<v><vh>7/15 Added code to support font prefs.</vh></v>
<v t="T213"><vh>7/15 Added frame code to support non-modal panes</vh></v>
</v>
<v><vh>Earlier</vh>
<v><vh>7/14</vh>
<v t="T214"><vh>7/13 Added default tables to config module</vh></v>
<v t="T215"><vh>7/13 Added name picker to color panel</vh></v>
<v t="T216"><vh>7/13 Finished handlers for Font frame</vh></v>
</v>
<v><vh>7/12</vh>
<v t="T217"><vh>7/12 Font &amp; color panels need not be modal !</vh></v>
<v t="T218"><vh>7/12 Finished Tk work on Font frame</vh></v>
</v>
<v><vh>7/11</vh>
<v t="T219"><vh>7/11 Fixed syntax coloring bug</vh></v>
<v t="T220"><vh>7/11 Lots of work on preferences and color panel</vh></v>
</v>
<v><vh>7/10 File (and clipboard) format changed!</vh>
<v t="T221"><vh>7/10 Allowed "ISO-8859-1" specification</vh></v>
<v><vh>7/10 Warn and abort if not Python 2.2 or above</vh></v>
<v><vh>7/10 app.finishCreate checks for Python 2.2 or higher</vh></v>
<v t="T222"><vh>7/10 Cleaned up Recent Files menu code</vh></v>
<v><vh>7/10 All panels now have labeled frames and grooved borders</vh></v>
<v><vh>7/10 Created leoFontPanel.py and added leoColorPanel class to leoColor.py</vh></v>
</v>
<v><vh>7/9 Created create_labeled_frame and Font and Colors panels</vh></v>
<v><vh>7/8</vh>
<v t="T223"><vh>7/8 Improved syntax coloring</vh></v>
<v t="T224"><vh>7/8 The REM hack &amp; fixed crasher</vh></v>
<v t="T225"><vh>7/8 Fixed crasher in atFile.scanAllDirectives</vh></v>
<v t="T226"><vh>7/8 Finished Toggle Split Direction</vh></v>
</v>
</v>
<v><vh>leo.py 2.5 and earlier</vh>
<v><vh>7/7</vh>
<v t="T227"><vh>7/7 Fixed crashers when undoing or redoing moves</vh></v>
<v><vh>7/7 Updated LeoDocs.leo and Leo's web site</vh></v>
<v><vh>7/7 Released 2.5 and updated CVS</vh></v>
</v>
<v><vh>7/6 version 2.5 is now code complete</vh>
<v t="T228"><vh>7/6 Improved Import to @root</vh></v>
<v t="T229"><vh>7/6 Fixed Import bug: empty classes and nested classes</vh></v>
<v t="T230"><vh>7/6 Fixed Import bug that caused orphan nodes</vh></v>
<v t="T231"><vh>7/6 Fixed Import bug that caused duplicate class lines.</vh></v>
<v><vh>7/6 Renamed Font to Set Font... and Syntax Coloring... to Set Colors...</vh></v>
<v t="T232"><vh>7/6 Created c.initJoinedCloneBits</vh></v>
<v t="T233"><vh>7/6 Verified that undo works</vh></v>
</v>
<v><vh>7/5</vh>
<v t="T234"><vh>7/5 Made extract commands undoable &amp; simplified undo.</vh></v>
<v t="T235"><vh>7/5 Made import commands undoable.</vh></v>
<v t="T236"><vh>7/5 Discovered traceback module</vh></v>
<v><vh>7/5 Made Cascade command functional</vh></v>
<v><vh>7/5 Enabled Minimize All command</vh></v>
<v><vh>7/5 Forced syntax coloring after extract commands</vh></v>
</v>
<v><vh>7/4</vh>
<v><vh>7/4 Find/Change settings can be overridden by leoConfig.txt</vh></v>
<v t="T237"><vh>7/4 Invalid directories are no longer errors in leoAtFiles.scanAllDirectives</vh></v>
<v t="T238"><vh>7/4 Prefs now can be overridden by leoConfig.txt</vh></v>
</v>
<v><vh>7/3</vh>
<v t="T239"><vh>7/3 Added Convert All Blanks and Convert All Tabs commands</vh></v>
<v><vh>7/3 Added Convert Tabs command</vh></v>
<v><vh>7/3 Changed tabs to blanks when tab width is negative</vh></v>
<v t="T240"><vh>7/3 Changed c.tab/page_width to self.tab/page_width in leoAtFile.py</vh></v>
<v t="T241"><vh>7/3 Added OK, Cancel, Revert buttons to Prefs panel</vh></v>
<v t="T242"><vh>7/3 Added window name to Prefs title</vh></v>
<v t="T243"><vh>7/3 Added @language python to all @file nodes</vh></v>
</v>
<v><vh>7/2</vh>
<v t="T244"><vh>7/2 Changed defaultextension from "x" to ".x"</vh></v>
<v t="T245"><vh>7/2 Made prefs a modal dialog</vh></v>
<v t="T246"><vh>7/2 About c.defaultDirectory</vh></v>
<v t="T247"><vh>7/2 Changed Save and Save As...</vh></v>
<v><vh>7/2 Fixed crashers in Remove Sentinels command</vh></v>
<v t="T248"><vh>7/2 Fixed crasher in import.scanAllDirectives)</vh></v>
<v t="T249"><vh>7/2 Hacked code so tab width works</vh></v>
<v><vh>7/2 Fixed doc problems</vh>
<v t="T250"><vh>Demote docs</vh></v>
<v t="T251"><vh>Open/Close log window docs</vh></v>
<v t="T252"><vh>Insert Headline docs</vh></v>
<v t="T253"><vh>Extract Section docs</vh></v>
<v t="T254"><vh>Syntax Coloring... &amp; Font...</vh></v>
</v>
</v>
<v t="T255"><vh>7/1 Cut/Paste now works properly</vh></v>
</v>
</v>
<v><vh>June 2002	</vh>
<v t="T256"><vh>06/22 Implemented Recent Files menu &amp; leoConfig.py</vh></v>
<v t="T257"><vh>06/19 Removed assert from st_enter_root_name</vh></v>
<v t="T258"><vh>06/18 Improved error recovery when writing .leo files</vh></v>
<v t="T259"><vh>06/16 Changed leo.py so Leo can open files when files are double-clicked</vh></v>
<v t="T260"><vh>06/16 Finished updating LeoDocs.leo to match Leo's web site</vh></v>
<v t="T261"><vh>06/15 Fixed the control-I and control-H bugs</vh></v>
<v t="T262"><vh>06/15 Double clicking in a headline now selects a word</vh></v>
<v t="T263"><vh>06/15 Implemented Drag and Drop</vh></v>
<v t="T264"><vh>06/04 Changed atFile.scanAllDirectives to use c.openDirectory as default</vh></v>
<v><vh>06/03 Changed cursor to double arrow when cursor is over splitter bars</vh></v>
<v t="T265"><vh>06/02 Bug fix in es in leoGlobals</vh></v>
<v t="T266"><vh>06/02 Tried and failed to call wm_iconbitmap</vh></v>
</v>
<v><vh>May 2002</vh>
<v t="T267"><vh>5/30/02 Move theory of operation sections back into this outline</vh></v>
<v><vh>5/27/02 Undo move down doesn't always work</vh></v>
<v t="T268"><vh>5/27/02 Fixed bugs involving changing roots</vh></v>
<v t="T269"><vh>5/27/02 Handled unicode error in leoFileCommands::put</vh></v>
<v t="T270"><vh>5/13/02 LeoPy.leo corrupted</vh></v>
</v>
<v><vh>April 2002</vh>
<v t="T271"><vh>4/27/02 Started Remove Sentinels command</vh></v>
<v t="T272"><vh>4/27/02 Changes to Export Noweb command</vh></v>
<v t="T273"><vh>4/25/02 Added code to os()</vh></v>
<v t="T274"><vh>4/7/02 Added frame.outlineToNowebDefaultFileName ivar</vh></v>
<v t="T275"><vh>4/7/02 Replaced &lt;&lt;*&gt;&gt;= with &lt;&lt;fileName&gt;&gt;= whenever possible</vh></v>
<v t="T276"><vh>4/7/02 Added code to make @ defs not start a doc part</vh></v>
<v><vh>4/7/02 Added warnings for all non-undoable import commands</vh></v>
</v>
<v><vh>March 2002</vh>
<v t="T277"><vh>3/16 Fixed moves up to root postion</vh></v>
<v t="T278"><vh>3/16 Simplified syntax colorer for docState</vh></v>
<v t="T279"><vh>3/10 Rewrote skipLeadingComments</vh></v>
<v t="T280"><vh>3/08 Modified colorer for CWEB</vh></v>
<v t="T281"><vh>3/07 Color strings green</vh></v>
<v t="T282"><vh>3/07 Rewrote importWebCommand and its allies</vh></v>
<v><vh>3/06 Import/Export commands</vh>
<v t="T283"><vh>3/06 Outline To Noweb works (as well as it is going to)</vh></v>
<v t="T284"><vh>3/06 Flatten Outline and Import Flattened Outline work</vh></v>
<v t="T285"><vh>3/06 Python, C, Java and Pascal Imports now work</vh></v>
</v>
<v><vh>3/05 Import commands, colorizer, clear IDLE breakpoints</vh>
<v t="T286"><vh>3/05 Import commands, colorizer</vh></v>
<v t="T287"><vh>3/05 Added ability to clear breakpoints in IDLE</vh></v>
</v>
<v><vh>3/04 Released leo.py 2.0 and Borland v2.6</vh>
<v t="T288"><vh>3/04 Improved read error messages.</vh></v>
<v t="T289"><vh>3/04 Untangle calls v.trimTrailingLines only for changed nodes</vh></v>
<v t="T290"><vh>3/04 changed v.setBodyStringOrPane</vh></v>
<v t="T291"><vh>3/04 Added finished messages for Tangle/Untangle</vh></v>
</v>
<v><vh>3/03 Fixed Untangle, </vh>
<v><vh>3/03 Created readme files</vh></v>
<v t="T292"><vh>3/03 Fixed Untangle bug</vh></v>
</v>
<v><vh>3/02 Finished Undo, Preparing for release</vh>
<v><vh>3/02 Created distutils files to distribute Borland Leo</vh></v>
<v><vh>3/02 Created release notes for Borland v2.6</vh></v>
<v t="T293"><vh>3/02 Documented new commands and features</vh></v>
<v t="T294"><vh>3/02 Fixed all pychecker complaints against leoImport.py</vh></v>
<v t="T295"><vh>3/02 Added @space to Utils &amp; Tangle/Untangle code in LeoCB</vh></v>
<v t="T296"><vh>3/02 Completed Undo Change All</vh></v>
</v>
<v><vh>3/01 Finished Tangle, Finished v2.6, etc.</vh>
<v><vh>3/01 Completely supress all auto-indent in @nocolor mode</vh></v>
<v t="T297"><vh>3/01 Tangle now works exactly like LeoCB Tangle</vh></v>
<v t="T298"><vh>3/01 Finished Borland version 2.6</vh></v>
</v>
</v>
<v><vh>Feb 2002</vh>
<v><vh>2/28 Small fixes</vh>
<v t="T299"><vh>Tangle now treats @c like @code</vh></v>
<v t="T300"><vh>Changed is_special_bits</vh></v>
<v t="T301"><vh>Installed Johansson patches</vh></v>
</v>
<v><vh>2/27 pychecker(!), colorizer bug</vh>
<v t="T302"><vh>2/27 Fixed bug in colorizer</vh></v>
<v t="T303"><vh>2/27 Discovered pychecker (several bug fixes)</vh>
<v t="T304"><vh>Fixed bug in Mark Changed Roots</vh></v>
<v t="T305"><vh>Fixed bug in scanText related to @delims sentinel</vh></v>
<v t="T306"><vh>Fixed bug in write</vh></v>
<v t="T307"><vh>Fixed bugs in leoFileCommands</vh></v>
<v t="T308"><vh>Fixed bugs in leoNodes</vh></v>
<v t="T309"><vh>Fixed bugs in leoTangle</vh></v>
</v>
</v>
<v t="T310"><vh>2/26 LeoCB can read compressed derived files</vh></v>
<v><vh>2/25 Fixed IDLE, added verbatimAfterRef sentinel</vh>
<v t="T311"><vh>2/25 Fixed breakpoints in IDLE</vh></v>
<v t="T312"><vh>2/25 Added verbatimAfterRef sentinel</vh></v>
</v>
<v t="T313"><vh>2/24 suppressing newlines</vh></v>
<v><vh>2/23 Untangle, colorizer bug</vh>
<v t="T314"><vh>2/23 Debugging untangle: fixed leading single-comments bug</vh></v>
<v t="T315"><vh>2/23 Fixed small colorizing bug</vh></v>
</v>
<v><vh>2/22 askOKCancel dialog, suppressing auto-indent.</vh>
<v t="T316"><vh>2/22 Created askOkCancel dialog for Read @file Nodes</vh></v>
<v><vh>2/22 Supressed auto-indent in @nocolor mode.</vh></v>
</v>
<v><vh>2/20 and 2/21 Debugged Untangle</vh></v>
<v t="T317"><vh>2/19 Improved Unlimited Undo</vh></v>
<v t="T318"><vh>2/18 Unlimited Undo works</vh></v>
<v><vh>2/16 Syntax coloring</vh>
<v t="T319"><vh>2/16 Fixed bugs in colorAnyLanguage</vh></v>
<v><vh>2/16 Finished adding keywords for colorAnyLanguage</vh></v>
</v>
<v><vh>2/15 Syntax coloring, undo, @space bug</vh>
<v t="T320"><vh>02/15 Created colorAnyLanguage</vh></v>
<v t="T321"><vh>02/15 Fixed @space bug</vh></v>
<v t="T322"><vh>02/15 Bug fix: section definition lines now end coloring for doc parts</vh></v>
<v t="T323"><vh>02/15 Finished Limited undo.</vh></v>
<v t="T324"><vh>02/15 Added files to manifest</vh></v>
</v>
<v><vh>02/14 CVS</vh>
<v t="T325"><vh>02/14 Fixed Undo problems</vh></v>
<v t="T326"><vh>02/14 Checked out Leo from CVS</vh></v>
<v><vh>02/14 Cant mend clones, How to use CVS</vh>
<v t="T327"><vh>CVS: Making a virtue out of necessity</vh></v>
<v t="T328"><vh>Ooops: Leo can't mend clone links!</vh></v>
<v t="T329"><vh>Completed Mending dialog</vh></v>
</v>
</v>
<v><vh>02/13 Mending clone links, undo</vh>
<v><vh>Made the undo class partly functional</vh></v>
<v t="T330"><vh>Created menu utilities</vh></v>
<v t="T331"><vh>Fixed bug in Extract and Extract Section commands</vh></v>
</v>
<v><vh>02/12 Minor fixes</vh>
<v t="T332"><vh>Studied the DnD code</vh></v>
<v t="T333"><vh>Cleared tab and space tags in colorizePython</vh></v>
<v t="T334"><vh>Made headlines longer</vh></v>
<v t="T335"><vh>Cleaned code</vh></v>
</v>
<v><vh>02/11 experiments</vh>
<v t="T336"><vh>created sortSequence utility</vh></v>
<v t="T337"><vh>experimented with inspect</vh></v>
</v>
<v><vh>02/10 1.0 released</vh>
<v t="T338"><vh>Removed "from x import *" from reload_all() and OnOpenPythonWindow'</vh></v>
<v><vh>Released 1.0</vh></v>
<v t="T339"><vh>Added Contract Parent (Alt-0)</vh></v>
<v t="T340"><vh>Fixed bugs in Prefs panel</vh></v>
</v>
<v><vh>02/09 Preparing for release</vh>
<v t="T341"><vh>02/09 Got clean import of leoImport.py</vh></v>
<v t="T342"><vh>02/09 Created do-nothing leoUndo.py</vh></v>
<v t="T343"><vh>02/09 Updated current language properly in Prefs panel</vh></v>
<v t="T344"><vh>02/09 Re-marked @file nodes dirty on write errors</vh></v>
<v t="T345"><vh>02/09 Prefs Panel stick to current window</vh></v>
<v><vh>02/09 Tangle passes full regression test</vh></v>
<v t="T346"><vh>02/09 Added Sort Siblings</vh></v>
</v>
<v><vh>02/08 Regression testing</vh>
<v t="T347"><vh>02/08 Found Tangle problem</vh></v>
<v><vh>02/08 Cleaned up leoCompare.py</vh></v>
<v t="T348"><vh>02/08 @c in Tangled files</vh></v>
<v t="T349"><vh>02/08 Testing wiped out files!</vh></v>
</v>
<v><vh>02/07 New commands and bug fixes</vh>
<v t="T350"><vh>02/07 Possible reversion</vh></v>
<v><vh>02/07 Converted Import Files code</vh></v>
<v t="T351"><vh>02/07 Search suboutline only now applies to Search/ChangeAll</vh></v>
<v t="T352"><vh>02/07 Fixed bug in search()</vh></v>
<v><vh>02/07 Fixed bug: @others wasn't colored unless at left margin.</vh></v>
<v><vh>02/07 * Added indent and undent commands</vh></v>
<v t="T353"><vh>02/07 * Improved idle_body_key</vh></v>
</v>
<v><vh>02/06 Finished commands</vh>
<v t="T354"><vh>02/06 Rewrote and tested all Edit Body commands</vh></v>
<v t="T355"><vh>02/06 Rewrote and tested Convert Blanks command</vh></v>
<v t="T356"><vh>02/06 Removed Print and Page Setup commands</vh></v>
<v t="T357"><vh>02/06 * Implemented View All Characters</vh></v>
<v t="T358"><vh>02/06 Got the arrow binding right</vh></v>
<v><vh>02/06 finished Delete command</vh></v>
<v t="T359"><vh>02/06 created tree.onBodyChanged</vh></v>
<v><vh>02/06 rewrote and tested Revert</vh></v>
<v><vh>02/06 created leoDialog.yesNo</vh></v>
</v>
<v><vh>2/05 More bug fixes</vh>
<v t="T360"><vh>02/05 * Extended Sherlock</vh></v>
<v t="T361"><vh>02/05 * Properly enabled and disabled all menu items</vh></v>
<v t="T362"><vh>02/05 Got special accelerator keys working</vh></v>
<v><vh>02/05 GoTo commands now working</vh></v>
<v t="T363"><vh>02/05 Got Alt-keys working</vh></v>
<v t="T364"><vh>02/05 Made es and trace safer during quit</vh></v>
<v t="T365"><vh>02/05 Fixed bugs in Search Headline and Find, Then Change</vh></v>
<v t="T366"><vh>02/05 Do not eliminate begin/endUpdate!</vh></v>
</v>
<v><vh>02/04 Many bug fixes &amp; some big improvements</vh>
<v t="T367"><vh>02/04 Fixed Change command in headline</vh></v>
<v t="T368"><vh>02/04 A kludgy way to cut &amp; paste between Leo &amp; Leo.py</vh></v>
<v t="T369"><vh>02/04 Ended all event handlers with return "break"</vh></v>
<v><vh>02/04 Changed Insert Node accelerator from Control-K to Control-I</vh></v>
<v t="T370"><vh>02/04 Implemented Toggle Active Pane</vh></v>
<v t="T371"><vh>02/04 ** Overrode default text keys</vh></v>
<v><vh>02/04 Documented control characters used in the body pane.</vh></v>
<v t="T372"><vh>02/04 ** Breakthrough regarding events and accelerators</vh></v>
<v t="T373"><vh>02/04 Implemented Select All command</vh></v>
<v t="T374"><vh>02/04 created OnBodyDoubleClick and allies</vh></v>
<v><vh>02/04 create setTextSelelection utility</vh></v>
<v t="T375"><vh>02/04 Created Sort command</vh></v>
<v t="T376"><vh>02/04 Fixed Tangle Marked and Tangle All commands</vh></v>
</v>
<v t="T377"><vh>02/03 Created shortcuts for opening LeoPy.leo</vh></v>
<v><vh>02/03 Released 0.08</vh></v>
<v><vh>02/02 Fixing Bugs</vh>
<v t="T378"><vh>02/02 Fixed bugs in outline-only and whole-word searches &amp; is_c_id</vh></v>
<v t="T379"><vh>02/02 ** Drawing breakthroughs</vh></v>
<v t="T380"><vh>02/02 Fixed control-d bug</vh></v>
<v t="T381"><vh>02/02 ** About redrawing</vh></v>
</v>
<v><vh>02/01 Fixing bugs</vh>
<v t="T382"><vh>02/01 Test tangle path errors</vh></v>
<v t="T383"><vh>02/01 ** started tree.makeVisible &amp; tree.scrollTo</vh></v>
<v t="T384"><vh>02/01 ** used distutils</vh></v>
</v>
</v>
<v><vh>Jan 2002</vh>
<v><vh>01/31 Preparing for release...</vh>
<v t="T385"><vh>** 01/31 leo.py now tangles better than LeoCB</vh></v>
<v t="T386"><vh>01/31 Created open script in leo.py</vh></v>
<v t="T387"><vh>01/31 Fixed suboutline only logic</vh></v>
<v t="T388"><vh>01/31 Tested directory logic</vh></v>
<v t="T389"><vh>01/31 replaced frame.defaultDirectory by c.tangle_directory</vh></v>
</v>
<v><vh>01/30 Major improvements...</vh>
<v t="T390"><vh>01/30 ** May have solved the load path problem</vh></v>
<v t="T391"><vh>01/30 ** Rewrote path logic: removed all calls to os.chdir</vh></v>
<v t="T392"><vh>01/30 ** Fixed major bug causing @file read errors</vh></v>
<v t="T393"><vh>01/30 ** Changed how directories are handled</vh></v>
</v>
<v t="T394"><vh>01/29 Improved Paste Node command</vh></v>
<v t="T395"><vh>01/28 Generalized trace to allow function args</vh></v>
<v t="T396"><vh>01/28 Found source of Find performance bug</vh></v>
<v t="T397"><vh>01/25 Found one source of misreads</vh></v>
<v><vh>01/24 Implemented Sherlock: init_trace and trace</vh></v>
<v t="T398"><vh>01/22 More work on leoTangle.py</vh></v>
<v><vh>01/21 Started workon leoTangle.py</vh></v>
<v><vh>01/20</vh>
<v t="T399"><vh>01/20 Lost clones into leoColor.py</vh></v>
<v t="T400"><vh>01/20 Implemented hyperlinks</vh></v>
</v>
<v><vh>01/18 Completed Change all command</vh></v>
<v><vh>01/17</vh>
<v t="T401"><vh>01/17 Breakthrough: tree.redraw_now</vh></v>
<v t="T402"><vh>01/17 much work on Find class</vh></v>
<v t="T403"><vh>01/17 v.edit_text defined only if v is visible</vh></v>
</v>
<v><vh>01/16</vh>
<v t="T404"><vh>01/16 Fixed idle_headline logic</vh></v>
<v t="T405"><vh>01/16 Lost data in outline (not derived files)</vh></v>
<v><vh>01/16 Fixed minor find/change bugs and removed batch checkbox</vh></v>
<v t="T406"><vh>01/16 Breakthrough re event handlers!</vh></v>
</v>
<v><vh>01/15 Find/Change</vh>
<v t="T407"><vh>01/15 ** Completed find/change commands</vh></v>
<v t="T408"><vh>01/15 Converted headline from Tk.Entry to Tk.Text</vh></v>
</v>
<v><vh>01/14</vh>
<v t="T409"><vh>01/14 Fixed bug: cancelling dialog wrote .leo</vh></v>
<v t="T410"><vh>01/14 Got basic Find commands to work</vh></v>
<v t="T411"><vh>01/14 Fixed Save To bug</vh></v>
<v><vh>01/14 Added log messages for saves</vh></v>
<v><vh>01/14 Always recompute file indices on saves</vh></v>
<v t="T412"><vh>01/14 Reduced width of log window</vh></v>
</v>
<v><vh>01/13</vh>
<v t="T413"><vh>01/13 exec statement simplifies code</vh></v>
<v t="T414"><vh>01/13 Prefs/Find settings now functional</vh></v>
</v>
<v><vh>01/11</vh>
<v t="T415"><vh>01/11 Replaced globals with app() ivars</vh></v>
<v t="T416"><vh>01/11 New memory management: created c/v/tree/frame destroy routines</vh></v>
<v t="T417"><vh>01/11 About destroy routines: eliminating circular references</vh></v>
<v t="T418"><vh>01/11 disabled c.setChanged while loading</vh></v>
<v t="T419"><vh>01/11 Eliminated ?? error message on exit</vh></v>
<v t="T420"><vh>01/11 created leoFrame.__del__</vh></v>
</v>
<v><vh>01/10</vh>
<v t="T421"><vh>01/10 Worked on Quit error messages</vh></v>
<v><vh>01/10 Released v 0.07</vh></v>
<v t="T422"><vh>01/10 Tested c2py on Borland</vh></v>
</v>
<v><vh>01/09</vh>
<v t="T423"><vh>01/09 Wrote and debugged leo1to2 scripts !</vh></v>
<v t="T424"><vh>01/09 Made Python window functional !</vh></v>
<v><vh>01/09 Added auto indent</vh></v>
</v>
<v><vh>01/08</vh>
<v t="T425"><vh>01/08 bodyKeepsFocus logic</vh></v>
<v t="T426"><vh>01/08 Fixed bug: no doesn't abort a Quit command</vh></v>
<v t="T427"><vh>01/08 Fixed bug: changing clones didn't mark joined dirty.</vh></v>
<v t="T428"><vh>01/08 Got cut/copy/paste working</vh></v>
<v t="T429"><vh>01/08 Fixed reooloring problem</vh></v>
<v><vh>01/08 Added Help-Leo Documentation command</vh></v>
<v><vh>01/08 Save commands now ensure .leo extension</vh></v>
<v t="T430"><vh>01/08 Still no joy with canvas border</vh></v>
<v t="T431"><vh>01/08 Expermented with window icons</vh></v>
<v t="T432"><vh>01/08 Increased size of open windows</vh></v>
<v t="T433"><vh>01/08 Improved look of prefs panel</vh></v>
<v t="T434"><vh>01/08 Made progress towards "Show invisibles"</vh></v>
<v t="T435"><vh>01/08 @ignore now colored properly</vh></v>
<v><vh>01/08 @color and @nocolor are now inherited</vh></v>
</v>
<v><vh>01/07</vh>
<v t="T436"><vh>01/07 Fixed some bugs in Move Up and Move Down commands</vh></v>
<v t="T437"><vh>01/07 Fixed loss-of-data on insert command</vh></v>
<v t="T438"><vh>01/07 tab width</vh></v>
</v>
<v><vh>01/06</vh>
<v t="T439"><vh>01/06 borders again</vh></v>
<v t="T440"><vh>01/06 editing and selecting</vh></v>
</v>
</v>
</v>
<v><vh>2001</vh>
<v><vh>Dec 2001</vh>
<v t="T441"><vh>12/20/01 Fixed Linux problems</vh></v>
<v t="T442"><vh>12/19/01 Improved LeoDocs.leo</vh></v>
<v t="T443"><vh>12/18/01 Improved Leo2 documentation</vh></v>
<v t="T444"><vh>12/17/01 ** Leo 0.05 released</vh></v>
<v t="T445"><vh>12/16/01 Found the source of the file mismatches</vh></v>
<v t="T446"><vh>12/16/01 Created directory compare routines</vh></v>
<v><vh>12/15/01 Leo is operational</vh></v>
<v t="T447"><vh>12/15/01 Fixed bug in scanText</vh></v>
<v t="T448"><vh>12/15/01 Fixed bug in putBodyPart</vh></v>
<v t="T449"><vh>12/15/01 Fixed lookahead code in scanText, scanDoc</vh></v>
<v t="T450"><vh>12/14/01 Created leoCompare.py</vh></v>
<v t="T451"><vh>12/14/01 Create leoDialog.py</vh></v>
<v t="T452"><vh>12/14/01 Fixed minor problems</vh></v>
<v t="T453"><vh>12/13/01 Fixed several clone bugs</vh></v>
<v t="T454"><vh>12/13/01 Aha: we can eliminate v.setIcon !</vh></v>
<v t="T455"><vh>12/13/01 ** Fixed bottleneck with endupdate(flag)</vh></v>
<v t="T456"><vh>12/13/01 ** Syntax coloring now works</vh></v>
<v t="T457"><vh>12/12/01 Cut/copy/paste of nodes now done using internal clipboard</vh></v>
<v t="T458"><vh>12/12/01 Fixed insert, move, clone and delete commands</vh></v>
<v t="T459"><vh>12/12/01 Looked into Tk &amp; Python clipboard commands</vh></v>
<v t="T460"><vh>12/11/01 Menu accelerators</vh></v>
<v t="T461"><vh>12/11/01 Properly initialized the file in getLeoFile</vh></v>
<v t="T462"><vh>12/10/01 Got accellerators working</vh></v>
<v t="T463"><vh>12/10/01 Simplified icon handling, tree.redraw</vh></v>
<v t="T464"><vh>12/10/01 Used idle-time handler to work around event problems</vh></v>
<v t="T465"><vh>12/09/01 Problems with canvas border</vh></v>
<v><vh>12/09/01 Tree now drawn properly</vh></v>
<v t="T466"><vh>12/08/01 Progress with selection</vh></v>
<v t="T467"><vh>12/07/01 Small improvements</vh></v>
<v><vh>12/07/01 Tree now contains labels for editing</vh></v>
<v t="T468"><vh>12/06/01 Open/Close events now handled properly</vh></v>
<v t="T469"><vh>12/06/01 Tree drawn correctly, slowly</vh></v>
<v t="T470"><vh>12/04/01 Create .gif icons</vh></v>
<v t="T471"><vh>12/04/01 replaced dvnodes with vnodes!</vh></v>
<v t="T472"><vh>12/04/01 read code is now fast enough!</vh></v>
<v t="T473"><vh>12/04/01 tree starts to work</vh></v>
<v t="T474"><vh>12/01/01</vh></v>
</v>
<v><vh>Nov 2001</vh>
<v t="T475"><vh>11/15/01 Created do-nothing tk app using Tkinter</vh></v>
<v t="T476"><vh>11/15/01 added -padx to log window</vh></v>
<v t="T477"><vh>11/13/01 Speeding up reads</vh></v>
<v t="T478"><vh>11/11/01 Design of tree class</vh></v>
<v t="T479"><vh>11/10/01 began conversion to tk</vh></v>
<v t="T480"><vh>11/10/01 es outputs newline</vh></v>
<v t="T481"><vh>11/10/01 fixed bug in putDocPart</vh></v>
<v t="T482"><vh>11/10/01 added code for @delims</vh></v>
<v t="T483"><vh>11/10/01 got @first working</vh></v>
<v t="T484"><vh>11/09/01 moved all globals into class</vh></v>
<v t="T485"><vh>11/09/01 fixed bugs in write logic</vh></v>
<v t="T486"><vh>11/09/01 fixed bugs read logic</vh></v>
<v t="T487"><vh>11/06/01 created Leo window using Tk</vh></v>
</v>
<v><vh>Oct 2001</vh>
<v t="T488"><vh>11/01/01 Write code works except for comments</vh></v>
<v><vh>10/31/01 Added Read/write submenu</vh></v>
<v t="T489"><vh>10/31/01 Fixed write code</vh></v>
<v t="T490"><vh>10/26/01 Read code is slow</vh></v>
<v t="T491"><vh>10/26/01 Read/write code now works</vh></v>
<v t="T492"><vh>10/11/01 Outline commands now work</vh></v>
<v t="T493"><vh>10/11/01 Removed redundant getters</vh></v>
<v t="T494"><vh>10/10/01 Debugged Commands, nodes, fileCommands</vh></v>
<v t="T495"><vh>10/08/01 design of leoFileCommands</vh></v>
<v t="T496"><vh>10/07/01 removed info and tagList classes</vh></v>
<v t="T497"><vh>10/05/01 c2py fixes, speedTest</vh></v>
<v t="T498"><vh>10/02/01 through 1/10/4</vh></v>
<v t="T499"><vh>10/01/01 fxed bugs in c2py</vh></v>
<v t="T500"><vh>10/01/01 c2py in leo</vh></v>
</v>
<v><vh>Sept 2001</vh>
<v t="T501"><vh>9/30/01 documented c2py</vh></v>
<v t="T502"><vh>9/29/01 c2py.py</vh></v>
<v t="T503"><vh>9/25/01 Idle has trees &amp; syntax coloring</vh></v>
<v t="T504"><vh>9/14/01</vh></v>
</v>
</v>
</v>
<v t="T505"><vh>Notes</vh>
<v t="T506"><vh>About packages (Mike Orr)</vh></v>
<v t="T507"><vh>about sys.settrace</vh></v>
<v><vh>Annoucnements</vh>
<v t="T508"><vh>ANN to vault of parnassus</vh></v>
<v t="T509"><vh>ANN: Python code hidden in leo.py</vh></v>
<v t="T510"><vh>ANN to comp.lang.python: ANN: Leo 3.3 outlining editor</vh></v>
<v t="T511"><vh>ANN: Leo 3.5 (and 3.4) outlining editor</vh></v>
<v t="T512"><vh>ANN: Leo 3.6 outlining editor</vh></v>
<v t="T513"><vh>ANN: Leo 3.7 outlining editor</vh></v>
<v t="T514"><vh>ANN: Leo 3.8 outlining editor</vh></v>
<v t="T515"><vh>ANN: Leo 3.9 outlining editor</vh></v>
</v>
<v t="T516"><vh>Distribution checklist</vh>
<v t="T517"><vh>Places to announce Leo</vh></v>
</v>
<v t="T518"><vh>Good Fonts</vh></v>
<v><vh>How to...</vh>
<v t="T519"><vh>How to add and remove files from CVS repository</vh></v>
<v t="T520"><vh>How to add support for a new language</vh>
<v t="T521"><vh>code</vh>
<v t="T522" a="C"><vh>&lt;&lt; define global constants &gt;&gt;</vh></v>
<v t="T523" a="C"><vh>&lt;&lt; Create the Target Language frame &gt;&gt;</vh></v>
<v t="T524" a="C"><vh>&lt;&lt; define colorizer keywords &gt;&gt;</vh>
<v t="T525"><vh>&lt;&lt; leo keywords &gt;&gt;</vh></v>
<v t="T526"><vh>&lt;&lt; c keywords &gt;&gt;</vh></v>
<v t="T527"><vh>&lt;&lt; html keywords &gt;&gt;</vh></v>
<v t="T528"><vh>&lt;&lt; java keywords &gt;&gt;</vh></v>
<v t="T529"><vh>&lt;&lt; latex keywords &gt;&gt;</vh></v>
<v t="T530"><vh>&lt;&lt; pascal keywords &gt;&gt;</vh></v>
<v t="T531"><vh>&lt;&lt; perl keywords &gt;&gt;</vh></v>
<v t="T532"><vh>&lt;&lt; python keywords &gt;&gt;</vh></v>
<v t="T533"><vh>&lt;&lt; tcl/tk keywords &gt;&gt;</vh></v>
<v t="T534"><vh>&lt;&lt; php keywords &gt;&gt;</vh></v>
</v>
<v t="T535"><vh>&lt;&lt; configure language-specific settings &gt;&gt; (colorizer)</vh></v>
<v t="T536" a="C"><vh>&lt;&lt; check for syntax coloring prefs &gt;&gt; (getPrefs)</vh></v>
<v t="T537" a="C"><vh>&lt;&lt; initialize constant ivars, lists &amp; dicts &gt;&gt; (leoConfig)</vh></v>
<v t="T538" a="C"><vh>set_delims_from_language</vh></v>
<v t="T539" a="C"><vh>set_language</vh></v>
<v t="T540" a="C"><vh>colorizeAnyLanguage &amp; allies</vh>
<v t="T541"><vh>&lt;&lt; initialize ivars &amp; tags &gt;&gt;</vh>
<v t="T542"><vh>&lt;&lt; configure tags &gt;&gt;</vh></v>
<v t="T543"><vh>&lt;&lt; configure language-specific settings &gt;&gt;</vh></v>
</v>
<v t="T544"><vh>&lt;&lt; incrementally color the text &gt;&gt;</vh>
<v t="T545"><vh>&lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;</vh></v>
<v t="T546"><vh>&lt;&lt; clear leading_lines if middle lines involve @color or @recolor  &gt;&gt;</vh></v>
<v t="T547"><vh>&lt;&lt; initialize new states &gt;&gt;</vh></v>
<v t="T548"><vh>&lt;&lt; colorize until the states match &gt;&gt;</vh></v>
</v>
<v t="T549"><vh>colorizeLine &amp; allies</vh>
<v t="T550"><vh>continueBlockComment</vh></v>
<v t="T551"><vh>continueSingle/DoubleString</vh></v>
<v t="T552"><vh>continueDocPart</vh>
<v t="T553"><vh>&lt;&lt; handle cweb doc part &gt;&gt;</vh></v>
<v t="T554"><vh>&lt;&lt; handle noweb doc part &gt;&gt;</vh></v>
</v>
<v t="T555"><vh>continueNocolor</vh></v>
<v t="T556"><vh>continueSingle/DoublePythonString</vh></v>
<v t="T557"><vh>doAtKeyword: NOT for cweb keywords</vh></v>
<v t="T558"><vh>doLatexLine</vh></v>
<v t="T559"><vh>doNormalState</vh>
<v t="T560"><vh>Valid regardless of latex mode</vh>
<v t="T561"><vh>&lt;&lt; handle possible  keyword &gt;&gt;</vh></v>
<v t="T562"><vh>&lt;&lt; handle at keyword &gt;&gt;</vh>
<v t="T563"><vh>&lt;&lt; Handle cweb control word &gt;&gt;</vh></v>
<v t="T564"><vh>&lt;&lt; handle cweb ref or def &gt;&gt;</vh></v>
</v>
<v t="T565"><vh>&lt;&lt; handle single-line comment &gt;&gt;</vh></v>
<v t="T566"><vh>&lt;&lt; start block comment &gt;&gt;</vh></v>
<v t="T567"><vh>&lt;&lt; handle latex line &gt;&gt;</vh></v>
</v>
<v t="T568"><vh>Vaid only in latex mode</vh>
<v t="T569"><vh>&lt;&lt; handle latex normal character &gt;&gt;</vh></v>
</v>
<v t="T570"><vh>Valid when not in latex_mode</vh>
<v t="T571"><vh>&lt;&lt; handle string &gt;&gt;</vh></v>
<v t="T572"><vh>&lt;&lt; handle C preprocessor line &gt;&gt;</vh></v>
<v t="T573"><vh>&lt;&lt; handle special php keywords &gt;&gt;</vh></v>
<v t="T574"><vh>&lt;&lt; handle blank &gt;&gt;</vh></v>
<v t="T575"><vh>&lt;&lt; handle tab &gt;&gt;</vh></v>
<v t="T576"><vh>&lt;&lt; handle normal character &gt;&gt;</vh></v>
</v>
</v>
<v t="T577"><vh>doNowebSecRef</vh>
<v t="T578"><vh>&lt;&lt; set the hyperlink &gt;&gt;</vh></v>
</v>
<v t="T579"><vh>removeAllTags &amp; removeTagsFromLines</vh></v>
</v>
</v>
<v t="T580" a="C"><vh>getPrefs</vh>
<v t="T536" a="C"><vh>&lt;&lt; check for syntax coloring prefs &gt;&gt; (getPrefs)</vh></v>
</v>
</v>
<v t="T581"><vh>@root tcl/tk test</vh>
<v t="T582"><vh>&lt;&lt; stuff &gt;&gt;</vh></v>
</v>
</v>
<v t="T583"><vh>How to bind args to callbacks</vh>
<v t="T584"><vh>callback class</vh></v>
</v>
<v t="T585"><vh>How to call any Python method from the C API</vh></v>
<v t="T586"><vh>How to create sentinel lines in CWEB</vh></v>
<v t="T587"><vh>How to Increase environment space</vh></v>
<v><vh>How to install Leo on MacOS X</vh>
<v t="T588"><vh>Bruce M. Bolden</vh></v>
<v t="T589"><vh>Tom Fetherston</vh></v>
</v>
<v t="T590"><vh>How to remove cursed newlines: use binary mode</vh>
<v t="T591"><vh>The solution</vh></v>
<v t="T592"><vh>cursed newline answer</vh></v>
<v t="T593"><vh>cursed newline answer 2</vh></v>
</v>
<v t="T594"><vh>How to run Pychecker</vh></v>
<v><vh>How to run Python programs easily on NT,2K,XP</vh>
<v t="T595"><vh>setting the PATHEXT env var</vh></v>
<v t="T596"><vh>Yet another Python .bat wrapper</vh></v>
</v>
<v t="T597"><vh>Selection notes</vh></v>
</v>
<v><vh>Leo and CVS</vh>
<v t="T598"><vh>Initial post by Steven Schaefer</vh></v>
</v>
<v><vh>Milestones</vh>
<v><vh>02/03/02 Leo 0.08 released</vh></v>
<v><vh>12/17/01 ** Leo 0.05 released</vh></v>
<v t="T599"><vh>12/16/01 Leo becomes functional</vh></v>
<v t="T600"><vh>12/13/01 Syntax coloring works</vh></v>
<v><vh>12/09/01 Tree now drawn properly</vh></v>
<v><vh>12/05/01 Tree works with Tkinter</vh></v>
<v t="T601"><vh>11/10/01 ** began conversion to tk</vh></v>
<v><vh>10/26/01 First successful read of .leo file w/ @file nodes</vh></v>
<v t="T602"><vh>9/29/01 c2py: Totally in love with Python</vh></v>
<v t="T603"><vh>ca. 9/1/01 began work on wxPython version of Leo</vh></v>
</v>
<v><vh>Promo</vh>
<v t="T604"><vh>Argument: what is Leo?</vh></v>
</v>
<v t="T605"><vh>Pychecker report for 3.9</vh></v>
<v t="T606"><vh>Scripting compatibility</vh>
<v t="T607"><vh>Functions (done with stub topCommand)</vh></v>
<v t="T608"><vh>Commands (menu commands &amp; enablers not ready yet)</vh>
<v t="T609"><vh>menu commands (not ready yet)</vh></v>
<v t="T610"><vh>command enablers (not ready yet)</vh></v>
</v>
<v t="T611"><vh>Prefs (not ready yet)</vh></v>
<v t="T612"><vh>vnodes (done except for minor routines)</vh></v>
</v>
<v><vh>Supporting PHP</vh>
<v t="T613"><vh>First posting</vh></v>
<v t="T614"><vh>Second posting</vh></v>
<v t="T615"><vh>Third posting</vh></v>
</v>
<v t="T616"><vh>Test code</vh>
<v t="T617"><vh>test of @silent</vh>
<v t="T618"><vh>newlineTest.txt</vh></v>
</v>
</v>
<v t="T619"><vh>tk undo</vh></v>
<v t="T620"><vh>Unused code</vh>
<v t="T621"><vh>onKillLeoEvent</vh></v>
</v>
</v>
<v t="T622"><vh>To do</vh>
<v t="T623"><vh>to do 3.10</vh>
<v t="T624"><vh>First: Fix unicode problems</vh></v>
<v><vh>Easy stuff</vh>
<v t="T625"><vh>Option for control drag</vh></v>
<v t="T626"><vh>Toggle angle brackets</vh></v>
<v t="T627"><vh>option for show invisibibles colors</vh></v>
<v t="T628"><vh>Import dialog</vh></v>
<v t="T629"><vh>Sort top-level nodes</vh></v>
</v>
<v><vh>Update docs</vh>
<v><vh>at root-code, @root-doc</vh></v>
<v><vh>at file-asis-nosent-noref</vh></v>
<v t="T630"><vh>** Rewrite scripting chapter</vh></v>
<v><vh>** Mention new Chapter in readme file</vh></v>
<v><vh>Node Only checkbox in Find menu</vh></v>
<v><vh>Export Headlines command</vh></v>
<v><vh>Mark clones &amp; Go To Next Marked directive</vh></v>
<v t="T631"><vh>colorizing directives</vh></v>
<v t="T632"><vh>examples of customization</vh></v>
</v>
<v t="T633"><vh>(Improve Sherlock and es</vh></v>
<v t="T634"><vh>cleanup</vh></v>
</v>
<v><vh>Later versions</vh>
<v><vh>4.0 gti's and new format for derived files</vh>
<v t="T635"><vh>4.0 cleanup</vh></v>
<v><vh>@include x.leo</vh></v>
<v t="T636"><vh>clone somewhere else</vh></v>
</v>
<v><vh>4.x (More requested features)</vh>
<v><vh>Major</vh>
<v t="T637"><vh>Split panes</vh></v>
</v>
<v t="T638"><vh>Unicode</vh>
<v t="T639"><vh>@codepage iso-8859-1</vh></v>
<v><vh>Old Unicode problems &amp; solution</vh>
<v t="T95" a="C"><vh>From  Martin v. Löwis</vh></v>
<v t="T640"><vh>One</vh></v>
<v t="T641"><vh>Two vnode.mHeadString (fixed)</vh></v>
<v t="T642"><vh>Three</vh></v>
<v t="T643"><vh>Four</vh></v>
<v t="T644"><vh>Five</vh></v>
</v>
</v>
<v><vh>Other</vh>
<v t="T645"><vh>(cweb projects)</vh>
<v><vh>(cweb &amp; cweb hack)</vh>
<v t="T646"><vh>Original bug report</vh></v>
<v t="T647"><vh>cweb hack</vh>
<v><vh>writing...</vh>
<v t="T648" a="C"><vh>putDirective  (handles @delims)</vh>
<v t="T649"><vh>&lt;&lt; handle @delims &gt;&gt;</vh></v>
</v>
<v t="T650" a="C"><vh>putSentinel (applies cweb hack)</vh></v>
</v>
<v><vh>reading...</vh>
<v t="T651" a="C"><vh>skipSentinelStart</vh></v>
<v t="T652" a="C"><vh>sentinelKind</vh></v>
<v t="T653" a="C"><vh>nodeSentinelText</vh></v>
<v t="T654" a="C"><vh>&lt;&lt; Set headline and ref &gt;&gt;</vh></v>
<v t="T655" a="C"><vh>&lt;&lt; scan @ref &gt;&gt;</vh></v>
<v t="T656" a="C"><vh>&lt;&lt; scan @@ &gt;&gt;</vh></v>
</v>
</v>
<v t="T657" a="C"><vh>directiveKind</vh></v>
</v>
<v t="T658"><vh>(raw cweb mode in @root treees) (proper cweb hack not applied yet)</vh>
<v t="T659"><vh>Test</vh>
<v t="T660"><vh>@root rawCwebTest</vh>
<v t="T661"><vh>&lt;&lt; noweb sec1 &gt;&gt;</vh></v>
<v t="T662"><vh>noweb sec2</vh></v>
</v>
</v>
<v><vh>Setting raw_cweb_flag</vh>
<v t="T663" a="C"><vh>&lt;&lt; constants &amp; synonyms &gt;&gt;</vh></v>
<v t="T664" a="C"><vh>&lt;&lt; init directive ivars &gt;&gt; (tangle)</vh></v>
</v>
<v><vh>Using the new raw_cweb_flag</vh>
<v t="T665" a="C"><vh>token_type</vh>
<v t="T666"><vh>&lt;&lt; set token_type in noweb mode &gt;&gt;</vh></v>
<v t="T667"><vh>&lt;&lt; set token_type for CWEB mode &gt;&gt;</vh></v>
<v t="T668"><vh>&lt;&lt; set kind for directive &gt;&gt;</vh></v>
</v>
</v>
<v t="T669"><vh>contain use_cweb_flag or use_noweb_flag</vh>
<v><vh>Tangle pass 1</vh>
<v t="T670" a="C"><vh>handle_newline</vh></v>
<v t="T671" a="C"><vh>skip_body</vh>
<v t="T672"><vh>The interface between tangle and untangle</vh>
<v t="T673"><vh>&lt;&lt; Define a section containing only an @doc part &gt;&gt;</vh></v>
<v t="T674"><vh>&lt;&lt; Define a section for a leading code part &gt;&gt;</vh></v>
<v t="T675"><vh>&lt;&lt; Scan and define a section definition &gt;&gt;</vh></v>
<v t="T676"><vh>&lt;&lt; Scan and define an @code defininition &gt;&gt;</vh></v>
<v t="T677"><vh>&lt;&lt; Scan and define a root section &gt;&gt;</vh></v>
</v>
</v>
<v t="T678" a="C"><vh>skip_code</vh>
<v t="T679"><vh>&lt;&lt; skip a noweb code section &gt;&gt;</vh>
<v t="T680"><vh>&lt;&lt; handle possible noweb section reference &gt;&gt;</vh></v>
</v>
<v t="T681"><vh>&lt;&lt; skip a CWEB code section &gt;&gt;</vh>
<v t="T682"><vh>&lt;&lt; handle CWEB control code &gt;&gt;</vh></v>
</v>
</v>
</v>
<v><vh>Tangle pass 2</vh>
<v t="T683" a="C"><vh>put_code</vh>
<v t="T684"><vh>&lt;&lt;put possible section reference &gt;&gt;</vh></v>
<v t="T685"><vh>&lt;&lt; handle 2-character CWEB control codes &gt;&gt;</vh></v>
<v t="T686"><vh>&lt;&lt; handle noweb @ &lt; &lt; convention &gt;&gt;</vh></v>
</v>
<v t="T687" a="C"><vh>put_newline</vh>
<v t="T688"><vh>&lt;&lt; Output leading white space except for blank lines &gt;&gt;</vh></v>
</v>
<v t="T689" a="C"><vh>put_section</vh>
<v t="T690"><vh>&lt;&lt; Calculate the new value of tangle_indent &gt;&gt;</vh></v>
<v t="T691"><vh>&lt;&lt; Set 'newline_flag' if the line ends with the reference &gt;&gt;</vh></v>
<v t="T692"><vh>&lt;&lt;put all parts of the section definition&gt;&gt;</vh>
<v t="T693"><vh>&lt;&lt; Put the section name in a comment &gt;&gt;</vh>
<v t="T694"><vh>&lt;&lt; put ( n of m ) &gt;&gt;</vh></v>
</v>
<v t="T695"><vh>&lt;&lt; Put the ending comment &gt;&gt;</vh></v>
</v>
<v t="T696"><vh>&lt;&lt;Put a comment about the undefined section&gt;&gt;</vh></v>
</v>
</v>
<v><vh>Utils...</vh>
<v t="T697" a="C"><vh>compare_section_names</vh></v>
<v t="T698" a="C"><vh>is_section_name</vh></v>
<v t="T699" a="C"><vh>is_sentinel_line &amp; is_sentinel_line_with_data</vh>
<v t="T700"><vh>&lt;&lt; Initialize the return values  &gt;&gt;</vh></v>
<v t="T701"><vh>&lt;&lt; Make sure the line starts with start_sentinel &gt;&gt;</vh></v>
<v t="T702"><vh>&lt;&lt; Set end_flag if we have -- end -- &gt;&gt;</vh></v>
<v t="T703"><vh>&lt;&lt; Make sure we have a section reference &gt;&gt;</vh></v>
<v t="T704"><vh>&lt;&lt; Set part and of if they exist &gt;&gt;</vh></v>
<v t="T705"><vh>&lt;&lt; Set nl_flag to false if !newline exists &gt;&gt;</vh></v>
<v t="T706"><vh>&lt;&lt; Make sure the line ends with end_sentinel &gt;&gt;</vh></v>
</v>
<v t="T707" a="C"><vh>skip_section_name</vh></v>
<v t="T665" a="C"><vh>token_type</vh>
<v t="T666"><vh>&lt;&lt; set token_type in noweb mode &gt;&gt;</vh></v>
<v t="T667"><vh>&lt;&lt; set token_type for CWEB mode &gt;&gt;</vh></v>
<v t="T668"><vh>&lt;&lt; set kind for directive &gt;&gt;</vh></v>
</v>
</v>
<v><vh>Untangle &amp; ust &amp; st</vh>
<v t="T708" a="C"><vh>forgiving_compare</vh>
<v t="T709"><vh>&lt;&lt; Define forgiving_compare vars &gt;&gt;</vh></v>
<v t="T710" a="C"><vh>&lt;&lt; Check both parts for @ comment conventions &gt;&gt;</vh></v>
<v t="T711"><vh>&lt;&lt; Compare non-critical newlines &gt;&gt;</vh></v>
<v t="T712"><vh>&lt;&lt; Compare non-critical whitespace &gt;&gt;</vh></v>
<v t="T713"><vh>&lt;&lt; Compare possible preprocessor directives &gt;&gt;</vh>
<v t="T714" a="C"><vh>&lt;&lt; Compare single characters &gt;&gt;</vh></v>
<v t="T715"><vh>&lt;&lt; Compare preprocessor directives &gt;&gt;</vh></v>
</v>
<v t="T716"><vh>&lt;&lt; Compare possible strings &gt;&gt;</vh>
<v t="T714" a="C"><vh>&lt;&lt; Compare single characters &gt;&gt;</vh></v>
<v t="T717"><vh>&lt;&lt; Compare C strings &gt;&gt;</vh></v>
<v t="T718"><vh>&lt;&lt; Compare Pascal strings &gt;&gt;</vh></v>
</v>
<v t="T719"><vh>&lt;&lt; Compare possible section references &gt;&gt;</vh></v>
<v t="T720"><vh>&lt;&lt; Compare comments or single characters &gt;&gt;</vh>
<v t="T714" a="C"><vh>&lt;&lt; Compare single characters &gt;&gt;</vh></v>
</v>
<v t="T721"><vh>&lt;&lt; Make sure both parts have ended &gt;&gt;</vh></v>
<v t="T722"><vh>&lt;&lt; Trace the mismatch &gt;&gt;</vh></v>
</v>
<v t="T723" a="C"><vh>compare_comments</vh>
<v t="T710" a="C"><vh>&lt;&lt; Check both parts for @ comment conventions &gt;&gt;</vh></v>
</v>
<v t="T724" a="C"><vh>ust_warn_about_orphans</vh></v>
<v t="T725" a="C"><vh>st_check</vh></v>
</v>
</v>
</v>
<v><vh>(cweb colorizing)</vh>
<v t="T726"><vh> Bug report</vh></v>
<v t="T727"><vh> latex test</vh></v>
<v t="T728"><vh> cweb test</vh>
<v t="T729"><vh>&lt;&lt; section ref &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T730"><vh>(Go to line number)</vh>
<v t="T731"><vh>tests</vh>
<v t="T732"><vh>@file c:\prog\test\lineTest.txt</vh>
<v t="T733"><vh>&lt;&lt; ref &gt;&gt;</vh></v>
</v>
<v t="T734"><vh>@rawfile c:\prog\test\rawLineTest.txt</vh>
<v t="T735"><vh>&lt;&lt; ref &gt;&gt;</vh></v>
</v>
</v>
<v t="T736" a="C"><vh>OnGoToLineNumber &amp; allies</vh>
<v t="T737"><vh>&lt;&lt; set root to the nearest @file, @silentfile or @rawfile ancestor node &gt;&gt;</vh></v>
<v t="T738"><vh>&lt;&lt; read the file into lines &gt;&gt;</vh></v>
<v t="T739"><vh>&lt;&lt; get n, the line number, from a dialog &gt;&gt;</vh></v>
<v t="T740"><vh>&lt;&lt; count outline lines, setting v,n2,found &gt;&gt;</vh></v>
<v t="T741"><vh>&lt;&lt; set v to the node whose headline is vnodeName &gt;&gt;</vh></v>
<v t="T742"><vh>&lt;&lt; select v and make it visible &gt;&gt;</vh></v>
<v t="T743"><vh>&lt;&lt; put the cursor on line n2 of the body text &gt;&gt;</vh></v>
<v t="T744"><vh>convertLineToVnodeAndLine</vh>
<v t="T745"><vh>&lt;&lt; set delim, leoLine from the @+leo line &gt;&gt;</vh></v>
<v t="T746"><vh>&lt;&lt; scan back to  @+node, setting offset,nodeSentinelLine &gt;&gt;</vh>
<v t="T747"><vh>&lt;&lt; handle delim while scanning backward &gt;&gt;</vh></v>
</v>
<v t="T748"><vh>&lt;&lt; set vnodeName from s &gt;&gt;</vh></v>
</v>
<v t="T749"><vh>skipToMatchingSentinel</vh></v>
</v>
</v>
<v t="T750"><vh>Moves, sorts, promotes, etc. in cloned trees can be _very_ slow.</vh>
<v><vh>Disable undo to test outline move performance</vh></v>
</v>
<v t="T751"><vh>More outline commands 1</vh></v>
<v t="T752"><vh>Outline Navigation 2</vh></v>
<v t="T753"><vh>Outline Navigation commands 3</vh></v>
</v>
</v>
<v><vh>5.0 Graphics in the body pane, per-character fonts</vh>
<v t="T754" a="C"><vh>Fix drawing bug (later)</vh></v>
</v>
<v><vh>Improvements</vh>
<v t="T755"><vh>XSLT links</vh></v>
<v><vh>Important: Later</vh>
<v t="T756"><vh>Script based find-replace</vh></v>
<v t="T757"><vh>Remote access Scott Powell</vh></v>
<v t="T758"><vh>Keep right panes constant when tiling horizontally</vh></v>
<v t="T759"><vh>Allow empty section definitions in @root trees</vh></v>
<v t="T760"><vh>Replace config module with scanPythonText code</vh>
<v t="T761"><vh>@file scanPythonText.py</vh>
<v t="T762"><vh>class Parser</vh>
<v t="T763"><vh>class StringBuffer</vh>
<v t="T764"><vh>__init__</vh></v>
<v t="T765"><vh>__call__</vh></v>
<v t="T766"><vh>__getslice__</vh></v>
</v>
<v t="T767"><vh>class Body</vh>
<v t="T768"><vh>__init__</vh></v>
<v t="T769"><vh>__call__</vh></v>
<v t="T770"><vh>__repr__</vh></v>
</v>
<v t="T771"><vh>__init__</vh></v>
<v t="T772"><vh>readline</vh></v>
<v t="T773"><vh>tokeneater</vh></v>
</v>
<v t="T774"><vh>scanPythonText</vh></v>
</v>
</v>
<v t="T775"><vh>Investigate mind maps</vh></v>
<v><vh>Experiment with Psycho!</vh></v>
</v>
<v t="T776"><vh>Later or never</vh>
<v t="T777"><vh>F key as meta key?</vh></v>
<v t="T778"><vh>do @file http &amp; @file ftp</vh></v>
<v t="T779"><vh>Recording sessions and ways to create clones</vh></v>
<v t="T780"><vh>Add support for Zope, whatever that means</vh></v>
<v t="T781"><vh>Time stamp on @file nodes</vh></v>
<v><vh>regex replace</vh></v>
<v><vh>Idle stuff</vh>
<v><vh>Import code to fix Idle breakpoints</vh></v>
<v><vh>Create leoIdle module to add Leo support to Idle</vh></v>
</v>
<v t="T782"><vh>Pobably never</vh>
<v><vh>Can't do</vh>
<v t="T783"><vh>add mutex so only one copy of Leo will run</vh></v>
</v>
<v><vh>Might do, put don't count on it</vh>
<v><vh>Add slots to Leo classes</vh></v>
<v t="T784"><vh>Big change to Leo</vh></v>
</v>
<v><vh>Won't do</vh>
<v><vh>Fix Borland bugs (v2.8)</vh>
<v t="T785"><vh>Fix javadoc problem</vh></v>
<v t="T786"><vh>Contract All keeps current text pane</vh></v>
<v t="T787"><vh>Null node to clipboard:invalid outl/file </vh></v>
<v t="T788"><vh>Endless tangle with repeated @root file</vh></v>
</v>
<v t="T789"><vh>automatic "tab nanny" and syntax checking of Python code</vh></v>
<v t="T790"><vh>Load derived files directly</vh></v>
<v t="T791"><vh>More compare options</vh></v>
<v t="T792"><vh>Install Linux box</vh>
<v t="T793"><vh>Create Linux test box</vh></v>
</v>
</v>
<v t="T794"><vh>Resolve CVS conflicts command (4.0 makes this obsolete)</vh></v>
</v>
</v>
<v><vh>Things I'd like to see...</vh>
<v><vh>100% pure Python spell checker</vh></v>
<v><vh>HTML rendering in standard Tk Text widget</vh></v>
</v>
</v>
</v>
<v><vh>Known bugs</vh>
<v t="T795"><vh>Linux-only Bugs</vh>
<v t="T796"><vh>Possible webbrowser bug</vh></v>
<v t="T797"><vh>Fix horiz scrollbar bug when tiling horizontally</vh></v>
<v t="T798"><vh>Control-V doesn't work on Linux</vh></v>
</v>
<v t="T799"><vh>Tk bugs</vh>
<v t="T800"><vh>Caps lock affects keyboard shortcuts on Windows</vh></v>
<v t="T801"><vh>Tree problems</vh></v>
</v>
<v t="T802"><vh>Report Tk bugs</vh>
<v t="T803"><vh>Caps lock affects shortcuts</vh></v>
<v><vh>Control-T can't be overridden in canvas text.</vh></v>
<v><vh>(Alt-ctrl = Alt)  ?</vh>
<v t="T804" a="C"><vh>Bug report</vh></v>
</v>
<v t="T805"><vh>Tk code</vh>
<v t="T806"><vh>@file c:/prog/test/leoSplitter.tcl</vh>
<v t="T807"><vh>go</vh></v>
<v t="T808"><vh>createLeo</vh></v>
<v t="T809"><vh>createMenus</vh></v>
<v><vh>createSplitter</vh>
<v t="T810"><vh>createSplitter</vh></v>
<v t="T811"><vh>onGrabSplitterBar</vh></v>
<v t="T812"><vh>onDropSplitterBar</vh></v>
<v t="T813"><vh>onDragSplitterBar</vh></v>
<v t="T814"><vh>divideSplitter</vh></v>
</v>
<v t="T815"><vh>createFindPanel</vh>
<v t="T816"><vh>&lt;&lt; Create the Find and Change panes &gt;&gt;</vh></v>
<v t="T817"><vh>&lt;&lt; Create two columns of checkboxes &gt;&gt;</vh></v>
<v t="T818"><vh>&lt;&lt; Create two rows of buttons &gt;&gt;</vh></v>
</v>
<v t="T819"><vh>createPrefsPanel</vh>
<v t="T820"><vh>&lt;&lt; Create the Global Options frame &gt;&gt;</vh></v>
<v t="T821"><vh>&lt;&lt; Create the Tangle Options frame &gt;&gt;</vh></v>
<v t="T822"><vh>&lt;&lt; Create the Target Language frame &gt;&gt;</vh></v>
</v>
<v t="T823"><vh>createColorPanel</vh></v>
<v t="T824"><vh>createFontPanel</vh>
<v t="T825"><vh>&lt;&lt; create family pane &gt;&gt;</vh></v>
<v t="T826"><vh>&lt;&lt; create style pane &gt;&gt;</vh></v>
<v t="T827"><vh>&lt;&lt; create buttons &gt;&gt;</vh></v>
<v t="T828"><vh>&lt;&lt; create size pane &gt;&gt;</vh></v>
<v t="T829"><vh>&lt;&lt; create sample pane &gt;&gt;</vh></v>
</v>
<v t="T830"><vh>dkffontCreateFontPanel</vh>
<v t="T831"><vh>get_accel</vh></v>
<v t="T832"><vh>get_gap</vh></v>
<v t="T833"><vh>list_families</vh></v>
</v>
<v t="T834"><vh>createComparePanel</vh></v>
<v t="T835"><vh>createWindowWithCursor</vh></v>
<v t="T836"><vh>createWindowWithIcon</vh></v>
<v t="T837"><vh>myFrame</vh></v>
<v t="T838"><vh>tk labeled frames</vh></v>
</v>
<v><vh>tkBugs.tcl</vh>
<v t="T839"><vh>@file c:/prog/test/tkBugs.tcl</vh>
<v t="T840"><vh>canvasBug</vh></v>
<v t="T841"><vh>bindBug</vh></v>
</v>
</v>
</v>
</v>
</v>
</v>
<v t="T842"><vh>to do 3.9.1</vh>
<v t="T843"><vh>@nsf problems</vh></v>
<v t="T844"><vh>Fix reversion</vh></v>
</v>
<v t="T845"><vh>(Project Views)</vh>
<v><vh> Colorizing</vh>
<v><vh> Colorizer tests</vh>
<v t="T846"><vh> Syntax coloring tests</vh></v>
<v t="T847"><vh>(body flashing &amp; recolor)</vh>
<v t="T848" a="C"><vh>tree.select</vh></v>
<v t="T849" a="C"><vh>tree.recolor, recolor_now, recolor_range</vh></v>
</v>
<v><vh>(PHP syntax coloring)</vh>
<v t="T850"><vh>php test</vh></v>
</v>
</v>
<v t="T851"><vh>(colorizing bug)</vh>
<v t="T852"><vh>@file c:\prog\test\Enroll SerNum.c</vh>
<v t="T853"><vh>&lt;&lt; Defines &gt;&gt;</vh></v>
<v><vh>&lt;&lt; Head &gt;&gt;</vh></v>
</v>
</v>
<v t="T854"><vh>(Incremental Syntax Coloring)</vh>
<v><vh> Tests</vh>
<v t="T855"><vh> Long text for tests</vh></v>
<v t="T856"><vh>Dave Hein</vh>
<v t="T857"><vh>Test</vh></v>
</v>
<v t="T858"><vh>Dave Hein2</vh>
<v t="T859"><vh>NewHeadline</vh></v>
</v>
<v t="T860"><vh>Long test</vh></v>
<v t="T861"><vh>problems</vh></v>
<v><vh>Test 1</vh>
<v t="T848" a="C"><vh>tree.select</vh></v>
<v t="T862"><vh>nocolor</vh>
<v t="T848" a="C"><vh>tree.select</vh></v>
</v>
</v>
</v>
</v>
</v>
<v><vh> Commands, utilities &amp; scripts</vh>
<v t="T863"><vh>(top bug)</vh>
<v t="T864" a="C"><vh>frame.doCommand</vh></v>
<v t="T865" a="C"><vh>frame.OnMenuClick (enables and disables all menu items)</vh></v>
<v t="T41" a="C"><vh>top</vh></v>
</v>
<v><vh> File menu</vh>
<v t="T866"><vh>(Open With command)</vh>
<v t="T867" a="C"><vh>&lt;&lt; create the popup menu &gt;&gt;</vh>
<v t="T868"><vh>&lt;&lt; set isAtRoot and isAtFile if v's tree contains @root or @file nodes &gt;&gt;</vh></v>
</v>
<v t="T869" a="C"><vh>app.__init__</vh>
<v t="T522" a="C"><vh>&lt;&lt; define global constants &gt;&gt;</vh></v>
<v t="T870"><vh>&lt;&lt; define global data structures &gt;&gt;</vh></v>
</v>
<v t="T871" a="C"><vh>app.handleOpenTempFiles</vh></v>
<v t="T872" a="C"><vh>createMenuEntries</vh>
<v t="T873"><vh>&lt;&lt; get menu and bind shortcuts &gt;&gt;</vh></v>
</v>
<v t="T874" a="C"><vh>createMenuItemsFromTable</vh></v>
<v t="T875" a="C"><vh>createOpenWithMenuFromTable</vh></v>
<v t="T876" a="C"><vh>sanitize_filename</vh></v>
<v t="T877" a="C"><vh>frame.OnOpenWith</vh>
<v t="T878"><vh>&lt;&lt; set ext based on the present language &gt;&gt;</vh></v>
<v t="T879"><vh>&lt;&lt; set path to the full pathname of a temp file using ext &gt;&gt;</vh></v>
<v t="T880"><vh>&lt;&lt; execute a command to open path &gt;&gt;</vh></v>
</v>
</v>
<v><vh>(Quit safe log and trace)</vh>
<v t="T881" a="C"><vh>tree.destroy</vh></v>
<v t="T882" a="C"><vh>v.destroy</vh></v>
<v t="T883" a="C"><vh>c.destroy</vh></v>
<v t="T884" a="C"><vh>frame.destroy</vh></v>
<v t="T885" a="C"><vh>frame.OnCloseLeoEvent</vh>
<v t="T886"><vh>&lt;&lt; Prompt for change.  Set veto if the user cancels &gt;&gt;</vh>
<v t="T887"><vh>&lt;&lt; Put up a file save dialog; set veto if the user cancels &gt;&gt;</vh></v>
</v>
</v>
<v t="T888" a="C"><vh>frame.OnQuit</vh></v>
<v t="T889" a="C"><vh>app.quit</vh></v>
<v t="T890" a="C"><vh>frame.put, putnl</vh></v>
</v>
<v t="T891"><vh>(Java import problems problems)</vh>
<v t="T892"><vh>Originals</vh>
<v t="T893"><vh>Adventure.java (formatting problems)</vh></v>
<v t="T894"><vh>Bath.java (no @language)</vh></v>
<v t="T895"><vh>HelloDate.java (javascript problems)</vh></v>
</v>
<v t="T896"><vh>New tests</vh>
<v t="T897"><vh>@file Adventure.java</vh>
<v t="T898"><vh>&lt;&lt; Adventure declarations &gt;&gt;</vh></v>
<v t="T899"><vh>interface CanFight</vh></v>
<v t="T900"><vh>interface CanSwim</vh></v>
<v t="T901"><vh>interface CanFly</vh></v>
<v t="T902"><vh>class ActionCharacter</vh>
<v t="T903"><vh>fight</vh></v>
</v>
<v t="T904"><vh>class Hero</vh>
<v t="T905"><vh>swim</vh></v>
<v t="T906"><vh>fly</vh></v>
</v>
<v t="T907"><vh>class Adventure</vh>
<v t="T908"><vh>t</vh></v>
<v t="T909"><vh>u</vh></v>
<v t="T910"><vh>v</vh></v>
<v t="T911"><vh>w</vh></v>
<v t="T912"><vh>main</vh></v>
</v>
</v>
<v t="T913"><vh>@file Bath.java</vh>
<v t="T914"><vh>class Soap</vh>
<v t="T915"><vh>&lt;&lt; class Soap declarations &gt;&gt;</vh></v>
<v t="T916"><vh>Soap</vh></v>
<v t="T917"><vh>toString</vh></v>
</v>
<v t="T918"><vh>class Bath</vh>
<v t="T919"><vh>&lt;&lt; class Bath declarations &gt;&gt;</vh></v>
<v t="T920"><vh>Bath</vh></v>
<v t="T921"><vh>print</vh></v>
<v t="T922"><vh>main</vh></v>
</v>
</v>
<v t="T923"><vh>@file HelloDate.java</vh>
<v t="T924"><vh>&lt;&lt; HelloDate declarations &gt;&gt;</vh></v>
<v t="T925"><vh>class HelloDate</vh>
<v t="T926"><vh>main</vh></v>
</v>
</v>
</v>
<v t="T927" a="C"><vh>skip_braces</vh></v>
<v t="T928" a="C"><vh>find_line_start</vh></v>
</v>
</v>
<v><vh> Edit menu</vh>
<v t="T929"><vh>(Convert Blanks and Convert Tabs)</vh>
<v t="T930" a="C"><vh>updateBodyPane (handles undo)</vh></v>
<v t="T931" a="C"><vh>Whitespace...</vh>
<v t="T932"><vh>computeLeadingWhitespace</vh></v>
<v t="T933" a="C"><vh>computeWidth</vh></v>
<v t="T934" a="C"><vh>get_leading_ws</vh></v>
<v t="T935"><vh>optimizeLeadingWhitespace</vh></v>
<v t="T936"><vh>removeLeadingWhitespace</vh></v>
<v t="T937"><vh>removeTrailingWs</vh></v>
<v t="T938"><vh>skip_leading_ws</vh></v>
<v t="T939"><vh>skip_leading_ws_with_indent</vh></v>
</v>
<v t="T940" a="C"><vh>convertAllBlanks</vh></v>
<v t="T941" a="C"><vh>convertAllTabs</vh></v>
<v t="T942" a="C"><vh>convertTabs</vh></v>
<v t="T943" a="C"><vh>convertBlanks</vh></v>
</v>
<v><vh>(Cut &amp; Paste ) (Middle-button bug reported by Timo)</vh>
<v t="T944"><vh> Paste bug report</vh></v>
<v t="T945"><vh> Test</vh></v>
<v t="T946" a="C"><vh>canPasteOutline</vh></v>
<v t="T947" a="C"><vh>Cut &amp; Paste Outlines</vh>
<v t="T948"><vh>cutOutline</vh></v>
<v t="T949"><vh>copyOutline</vh></v>
<v t="T950"><vh>pasteOutline</vh></v>
</v>
<v><vh>Event handlers</vh>
<v t="T951" a="C"><vh>frame.OnPaste, OnPasteNode, OnPasteFromMenu</vh></v>
<v t="T952" a="C"><vh>frame.OnCopy, OnCopyFromMenu</vh></v>
<v t="T953" a="C"><vh>frame.OnCut, OnCutFrom Menu</vh></v>
</v>
<v t="T954" a="C"><vh>frame.__init__</vh>
<v t="T955" a="C"><vh>&lt;&lt; set the LeoFrame ivars &gt;&gt;</vh></v>
<v t="T956"><vh>&lt;&lt; create the first tree node &gt;&gt;</vh></v>
</v>
<v t="T957" a="C"><vh>Tk.Text selection (utils)</vh>
<v t="T958" a="C"><vh>bound_paragraph</vh></v>
<v t="T959"><vh>getTextSelection</vh></v>
<v t="T960"><vh>getSelectedText</vh></v>
<v t="T961"><vh>setTextSelection</vh></v>
</v>
</v>
<v><vh>(Cut/Paste Crash)</vh>
<v t="T962"><vh>Bug report</vh></v>
<v t="T963" a="C"><vh>os, onl, etc. (leoAtFile)</vh></v>
<v t="T964" a="C"><vh>putDocPart</vh>
<v t="T965"><vh>&lt;&lt; copy words, splitting the line if needed &gt;&gt;</vh></v>
</v>
</v>
<v><vh>(Delete &amp; Revert)</vh>
<v t="T966" a="C"><vh>canRevert</vh></v>
<v t="T967" a="C"><vh>OnRevert</vh></v>
<v t="T968" a="C"><vh>OnDelete</vh></v>
</v>
<v t="T969"><vh>(Execute script )</vh>
<v t="T970" a="C"><vh>OnExecuteScript</vh></v>
</v>
<v><vh>(Find)</vh>
<v t="T971" a="C"><vh>tree.redraw , force_redraw, redraw_now</vh></v>
<v t="T972" a="C"><vh>tree.set...LabelState</vh>
<v t="T973"><vh>&lt;&lt; set editing headline colors &gt;&gt;</vh></v>
<v t="T974"><vh>&lt;&lt; set selected, disabled headline colors &gt;&gt;</vh></v>
<v t="T975"><vh>&lt;&lt; set unselected headline colors &gt;&gt;</vh></v>
</v>
<v t="T976" a="C"><vh>&lt;&lt; Theory of operation of find/change &gt;&gt;</vh></v>
<v t="T977" a="C"><vh>find.__init__ (creates find panel)</vh>
<v t="T978"><vh>&lt;&lt; Initialize the leoFind ivars &gt;&gt;</vh></v>
<v t="T979"><vh>&lt;&lt; Create the Find and Change panes &gt;&gt;</vh></v>
<v t="T980"><vh>&lt;&lt; Create two columns of checkboxes &gt;&gt;</vh></v>
<v t="T981"><vh>&lt;&lt; Create two rows of buttons &gt;&gt;</vh></v>
</v>
<v t="T982" a="C"><vh>find.init</vh>
<v t="T983"><vh>&lt;&lt; set widgets &gt;&gt;</vh></v>
</v>
<v t="T984" a="C"><vh>resetWrap</vh></v>
<v t="T985" a="C"><vh>Top Level Commands</vh>
<v t="T986"><vh>changeButton</vh></v>
<v t="T987"><vh>changeAllButton</vh></v>
<v t="T988"><vh>changeThenFindButton</vh></v>
<v t="T989"><vh>findButton</vh></v>
<v t="T990"><vh>findAllButton</vh></v>
<v t="T991"><vh>changeCommand </vh></v>
<v t="T992"><vh>changeThenFindCommandd</vh></v>
<v t="T993"><vh>findNextCommand</vh></v>
<v t="T994"><vh>fndPreviousCommand</vh></v>
<v t="T995"><vh>setup_button</vh></v>
<v t="T996"><vh>setup_command</vh></v>
</v>
<v t="T997" a="C"><vh>Utilities</vh>
<v t="T998" a="C"><vh>batchChange</vh>
<v t="T999"><vh>&lt;&lt; set the undo head params &gt;&gt;</vh></v>
<v t="T1000"><vh>&lt;&lt; set the undo body typing params &gt;&gt;</vh></v>
</v>
<v t="T1001"><vh>change</vh></v>
<v t="T1002" a="C"><vh>changeAll</vh></v>
<v t="T1003" a="C"><vh>changeSelection</vh></v>
<v t="T1004"><vh>changeThenFind</vh></v>
<v t="T1005"><vh>findAll</vh></v>
<v t="T1006"><vh>findNext</vh></v>
<v t="T1007" a="C"><vh>findNextMatch</vh></v>
<v t="T1008"><vh>selectNextVnode</vh></v>
<v t="T1009"><vh>search</vh>
<v t="T1010"><vh>&lt;&lt; search again after getting stuck going backward &gt;&gt;</vh></v>
<v t="T1011"><vh>&lt;&lt; return if we are passed the wrap point &gt;&gt;</vh></v>
<v t="T1012"><vh>&lt;&lt; test for whole word match &gt;&gt;</vh></v>
</v>
<v t="T1013"><vh>Initializing &amp; finalizing &amp; selecting</vh>
<v t="T1014"><vh>checkArgs</vh></v>
<v t="T1015"><vh>initBatchCommands</vh></v>
<v t="T1016"><vh>initBatchText &amp; initNextText</vh></v>
<v t="T1017"><vh>initInHeadline</vh></v>
<v t="T1018"><vh>initInteractiveCommands</vh></v>
<v t="T1019"><vh>printLine</vh></v>
<v t="T1020"><vh>restore</vh></v>
<v t="T1021"><vh>save</vh></v>
<v t="T1022"><vh>showSuccess</vh></v>
</v>
</v>
</v>
<v t="T1023"><vh>(Reformat Paragraph)</vh>
<v t="T1024"><vh>tests</vh></v>
<v><vh>Utilities...</vh>
<v t="T933" a="C"><vh>computeWidth</vh></v>
<v t="T934" a="C"><vh>get_leading_ws</vh></v>
<v t="T1025" a="C"><vh>skip_non_ws</vh></v>
<v t="T1026" a="C"><vh>wrap_lines</vh>
<v t="T1027"><vh>&lt;&lt; place blank and word on the present line &gt;&gt;</vh></v>
<v t="T1028"><vh>&lt;&lt; place word on a new line &gt;&gt;</vh></v>
</v>
</v>
<v t="T1029" a="C"><vh>getBodyLines</vh></v>
<v t="T958" a="C"><vh>bound_paragraph</vh></v>
<v t="T1030" a="C"><vh>reformatParagraph</vh>
<v t="T1031"><vh>&lt;&lt; Set the new insert at the start of the next paragraph &gt;&gt;</vh></v>
</v>
</v>
<v t="T1032"><vh>(Undo typing)</vh>
<v><vh> Tests</vh>
<v t="T1033"><vh>Unicode test Ã¸, Ã³</vh></v>
<v t="T1034"><vh>test</vh></v>
<v t="T1035"><vh>test2</vh></v>
<v t="T1036"><vh>Long Test</vh></v>
</v>
<v><vh>Main undo code...</vh>
<v t="T1037" a="C"><vh> undo.__init__</vh>
<v t="T1038"><vh>clearUndoState &amp; clearIvars</vh></v>
</v>
<v t="T1039" a="C"><vh>&lt;&lt; redo typing cases &gt;&gt;</vh></v>
<v t="T1040" a="C"><vh>&lt;&lt; undo typing cases &gt;&gt;</vh></v>
<v t="T1041" a="C"><vh>setUndoTypes</vh></v>
<v t="T1042" a="C"><vh>setUndoTypingParams</vh>
<v t="T1043"><vh>&lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;</vh></v>
<v t="T1044" a="C"><vh>&lt;&lt; save undo text info &gt;&gt;</vh></v>
</v>
<v t="T1045" a="C"><vh>undoRedoText</vh>
<v t="T1046"><vh>&lt;&lt; Incrementally update the Tk.Text widget &gt;&gt;</vh></v>
<v t="T1047"><vh>&lt;&lt; Compute the result using v's body text &gt;&gt;</vh></v>
<v t="T1048"><vh>&lt;&lt; Get textResult from the Tk.Text widget &gt;&gt;</vh></v>
<v t="T1049"><vh>&lt;&lt; print mismatch trace &gt;&gt;</vh></v>
</v>
</v>
<v><vh>Statistics...</vh>
<v t="T1044" a="C"><vh>&lt;&lt; save undo text info &gt;&gt;</vh></v>
<v t="T1050" a="C"><vh>OnClose</vh></v>
</v>
<v t="T1051"><vh>Trailing newline problems...</vh>
<v t="T1052" a="C"><vh>setBodyStringOrPane &amp; setBodyTextOrPane</vh></v>
<v t="T1053" a="C"><vh>setTnodeText</vh></v>
<v t="T848" a="C"><vh>tree.select</vh></v>
</v>
</v>
<v t="T1054"><vh>(Undo)</vh>
<v t="T1055" a="C"><vh>c.deleteHeadline</vh></v>
<v t="T1056" a="C"><vh>c.insertHeadline</vh></v>
<v t="T947" a="C"><vh>Cut &amp; Paste Outlines</vh>
<v t="T948"><vh>cutOutline</vh></v>
<v t="T949"><vh>copyOutline</vh></v>
<v t="T950"><vh>pasteOutline</vh></v>
</v>
<v><vh>Find/Change</vh>
<v t="T1003" a="C"><vh>changeSelection</vh></v>
<v t="T1002" a="C"><vh>changeAll</vh></v>
<v t="T998" a="C"><vh>batchChange</vh>
<v t="T999"><vh>&lt;&lt; set the undo head params &gt;&gt;</vh></v>
<v t="T1000"><vh>&lt;&lt; set the undo body typing params &gt;&gt;</vh></v>
</v>
</v>
<v t="T1057" a="C"><vh>Moving, Dragging, Promote, Demote, Sort</vh>
<v t="T1058" a="C"><vh>c.dragAfter</vh></v>
<v t="T1059" a="C"><vh>c.dragToNthChildOf</vh></v>
<v t="T1060" a="C"><vh>c.dragCloneAfter</vh></v>
<v t="T1061" a="C"><vh>c.dragCloneToNthChildOf</vh></v>
<v t="T1062" a="C"><vh>c.sortChildren, sortSiblings</vh>
<v t="T1063"><vh>&lt;&lt; Set the undo info for sortChildren &gt;&gt;</vh></v>
<v t="T1064"><vh>&lt;&lt; Set the undo info for sortSiblings &gt;&gt;</vh></v>
</v>
<v t="T1065"><vh>demote</vh></v>
<v t="T1066"><vh>moveOutlineDown</vh>
<v t="T1067"><vh>&lt;&lt; Move v down &gt;&gt;</vh></v>
</v>
<v t="T1068"><vh>moveOutlineLeft</vh></v>
<v t="T1069"><vh>moveOutlineRight</vh></v>
<v t="T1070"><vh>moveOutlineUp</vh>
<v t="T1071"><vh>&lt;&lt; Move v up &gt;&gt;</vh></v>
</v>
<v t="T1072"><vh>promote</vh></v>
</v>
<v t="T1073" a="C"><vh>u.redo</vh>
<v t="T1074"><vh>&lt;&lt; redo clone cases &gt;&gt;</vh></v>
<v t="T1075"><vh>&lt;&lt; redo delete cases &gt;&gt;</vh></v>
<v t="T1076"><vh>&lt;&lt; redo insert cases &gt;&gt;</vh></v>
<v t="T1077"><vh>&lt;&lt; redo move &amp; drag cases &gt;&gt;</vh></v>
<v t="T1078"><vh>&lt;&lt; redo promote and demote cases &gt;&gt;</vh></v>
<v t="T1079"><vh>&lt;&lt; redo replace cases &gt;&gt;</vh></v>
<v t="T1080"><vh>&lt;&lt; redo sort cases &gt;&gt;</vh></v>
<v t="T1039" a="C"><vh>&lt;&lt; redo typing cases &gt;&gt;</vh></v>
</v>
<v t="T1081" a="C"><vh>State routines...</vh>
<v t="T1082"><vh>canRedo &amp; canUndo</vh></v>
<v t="T1083"><vh>enableMenuItems</vh></v>
<v t="T1084"><vh>getBead, peekBead, setBead</vh></v>
<v t="T1085"><vh>redoMenuName, undoMenuName</vh></v>
<v t="T1086" a="C"><vh>setRedoType, setUndoType</vh></v>
<v t="T1087"><vh>setUndoParams</vh></v>
<v t="T1042" a="C"><vh>setUndoTypingParams</vh>
<v t="T1043"><vh>&lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;</vh></v>
<v t="T1044" a="C"><vh>&lt;&lt; save undo text info &gt;&gt;</vh></v>
</v>
<v t="T1041" a="C"><vh>setUndoTypes</vh></v>
</v>
<v t="T957" a="C"><vh>Tk.Text selection (utils)</vh>
<v t="T958" a="C"><vh>bound_paragraph</vh></v>
<v t="T959"><vh>getTextSelection</vh></v>
<v t="T960"><vh>getSelectedText</vh></v>
<v t="T961"><vh>setTextSelection</vh></v>
</v>
<v t="T1088" a="C"><vh>u.undo</vh>
<v t="T1089"><vh>&lt;&lt; undo clone cases &gt;&gt;</vh></v>
<v t="T1090"><vh>&lt;&lt; undo delete cases &gt;&gt;</vh></v>
<v t="T1091"><vh>&lt;&lt; undo insert cases &gt;&gt;</vh></v>
<v t="T1092"><vh>&lt;&lt; undo move  &amp; drag cases &gt;&gt;</vh></v>
<v t="T1093"><vh>&lt;&lt; undo promote and demote cases &gt;&gt;</vh></v>
<v t="T1094"><vh>&lt;&lt; undo replace cases &gt;&gt;</vh></v>
<v t="T1095"><vh>&lt;&lt; undo sort cases &gt;&gt;</vh></v>
<v t="T1040" a="C"><vh>&lt;&lt; undo typing cases &gt;&gt;</vh></v>
</v>
<v t="T1096" a="C"><vh>undoDemote</vh></v>
<v t="T1097" a="C"><vh>undoPromote</vh></v>
<v t="T930" a="C"><vh>updateBodyPane (handles undo)</vh></v>
</v>
</v>
<v><vh> Outline menu</vh>
<v t="T1098"><vh>(Contract Children)</vh>
<v><vh>test</vh>
<v><vh>a</vh>
<v><vh>b</vh>
<v><vh>NewHeadline</vh></v>
<v><vh>NewHeadline</vh></v>
<v><vh>NewHeadline</vh></v>
</v>
</v>
<v><vh>b</vh>
<v><vh>b1</vh>
<v><vh>NewHeadline</vh></v>
<v><vh>NewHeadline</vh></v>
<v><vh>NewHeadline</vh></v>
</v>
</v>
</v>
<v t="T1099" a="C"><vh>OnContractChildren</vh></v>
<v t="T1100" a="C"><vh>contractSubheads</vh></v>
</v>
</v>
<v><vh> Window menu</vh>
<v t="T1101"><vh>(Control-T switches letters in headlines)</vh>
<v t="T1102" a="C"><vh>tree.OnCtontrolT</vh></v>
<v t="T872" a="C"><vh>createMenuEntries</vh>
<v t="T873"><vh>&lt;&lt; get menu and bind shortcuts &gt;&gt;</vh></v>
</v>
<v t="T1103" a="C"><vh>drawText (bind)</vh>
<v t="T1104"><vh>&lt;&lt; configure the text depending on state &gt;&gt;</vh></v>
</v>
</v>
<v t="T1105"><vh>(Problems opening Python window)</vh>
<v t="T1106" a="C"><vh>OnOpenPythonWindow (Dave Hein)   </vh>
<v t="T1107"><vh>&lt;&lt; open idle in Linux &gt;&gt;</vh></v>
<v t="T1108"><vh>&lt;&lt; open idle in Windows &gt;&gt;</vh></v>
<v t="T1109"><vh>leoPyShellMain</vh></v>
</v>
</v>
</v>
</v>
<v><vh> Configuration</vh>
<v t="T1110"><vh>(font settings bug)(works for me)</vh>
<v t="T1111" a="C"><vh>config.getFontFromParams</vh></v>
<v t="T1112" a="C"><vh>createBothLeoSplitters</vh>
<v t="T1113" a="C"><vh>&lt;&lt; create the body pane &gt;&gt;</vh></v>
<v t="T1114"><vh>&lt;&lt; create the tree pane &gt;&gt;</vh></v>
<v t="T1115"><vh>&lt;&lt; create the log pane &gt;&gt;</vh></v>
</v>
</v>
<v t="T1116"><vh>(problems with find settings)</vh>
<v t="T1117" a="C"><vh>put (basic)(leoFileCommands)</vh></v>
<v t="T1118" a="C"><vh>putFindSettings</vh>
<v t="T1119"><vh>&lt;&lt; put find settings that may exist in leoConfig.txt &gt;&gt;</vh></v>
</v>
<v t="T1120" a="C"><vh>putPrefs</vh>
<v t="T1121"><vh>&lt;&lt; put prefs that may exist in leoConfig.txt &gt;&gt; (putPrefs)</vh>
<v t="T1122"><vh>&lt;&lt; put default directory &gt;&gt;</vh></v>
</v>
</v>
<v t="T1123" a="C"><vh>setConfigFindIvars</vh></v>
<v t="T1124" a="C"><vh>c.setIvarsFromFind</vh></v>
<v t="T1125" a="C"><vh>find.set_ivars</vh></v>
<v t="T977" a="C"><vh>find.__init__ (creates find panel)</vh>
<v t="T978"><vh>&lt;&lt; Initialize the leoFind ivars &gt;&gt;</vh></v>
<v t="T979"><vh>&lt;&lt; Create the Find and Change panes &gt;&gt;</vh></v>
<v t="T980"><vh>&lt;&lt; Create two columns of checkboxes &gt;&gt;</vh></v>
<v t="T981"><vh>&lt;&lt; Create two rows of buttons &gt;&gt;</vh></v>
</v>
<v t="T1126" a="C"><vh>write_LEO_file</vh>
<v t="T1127"><vh>&lt;&lt; create backup file &gt;&gt;</vh></v>
<v t="T1128"><vh>&lt;&lt; delete backup file &gt;&gt;</vh></v>
<v t="T1129"><vh>&lt;&lt; erase filename and rename backupName to fileName &gt;&gt;</vh></v>
</v>
</v>
</v>
<v><vh> Dialogs &amp; panels</vh>
<v t="T1130"><vh>(Color panels)</vh>
<v t="T1131"><vh>&lt;&lt; configure tags &gt;&gt;</vh></v>
<v t="T1132" a="C"><vh>create_labeled_frame</vh></v>
<v t="T1133" a="C"><vh>class leoColorPanel</vh>
<v t="T1134"><vh>colorPanel.__init__</vh></v>
<v t="T1135"><vh>run</vh>
<v t="T1136"><vh>&lt;&lt; create color panel &gt;&gt;</vh></v>
</v>
<v t="T1137"><vh>showColorPicker</vh></v>
<v t="T1138"><vh>showColorName</vh></v>
<v t="T1139" a="C"><vh>colorPanel.onOk, onCancel, onRevert</vh></v>
<v t="T1140"><vh>update</vh></v>
</v>
</v>
<v><vh>(Compare window)</vh>
<v t="T1141" a="C"><vh>OnOpenCompareWindow</vh></v>
<v t="T1142" a="C"><vh>finishCreate</vh></v>
<v t="T1143" a="C"><vh>setIvarsFromWidgets</vh></v>
<v t="T1144" a="C"><vh>compare_files (entry)</vh></v>
<v t="T1145" a="C"><vh>openOutputFile (compare)</vh></v>
</v>
<v><vh>(Hyperlink in About Leo command)</vh>
<v t="T1146" a="C"><vh>OnAbout (version number &amp; date)</vh></v>
<v t="T1147" a="C"><vh>aboutLeo</vh>
<v t="T1148"><vh>onAboutLeoUrl</vh></v>
<v t="T1149"><vh>onAboutLeoEmail</vh></v>
</v>
<v t="T1150" a="C"><vh>tree.getIconImage</vh></v>
</v>
<v t="T1151"><vh>(non-modal dialogs)</vh>
<v t="T1152" a="C"><vh>OnPreferences</vh></v>
<v t="T1153" a="C"><vh>OnColorPanel</vh></v>
<v t="T1154" a="C"><vh>OnFontPanel</vh></v>
<v t="T1155" a="C"><vh>leoFont.onOk, onCancel, onRevert</vh>
<v t="T1156"><vh>&lt;&lt; update the configuration settings &gt;&gt;</vh></v>
</v>
<v t="T1139" a="C"><vh>colorPanel.onOk, onCancel, onRevert</vh></v>
<v t="T1157" a="C"><vh>OnClosePrefsFrame</vh></v>
<v t="T1158" a="C"><vh>prefs.onOK, onCancel, onRevert</vh>
<v t="T1159"><vh>&lt;&lt; restore options &gt;&gt;</vh></v>
</v>
<v t="T955" a="C"><vh>&lt;&lt; set the LeoFrame ivars &gt;&gt;</vh></v>
<v t="T885" a="C"><vh>frame.OnCloseLeoEvent</vh>
<v t="T886"><vh>&lt;&lt; Prompt for change.  Set veto if the user cancels &gt;&gt;</vh>
<v t="T887"><vh>&lt;&lt; Put up a file save dialog; set veto if the user cancels &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v><vh> Directives</vh>
<v t="T1160"><vh>(@comment suppresses all coloring)</vh>
<v t="T1161"><vh>Test</vh>
<v t="T1162"><vh>NewHeadline</vh></v>
</v>
</v>
<v><vh>(@first &amp; @last)</vh>
<v t="T1163"><vh>theory of operation</vh></v>
<v t="T1164" a="C"><vh>atFile.write</vh>
<v t="T1165"><vh>&lt;&lt; initialize &gt;&gt;</vh></v>
<v t="T1166"><vh>&lt;&lt; open the file; return on error &gt;&gt;</vh></v>
<v t="T1167"><vh>&lt;&lt; write then entire @file tree &gt;&gt;</vh>
<v t="T1168" a="C"><vh>&lt;&lt; put all @first lines in root &gt;&gt;</vh></v>
<v t="T1169"><vh>&lt;&lt; put optional @comment sentinel lines &gt;&gt;</vh></v>
<v t="T1170" a="C"><vh>&lt;&lt; put all @last lines in root &gt;&gt;</vh></v>
</v>
<v t="T1171"><vh>&lt;&lt; Warn about @ignored and orphans  &gt;&gt;</vh></v>
<v t="T1172"><vh>&lt;&lt; finish writing &gt;&gt;</vh></v>
</v>
<v t="T1173" a="C"><vh>scanHeader</vh></v>
<v t="T1168" a="C"><vh>&lt;&lt; put all @first lines in root &gt;&gt;</vh></v>
<v t="T1170" a="C"><vh>&lt;&lt; put all @last lines in root &gt;&gt;</vh></v>
</v>
<v t="T1174"><vh>(@path changes)</vh>
<v t="T1175"><vh>test</vh>
<v t="T1176"><vh>@file c:\prog\test\bletch\test.txt</vh></v>
</v>
<v t="T1177" a="C"><vh>getBaseDirectory</vh></v>
</v>
<v><vh>(@quiet)</vh>
<v t="T1178"><vh>Quiet test</vh>
<v t="T1179"><vh>@root c:\prog\test\quietTest.txt</vh>
<v t="T1180"><vh>&lt;&lt; ref1 &gt;&gt;</vh></v>
<v t="T1181"><vh>ref2</vh></v>
<v t="T1182"><vh>&lt;&lt; ref3 &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T1183"><vh>(@raw)</vh>
<v><vh> Test</vh>
<v t="T1184"><vh>@file c:\prog\test\atRawTest.txt</vh>
<v t="T1185"><vh>&lt;&lt; ref &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T1186"><vh>(@rawfile &amp; @silentfile)</vh>
<v><vh> Tests</vh>
<v t="T1187"><vh>@silentfile c:\prog\test\silentFile.txt </vh>
<v t="T1188"><vh>node1</vh></v>
<v t="T1189"><vh>@@ node2 headline  d</vh></v>
<v t="T1190"><vh>node3</vh></v>
</v>
<v t="T1191"><vh>@rawfile c:\prog\test\rawFile.txt </vh>
<v t="T1192"><vh>node1</vh></v>
<v t="T1193"><vh>@@ node2 headline  d</vh></v>
<v t="T1194"><vh>node3</vh></v>
</v>
</v>
</v>
<v><vh>(@tabwidth)</vh>
<v><vh> test</vh>
<v t="T1195"><vh>2</vh>
<v t="T1196"><vh>2, inherited</vh></v>
</v>
<v t="T1197"><vh>4</vh></v>
</v>
</v>
<v t="T1198"><vh>(@url)</vh>
<v><vh> Tests</vh>
<v><vh>@url</vh></v>
<v><vh>@url http://personalpages.tds.net/~edream/front.html</vh></v>
<v><vh>@url http://prdownloads.sourceforge.net/leo/sbooks.chm?download</vh></v>
<v><vh>@url file:c:/prog/test/front.html</vh></v>
<v><vh>@url badurl</vh></v>
</v>
<v t="T1199" a="C"><vh>tree.OnIconDoubleClick (@url)</vh>
<v t="T1200"><vh>&lt;&lt; stop the url after any embedded blank and issue warning &gt;&gt;</vh></v>
<v t="T1201"><vh>&lt;&lt; check the url; return if bad &gt;&gt;</vh></v>
<v t="T1202"><vh>&lt;&lt; pass the url to the web browser &gt;&gt;</vh></v>
</v>
</v>
<v t="T1203"><vh>(create_nonexistent_directories)</vh>
<v t="T1204"><vh>Initial report</vh></v>
<v t="T1205" a="C"><vh>makeAllNonExistentDirectories</vh></v>
<v t="T1206"><vh>## @file c:/prog/test/dir1/dir2/dir3/dirTest.txt</vh></v>
<v t="T1207"><vh>@root c:/prog/test/dir1/dir2/dir3/dirTest.txt</vh></v>
<v t="T1208" a="C"><vh>utils_rename</vh></v>
</v>
<v t="T1209"><vh>(Negative tab widths)</vh>
<v><vh>in leoAtFile</vh>
<v t="T1210" a="C"><vh>putIndent</vh></v>
<v t="T963" a="C"><vh>os, onl, etc. (leoAtFile)</vh></v>
</v>
<v><vh>in leoTangle</vh>
<v t="T1211" a="C"><vh>put_leading_ws</vh></v>
<v t="T1212" a="C"><vh>oblank, oblanks, os, otab, otabs (Tangle)</vh></v>
</v>
</v>
<v t="T1213"><vh>(Nested @others directives )</vh>
<v t="T180" a="C"><vh>Proof that nested @others directives are valid</vh></v>
<v t="T1214"><vh>@file c:/prog/test/atOthersTest.txt</vh>
<v t="T1215"><vh>class a</vh>
<v t="T1216"><vh>a::one</vh></v>
<v t="T1217"><vh>a:two</vh></v>
</v>
<v t="T1218"><vh>class b</vh></v>
<v t="T1219"><vh>b::one</vh></v>
<v t="T1220"><vh>b:two</vh></v>
<v t="T1221"><vh>&lt;&lt; class c &gt;&gt;</vh>
<v t="T1222"><vh>c::f</vh></v>
</v>
<v t="T1223"><vh>&lt;&lt; class d &gt;&gt;</vh>
<v t="T1224"><vh>&lt;&lt; more d &gt;&gt;</vh></v>
<v t="T1225"><vh>&lt;&lt; still more d &gt;&gt;</vh></v>
</v>
</v>
<v t="T1226" a="C"><vh>inAtOthers</vh></v>
<v t="T1227" a="C"><vh>putAtOthers</vh></v>
<v t="T1228" a="C"><vh>putAtOthersChild</vh></v>
</v>
<v><vh>(Nested @others in Import command)</vh>
<v t="T1229" a="C"><vh>&lt;&lt; append Java method reference to parent node &gt;&gt;</vh></v>
<v t="T1230" a="C"><vh>&lt;&lt; create nodes for all defs of the class &gt;&gt;</vh>
<v t="T1231"><vh>&lt;&lt; create parent_vnode &gt;&gt;</vh></v>
</v>
<v t="T1232" a="C"><vh>scanCText</vh>
<v t="T1233"><vh>&lt;&lt; define scanCText vars &gt;&gt;</vh></v>
<v t="T1234"><vh>&lt;&lt; handle # sign &gt;&gt;</vh>
<v t="T1235"><vh>&lt;&lt; create a child node for all #include statements &gt;&gt;</vh></v>
</v>
<v t="T1236"><vh>&lt;&lt; handle open curly bracket in C &gt;&gt; (scans function)</vh>
<v t="T1237"><vh>&lt;&lt; create a declaration node &gt;&gt;</vh></v>
<v t="T1238"><vh>&lt;&lt; append C function/method reference to parent node &gt;&gt;</vh></v>
</v>
<v t="T1239"><vh>&lt;&lt; handle id, class, typedef, struct, union, namespace &gt;&gt;</vh>
<v t="T1240"><vh>&lt;&lt; create children for the namespace &gt;&gt;</vh></v>
<v t="T1241"><vh>&lt;&lt; test for operator keyword &gt;&gt;</vh></v>
</v>
<v t="T1242"><vh>&lt;&lt; handle possible C comments &gt;&gt;</vh></v>
<v t="T1243"><vh>&lt;&lt; handle equal sign in C&gt;&gt;</vh></v>
<v t="T1244"><vh>&lt;&lt; handle open paren in C &gt;&gt;</vh></v>
<v t="T1245"><vh>&lt;&lt; handle semicolon in C &gt;&gt;</vh></v>
<v t="T1246" a="C"><vh>&lt;&lt; Append any unused text to the parent's body text &gt;&gt;</vh></v>
</v>
<v t="T1247" a="C"><vh>scanJavaText</vh>
<v t="T1248"><vh>&lt;&lt; define scanJavaText vars &gt;&gt;</vh></v>
<v t="T1249"><vh>&lt;&lt; handle open curly bracket in Java &gt;&gt;</vh>
<v t="T1250"><vh>&lt;&lt; create a Java declaration node &gt;&gt;</vh></v>
<v t="T1229" a="C"><vh>&lt;&lt; append Java method reference to parent node &gt;&gt;</vh></v>
<v t="T1251"><vh>&lt;&lt; recursively scan the text &gt;&gt;</vh></v>
</v>
<v t="T1252"><vh>&lt;&lt; skip and remember the Java id &gt;&gt;</vh></v>
<v t="T1253"><vh>&lt;&lt; handle possible Java comments &gt;&gt;</vh></v>
<v t="T1254"><vh>&lt;&lt; handle equal sign in Java &gt;&gt;</vh></v>
<v t="T1255"><vh>&lt;&lt; handle open paren in Java &gt;&gt;</vh></v>
<v t="T1256"><vh>&lt;&lt; handle semicolon in Java &gt;&gt;</vh></v>
<v t="T1246" a="C"><vh>&lt;&lt; Append any unused text to the parent's body text &gt;&gt;</vh></v>
</v>
</v>
<v t="T1257"><vh>(REM_ hack and perlpod hacks)</vh>
<v t="T1258"><vh>perlpod test</vh>
<v t="T1259"><vh>perlpod test</vh>
<v t="T1260"><vh>&lt;&lt; ref &gt;&gt;</vh></v>
</v>
</v>
<v t="T1261"><vh>REM test</vh>
<v t="T1262"><vh>@file c:/prog/test/remTest.txt</vh></v>
</v>
</v>
<v t="T1263"><vh>(Suppress @@ sentinel unless leading @ starts a directive)</vh>
<v t="T1264"><vh>@file c:\prog\test\perltest.txt</vh></v>
<v t="T1265" a="C"><vh>&lt;&lt; put @verbatim sentinel if necessary &gt;&gt;</vh></v>
<v t="T657" a="C"><vh>directiveKind</vh></v>
</v>
</v>
<v><vh> Drawing</vh>
<v><vh>(Adjusting tree for large fonts)</vh>
<v t="T1266" a="C"><vh> &lt;&lt; drawing constants &gt;&gt;</vh></v>
<v t="T1267" a="C"><vh>tree.getFont,setFont,setFontFromConfig</vh></v>
<v t="T1268" a="C"><vh>setLineHeight</vh></v>
<v t="T1269" a="C"><vh>tree.__init__</vh></v>
</v>
<v><vh>(Autoscrolling while dragging)</vh>
<v t="T1270" a="C"><vh>tree.findVnodeWithIconId</vh></v>
<v t="T1271" a="C"><vh>tree.OnEndDrag</vh>
<v t="T1272"><vh>&lt;&lt; set vdrag, childFlag &gt;&gt;</vh></v>
</v>
<v t="T1273" a="C"><vh>tree.OnDrag</vh></v>
<v t="T1274" a="C"><vh>tree.OnContinueDrag</vh>
<v t="T1275"><vh>&lt;&lt; expand vdrag and redraw &gt;&gt; (not used)</vh></v>
<v t="T1276"><vh>&lt;&lt; scroll the canvas as needed &gt;&gt;</vh></v>
</v>
</v>
<v><vh>(c.makeVisible &amp; scrolling)</vh>
<v t="T1277"><vh>c.makeVisible</vh></v>
<v t="T1278" a="C"><vh>lastVisible</vh></v>
<v t="T1279" a="C"><vh>tree.yoffset</vh></v>
<v t="T1280" a="C"><vh>tree.expandAllAncestors</vh></v>
<v t="T1281" a="C"><vh>tree.idle_scrollTo</vh></v>
<v t="T971" a="C"><vh>tree.redraw , force_redraw, redraw_now</vh></v>
</v>
<v t="T1282"><vh>(Cleanly opening windows)</vh>
<v t="T1283" a="C"><vh>OnNew</vh></v>
<v t="T1284" a="C"><vh>c.__init__</vh>
<v t="T1285"><vh>&lt;&lt; initialize ivars &gt;&gt;</vh></v>
</v>
<v t="T954" a="C"><vh>frame.__init__</vh>
<v t="T955" a="C"><vh>&lt;&lt; set the LeoFrame ivars &gt;&gt;</vh></v>
<v t="T956"><vh>&lt;&lt; create the first tree node &gt;&gt;</vh></v>
</v>
<v><vh>From leo.py</vh>
<v t="T1286" a="C"><vh>leo.leoOpen</vh>
<v t="T1287" a="C"><vh>&lt;&lt; set the icon image &gt;&gt;</vh></v>
</v>
<v t="T1288" a="C"><vh>leo.run</vh>
<v t="T1287" a="C"><vh>&lt;&lt; set the icon image &gt;&gt;</vh></v>
</v>
</v>
<v><vh>From leoFileCommands</vh>
<v t="T1289" a="C"><vh>getGlobals</vh></v>
</v>
</v>
<v><vh>(Drawing the dirty bits of ancestors and joined nodes)</vh>
<v t="T1290" a="C"><vh>endEditLabel &amp; endEditLabelCommand</vh></v>
<v t="T1291" a="C"><vh>setDirty, setDirtyDeleted &amp; initDirtyBit</vh></v>
<v t="T1292" a="C"><vh>setChanged</vh></v>
<v t="T1293" a="C"><vh>setAncestorAtFileNodeDirty</vh></v>
<v t="T1294" a="C"><vh>setAncestorsOfClonedNodesInTreeDirty</vh></v>
</v>
<v t="T1295" a="C"><vh>(Popup menus)</vh>
<v t="T1103" a="C"><vh>drawText (bind)</vh>
<v t="T1104"><vh>&lt;&lt; configure the text depending on state &gt;&gt;</vh></v>
</v>
<v t="T1296" a="C"><vh>OnHeadlineClick &amp; OnHeadlinePopup</vh></v>
<v t="T1297" a="C"><vh>tree.OnPopup</vh>
<v t="T867" a="C"><vh>&lt;&lt; create the popup menu &gt;&gt;</vh>
<v t="T868"><vh>&lt;&lt; set isAtRoot and isAtFile if v's tree contains @root or @file nodes &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T1298"><vh>(Remember cursor and scrollbar positions in text)</vh>
<v t="T1299" a="C"><vh>t.__init__</vh></v>
<v t="T1113" a="C"><vh>&lt;&lt; create the body pane &gt;&gt;</vh></v>
<v t="T1300" a="C"><vh>c.selectVnode (calls tree.select)</vh></v>
<v t="T1301" a="C"><vh>OnActivate</vh></v>
<v t="T1302" a="C"><vh>loadBodyPaneFromTnode</vh></v>
<v t="T1303" a="C"><vh>Setting body text</vh>
<v t="T1304"><vh>saveBodyPaneToTnode</vh></v>
<v t="T1053" a="C"><vh>setTnodeText</vh></v>
<v t="T1305"><vh>setSelection</vh></v>
</v>
<v t="T1306" a="C"><vh> Selecting &amp; editing (tree)</vh>
<v t="T1307"><vh>abortEditLabelCommand</vh></v>
<v t="T1308"><vh>dimEditLabel, undimEditLabel</vh></v>
<v t="T1309" a="C"><vh>editLabel</vh></v>
<v t="T1290" a="C"><vh>endEditLabel &amp; endEditLabelCommand</vh></v>
<v t="T1280" a="C"><vh>tree.expandAllAncestors</vh></v>
<v t="T1310"><vh>tree.scanForTabWidth</vh>
<v t="T1311"><vh>&lt;&lt; set w and break on @tabwidth &gt;&gt;</vh></v>
</v>
<v t="T848" a="C"><vh>tree.select</vh></v>
<v t="T972" a="C"><vh>tree.set...LabelState</vh>
<v t="T973"><vh>&lt;&lt; set editing headline colors &gt;&gt;</vh></v>
<v t="T974"><vh>&lt;&lt; set selected, disabled headline colors &gt;&gt;</vh></v>
<v t="T975"><vh>&lt;&lt; set unselected headline colors &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T1312"><vh>(Scrollwheel) </vh>
<v t="T1313" a="C"><vh> Event handlers</vh>
<v t="T885" a="C"><vh>frame.OnCloseLeoEvent</vh>
<v t="T886"><vh>&lt;&lt; Prompt for change.  Set veto if the user cancels &gt;&gt;</vh>
<v t="T887"><vh>&lt;&lt; Put up a file save dialog; set veto if the user cancels &gt;&gt;</vh></v>
</v>
</v>
<v t="T1314"><vh>OnActivateBody &amp; OnBodyDoubleClick</vh></v>
<v t="T1315"><vh>OnActivateLeoEvent, OnDeactivateLeoEvent</vh></v>
<v t="T1316"><vh>OnActivateLog</vh></v>
<v t="T1317"><vh>OnActivateTree</vh></v>
<v t="T1318" a="C"><vh>frame.OnControlKeyUp/Down</vh></v>
<v t="T1319"><vh>OnMouseWheel (Tomaz Ficko)</vh></v>
<v t="T1320" a="C"><vh>frame.OnVisibility</vh></v>
</v>
<v t="T1112" a="C"><vh>createBothLeoSplitters</vh>
<v t="T1113" a="C"><vh>&lt;&lt; create the body pane &gt;&gt;</vh></v>
<v t="T1114"><vh>&lt;&lt; create the tree pane &gt;&gt;</vh></v>
<v t="T1115"><vh>&lt;&lt; create the log pane &gt;&gt;</vh></v>
</v>
</v>
<v><vh>(secondary ratio)</vh>
<v t="T955" a="C"><vh>&lt;&lt; set the LeoFrame ivars &gt;&gt;</vh></v>
<v t="T1321" a="C"><vh>fileCommands.open</vh>
<v t="T1322" a="C"><vh>&lt;&lt; Set the default directory &gt;&gt;</vh></v>
</v>
<v t="T1323" a="C"><vh>initialRatios</vh></v>
<v t="T1283" a="C"><vh>OnNew</vh></v>
<v t="T1324" a="C"><vh>OnToggleSplitDirection</vh></v>
<v t="T1325" a="C"><vh>resizePanesToRatio</vh></v>
</v>
<v t="T1326"><vh>(Simplified redraw)</vh>
<v t="T1269" a="C"><vh>tree.__init__</vh></v>
<v t="T971" a="C"><vh>tree.redraw , force_redraw, redraw_now</vh></v>
<v t="T1327" a="C"><vh>beginUpdate</vh></v>
<v t="T1328" a="C"><vh>endUpdate</vh></v>
</v>
<v t="T1329"><vh>(tab_width)</vh>
<v t="T664" a="C"><vh>&lt;&lt; init directive ivars &gt;&gt; (tangle)</vh></v>
<v t="T1330" a="C"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="T1331" a="C"><vh>&lt;&lt; Set ivars &gt;&gt;</vh></v>
<v t="T1332" a="C"><vh>prefs.init</vh>
<v t="T1333"><vh>&lt;&lt; remember values for revert &gt;&gt;</vh></v>
<v t="T1334"><vh>&lt;&lt; set widgets &gt;&gt;</vh></v>
</v>
<v t="T1335" a="C"><vh>prefs.set_ivars &amp; idle_set_ivars &amp; print_ivars</vh>
<v t="T1336"><vh>&lt;&lt; update ivars &gt;&gt;</vh></v>
</v>
<v t="T1284" a="C"><vh>c.__init__</vh>
<v t="T1285"><vh>&lt;&lt; initialize ivars &gt;&gt;</vh></v>
</v>
<v t="T954" a="C"><vh>frame.__init__</vh>
<v t="T955" a="C"><vh>&lt;&lt; set the LeoFrame ivars &gt;&gt;</vh></v>
<v t="T956"><vh>&lt;&lt; create the first tree node &gt;&gt;</vh></v>
</v>
<v t="T1337" a="C"><vh>f.setTabWidth</vh></v>
<v t="T1338"><vh>test</vh></v>
</v>
<v><vh>Control-I and control-H didn't work</vh>
<v t="T1056" a="C"><vh>c.insertHeadline</vh></v>
<v t="T1339" a="C"><vh>editVnode (calls tree.editLabel)</vh></v>
<v t="T1309" a="C"><vh>editLabel	</vh></v>
<v t="T1290" a="C"><vh>endEditLabel &amp; endEditLabelCommand</vh></v>
<v t="T972" a="C"><vh>tree.set...LabelState</vh>
<v t="T973"><vh>&lt;&lt; set editing headline colors &gt;&gt;</vh></v>
<v t="T974"><vh>&lt;&lt; set selected, disabled headline colors &gt;&gt;</vh></v>
<v t="T975"><vh>&lt;&lt; set unselected headline colors &gt;&gt;</vh></v>
</v>
</v>
</v>
<v><vh> Events &amp; Hooks &amp; Bindings</vh>
<v><vh>(Alt-ctrl = Alt) (Looks like tk bug)</vh>
<v t="T804" a="C"><vh>Bug report</vh></v>
</v>
<v t="T1340"><vh>(Auto indent patch) McNab</vh>
<v t="T1341"><vh>test</vh></v>
</v>
<v t="T1342"><vh>(Hooks)</vh>
<v t="T1343" a="C"><vh>enableIdleTimeHook, disableIdleTimeHook, idleTimeHookHandler</vh></v>
<v t="T1344" a="C"><vh>handleLeoHook</vh></v>
<v t="T1284" a="C"><vh>c.__init__</vh>
<v t="T1285"><vh>&lt;&lt; initialize ivars &gt;&gt;</vh></v>
</v>
<v t="T869" a="C"><vh>app.__init__</vh>
<v t="T522" a="C"><vh>&lt;&lt; define global constants &gt;&gt;</vh></v>
<v t="T870"><vh>&lt;&lt; define global data structures &gt;&gt;</vh></v>
</v>
<v><vh>Code containing hooks</vh>
<v t="T889" a="C"><vh>app.quit</vh></v>
<v t="T954" a="C"><vh>frame.__init__</vh>
<v t="T955" a="C"><vh>&lt;&lt; set the LeoFrame ivars &gt;&gt;</vh></v>
<v t="T956"><vh>&lt;&lt; create the first tree node &gt;&gt;</vh></v>
</v>
<v t="T864" a="C"><vh>frame.doCommand</vh></v>
<v t="T865" a="C"><vh>frame.OnMenuClick (enables and disables all menu items)</vh></v>
<v t="T1345" a="C"><vh>frame.OnOpenRecentFile</vh>
<v t="T1346"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="T877" a="C"><vh>frame.OnOpenWith</vh>
<v t="T878"><vh>&lt;&lt; set ext based on the present language &gt;&gt;</vh></v>
<v t="T879"><vh>&lt;&lt; set path to the full pathname of a temp file using ext &gt;&gt;</vh></v>
<v t="T880"><vh>&lt;&lt; execute a command to open path &gt;&gt;</vh></v>
</v>
<v t="T1347" a="C"><vh>frame.OpenWithFileName</vh>
<v t="T1348"><vh>&lt;&lt; make fileName the most recent file of frame &gt;&gt;</vh></v>
</v>
<v t="T1286" a="C"><vh>leo.leoOpen</vh>
<v t="T1287" a="C"><vh>&lt;&lt; set the icon image &gt;&gt;</vh></v>
</v>
<v t="T1288" a="C"><vh>leo.run</vh>
<v t="T1287" a="C"><vh>&lt;&lt; set the icon image &gt;&gt;</vh></v>
</v>
<v t="T1199" a="C"><vh>tree.OnIconDoubleClick (@url)</vh>
<v t="T1200"><vh>&lt;&lt; stop the url after any embedded blank and issue warning &gt;&gt;</vh></v>
<v t="T1201"><vh>&lt;&lt; check the url; return if bad &gt;&gt;</vh></v>
<v t="T1202"><vh>&lt;&lt; pass the url to the web browser &gt;&gt;</vh></v>
</v>
<v t="T848" a="C"><vh>tree.select</vh></v>
</v>
</v>
<v t="T1349"><vh>(memory management)</vh>
<v t="T881" a="C"><vh>tree.destroy</vh></v>
<v t="T882" a="C"><vh>v.destroy</vh></v>
<v t="T1350" a="C"><vh>v.__init__</vh>
<v t="T1351"><vh>&lt;&lt; initialize vnode data members &gt;&gt;</vh></v>
</v>
<v t="T869" a="C"><vh>app.__init__</vh>
<v t="T522" a="C"><vh>&lt;&lt; define global constants &gt;&gt;</vh></v>
<v t="T870"><vh>&lt;&lt; define global data structures &gt;&gt;</vh></v>
</v>
</v>
</v>
<v><vh> Files &amp; Directories</vh>
<v><vh>( Open files in  "wb" mode )</vh>
<v t="T1145" a="C"><vh>openOutputFile (compare)</vh></v>
<v t="T1352" a="C"><vh>update (config)</vh>
<v t="T1353"><vh>&lt;&lt; write recent files section &gt;&gt;</vh></v>
</v>
<v t="T1354" a="C"><vh>flattenOutline</vh></v>
<v t="T1355" a="C"><vh>outlineToWeb</vh></v>
<v t="T1356" a="C"><vh>&lt;&lt; Write s into newFileName &gt;&gt;</vh></v>
<v t="T1357" a="C"><vh>&lt;&lt; open filename to f, or return &gt;&gt;</vh></v>
<v t="T1358" a="C"><vh>tangle.put_all_roots</vh>
<v t="T1359"><vh>&lt;&lt;Get root specific attributes&gt;&gt;</vh></v>
<v t="T1360"><vh>&lt;&lt;Put @first lines&gt;&gt;</vh></v>
<v t="T1361"><vh>&lt;&lt;Write a banner at the start of the output file&gt;&gt;</vh></v>
<v t="T1362"><vh>&lt;&lt; Erase the temporary file &gt;&gt;</vh></v>
</v>
</v>
<v t="T1363"><vh>("ISO-8859-1" )(New file format!)</vh>
<v t="T522" a="C"><vh>&lt;&lt; define global constants &gt;&gt;</vh></v>
<v t="T1364" a="C"><vh>config.__init__</vh>
<v t="T1365"><vh>&lt;&lt; get the default font &gt;&gt;</vh></v>
<v t="T537" a="C"><vh>&lt;&lt; initialize constant ivars, lists &amp; dicts &gt;&gt; (leoConfig)</vh></v>
<v t="T1366"><vh>&lt;&lt; initialize ivars that may be set by config options &gt;&gt;</vh></v>
</v>
<v t="T1367" a="C"><vh>getXmlVersionTag</vh></v>
<v t="T1368" a="C"><vh>putProlog</vh>
<v t="T1369"><vh>&lt;&lt; Put the &lt;?xml...?&gt; line &gt;&gt;</vh></v>
<v t="T1370"><vh>&lt;&lt; Put the optional &lt;?xml-stylesheet...?&gt; line &gt;&gt;</vh></v>
</v>
<v t="T1371" a="C"><vh>getLeoOutline (from clipboard)</vh></v>
<v t="T1372" a="C"><vh>getLeoFile (Leo2)</vh>
<v t="T1373"><vh>&lt;&lt; warn on read-only files &gt;&gt;</vh></v>
<v t="T1374"><vh>&lt;&lt; Create join lists of all vnodes &gt;&gt;</vh></v>
</v>
<v t="T947" a="C"><vh>Cut &amp; Paste Outlines</vh>
<v t="T948"><vh>cutOutline</vh></v>
<v t="T949"><vh>copyOutline</vh></v>
<v t="T950"><vh>pasteOutline</vh></v>
</v>
<v t="T946" a="C"><vh>canPasteOutline</vh></v>
</v>
<v t="T1375"><vh>(@delims bug)</vh>
<v t="T1376"><vh>initial report</vh></v>
<v t="T1377"><vh>second report</vh>
<v t="T1378"><vh>&lt;&lt;intro&gt;&gt;</vh></v>
</v>
<v t="T1379" a="C"><vh>&lt;&lt; scan @delims &gt;&gt;</vh></v>
</v>
<v t="T1380"><vh>(assert 0 in putBodyPart)</vh>
<v t="T1381"><vh>@file c:\prog\test\TestRoar.txt </vh>
<v t="T1382"><vh>&lt;&lt; Raw ON &gt;&gt;</vh></v>
<v t="T1383"><vh>&lt;&lt; Raw OFF &gt;&gt;</vh></v>
<v t="T1384"><vh>&lt;&lt;Stuff&gt;&gt;</vh></v>
</v>
<v t="T657" a="C"><vh>directiveKind</vh></v>
<v t="T1385" a="C"><vh>putBodyPart (removes trailing lines)</vh>
<v t="T1386"><vh>&lt;&lt; put code/doc parts and sentinels &gt;&gt;</vh>
<v t="T1387"><vh>&lt;&lt; initialize lookingForFirst/Last &amp; initialLastDirective &gt;&gt;</vh></v>
<v t="T1388"><vh>&lt;&lt; set lookingForFirst/Last &amp; initialLastDirective &gt;&gt;</vh></v>
<v t="T1389"><vh>&lt;&lt; handle misc directives &gt;&gt;</vh></v>
<v t="T1390"><vh>&lt;&lt; put out the last directives, if any &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T1391"><vh>(atFile read bug)</vh></v>
<v t="T1392"><vh>(Block comment gets doubled in html)</vh>
<v t="T1393"><vh>@file c:\prog\test\htmlTest.txt</vh></v>
<v t="T1394" a="C"><vh>scanDoc</vh>
<v t="T1395"><vh>&lt;&lt; Skip the opening sentinel &gt;&gt;</vh></v>
<v t="T1396"><vh>&lt;&lt; Skip an opening block delim &gt;&gt;</vh></v>
<v t="T1397"><vh>&lt;&lt; set kind, nextLine &gt;&gt;</vh></v>
<v t="T1398"><vh>&lt;&lt; Skip the leading stuff &gt;&gt;</vh></v>
<v t="T1399"><vh>&lt;&lt; Append s to out &gt;&gt;</vh></v>
<v t="T1400"><vh>&lt;&lt; Remove a closing block delim from out &gt;&gt;</vh></v>
</v>
</v>
<v t="T1401"><vh>(Deleting clones does not mark nodes dirty!)</vh>
<v t="T1294" a="C"><vh>setAncestorsOfClonedNodesInTreeDirty</vh></v>
<v t="T1293" a="C"><vh>setAncestorAtFileNodeDirty</vh></v>
<v t="T1291" a="C"><vh>setDirty, setDirtyDeleted &amp; initDirtyBit</vh></v>
<v t="T1062" a="C"><vh>c.sortChildren, sortSiblings</vh>
<v t="T1063"><vh>&lt;&lt; Set the undo info for sortChildren &gt;&gt;</vh></v>
<v t="T1064"><vh>&lt;&lt; Set the undo info for sortSiblings &gt;&gt;</vh></v>
</v>
<v t="T1402" a="C"><vh>v.sortChildren</vh></v>
<v t="T1403" a="C"><vh>moveToNthChildOf</vh></v>
<v t="T1055" a="C"><vh>c.deleteHeadline</vh></v>
</v>
<v t="T1404"><vh>(double @root bug)</vh>
<v t="T1405"><vh>Assert fails</vh></v>
<v t="T1406"><vh>double at-root test (assert fails)</vh></v>
</v>
<v t="T1407"><vh>(Javadoc problem)</vh>
<v t="T1408"><vh>Java test</vh>
<v t="T1409"><vh>MemoryBuffer.java</vh>
<v t="T1410"><vh>&lt;&lt; MemoryBuffer declarations &gt;&gt;</vh></v>
<v t="T1411"><vh>class MemoryBuffer</vh>
<v t="T1412"><vh>&lt;&lt; class MemoryBuffer declarations &gt;&gt;</vh></v>
<v t="T1413"><vh>MemoryBuffer</vh></v>
<v t="T1414"><vh>getHeight</vh></v>
<v t="T1415"><vh>getWidth</vh></v>
<v t="T1416"><vh>negotiateDimensions</vh></v>
</v>
</v>
</v>
</v>
<v t="T1417"><vh>(missing dirty marks ) </vh>
<v t="T1291" a="C"><vh>setDirty, setDirtyDeleted &amp; initDirtyBit</vh></v>
<v t="T1293" a="C"><vh>setAncestorAtFileNodeDirty</vh></v>
</v>
<v t="T1418"><vh>(Partial path name problems)</vh>
<v><vh> Tests</vh>
<v t="T1419"><vh>@file Icons/test.txt</vh></v>
<v t="T1420"><vh>@root Icons/test2.txt</vh></v>
</v>
</v>
<v t="T1421"><vh>(Read cloned @file nodes only once)</vh>
<v t="T1422"><vh> multiple read test</vh>
<v t="T1423" a="C"><vh>@file c:\prog\test\multiple.txt</vh></v>
<v t="T1423" a="C"><vh>@file c:\prog\test\multiple.txt</vh></v>
</v>
</v>
<v t="T1424"><vh>(remarking bad @file nodes dirty)</vh></v>
<v><vh>(remove blank lines)</vh>
<v t="T1425" a="C"><vh>&lt;&lt; scan @+node &gt;&gt; (revised read code)</vh>
<v t="T1426"><vh>&lt;&lt; Set childIndex &gt;&gt;</vh></v>
<v t="T1427"><vh>&lt;&lt; Set cloneIndex &gt;&gt;</vh></v>
<v t="T654" a="C"><vh>&lt;&lt; Set headline and ref &gt;&gt;</vh></v>
<v t="T1428"><vh>&lt;&lt; Check the filename in the sentinel &gt;&gt;</vh></v>
<v t="T1429"><vh>&lt;&lt; look for sentinels that may follow a reference &gt;&gt;</vh></v>
</v>
<v t="T1430" a="C"><vh>putCodePart &amp; allies</vh>
<v t="T1431" a="C"><vh>&lt;&lt; handle the start of a line &gt;&gt;</vh>
<v t="T1432" a="C"><vh>&lt;&lt; handle @others &gt;&gt;</vh></v>
<v t="T1433"><vh>&lt;&lt; handle @raw &gt;&gt;</vh></v>
<v t="T1434"><vh>&lt;&lt; handle @end_raw &gt;&gt;</vh></v>
<v t="T1265" a="C"><vh>&lt;&lt; put @verbatim sentinel if necessary &gt;&gt;</vh></v>
</v>
<v t="T1435"><vh>&lt;&lt; put the line &gt;&gt;</vh>
<v t="T1436"><vh>&lt;&lt; put possible section reference &gt;&gt;</vh></v>
</v>
<v t="T1437"><vh>isSectionName</vh></v>
<v t="T1226" a="C"><vh>inAtOthers</vh></v>
<v t="T1227" a="C"><vh>putAtOthers</vh></v>
<v t="T1228" a="C"><vh>putAtOthersChild</vh></v>
<v t="T1438" a="C"><vh>putRef</vh>
<v t="T1439"><vh>&lt;&lt; Generate the expansion of the reference &gt;&gt;</vh></v>
</v>
</v>
<v t="T963" a="C"><vh>os, onl, etc. (leoAtFile)</vh></v>
<v t="T652" a="C"><vh>sentinelKind</vh></v>
<v t="T650" a="C"><vh>putSentinel (applies cweb hack)</vh></v>
</v>
<v><vh>(Restore access modes when writing)</vh>
<v><vh>atFile</vh>
<v t="T1440"><vh>&lt;&lt; Replace the target with the temp file if different &gt;&gt;</vh></v>
</v>
<v><vh>utils (for tangle)</vh>
<v t="T1441" a="C"><vh>update_file_if_changed</vh></v>
</v>
</v>
<v t="T1442"><vh>(stylesheet element in .leo files)</vh>
<v t="T1443" a="C"><vh>get &amp; match (basic)(leoFileCommands)</vh>
<v t="T1444"><vh>get routines</vh></v>
<v t="T1445"><vh>match routines</vh></v>
</v>
<v t="T1368" a="C"><vh>putProlog</vh>
<v t="T1369"><vh>&lt;&lt; Put the &lt;?xml...?&gt; line &gt;&gt;</vh></v>
<v t="T1370"><vh>&lt;&lt; Put the optional &lt;?xml-stylesheet...?&gt; line &gt;&gt;</vh></v>
</v>
<v t="T1446" a="C"><vh>getXmlStylesheetTag</vh></v>
</v>
<v t="T1447"><vh>(subdirstest problems)</vh>
<v><vh>From subdirtests.leo</vh>
<v><vh>c:/prog/test/new does not exist</vh>
<v t="T1448"><vh>@path new @root test1.txt</vh></v>
<v t="T1449"><vh>@root new/test2.txt</vh></v>
</v>
<v><vh>c:/prog/test does exist</vh>
<v t="T1450"><vh>@path c:/prog/test @root test3.txt</vh></v>
<v t="T1451"><vh>@root c:/prog/test/test4.txt</vh></v>
<v t="T1452"><vh>@root test5.txt</vh></v>
</v>
</v>
<v t="T1453" a="C"><vh>setRootFromText</vh></v>
<v t="T1454" a="C"><vh>get_directives_dict</vh>
<v t="T1455"><vh>&lt;&lt; set dict for @ directives &gt;&gt;</vh></v>
<v t="T1456"><vh>&lt;&lt; set dict["root"] for noweb * chunks &gt;&gt;</vh></v>
</v>
<v t="T1208" a="C"><vh>utils_rename</vh></v>
<v t="T1441" a="C"><vh>update_file_if_changed</vh></v>
<v t="T1177" a="C"><vh>getBaseDirectory</vh></v>
</v>
</v>
<v><vh> Menus</vh>
<v t="T1295" a="C"><vh>(Popup menus)</vh>
<v t="T1103" a="C"><vh>drawText (bind)</vh>
<v t="T1104"><vh>&lt;&lt; configure the text depending on state &gt;&gt;</vh></v>
</v>
<v t="T1296" a="C"><vh>OnHeadlineClick &amp; OnHeadlinePopup</vh></v>
<v t="T1297" a="C"><vh>tree.OnPopup</vh>
<v t="T867" a="C"><vh>&lt;&lt; create the popup menu &gt;&gt;</vh>
<v t="T868"><vh>&lt;&lt; set isAtRoot and isAtFile if v's tree contains @root or @file nodes &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T1457" a="C"><vh>Enabling Menu Items (Commands)</vh>
<v t="T1458"><vh>canContractAllHeadlines</vh></v>
<v t="T1459"><vh>canContractAllSubheads</vh></v>
<v t="T1460"><vh>canContractParent</vh></v>
<v t="T1461"><vh>canContractSubheads</vh></v>
<v t="T1462"><vh>canCutOutline &amp; canDeleteHeadline</vh></v>
<v t="T1463"><vh>canDemote</vh></v>
<v t="T1464"><vh>canExpandAllHeadlines</vh></v>
<v t="T1465"><vh>canExpandAllSubheads</vh></v>
<v t="T1466"><vh>canExpandSubheads</vh></v>
<v t="T1467"><vh>canExtract, canExtractSection &amp; canExtractSectionNames</vh></v>
<v t="T1468"><vh>canFindMatchingBracket</vh></v>
<v t="T1469"><vh>canGoToNextDirtyHeadline</vh></v>
<v t="T1470"><vh>canGoToNextMarkedHeadline</vh></v>
<v t="T1471"><vh>canMarkChangedHeadline</vh></v>
<v t="T1472"><vh>canMarkChangedRoots</vh></v>
<v t="T1473"><vh>canMoveOutlineDown</vh></v>
<v t="T1474"><vh>canMoveOutlineLeft</vh></v>
<v t="T1475"><vh>canMoveOutlineRight</vh></v>
<v t="T1476"><vh>canMoveOutlineUp</vh></v>
<v t="T946" a="C"><vh>canPasteOutline</vh></v>
<v t="T1477"><vh>canPromote</vh></v>
<v t="T966" a="C"><vh>canRevert</vh></v>
<v t="T1478"><vh>canSelect....</vh></v>
<v t="T1479"><vh>canShiftBodyLeft/Right</vh></v>
<v t="T1480"><vh>canSortChildren, canSortSiblings</vh></v>
<v t="T1481"><vh>canUndo &amp; canRedo</vh></v>
<v t="T1482"><vh>canUnmarkAll</vh></v>
</v>
<v t="T1483" a="C"><vh>frame.__del__</vh></v>
<v t="T954" a="C"><vh>frame.__init__</vh>
<v t="T955" a="C"><vh>&lt;&lt; set the LeoFrame ivars &gt;&gt;</vh></v>
<v t="T956"><vh>&lt;&lt; create the first tree node &gt;&gt;</vh></v>
</v>
<v t="T1484" a="C"><vh>Menus, Commands &amp; Shortcuts</vh>
<v t="T1485" a="C"><vh>canonicalizeShortcut</vh>
<v t="T1486"><vh>&lt;&lt; canonicalize the last field &gt;&gt;</vh>
<v t="T1487"><vh>&lt;&lt; define dict of Tk bind names &gt;&gt;</vh></v>
<v t="T1488"><vh>&lt;&lt; define dict of special names &gt;&gt;</vh></v>
</v>
<v t="T1489"><vh>&lt;&lt; set the last field, preserving case &gt;&gt;</vh></v>
<v t="T1490"><vh>&lt;&lt; synthesize the shortcuts from the information &gt;&gt;</vh></v>
</v>
<v t="T1491" a="C"><vh>createMenuBar</vh>
<v t="T1492"><vh>&lt;&lt; create the edit menu &gt;&gt;</vh>
<v t="T1493"><vh>&lt;&lt; create the first top-level edit entries &gt;&gt;</vh></v>
<v t="T1494"><vh>&lt;&lt; create the edit body submenu &gt;&gt;</vh></v>
<v t="T1495"><vh>&lt;&lt; create the edit headline submenu &gt;&gt;</vh></v>
<v t="T1496"><vh>&lt;&lt; create the find submenu &gt;&gt;</vh></v>
<v t="T1497"><vh>&lt;&lt; create the last top-level edit entries &gt;&gt;</vh></v>
</v>
<v t="T1498"><vh>&lt;&lt; create the file menu &gt;&gt;</vh>
<v t="T1499"><vh>&lt;&lt; create the top-level file entries &gt;&gt;</vh></v>
<v t="T1500"><vh>&lt;&lt; create the recent files submenu &gt;&gt;</vh></v>
<v t="T1501"><vh>&lt;&lt; create the read/write submenu &gt;&gt;</vh></v>
<v t="T1502"><vh>&lt;&lt; create the tangle submenu &gt;&gt;</vh></v>
<v t="T1503"><vh>&lt;&lt; create the untangle submenu &gt;&gt;</vh></v>
<v t="T1504"><vh>&lt;&lt; create the import submenu &gt;&gt;</vh></v>
<v t="T1505"><vh>&lt;&lt; create the export submenu &gt;&gt;</vh></v>
</v>
<v t="T1506"><vh>&lt;&lt; create the outline menu &gt;&gt;</vh>
<v t="T1507"><vh>&lt;&lt; create top-level outline menu &gt;&gt;</vh></v>
<v t="T1508"><vh>&lt;&lt; create expand submenu &gt;&gt;</vh></v>
<v t="T1509"><vh>&lt;&lt; create contract submenu &gt;&gt;</vh></v>
<v t="T1510"><vh>&lt;&lt; create move submenu &gt;&gt;</vh></v>
<v t="T1511"><vh>&lt;&lt; create mark submenu &gt;&gt;</vh></v>
<v t="T1512"><vh>&lt;&lt; create goto submenu &gt;&gt;</vh></v>
</v>
<v t="T1513"><vh>&lt;&lt; create the window menu &gt;&gt;</vh></v>
<v t="T1514"><vh>&lt;&lt; create the help menu &gt;&gt;</vh></v>
</v>
<v t="T872" a="C"><vh>createMenuEntries</vh>
<v t="T873"><vh>&lt;&lt; get menu and bind shortcuts &gt;&gt;</vh></v>
</v>
<v t="T1515" a="C"><vh>createRecentFilesMenuItems</vh></v>
<v t="T864" a="C"><vh>frame.doCommand</vh></v>
<v t="T1516" a="C"><vh>get/set/destroyMenu</vh></v>
<v t="T1517"><vh>Menu Command Handlers</vh>
<v t="T1518"><vh>File Menu</vh>
<v t="T1519"><vh>top level</vh>
<v t="T1283" a="C"><vh>OnNew</vh></v>
<v t="T1520"><vh>frame.OnOpen</vh>
<v t="T1521"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="T877" a="C"><vh>frame.OnOpenWith</vh>
<v t="T878"><vh>&lt;&lt; set ext based on the present language &gt;&gt;</vh></v>
<v t="T879"><vh>&lt;&lt; set path to the full pathname of a temp file using ext &gt;&gt;</vh></v>
<v t="T880"><vh>&lt;&lt; execute a command to open path &gt;&gt;</vh></v>
</v>
<v t="T1347" a="C"><vh>frame.OpenWithFileName</vh>
<v t="T1348"><vh>&lt;&lt; make fileName the most recent file of frame &gt;&gt;</vh></v>
</v>
<v t="T1050" a="C"><vh>OnClose</vh></v>
<v t="T1522"><vh>OnSave</vh></v>
<v t="T1523"><vh>OnSaveAs</vh></v>
<v t="T1524"><vh>OnSaveTo</vh></v>
<v t="T967" a="C"><vh>OnRevert</vh></v>
<v t="T888" a="C"><vh>frame.OnQuit</vh></v>
</v>
<v t="T1525" a="C"><vh>Recent Files submenu</vh>
<v t="T1347" a="C"><vh>frame.OpenWithFileName</vh>
<v t="T1348"><vh>&lt;&lt; make fileName the most recent file of frame &gt;&gt;</vh></v>
</v>
<v t="T1345" a="C"><vh>frame.OnOpenRecentFile</vh>
<v t="T1346"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
</v>
<v t="T1526"><vh>Read/Write submenu</vh>
<v t="T1527"><vh>fileCommands.OnReadOutlineOnly</vh></v>
<v t="T1528"><vh>OnReadAtFileNodes</vh></v>
<v t="T1529"><vh>OnWriteOutlineOnly</vh></v>
<v t="T1530"><vh>OnWriteAtFileNodes</vh></v>
</v>
<v t="T1531"><vh>Tangle submenu</vh>
<v t="T1532"><vh>OnTangleAll</vh></v>
<v t="T1533"><vh>OnTangleMarked</vh></v>
<v t="T1534"><vh>OnTangle</vh></v>
</v>
<v t="T1535"><vh>Untangle submenu</vh>
<v t="T1536"><vh>OnUntangleAll</vh></v>
<v t="T1537"><vh>OnUntangleMarked</vh></v>
<v t="T1538"><vh>OnUntangle</vh></v>
</v>
<v t="T1539"><vh>Import&amp;Export submenu</vh>
<v t="T1540" a="C"><vh>OnExportHeadlines</vh></v>
<v t="T1541"><vh>OnFlattenOutline</vh></v>
<v t="T1542"><vh>OnImportAtRoot</vh></v>
<v t="T1543"><vh>OnImportAtFile</vh></v>
<v t="T1544"><vh>OnImportCWEBFiles</vh></v>
<v t="T1545"><vh>OnImportFlattenedOutline</vh></v>
<v t="T1546"><vh>OnImportNowebFiles</vh></v>
<v t="T1547"><vh>OnOutlineToCWEB</vh></v>
<v t="T1548"><vh>OnOutlineToNoweb</vh></v>
<v t="T1549"><vh>OnRemoveSentinels</vh></v>
<v t="T1550"><vh>OnWeave</vh></v>
</v>
</v>
<v t="T1551"><vh>Edit Menu (change to handle log pane too)</vh>
<v t="T1552"><vh>Edit top level</vh>
<v t="T1553"><vh>OnUndo</vh></v>
<v t="T1554"><vh>OnRedo</vh></v>
<v t="T953" a="C"><vh>frame.OnCut, OnCutFrom Menu</vh></v>
<v t="T952" a="C"><vh>frame.OnCopy, OnCopyFromMenu</vh></v>
<v t="T951" a="C"><vh>frame.OnPaste, OnPasteNode, OnPasteFromMenu</vh></v>
<v t="T968" a="C"><vh>OnDelete</vh></v>
<v t="T970" a="C"><vh>OnExecuteScript</vh></v>
<v t="T736" a="C"><vh>OnGoToLineNumber &amp; allies</vh>
<v t="T737"><vh>&lt;&lt; set root to the nearest @file, @silentfile or @rawfile ancestor node &gt;&gt;</vh></v>
<v t="T738"><vh>&lt;&lt; read the file into lines &gt;&gt;</vh></v>
<v t="T739"><vh>&lt;&lt; get n, the line number, from a dialog &gt;&gt;</vh></v>
<v t="T740"><vh>&lt;&lt; count outline lines, setting v,n2,found &gt;&gt;</vh></v>
<v t="T741"><vh>&lt;&lt; set v to the node whose headline is vnodeName &gt;&gt;</vh></v>
<v t="T742"><vh>&lt;&lt; select v and make it visible &gt;&gt;</vh></v>
<v t="T743"><vh>&lt;&lt; put the cursor on line n2 of the body text &gt;&gt;</vh></v>
<v t="T744"><vh>convertLineToVnodeAndLine</vh>
<v t="T745"><vh>&lt;&lt; set delim, leoLine from the @+leo line &gt;&gt;</vh></v>
<v t="T746"><vh>&lt;&lt; scan back to  @+node, setting offset,nodeSentinelLine &gt;&gt;</vh>
<v t="T747"><vh>&lt;&lt; handle delim while scanning backward &gt;&gt;</vh></v>
</v>
<v t="T748"><vh>&lt;&lt; set vnodeName from s &gt;&gt;</vh></v>
</v>
<v t="T749"><vh>skipToMatchingSentinel</vh></v>
</v>
<v t="T1555"><vh>OnSelectAll</vh></v>
<v t="T1154" a="C"><vh>OnFontPanel</vh></v>
<v t="T1153" a="C"><vh>OnColorPanel</vh></v>
<v t="T1556"><vh>OnViewAllCharacters</vh></v>
<v t="T1152" a="C"><vh>OnPreferences</vh></v>
</v>
<v t="T1557"><vh>Edit Body submenu</vh>
<v t="T1558"><vh>OnConvertBlanks &amp; OnConvertAllBlanks</vh></v>
<v t="T1559"><vh>OnConvertTabs &amp; OnConvertAllTabs</vh></v>
<v t="T1560"><vh>OnDedent</vh></v>
<v t="T1561"><vh>OnExtract</vh></v>
<v t="T1562"><vh>OnExtractNames</vh></v>
<v t="T1563"><vh>OnExtractSection</vh></v>
<v t="T1564"><vh>OnFindMatchingBracket</vh>
<v t="T1565"><vh>findMatchingBracket</vh></v>
</v>
<v t="T1566"><vh>OnIndent</vh></v>
<v t="T1567" a="C"><vh>OnInsertGraphicFile</vh></v>
</v>
<v t="T1568"><vh>Edit Headline submenu</vh>
<v t="T1569"><vh>OnEditHeadline</vh></v>
<v t="T1570"><vh>OnEndEditHeadline</vh></v>
<v t="T1571"><vh>OnAbortEditHeadline</vh></v>
</v>
<v t="T1572"><vh>Find submenu (frame methods)</vh>
<v t="T1573"><vh>OnFindPanel</vh></v>
<v t="T1574"><vh>OnFindNext</vh></v>
<v t="T1575"><vh>OnFindPrevious</vh></v>
<v t="T1576"><vh>OnReplace</vh></v>
<v t="T1577"><vh>OnReplaceThenFind</vh></v>
</v>
</v>
<v t="T1578"><vh>Outline Menu</vh>
<v t="T1579"><vh>top level</vh>
<v t="T1580"><vh>OnCutNode</vh></v>
<v t="T1581"><vh>OnCopyNode</vh></v>
<v t="T1582"><vh>OnPasteNodee</vh></v>
<v t="T1583"><vh>OnDeleteNode</vh></v>
<v t="T1584"><vh>OnInsertNode</vh></v>
<v t="T1585"><vh>OnCloneNode</vh></v>
<v t="T1586"><vh>OnSortChildren, OnSortSiblings</vh></v>
</v>
<v t="T1587"><vh>Expand/Contract</vh>
<v t="T1588"><vh>OnContractParent</vh></v>
<v t="T1589"><vh>OnExpandAll</vh></v>
<v t="T1590"><vh>OnExpandAllChildren</vh></v>
<v t="T1591"><vh>OnExpandChildren</vh></v>
<v t="T1592"><vh>OnContractAll</vh></v>
<v t="T1593"><vh>OnContractAllChildren</vh></v>
<v t="T1099" a="C"><vh>OnContractChildren</vh></v>
<v t="T1594"><vh>OnExpandNextLevel</vh></v>
<v t="T1595"><vh>OnExpandToLevel1</vh></v>
<v t="T1596"><vh>OnExpandToLevel2</vh></v>
<v t="T1597"><vh>OnExpandToLevel3</vh></v>
<v t="T1598"><vh>OnExpandToLevel4</vh></v>
<v t="T1599"><vh>OnExpandToLevel5</vh></v>
<v t="T1600"><vh>OnExpandToLevel6</vh></v>
<v t="T1601"><vh>OnExpandToLevel7</vh></v>
<v t="T1602"><vh>OnExpandToLevel8</vh></v>
<v t="T1603"><vh>OnExpandToLevel9</vh></v>
</v>
<v t="T1604"><vh>Move/Select</vh>
<v t="T1605"><vh>OnMoveDownwn</vh></v>
<v t="T1606"><vh>OnMoveLeft</vh></v>
<v t="T1607"><vh>OnMoveRight</vh></v>
<v t="T1608"><vh>OnMoveUp</vh></v>
<v t="T1609"><vh>OnPromote</vh></v>
<v t="T1610"><vh>OnDemote</vh></v>
<v t="T1611"><vh>OnGoPrevVisible</vh></v>
<v t="T1612"><vh>OnGoNextVisible</vh></v>
<v t="T1613"><vh>OnGoBack</vh></v>
<v t="T1614"><vh>OnGoNext</vh></v>
</v>
<v t="T1615"><vh>Mark/Goto</vh>
<v t="T1616"><vh>OnMark</vh></v>
<v t="T1617"><vh>OnMarkSubheads</vh></v>
<v t="T1618"><vh>OnMarkChangedItems</vh></v>
<v t="T1619"><vh>OnMarkChangedRoots</vh></v>
<v t="T1620" a="C"><vh>OnMarkClones</vh></v>
<v t="T1621"><vh>OnUnmarkAll</vh></v>
<v t="T1622"><vh>OnGoToNextMarked</vh></v>
<v t="T1623"><vh>OnGoToNextChanged</vh></v>
<v t="T1624" a="C"><vh>OnGoToNextClone</vh></v>
</v>
</v>
<v t="T1625"><vh>Window Menu</vh>
<v t="T1626"><vh>OnEqualSizedPanes</vh></v>
<v t="T1627"><vh>OnToggleActivePane</vh></v>
<v t="T1324" a="C"><vh>OnToggleSplitDirection</vh></v>
<v t="T1628"><vh>OnCascade</vh></v>
<v t="T1629"><vh>OnMinimizeAll</vh></v>
<v t="T1630"><vh>OnHideLogWindow</vh></v>
<v t="T1141" a="C"><vh>OnOpenCompareWindow</vh></v>
<v t="T1106" a="C"><vh>OnOpenPythonWindow (Dave Hein)</vh>
<v t="T1107"><vh>&lt;&lt; open idle in Linux &gt;&gt;</vh></v>
<v t="T1108"><vh>&lt;&lt; open idle in Windows &gt;&gt;</vh></v>
<v t="T1109"><vh>leoPyShellMain</vh></v>
</v>
</v>
<v t="T1631"><vh>Help Menu</vh>
<v t="T1146" a="C"><vh>OnAbout (version number &amp; date)</vh></v>
<v t="T1632"><vh>OnLeoDocumentation</vh></v>
<v t="T1633"><vh>OnLeoHome</vh></v>
<v t="T1634"><vh>OnLeoHelp</vh>
<v t="T1635"><vh>showProgressBar</vh>
<v t="T1636"><vh>&lt;&lt; create the scale widget &gt;&gt;</vh></v>
</v>
</v>
<v t="T1637"><vh>OnLeoTutorial (version number)</vh></v>
<v t="T1638" a="C"><vh>OnLeoConfig, OnApplyConfig</vh></v>
</v>
</v>
<v t="T1639" a="C"><vh>Menu Convenience Routines</vh>
<v t="T874" a="C"><vh>createMenuItemsFromTable</vh></v>
<v t="T1640" a="C"><vh>createNewMenu</vh></v>
<v t="T875" a="C"><vh>createOpenWithMenuFromTable</vh></v>
<v t="T1641"><vh>deleteMenu</vh></v>
<v t="T1642"><vh>deleteMenuItem</vh></v>
<v t="T1643"><vh>setRealMenuNamesFromTable</vh></v>
</v>
<v t="T1644" a="C"><vh>Menu enablers (Frame)</vh>
<v t="T865" a="C"><vh>frame.OnMenuClick (enables and disables all menu items)</vh></v>
<v t="T1645"><vh>hasSelection</vh></v>
<v t="T1646"><vh>updateFileMenu</vh></v>
<v t="T1647"><vh>updateEditMenu</vh></v>
<v t="T1648"><vh>updateOutlineMenu</vh></v>
</v>
</v>
</v>
<v><vh> Preferences &amp; config settings</vh>
<v><vh>(Apply configuation settings)</vh>
<v t="T1649" a="C"><vh> Splitter stuff</vh>
<v t="T1325" a="C"><vh>resizePanesToRatio</vh></v>
<v t="T1650"><vh>bindBar</vh></v>
<v t="T1112" a="C"><vh>createBothLeoSplitters</vh>
<v t="T1113" a="C"><vh>&lt;&lt; create the body pane &gt;&gt;</vh></v>
<v t="T1114"><vh>&lt;&lt; create the tree pane &gt;&gt;</vh></v>
<v t="T1115"><vh>&lt;&lt; create the log pane &gt;&gt;</vh></v>
</v>
<v t="T1651"><vh>createLeoSplitter</vh></v>
<v t="T1652"><vh>divideAnySplitter</vh></v>
<v t="T1653"><vh>divideLeoSplitter</vh></v>
<v t="T1323" a="C"><vh>initialRatios</vh></v>
<v t="T1654"><vh>onDrag...</vh></v>
<v t="T1655"><vh>placeSplitter</vh></v>
</v>
<v t="T1364" a="C"><vh>config.__init__</vh>
<v t="T1365"><vh>&lt;&lt; get the default font &gt;&gt;</vh></v>
<v t="T537" a="C"><vh>&lt;&lt; initialize constant ivars, lists &amp; dicts &gt;&gt; (leoConfig)</vh></v>
<v t="T1366"><vh>&lt;&lt; initialize ivars that may be set by config options &gt;&gt;</vh></v>
</v>
<v t="T1111" a="C"><vh>config.getFontFromParams</vh></v>
<v t="T1638" a="C"><vh>OnLeoConfig, OnApplyConfig</vh></v>
<v t="T1112" a="C"><vh>createBothLeoSplitters</vh>
<v t="T1113" a="C"><vh>&lt;&lt; create the body pane &gt;&gt;</vh></v>
<v t="T1114"><vh>&lt;&lt; create the tree pane &gt;&gt;</vh></v>
<v t="T1115"><vh>&lt;&lt; create the log pane &gt;&gt;</vh></v>
</v>
<v><vh>Reconfiguration...</vh>
<v t="T1656" a="C"><vh>f.configureBarsFromConfig</vh></v>
<v t="T1657" a="C"><vh>f.reconfigureFromConfig</vh></v>
<v t="T1658" a="C"><vh>f.setBodyFontFromConfig</vh></v>
<v t="T1659" a="C"><vh>f.setLogFontFromConfig</vh></v>
<v t="T1337" a="C"><vh>f.setTabWidth</vh></v>
<v t="T1267" a="C"><vh>tree.getFont,setFont,setFontFromConfig</vh></v>
</v>
</v>
<v t="T1660"><vh>(config precedence)</vh>
<v t="T196" a="C"><vh>7/18 Changed precedence scheme for preferences</vh></v>
</v>
<v><vh>(output_newline option)</vh>
<v t="T1661"><vh>&lt;&lt; Open files.  Set orphan and dirty flags and return on errors &gt;&gt; write</vh></v>
<v t="T1358" a="C"><vh>tangle.put_all_roots</vh>
<v t="T1359"><vh>&lt;&lt;Get root specific attributes&gt;&gt;</vh></v>
<v t="T1360"><vh>&lt;&lt;Put @first lines&gt;&gt;</vh></v>
<v t="T1361"><vh>&lt;&lt;Write a banner at the start of the output file&gt;&gt;</vh></v>
<v t="T1362"><vh>&lt;&lt; Erase the temporary file &gt;&gt;</vh></v>
</v>
<v t="T1662" a="C"><vh>getUserNewline</vh></v>
<v t="T963" a="C"><vh>os, onl, etc. (leoAtFile)</vh></v>
<v t="T1212" a="C"><vh>oblank, oblanks, os, otab, otabs (Tangle)</vh></v>
<v t="T1663" a="C"><vh>Export</vh>
<v t="T1664"><vh>convertCodePartToWeb</vh>
<v t="T1665"><vh>&lt;&lt; put v's headline ref in head_ref&gt;&gt;</vh></v>
<v t="T1666"><vh>&lt;&lt; put name following @root or @file in file_name &gt;&gt;</vh>
<v t="T1667"><vh>&lt;&lt; Set file_name &gt;&gt;</vh></v>
</v>
<v t="T1668"><vh>&lt;&lt; append ref to file_name &gt;&gt;</vh></v>
<v t="T1669"><vh>&lt;&lt; append head_ref &gt;&gt;</vh></v>
</v>
<v t="T1670"><vh>convertDocPartToWeb (handle @ %def)</vh></v>
<v t="T1671"><vh>convertVnodeToWeb</vh>
<v t="T1672"><vh>&lt;&lt; Supply a missing doc part &gt;&gt;</vh></v>
</v>
<v t="T1673"><vh>copyPart</vh></v>
<v t="T1674" a="C"><vh>exportHeadlines</vh></v>
<v t="T1354" a="C"><vh>flattenOutline</vh></v>
<v t="T1355" a="C"><vh>outlineToWeb</vh></v>
<v t="T1675"><vh>removeSentinelsCommand</vh>
<v t="T1676"><vh>&lt;&lt; Read file into s &gt;&gt;</vh></v>
<v t="T1677"><vh>&lt;&lt; set delims from the header line &gt;&gt;</vh></v>
<v t="T1356" a="C"><vh>&lt;&lt; Write s into newFileName &gt;&gt;</vh></v>
</v>
<v t="T1678"><vh>removeSentinelLines</vh>
<v t="T1679"><vh>&lt;&lt; handle possible sentinel &gt;&gt;</vh></v>
</v>
<v t="T1680"><vh>weave</vh>
<v t="T1357" a="C"><vh>&lt;&lt; open filename to f, or return &gt;&gt;</vh></v>
<v t="T1681"><vh>&lt;&lt; write the context of v to f &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T1682"><vh>(text colors)</vh>
<v t="T1103" a="C"><vh>drawText (bind)</vh>
<v t="T1104"><vh>&lt;&lt; configure the text depending on state &gt;&gt;</vh></v>
</v>
<v t="T972" a="C"><vh>tree.set...LabelState</vh>
<v t="T973"><vh>&lt;&lt; set editing headline colors &gt;&gt;</vh></v>
<v t="T974"><vh>&lt;&lt; set selected, disabled headline colors &gt;&gt;</vh></v>
<v t="T975"><vh>&lt;&lt; set unselected headline colors &gt;&gt;</vh></v>
</v>
<v t="T1112" a="C"><vh>createBothLeoSplitters</vh>
<v t="T1113" a="C"><vh>&lt;&lt; create the body pane &gt;&gt;</vh></v>
<v t="T1114"><vh>&lt;&lt; create the tree pane &gt;&gt;</vh></v>
<v t="T1115"><vh>&lt;&lt; create the log pane &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T1683"><vh>(Key handlers)</vh>
<v t="T1684" a="C"><vh>tree.onBodyChanged, onBodyWillChange, OnBodyKey, idle_body_key</vh>
<v t="T1685"><vh>&lt;&lt; replace body text by u &gt;&gt;</vh></v>
<v t="T1686"><vh>&lt;&lt; set removeTrailing &gt;&gt;</vh></v>
<v t="T1687"><vh>&lt;&lt; Do auto indent &gt;&gt; (David McNab)</vh></v>
<v t="T1688"><vh>&lt;&lt; convert leading tab to blanks &gt;&gt;</vh></v>
</v>
<v t="T1689" a="C"><vh>tree.OnHeadlineKey, onHeadlineChanged, idle_head_key</vh>
<v t="T1690"><vh>&lt;&lt; Make sure that the headline text is valid in the encoding &gt;&gt;</vh></v>
</v>
</v>
<v t="T1691"><vh>(scanAllDirectives &amp; scanDirectives)</vh>
<v t="T1692" a="C"><vh>atFile.scanAllDirectives (calls writeError on errors)</vh>
<v t="T1331" a="C"><vh>&lt;&lt; Set ivars &gt;&gt;</vh></v>
<v t="T1693"><vh>&lt;&lt; Set path from @file node &gt;&gt;</vh></v>
<v t="T1694"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="T1695"><vh>&lt;&lt; Test for @header and @noheader &gt;&gt;</vh></v>
<v t="T1696"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="T1697"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
<v t="T1698"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
<v t="T1330" a="C"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="T1699"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="T1700"><vh>&lt;&lt; Set current directory &gt;&gt;</vh></v>
<v t="T1701"><vh>&lt;&lt; Set comment Strings from delims &gt;&gt;</vh></v>
</v>
<v t="T1702" a="C"><vh>tangle.scanAllDirectives</vh>
<v t="T1703"><vh>&lt;&lt; Collect @first attributes &gt;&gt;</vh></v>
<v t="T1704"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="T1705"><vh>&lt;&lt; Test for print modes directives &gt;&gt;</vh></v>
<v t="T1706"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="T1707"><vh>&lt;&lt; compute dir and relative_path from s[k:] &gt;&gt;</vh></v>
<v t="T1708"><vh>&lt;&lt; handle absolute @path &gt;&gt;</vh></v>
</v>
<v t="T1709"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="T1710"><vh>&lt;&lt; Test for @root &gt;&gt;</vh></v>
<v t="T1711"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="T1712"><vh>&lt;&lt; Test for @header and @noheader &gt;&gt;</vh></v>
<v t="T1713"><vh>&lt;&lt; Set self.tangle_directory &gt;&gt;</vh>
<v t="T1714"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
</v>
<v t="T1715" a="C"><vh>scanColorDirectives</vh>
<v t="T1716"><vh>&lt;&lt; Test for @comment or @language &gt;&gt;</vh></v>
<v t="T1717"><vh>&lt;&lt; Test for @root, @root-doc or @root-code &gt;&gt;</vh></v>
</v>
<v t="T1718" a="C"><vh>scanDirectives (utils)</vh>
<v t="T1719"><vh>&lt;&lt; Set local vars &gt;&gt;</vh></v>
<v t="T1720"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="T1721"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="T1722"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="T1723"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
</v>
<v t="T1724"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
</v>
</v>
<v><vh>(Unicode)</vh>
<v><vh> Tests</vh>
<v t="T1725"><vh>@file c:/prog/test/unicodeTest.txt</vh>
<v t="T1726"><vh>New®</vh></v>
</v>
</v>
<v t="T1727" a="C"><vh> Unicode... (utils)</vh>
<v t="T1728"><vh>convertChar/String/ToXMLCharRef</vh></v>
<v t="T1729"><vh>convertStringToUnicode</vh></v>
<v t="T1730"><vh>convertUnicodeToString</vh></v>
<v t="T1731"><vh>es_nonEncodingChar, returnNonEncodingChar</vh></v>
<v t="T1732"><vh>replaceNonEncodingChar/s</vh></v>
</v>
<v><vh>Uses unicode</vh>
<v t="T1125" a="C"><vh>find.set_ivars</vh></v>
<v t="T1052" a="C"><vh>setBodyStringOrPane &amp; setBodyTextOrPane</vh></v>
<v t="T1733" a="C"><vh>setHeadString &amp; initHeadString</vh></v>
<v t="T848" a="C"><vh>tree.select</vh></v>
<v><vh>Output routines...</vh>
<v><vh>leoFileCommands</vh>
<v t="T1117" a="C"><vh>put (basic)(leoFileCommands)</vh></v>
<v t="T1443" a="C"><vh>get &amp; match (basic)(leoFileCommands)</vh>
<v t="T1444"><vh>get routines</vh></v>
<v t="T1445"><vh>match routines</vh></v>
</v>
</v>
<v t="T1734"><vh>leoAtFile</vh>
<v t="T963" a="C"><vh>os, onl, etc. (leoAtFile)</vh></v>
</v>
<v><vh>Tangle</vh>
<v t="T1212" a="C"><vh>oblank, oblanks, os, otab, otabs (Tangle)</vh></v>
</v>
<v><vh>Log</vh>
<v t="T890" a="C"><vh>frame.put, putnl</vh></v>
<v t="T1735" a="C"><vh>es, enl, ecnl</vh></v>
</v>
</v>
</v>
</v>
<v><vh>* Unfinished projects</vh>
<v t="T1736"><vh>(4.0 notes)</vh>
<v t="T1737"><vh>To do</vh></v>
<v t="T1738"><vh>Derived file format</vh></v>
<v t="T1739"><vh>Read code</vh>
<v t="T1740"><vh>readDerivedFile</vh></v>
<v t="T1741"><vh>scanTnodes &amp; allies</vh>
<v t="T1742"><vh>&lt;&lt; set the ivars for this invocation &gt;&gt;</vh></v>
<v t="T1743"><vh>&lt;&lt; define the dispatching table &gt;&gt; (move to ctor)</vh></v>
<v t="T1744"><vh>&lt;&lt; get the next line into s or break &gt;&gt;</vh></v>
<v t="T1745"><vh>&lt;&lt; set kind, nextKind &gt;&gt;</vh></v>
<v t="T1746"><vh>&lt;&lt; Set lineIndent, linep and leading_ws &gt;&gt;</vh></v>
<v t="T1747"><vh>&lt;&lt; use kind to dispatch the sentinel's handler &gt;&gt;</vh></v>
<v t="T1748"><vh>&lt;&lt; handle unexpected end of text &gt;&gt;</vh></v>
<v t="T1749"><vh>Handlers for sentinels...</vh>
<v t="T1750"><vh>doEndSentinel (should make _caller_ return self.lastLines or break)</vh></v>
<v t="T1751"><vh>doNormalLine</vh></v>
<v t="T1752"><vh>doStartAt</vh></v>
<v t="T1753"><vh>doStartComment</vh></v>
<v t="T1754"><vh>doStartDelims</vh></v>
<v t="T1755"><vh>doStartDirective</vh></v>
<v t="T1756"><vh>doStartDoc</vh></v>
<v t="T1757"><vh>doStartLeo</vh></v>
<v t="T1758"><vh>doStartOthers</vh></v>
<v t="T1759"><vh>doStartTnode (old node &amp; body sentinels)</vh>
<v t="T1760"><vh>doStartBody (recursive call)</vh></v>
<v t="T1761"><vh>doStartNode (scan the sentinel)</vh>
<v t="T1762"><vh>&lt;&lt; Set childIndex &gt;&gt;</vh></v>
<v t="T1763"><vh>&lt;&lt; Set cloneIndex &gt;&gt;</vh></v>
<v t="T1764"><vh>&lt;&lt; Set headline and ref &gt;&gt;</vh></v>
<v t="T1765"><vh>&lt;&lt; Check the filename in the sentinel &gt;&gt;</vh></v>
<v t="T1766"><vh>&lt;&lt; look for sentinels that may follow a reference &gt;&gt;</vh></v>
</v>
<v t="T1767"><vh>&lt;&lt; scan the +tnode sentinel line &gt;&gt;</vh></v>
<v t="T1768"><vh>&lt;&lt; scan the following headline &gt;&gt;</vh></v>
</v>
<v t="T1769"><vh>doStartRef</vh></v>
<v t="T1770"><vh>doStartVerbatim</vh></v>
<v t="T1771"><vh>doUnknownSentinel</vh></v>
</v>
</v>
</v>
</v>
<v><vh>(Styled text and graphics)(not ready yet)</vh>
<v t="T1772"><vh>To do</vh>
<v t="T754" a="C"><vh>Fix drawing bug (later)</vh></v>
<v t="T1773"><vh>Create tag list of styles &amp; graphics.  Attach it to tnodes</vh></v>
<v><vh>Read and write tag list to .leo files</vh></v>
<v><vh>Different fonts for different documents.</vh></v>
</v>
<v t="T1301" a="C"><vh>OnActivate</vh></v>
<v t="T1567" a="C"><vh>OnInsertGraphicFile</vh></v>
</v>
<v t="T1774"><vh>(Eliminating blanks lines in derived files)</vh>
<v t="T113" a="C"><vh>Major change to atFile::read code</vh></v>
<v><vh>reading</vh>
<v t="T652" a="C"><vh>sentinelKind</vh></v>
<v t="T1775" a="C"><vh>sentinelName</vh></v>
<v t="T1776" a="C"><vh>&lt;&lt; scan @+others &gt;&gt;</vh></v>
<v t="T1777" a="C"><vh>&lt;&lt; scan @+body &gt;&gt; (revised read code)</vh></v>
<v t="T1425" a="C"><vh>&lt;&lt; scan @+node &gt;&gt; (revised read code)</vh>
<v t="T1426"><vh>&lt;&lt; Set childIndex &gt;&gt;</vh></v>
<v t="T1427"><vh>&lt;&lt; Set cloneIndex &gt;&gt;</vh></v>
<v t="T654" a="C"><vh>&lt;&lt; Set headline and ref &gt;&gt;</vh></v>
<v t="T1428"><vh>&lt;&lt; Check the filename in the sentinel &gt;&gt;</vh></v>
<v t="T1429"><vh>&lt;&lt; look for sentinels that may follow a reference &gt;&gt;</vh></v>
</v>
</v>
<v><vh>writing</vh>
<v t="T1430" a="C"><vh>putCodePart &amp; allies</vh>
<v t="T1431" a="C"><vh>&lt;&lt; handle the start of a line &gt;&gt;</vh>
<v t="T1432" a="C"><vh>&lt;&lt; handle @others &gt;&gt;</vh></v>
<v t="T1433"><vh>&lt;&lt; handle @raw &gt;&gt;</vh></v>
<v t="T1434"><vh>&lt;&lt; handle @end_raw &gt;&gt;</vh></v>
<v t="T1265" a="C"><vh>&lt;&lt; put @verbatim sentinel if necessary &gt;&gt;</vh></v>
</v>
<v t="T1435"><vh>&lt;&lt; put the line &gt;&gt;</vh>
<v t="T1436"><vh>&lt;&lt; put possible section reference &gt;&gt;</vh></v>
</v>
<v t="T1437"><vh>isSectionName</vh></v>
<v t="T1226" a="C"><vh>inAtOthers</vh></v>
<v t="T1227" a="C"><vh>putAtOthers</vh></v>
<v t="T1228" a="C"><vh>putAtOthersChild</vh></v>
<v t="T1438" a="C"><vh>putRef</vh>
<v t="T1439"><vh>&lt;&lt; Generate the expansion of the reference &gt;&gt;</vh></v>
</v>
</v>
<v t="T1438" a="C"><vh>putRef</vh>
<v t="T1439"><vh>&lt;&lt; Generate the expansion of the reference &gt;&gt;</vh></v>
</v>
<v t="T650" a="C"><vh>putSentinel (applies cweb hack)</vh></v>
<v t="T1778" a="C"><vh>putOpenLeoSentinel</vh></v>
<v t="T1432" a="C"><vh>&lt;&lt; handle @others &gt;&gt;</vh></v>
</v>
<v><vh>@others related</vh>
<v t="T1776" a="C"><vh>&lt;&lt; scan @+others &gt;&gt;</vh></v>
<v><vh>writing</vh>
<v t="T1438" a="C"><vh>putRef</vh>
<v t="T1439"><vh>&lt;&lt; Generate the expansion of the reference &gt;&gt;</vh></v>
</v>
<v t="T1431" a="C"><vh>&lt;&lt; handle the start of a line &gt;&gt;</vh>
<v t="T1432" a="C"><vh>&lt;&lt; handle @others &gt;&gt;</vh></v>
<v t="T1433"><vh>&lt;&lt; handle @raw &gt;&gt;</vh></v>
<v t="T1434"><vh>&lt;&lt; handle @end_raw &gt;&gt;</vh></v>
<v t="T1265" a="C"><vh>&lt;&lt; put @verbatim sentinel if necessary &gt;&gt;</vh></v>
</v>
<v t="T1432" a="C"><vh>&lt;&lt; handle @others &gt;&gt;</vh></v>
</v>
</v>
<v t="T1779"><vh>@file c:\prog\test\atOthersTest.txt</vh>
<v t="T1780"><vh>&lt;&lt; ref &gt;&gt;</vh></v>
<v t="T1781"><vh>a</vh></v>
<v t="T1782"><vh>b</vh></v>
</v>
</v>
<v t="T1783"><vh>(Syntax coloring a la jEdit) (do not delete)</vh>
<v t="T1784"><vh>Ideas for dynamic code</vh></v>
<v t="T1785"><vh>New data structures</vh></v>
<v t="T1786"><vh>jEdit modes</vh>
<v t="T1787"><vh>tex.xml</vh>
<v t="T1788"><vh>&lt;&lt; general rules &gt;&gt;</vh></v>
<v t="T1789"><vh>&lt;&lt; math rules &gt;&gt;</vh></v>
</v>
<v t="T1790"><vh>python.xml</vh>
<v t="T1791"><vh>&lt;&lt; remarks &gt;&gt;</vh></v>
<v t="T1792"><vh>&lt;&lt; comments &gt;&gt;</vh></v>
<v t="T1793"><vh>&lt;&lt; literals &gt;&gt;</vh></v>
<v t="T1794"><vh>&lt;&lt; operators &gt;&gt;</vh></v>
<v t="T1795"><vh>&lt;&lt; keywords &gt;&gt;</vh>
<v t="T1796"><vh>&lt;&lt; reserved words &gt;&gt;</vh></v>
<v t="T1797"><vh>&lt;&lt; builtins &gt;&gt;</vh></v>
<v t="T1798"><vh>&lt;&lt; exceptions &gt;&gt;</vh></v>
<v t="T1799"><vh>&lt;&lt; types &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T1800"><vh>jEdit docs</vh>
<v t="T1801"><vh>The Preamble and MODE tag</vh></v>
<v t="T1802"><vh>The PROPS Tag (Leo could ignore these)</vh></v>
<v t="T1803"><vh>The RULES Tag</vh></v>
</v>
</v>
<v t="T1804"><vh>(Speed up moves &amp; deletes)</vh>
<v t="T1805" a="C"><vh>c.checkMoveWithParentWithWarning</vh></v>
<v t="T1806" a="C"><vh>a</vh>
<v t="T1807"><vh>NewHeadline</vh></v>
</v>
<v t="T1806" a="C"><vh>a</vh>
<v t="T1807"><vh>NewHeadline</vh></v>
</v>
</v>
<v t="T1808"><vh>(new vnode code)</vh>
<v t="T1809"><vh>middleware</vh>
<v t="T1810"><vh>create_dependent_trees</vh></v>
<v t="T1811"><vh>destroy_dependent_trees (just unlinks them)</vh></v>
<v t="T1812"><vh>move_dependent_trees_down</vh></v>
<v t="T1813"><vh>move_dependent_trees_left</vh></v>
<v t="T1814"><vh>move_dependent_trees_right</vh></v>
<v t="T1815"><vh>move_dependent_trees_up</vh></v>
</v>
</v>
</v>
<v><vh>** 3.9.1 projects</vh>
<v t="T1816"><vh>(@nosentinelsfile)</vh>
<v t="T1817"><vh> Test</vh>
<v t="T1818"><vh>@nosentinelsfile c:\prog\test\nosentinelstest.txt</vh>
<v t="T1819"><vh>&lt;&lt; ref &gt;&gt;</vh></v>
<v t="T1820"><vh>others</vh></v>
</v>
</v>
<v t="T1821" a="C"><vh>atFile ctor</vh>
<v t="T1822"><vh>&lt;&lt; initialize atFile ivars &gt;&gt;</vh></v>
</v>
<v t="T1164" a="C"><vh>atFile.write</vh>
<v t="T1165"><vh>&lt;&lt; initialize &gt;&gt;</vh></v>
<v t="T1166"><vh>&lt;&lt; open the file; return on error &gt;&gt;</vh></v>
<v t="T1167"><vh>&lt;&lt; write then entire @file tree &gt;&gt;</vh>
<v t="T1168" a="C"><vh>&lt;&lt; put all @first lines in root &gt;&gt;</vh></v>
<v t="T1169"><vh>&lt;&lt; put optional @comment sentinel lines &gt;&gt;</vh></v>
<v t="T1170" a="C"><vh>&lt;&lt; put all @last lines in root &gt;&gt;</vh></v>
</v>
<v t="T1171"><vh>&lt;&lt; Warn about @ignored and orphans  &gt;&gt;</vh></v>
<v t="T1172"><vh>&lt;&lt; finish writing &gt;&gt;</vh></v>
</v>
<v t="T1823" a="C"><vh>atFile.writeAll</vh>
<v t="T1824"><vh>&lt;&lt; Clear all orphan bits &gt;&gt;</vh></v>
</v>
<v t="T650" a="C"><vh>putSentinel (applies cweb hack)</vh></v>
<v t="T1293" a="C"><vh>setAncestorAtFileNodeDirty</vh></v>
</v>
<v t="T1825"><vh>(@root starts in code mode)</vh>
<v t="T1826"><vh> Tests</vh>
<v t="T1827"><vh>@root rootcode.txt</vh>
<v t="T1828"><vh>&lt;&lt; ref &gt;&gt;</vh></v>
<v t="T1829"><vh>ref2</vh></v>
<v t="T1830"><vh>&lt;&lt; ref3 &gt;&gt;</vh></v>
</v>
<v t="T1831"><vh>@root rootdoc.txt</vh>
<v t="T1832"><vh>&lt;&lt; ref &gt;&gt;</vh></v>
</v>
</v>
<v t="T671" a="C"><vh>skip_body</vh>
<v t="T672"><vh>The interface between tangle and untangle</vh>
<v t="T673"><vh>&lt;&lt; Define a section containing only an @doc part &gt;&gt;</vh></v>
<v t="T674"><vh>&lt;&lt; Define a section for a leading code part &gt;&gt;</vh></v>
<v t="T675"><vh>&lt;&lt; Scan and define a section definition &gt;&gt;</vh></v>
<v t="T676"><vh>&lt;&lt; Scan and define an @code defininition &gt;&gt;</vh></v>
<v t="T677"><vh>&lt;&lt; Scan and define a root section &gt;&gt;</vh></v>
</v>
</v>
<v t="T1833" a="C"><vh>skip_doc</vh></v>
<v t="T670" a="C"><vh>handle_newline</vh></v>
</v>
<v><vh>(Allowing collapsed XML tags)</vh>
<v t="T1834"><vh>Bug report</vh></v>
<v t="T1835" a="C"><vh>Reading</vh>
<v t="T1836"><vh>createVnode</vh></v>
<v t="T1837"><vh>finishPaste (creating join lists could be a problem)</vh>
<v t="T1838"><vh>&lt;&lt; Create join lists of all pasted vnodes &gt;&gt;</vh></v>
<v t="T1839"><vh>&lt;&lt; Recompute clone bits for pasted vnodes &gt;&gt;</vh></v>
</v>
<v t="T1840"><vh>get routines</vh>
<v t="T1443" a="C"><vh>get &amp; match (basic)(leoFileCommands)</vh>
<v t="T1444"><vh>get routines</vh></v>
<v t="T1445"><vh>match routines</vh></v>
</v>
<v t="T1841"><vh>getClipboardHeader</vh></v>
<v t="T1842"><vh>getCloneWindows</vh></v>
<v t="T1843"><vh>getEscapedString</vh></v>
<v t="T1844" a="C"><vh>getFindPanelSettings</vh>
<v t="T1845"><vh>&lt;&lt; Set defaults of all flags &gt;&gt;</vh></v>
</v>
<v t="T1289" a="C"><vh>getGlobals</vh></v>
<v t="T1372" a="C"><vh>getLeoFile (Leo2)</vh>
<v t="T1373"><vh>&lt;&lt; warn on read-only files &gt;&gt;</vh></v>
<v t="T1374"><vh>&lt;&lt; Create join lists of all vnodes &gt;&gt;</vh></v>
</v>
<v t="T1846"><vh>getLeoHeader</vh></v>
<v t="T1371" a="C"><vh>getLeoOutline (from clipboard)</vh></v>
<v t="T1847"><vh>getPosition</vh></v>
<v t="T580" a="C"><vh>getPrefs</vh>
<v t="T536" a="C"><vh>&lt;&lt; check for syntax coloring prefs &gt;&gt; (getPrefs)</vh></v>
</v>
<v t="T1848"><vh>getSize</vh></v>
<v t="T1849"><vh>getT</vh></v>
<v t="T1850"><vh>getTnode</vh></v>
<v t="T1851"><vh>getTnodes</vh></v>
<v t="T1852"><vh>getVnode (Leo2)</vh>
<v t="T1853"><vh>&lt;&lt; Handle vnode attribute bits  &gt;&gt;</vh></v>
</v>
<v t="T1854"><vh>getVnodes</vh></v>
<v t="T1446" a="C"><vh>getXmlStylesheetTag</vh></v>
<v t="T1367" a="C"><vh>getXmlVersionTag</vh></v>
<v t="T1855"><vh>skipWs</vh></v>
<v t="T1856"><vh>skipWsAndNl</vh></v>
</v>
<v t="T1857"><vh>newTnode</vh></v>
<v t="T1858"><vh>readAtFileNodes</vh></v>
<v t="T1859"><vh>fileCommands.readOutlineOnly</vh>
<v t="T1322" a="C"><vh>&lt;&lt; Set the default directory &gt;&gt;</vh></v>
</v>
<v t="T1321" a="C"><vh>fileCommands.open</vh>
<v t="T1322" a="C"><vh>&lt;&lt; Set the default directory &gt;&gt;</vh></v>
</v>
<v t="T1860"><vh>xmlUnescape</vh></v>
</v>
</v>
<v t="T1861"><vh>(Drag &amp; Drop)(Control-drag to clone)</vh>
<v><vh> Drag tests</vh>
<v><vh>a</vh></v>
<v><vh>b</vh>
<v><vh>b1</vh></v>
<v><vh>b2</vh></v>
</v>
<v><vh>c</vh></v>
<v><vh>d</vh></v>
</v>
<v><vh>Commands routines...</vh>
<v t="T1805" a="C"><vh>c.checkMoveWithParentWithWarning</vh></v>
<v t="T1862" a="C"><vh>c.clone </vh></v>
<v t="T1058" a="C"><vh>c.dragAfter</vh></v>
<v t="T1060" a="C"><vh>c.dragCloneAfter</vh></v>
<v t="T1061" a="C"><vh>c.dragCloneToNthChildOf</vh></v>
<v t="T1059" a="C"><vh>c.dragToNthChildOf</vh></v>
</v>
<v><vh>Frame routines...</vh>
<v t="T954" a="C"><vh>frame.__init__</vh>
<v t="T955" a="C"><vh>&lt;&lt; set the LeoFrame ivars &gt;&gt;</vh></v>
<v t="T956"><vh>&lt;&lt; create the first tree node &gt;&gt;</vh></v>
</v>
<v t="T1318" a="C"><vh>frame.OnControlKeyUp/Down</vh></v>
</v>
<v><vh>Tree routines...</vh>
<v t="T1269" a="C"><vh>tree.__init__</vh></v>
<v t="T1863" a="C"><vh>tree.drawIcon (tag_bind))</vh></v>
<v t="T1270" a="C"><vh>tree.findVnodeWithIconId</vh></v>
<v t="T1281" a="C"><vh>tree.idle_scrollTo</vh></v>
<v t="T1864" a="C"><vh>tree.numberOfVisibleNodes</vh></v>
<v t="T1274" a="C"><vh>tree.OnContinueDrag</vh>
<v t="T1275"><vh>&lt;&lt; expand vdrag and redraw &gt;&gt; (not used)</vh></v>
<v t="T1276"><vh>&lt;&lt; scroll the canvas as needed &gt;&gt;</vh></v>
</v>
<v t="T1273" a="C"><vh>tree.OnDrag</vh></v>
<v t="T1271" a="C"><vh>tree.OnEndDrag</vh>
<v t="T1272"><vh>&lt;&lt; set vdrag, childFlag &gt;&gt;</vh></v>
</v>
<v t="T1865" a="C"><vh>tree.OnIconClick</vh></v>
<v t="T1279" a="C"><vh>tree.yoffset</vh></v>
</v>
<v t="T1073" a="C"><vh>u.redo</vh>
<v t="T1074"><vh>&lt;&lt; redo clone cases &gt;&gt;</vh></v>
<v t="T1075"><vh>&lt;&lt; redo delete cases &gt;&gt;</vh></v>
<v t="T1076"><vh>&lt;&lt; redo insert cases &gt;&gt;</vh></v>
<v t="T1077"><vh>&lt;&lt; redo move &amp; drag cases &gt;&gt;</vh></v>
<v t="T1078"><vh>&lt;&lt; redo promote and demote cases &gt;&gt;</vh></v>
<v t="T1079"><vh>&lt;&lt; redo replace cases &gt;&gt;</vh></v>
<v t="T1080"><vh>&lt;&lt; redo sort cases &gt;&gt;</vh></v>
<v t="T1039" a="C"><vh>&lt;&lt; redo typing cases &gt;&gt;</vh></v>
</v>
<v t="T1088" a="C"><vh>u.undo</vh>
<v t="T1089"><vh>&lt;&lt; undo clone cases &gt;&gt;</vh></v>
<v t="T1090"><vh>&lt;&lt; undo delete cases &gt;&gt;</vh></v>
<v t="T1091"><vh>&lt;&lt; undo insert cases &gt;&gt;</vh></v>
<v t="T1092"><vh>&lt;&lt; undo move  &amp; drag cases &gt;&gt;</vh></v>
<v t="T1093"><vh>&lt;&lt; undo promote and demote cases &gt;&gt;</vh></v>
<v t="T1094"><vh>&lt;&lt; undo replace cases &gt;&gt;</vh></v>
<v t="T1095"><vh>&lt;&lt; undo sort cases &gt;&gt;</vh></v>
<v t="T1040" a="C"><vh>&lt;&lt; undo typing cases &gt;&gt;</vh></v>
</v>
<v t="T1866" a="C"><vh>v.clone</vh></v>
</v>
<v><vh>(Expanding &amp; contracting leaks memory)</vh>
<v t="T1867"><vh> Bug report</vh></v>
<v t="T1269" a="C"><vh>tree.__init__</vh></v>
<v t="T971" a="C"><vh>tree.redraw , force_redraw, redraw_now</vh></v>
<v t="T864" a="C"><vh>frame.doCommand</vh></v>
<v t="T1868" a="C"><vh>collectGarbage</vh></v>
<v t="T1869" a="C"><vh>Drawing</vh>
<v t="T1870"><vh>About drawing and updating</vh></v>
<v t="T1327" a="C"><vh>beginUpdate</vh></v>
<v t="T1871" a="C"><vh>drawBox (tag_bind)</vh></v>
<v t="T1872"><vh>drawNode</vh></v>
<v t="T1103" a="C"><vh>drawText (bind)</vh>
<v t="T1104"><vh>&lt;&lt; configure the text depending on state &gt;&gt;</vh></v>
</v>
<v t="T1873"><vh>drawTree</vh>
<v t="T1874"><vh>&lt;&lt; draw vertical line &gt;&gt;</vh></v>
</v>
<v t="T1328" a="C"><vh>endUpdate</vh></v>
<v t="T1875"><vh>headWidth</vh></v>
<v t="T1876"><vh>hideAllChildren</vh></v>
<v t="T1877"><vh>hideNode (no longer used)</vh></v>
<v t="T1878"><vh>hideTree (no longer used)</vh></v>
<v t="T1278" a="C"><vh>lastVisible</vh></v>
<v t="T1268" a="C"><vh>setLineHeight</vh></v>
<v t="T1863" a="C"><vh>tree.drawIcon (tag_bind))</vh></v>
<v t="T1267" a="C"><vh>tree.getFont,setFont,setFontFromConfig</vh></v>
<v t="T1150" a="C"><vh>tree.getIconImage</vh></v>
<v t="T1281" a="C"><vh>tree.idle_scrollTo</vh></v>
<v t="T1864" a="C"><vh>tree.numberOfVisibleNodes</vh></v>
<v t="T849" a="C"><vh>tree.recolor, recolor_now, recolor_range</vh></v>
<v t="T971" a="C"><vh>tree.redraw , force_redraw, redraw_now</vh></v>
<v t="T1279" a="C"><vh>tree.yoffset</vh></v>
</v>
<v><vh>Calling bind or tag_bind</vh>
<v t="T1871" a="C"><vh>drawBox (tag_bind)</vh></v>
<v t="T1103" a="C"><vh>drawText (bind)</vh>
<v t="T1104"><vh>&lt;&lt; configure the text depending on state &gt;&gt;</vh></v>
</v>
<v t="T1863" a="C"><vh>tree.drawIcon (tag_bind))</vh></v>
</v>
<v t="T1879" a="C"><vh>tree.deleteBindings</vh></v>
</v>
<v t="T1880"><vh>(Export headline command)</vh>
<v t="T1540" a="C"><vh>OnExportHeadlines</vh></v>
<v t="T1674" a="C"><vh>exportHeadlines</vh></v>
</v>
<v><vh>(Find in current node only option)</vh>
<v><vh>Test</vh>
<v t="T1881"><vh>Search only this node in "node only" mode</vh>
<v t="T1882"><vh>NewHeadline</vh></v>
</v>
<v t="T1883"><vh>NewHeadline</vh></v>
</v>
<v t="T1123" a="C"><vh>setConfigFindIvars</vh></v>
<v t="T1884" a="C"><vh>setCommandsFindIvars</vh></v>
<v t="T977" a="C"><vh>find.__init__ (creates find panel)</vh>
<v t="T978"><vh>&lt;&lt; Initialize the leoFind ivars &gt;&gt;</vh></v>
<v t="T979"><vh>&lt;&lt; Create the Find and Change panes &gt;&gt;</vh></v>
<v t="T980"><vh>&lt;&lt; Create two columns of checkboxes &gt;&gt;</vh></v>
<v t="T981"><vh>&lt;&lt; Create two rows of buttons &gt;&gt;</vh></v>
</v>
<v t="T1844" a="C"><vh>getFindPanelSettings</vh>
<v t="T1845"><vh>&lt;&lt; Set defaults of all flags &gt;&gt;</vh></v>
</v>
<v t="T1118" a="C"><vh>putFindSettings</vh>
<v t="T1119"><vh>&lt;&lt; put find settings that may exist in leoConfig.txt &gt;&gt;</vh></v>
</v>
<v t="T1007" a="C"><vh>findNextMatch</vh></v>
</v>
<v t="T1885"><vh>(Improved Leo Icon)</vh>
<v t="T1886" a="C"><vh>attachLeoIcon &amp; allies</vh>
<v t="T1887"><vh>createLeoIcon</vh></v>
<v t="T1888"><vh>onVisibility</vh></v>
</v>
<v t="T1320" a="C"><vh>frame.OnVisibility</vh></v>
<v t="T954" a="C"><vh>frame.__init__</vh>
<v t="T955" a="C"><vh>&lt;&lt; set the LeoFrame ivars &gt;&gt;</vh></v>
<v t="T956"><vh>&lt;&lt; create the first tree node &gt;&gt;</vh></v>
</v>
</v>
<v><vh>(Mark clones &amp; Go To Next Clone)</vh>
<v t="T1620" a="C"><vh>OnMarkClones</vh></v>
<v t="T1624" a="C"><vh>OnGoToNextClone</vh></v>
<v t="T1889" a="C"><vh>markClones</vh></v>
<v t="T1890" a="C"><vh>goToNextClone</vh></v>
</v>
<v><vh>(Options for @file &amp; @root)</vh>
<v t="T1891"><vh>Tests</vh>
<v t="T1892"><vh>@file-nosent c:\prog\test\filenosent.txt</vh>
<v t="T1893"><vh>&lt;&lt; ref &gt;&gt;</vh></v>
</v>
<v t="T1894"><vh>@file-noref c:\prog\test\filenoref.txt</vh>
<v t="T1895"><vh>&lt;&lt; ref &gt;&gt;</vh></v>
</v>
<v t="T1896"><vh>@file-asis c:\prog\test\fileasis.txt</vh>
<v t="T1897"><vh>&lt;&lt; ref &gt;&gt;</vh></v>
</v>
</v>
<v t="T1898" a="C"><vh>Comparisons (vnode)</vh>
<v t="T1899"><vh>afterHeadlineMatch</vh></v>
<v t="T1900"><vh>at/../NodeName</vh></v>
<v t="T1901"><vh>isAt/../Node</vh></v>
<v t="T1902"><vh>isAtIgnoreNode</vh></v>
<v t="T1903"><vh>isAtOthersNode</vh></v>
<v t="T1904"><vh>matchHeadline</vh></v>
</v>
<v t="T1905" a="C"><vh>scanAtFileOptions</vh>
<v t="T1906"><vh>&lt;&lt; scan another @file option &gt;&gt;</vh></v>
</v>
<v t="T1907" a="C"><vh>scanAtRootOptions</vh>
<v t="T1908"><vh>&lt;&lt; scan another @root option &gt;&gt;</vh></v>
</v>
<v t="T1453" a="C"><vh>setRootFromText</vh></v>
<v t="T1909" a="C"><vh>setRootFromHeadline</vh></v>
</v>
<v t="T1910"><vh>(problems importing .py file)</vh>
<v t="T1911"><vh>original file</vh></v>
</v>
<v t="T1912"><vh>(Recent Files problems)</vh>
<v t="T1491" a="C"><vh>createMenuBar</vh>
<v t="T1492"><vh>&lt;&lt; create the edit menu &gt;&gt;</vh>
<v t="T1493"><vh>&lt;&lt; create the first top-level edit entries &gt;&gt;</vh></v>
<v t="T1494"><vh>&lt;&lt; create the edit body submenu &gt;&gt;</vh></v>
<v t="T1495"><vh>&lt;&lt; create the edit headline submenu &gt;&gt;</vh></v>
<v t="T1496"><vh>&lt;&lt; create the find submenu &gt;&gt;</vh></v>
<v t="T1497"><vh>&lt;&lt; create the last top-level edit entries &gt;&gt;</vh></v>
</v>
<v t="T1498"><vh>&lt;&lt; create the file menu &gt;&gt;</vh>
<v t="T1499"><vh>&lt;&lt; create the top-level file entries &gt;&gt;</vh></v>
<v t="T1500"><vh>&lt;&lt; create the recent files submenu &gt;&gt;</vh></v>
<v t="T1501"><vh>&lt;&lt; create the read/write submenu &gt;&gt;</vh></v>
<v t="T1502"><vh>&lt;&lt; create the tangle submenu &gt;&gt;</vh></v>
<v t="T1503"><vh>&lt;&lt; create the untangle submenu &gt;&gt;</vh></v>
<v t="T1504"><vh>&lt;&lt; create the import submenu &gt;&gt;</vh></v>
<v t="T1505"><vh>&lt;&lt; create the export submenu &gt;&gt;</vh></v>
</v>
<v t="T1506"><vh>&lt;&lt; create the outline menu &gt;&gt;</vh>
<v t="T1507"><vh>&lt;&lt; create top-level outline menu &gt;&gt;</vh></v>
<v t="T1508"><vh>&lt;&lt; create expand submenu &gt;&gt;</vh></v>
<v t="T1509"><vh>&lt;&lt; create contract submenu &gt;&gt;</vh></v>
<v t="T1510"><vh>&lt;&lt; create move submenu &gt;&gt;</vh></v>
<v t="T1511"><vh>&lt;&lt; create mark submenu &gt;&gt;</vh></v>
<v t="T1512"><vh>&lt;&lt; create goto submenu &gt;&gt;</vh></v>
</v>
<v t="T1513"><vh>&lt;&lt; create the window menu &gt;&gt;</vh></v>
<v t="T1514"><vh>&lt;&lt; create the help menu &gt;&gt;</vh></v>
</v>
<v t="T1525" a="C"><vh>Recent Files submenu</vh>
<v t="T1347" a="C"><vh>frame.OpenWithFileName</vh>
<v t="T1348"><vh>&lt;&lt; make fileName the most recent file of frame &gt;&gt;</vh></v>
</v>
<v t="T1345" a="C"><vh>frame.OnOpenRecentFile</vh>
<v t="T1346"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
</v>
</v>
<v><vh>(tangle_done bug)</vh>
<v t="T1913"><vh> Bug report</vh></v>
<v t="T1914"><vh> Test</vh>
<v t="T1915"><vh>@root test\tangleDone.txt</vh></v>
</v>
<v t="T1916" a="C"><vh>cleanup</vh>
<v t="T1917"><vh>&lt;&lt; call tangle_done.run() or untangle_done.run() &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="T1918"><vh>(Open With problems)</vh>
<v t="T875" a="C"><vh>createOpenWithMenuFromTable</vh></v>
<v t="T1919" a="C"><vh>&lt;&lt; create the Open With menu &gt;&gt;</vh></v>
</v>
<v t="T1920" a="V"><vh>(Underline menus)</vh>
<v t="T1921" a="C"><vh>canonicalizeMenuName</vh></v>
<v t="T1485" a="C"><vh>canonicalizeShortcut</vh>
<v t="T1486"><vh>&lt;&lt; canonicalize the last field &gt;&gt;</vh>
<v t="T1487"><vh>&lt;&lt; define dict of Tk bind names &gt;&gt;</vh></v>
<v t="T1488"><vh>&lt;&lt; define dict of special names &gt;&gt;</vh></v>
</v>
<v t="T1489"><vh>&lt;&lt; set the last field, preserving case &gt;&gt;</vh></v>
<v t="T1490"><vh>&lt;&lt; synthesize the shortcuts from the information &gt;&gt;</vh></v>
</v>
<v t="T1491" a="C"><vh>createMenuBar</vh>
<v t="T1492"><vh>&lt;&lt; create the edit menu &gt;&gt;</vh>
<v t="T1493"><vh>&lt;&lt; create the first top-level edit entries &gt;&gt;</vh></v>
<v t="T1494"><vh>&lt;&lt; create the edit body submenu &gt;&gt;</vh></v>
<v t="T1495"><vh>&lt;&lt; create the edit headline submenu &gt;&gt;</vh></v>
<v t="T1496"><vh>&lt;&lt; create the find submenu &gt;&gt;</vh></v>
<v t="T1497"><vh>&lt;&lt; create the last top-level edit entries &gt;&gt;</vh></v>
</v>
<v t="T1498"><vh>&lt;&lt; create the file menu &gt;&gt;</vh>
<v t="T1499"><vh>&lt;&lt; create the top-level file entries &gt;&gt;</vh></v>
<v t="T1500"><vh>&lt;&lt; create the recent files submenu &gt;&gt;</vh></v>
<v t="T1501"><vh>&lt;&lt; create the read/write submenu &gt;&gt;</vh></v>
<v t="T1502"><vh>&lt;&lt; create the tangle submenu &gt;&gt;</vh></v>
<v t="T1503"><vh>&lt;&lt; create the untangle submenu &gt;&gt;</vh></v>
<v t="T1504"><vh>&lt;&lt; create the import submenu &gt;&gt;</vh></v>
<v t="T1505"><vh>&lt;&lt; create the export submenu &gt;&gt;</vh></v>
</v>
<v t="T1506"><vh>&lt;&lt; create the outline menu &gt;&gt;</vh>
<v t="T1507"><vh>&lt;&lt; create top-level outline menu &gt;&gt;</vh></v>
<v t="T1508"><vh>&lt;&lt; create expand submenu &gt;&gt;</vh></v>
<v t="T1509"><vh>&lt;&lt; create contract submenu &gt;&gt;</vh></v>
<v t="T1510"><vh>&lt;&lt; create move submenu &gt;&gt;</vh></v>
<v t="T1511"><vh>&lt;&lt; create mark submenu &gt;&gt;</vh></v>
<v t="T1512"><vh>&lt;&lt; create goto submenu &gt;&gt;</vh></v>
</v>
<v t="T1513"><vh>&lt;&lt; create the window menu &gt;&gt;</vh></v>
<v t="T1514"><vh>&lt;&lt; create the help menu &gt;&gt;</vh></v>
</v>
<v t="T872" a="C"><vh>createMenuEntries</vh>
<v t="T873"><vh>&lt;&lt; get menu and bind shortcuts &gt;&gt;</vh></v>
</v>
<v t="T874" a="C"><vh>createMenuItemsFromTable</vh></v>
<v t="T1640" a="C"><vh>createNewMenu</vh></v>
<v t="T875" a="C"><vh>createOpenWithMenuFromTable</vh></v>
<v t="T1515" a="C"><vh>createRecentFilesMenuItems</vh></v>
<v t="T1922" a="C"><vh>enableMenu &amp; disableMenu &amp; setMenuLabel</vh></v>
<v t="T1516" a="C"><vh>get/set/destroyMenu</vh></v>
<v t="T1644" a="C"><vh>Menu enablers (Frame)</vh>
<v t="T865" a="C"><vh>frame.OnMenuClick (enables and disables all menu items)</vh></v>
<v t="T1645"><vh>hasSelection</vh></v>
<v t="T1646"><vh>updateFileMenu</vh></v>
<v t="T1647"><vh>updateEditMenu</vh></v>
<v t="T1648"><vh>updateOutlineMenu</vh></v>
</v>
<v t="T1086" a="C"><vh>setRedoType, setUndoType</vh></v>
</v>
<v t="T1923"><vh>Code</vh>
<v t="T1924"><vh>  Overview of code</vh>
<v t="T1925" a="C"><vh>&lt;&lt; About clones &gt;&gt;</vh></v>
<v t="T1926" a="C"><vh> &lt;&lt; About drawing and events &gt;&gt;</vh></v>
<v t="T1927" a="C"><vh>&lt;&lt; About Tangle and Untangle &gt;&gt;</vh></v>
<v t="T1928" a="C"><vh>&lt;&lt; About the vnode and tnode classes &gt;&gt;</vh></v>
<v t="T1929" a="C"><vh>&lt;&lt; How Leo implements unlimited undo &gt;&gt;</vh></v>
<v t="T976" a="C"><vh>&lt;&lt; Theory of operation of find/change &gt;&gt;</vh></v>
</v>
<v t="T1930"><vh> Batch Files</vh>
<v t="T1931"><vh>@silentfile bdist.bat</vh></v>
<v t="T1932"><vh>@silentfile go.bat</vh></v>
<v t="T1933"><vh>@silentfile help.bat</vh></v>
<v t="T1934"><vh>@silentfile sdist.bat</vh></v>
</v>
<v t="T1935"><vh> Customizing Leo</vh>
<v t="T1936"><vh>Documentation and warnings</vh>
<v t="T1937"><vh>Intro to scripts</vh></v>
<v t="T1938"><vh>About hooks</vh></v>
<v t="T1939"><vh>Summary of security issues</vh></v>
<v t="T1940"><vh>NEVER use this kind of code in a hook!!</vh></v>
</v>
<v t="T1941"><vh>(Convenience routines for customizeLeo.py)(for docs)</vh>
<v t="T1942"><vh>Convenience routines that enable and disable the "idle" hook</vh>
<v t="T1343" a="C"><vh>enableIdleTimeHook, disableIdleTimeHook, idleTimeHookHandler</vh></v>
</v>
<v t="T1639" a="C"><vh>Menu Convenience Routines</vh>
<v t="T874" a="C"><vh>createMenuItemsFromTable</vh></v>
<v t="T1640" a="C"><vh>createNewMenu</vh></v>
<v t="T875" a="C"><vh>createOpenWithMenuFromTable</vh></v>
<v t="T1641"><vh>deleteMenu</vh></v>
<v t="T1642"><vh>deleteMenuItem</vh></v>
<v t="T1643"><vh>setRealMenuNamesFromTable</vh></v>
</v>
</v>
<v t="T1943"><vh>@file customizeLeo.py</vh>
<v t="T1944"><vh>&lt;&lt; sign on (a security precaution) &gt;&gt;</vh></v>
<v t="T1945"><vh>&lt;&lt; trace tags &gt;&gt;</vh></v>
<v t="T1946"><vh>&lt;&lt; create and handle the Open With menu &gt;&gt;</vh>
<v t="T1919" a="C"><vh>&lt;&lt; create the Open With menu &gt;&gt;</vh></v>
<v t="T1947"><vh>&lt;&lt; check the temp files created by the Open With command &gt;&gt;</vh></v>
</v>
<v t="T1948"><vh>&lt;&lt; enable gc checking &gt;&gt;</vh></v>
<v t="T1949"><vh>&lt;&lt; create Scripts menu for LeoPy.leo &gt;&gt;</vh></v>
<v t="T1950"><vh>&lt;&lt; trace the key handlers &gt;&gt;</vh></v>
<v t="T1951"><vh>&lt;&lt; translate a few menu items into french &gt;&gt;</vh></v>
<v t="T1952"><vh>&lt;&lt; print the commander for each open window &gt;&gt;</vh></v>
<v t="T1953"><vh>&lt;&lt; test how Leo handles exceptions in this file &gt;&gt;</vh></v>
<v t="T1954"><vh>&lt;&lt; override the Equal Sized panes command &gt;&gt;</vh></v>
<v t="T1955"><vh>&lt;&lt; do something at the start of each command &gt;&gt;</vh></v>
</v>
</v>
<v t="T1956" a="C"><vh> Distribution &amp; files</vh>
<v t="T1957"><vh>leo.nsi</vh>
<v t="T1958"><vh>@root leo.nsi</vh>
<v t="T1959"><vh>&lt;&lt; installer settings &gt;&gt;</vh>
<v t="T1960"><vh>&lt;&lt; icons used by the installer &gt;&gt;</vh></v>
<v t="T1961"><vh>&lt;&lt; the installation dir &gt;&gt;</vh></v>
<v t="T1962"><vh>&lt;&lt; the user license &gt;&gt;</vh></v>
<v t="T1963"><vh>&lt;&lt; Additional Installer Settings &gt;&gt;</vh></v>
</v>
<v t="T1964"><vh>&lt;&lt; required files section&gt;&gt;</vh>
<v t="T1965"><vh>&lt;&lt; check to see whether Python is installed &gt;&gt;</vh></v>
</v>
<v t="T1966"><vh>&lt;&lt; optional files section&gt;&gt;</vh></v>
<v t="T1967"><vh>&lt;&lt; file association &gt;&gt;</vh></v>
<v t="T1968"><vh>&lt;&lt; post install section &gt;&gt;</vh></v>
<v t="T1969"><vh>&lt;&lt; uninstall section &gt;&gt;</vh>
<v t="T1970"><vh>&lt;&lt; remove file association &gt;&gt;</vh></v>
<v t="T1971"><vh>&lt;&lt; remove program folder &gt;&gt;</vh></v>
<v t="T1972"><vh>&lt;&lt; remove shortcuts &gt;&gt;</vh></v>
</v>
</v>
<v t="T1973"><vh>Unused</vh>
<v t="T1974"><vh>&lt;&lt; get the path to pythonw.exe &gt;&gt;</vh></v>
</v>
</v>
<v t="T1975"><vh>@silentfile LICENSE.TXT</vh></v>
<v t="T1976"><vh>@silentfile INSTALL.TXT</vh>
<v t="T1977"><vh>&lt;&lt; installing leo.py &gt;&gt;</vh></v>
<v t="T1978"><vh>&lt;&lt; shell &amp; batch scripts &gt;&gt;</vh></v>
<v t="T1979"><vh>&lt;&lt; Borland &gt;&gt;</vh></v>
<v t="T1980"><vh>&lt;&lt; MacOS &gt;&gt;</vh></v>
</v>
<v t="T1981"><vh>@silentfile PKG-INFO.TXT</vh></v>
<v t="T1982"><vh>@silentfile README.TXT</vh></v>
<v t="T1983"><vh>@silentfile manifest.in</vh></v>
</v>
<v t="T1984"><vh> Scripts</vh>
<v t="T1985"><vh>@file c2py.py</vh>
<v><vh>Documentation</vh>
<v t="T1986"><vh>&lt;&lt; what c2py does &gt;&gt;</vh></v>
<v t="T1987"><vh>&lt;&lt; theory of operation &gt;&gt;</vh></v>
</v>
<v t="T1988"><vh>&lt;&lt; specifying user types &gt;&gt;</vh></v>
<v t="T1989"><vh>&lt;&lt; define testData &gt;&gt;</vh></v>
<v t="T1990"><vh>speedTest</vh></v>
<v><vh>leo1to2</vh>
<v t="T1991"><vh>leo1to2</vh></v>
<v t="T1992"><vh>convertLeo1to2</vh></v>
<v t="T1993"><vh>convertStringLeo1to2</vh></v>
<v t="T1994"><vh>convertCodeList1to2</vh></v>
</v>
<v t="T1995"><vh>c2py entry points</vh>
<v t="T1996"><vh>convertCurrentTree</vh></v>
<v t="T1997"><vh>convertLeoTree</vh></v>
<v t="T1998"><vh>convertCFileToPython</vh></v>
</v>
<v><vh>c2py Top Level</vh>
<v t="T1999"><vh>convertCStringToPython</vh></v>
<v t="T2000"><vh>convertCodeList</vh></v>
<v t="T2001"><vh>convertDocList</vh></v>
<v t="T2002"><vh>skipDocPart</vh></v>
<v t="T2003"><vh>skipCodePart</vh></v>
</v>
<v><vh>removeSentinels</vh></v>
<v><vh>Scanning &amp; Replacing</vh>
<v t="T2004"><vh>convertLeadingBlanks</vh></v>
<v t="T2005"><vh>findInList</vh></v>
<v t="T2006"><vh>findInCode</vh></v>
<v t="T2007"><vh>mungeAllFunctions</vh>
<v t="T2008"><vh>handlePossibleFunctionHeader</vh></v>
<v t="T2009"><vh>massageFunctionArgs</vh></v>
<v t="T2010"><vh>massageFunctionHead (sets gClassName)</vh></v>
<v t="T2011"><vh>massageFunctionBody</vh>
<v t="T2012"><vh>massageIvars</vh></v>
<v t="T2013"><vh>removeCasts</vh></v>
<v t="T2014"><vh>removeTypeNames</vh></v>
</v>
</v>
<v t="T2015"><vh>handleAllKeywords</vh>
<v t="T2016"><vh>handleKeyword</vh></v>
</v>
<v t="T2017"><vh>isWs and isWOrNl</vh></v>
<v t="T2018"><vh>isSectionDef</vh></v>
<v t="T2019"><vh>isStringOrComment</vh></v>
<v t="T2020"><vh>match</vh></v>
<v t="T2021"><vh>matchWord</vh></v>
<v t="T2022"><vh>prevNonWsChar and prevNonWsOrNlChar</vh></v>
<v t="T2023"><vh>removeAllCComments</vh></v>
<v t="T2024"><vh>removeAllCSentinels</vh></v>
<v t="T2025"><vh>removeAllPythonComments</vh></v>
<v t="T2026"><vh>removeAllPythonSentinels</vh></v>
<v t="T2027"><vh>removeAtRoot</vh></v>
<v t="T2028"><vh>removeBlankLines</vh></v>
<v t="T2029"><vh>removeExcessWs</vh>
<v t="T2030"><vh>removeExessWsFromLine</vh></v>
</v>
<v t="T2031"><vh>removeLeadingAtCode</vh></v>
<v t="T2032"><vh>removeMatchingBrackets</vh></v>
<v t="T2033"><vh>removeSemicolonsAtEndOfLines</vh></v>
<v t="T2034"><vh>removeTrailingWs</vh></v>
<v t="T2035"><vh>replace</vh></v>
<v t="T2036"><vh>replaceComments</vh></v>
<v t="T2037"><vh>replaceSectionDefs</vh></v>
<v t="T2038"><vh>safeReplace</vh></v>
<v t="T2039"><vh>skipCBlockComment</vh></v>
<v t="T2040"><vh>skipPastLine</vh></v>
<v t="T2041"><vh>skipPastWord</vh></v>
<v t="T2042"><vh>skipString</vh></v>
<v t="T2043"><vh>skipStringOrComment</vh></v>
<v t="T2044"><vh>skipToMatchingBracket</vh></v>
<v t="T2045"><vh>skipWs and skipWsAndNl</vh></v>
<v t="T2046"><vh>stringToList</vh></v>
<v t="T2047"><vh>listToString</vh></v>
</v>
</v>
<v t="T2048"><vh>@file disStats.py</vh>
<v t="T2049"><vh>go</vh></v>
<v t="T2050"><vh>getFiles</vh></v>
<v t="T2051"><vh>getModules</vh></v>
<v t="T2052"><vh>any</vh></v>
<v t="T2053"><vh>code</vh></v>
<v t="T2054"><vh>print_stats</vh></v>
</v>
<v t="T2055"><vh>@file leoFindScript.py</vh>
<v t="T2056"><vh>changeAll</vh></v>
<v t="T2057"><vh>changeNext</vh></v>
<v t="T2058"><vh>changePrev</vh></v>
<v t="T2059"><vh>findAll</vh></v>
<v t="T2060"><vh>findNext</vh></v>
<v t="T2061"><vh>findPrev</vh></v>
<v t="T2062"><vh>reChangeAll</vh></v>
<v t="T2063"><vh>reChangeNext</vh></v>
<v t="T2064"><vh>reChangePrev</vh></v>
<v t="T2065"><vh>reFindAll</vh></v>
<v t="T2066"><vh>reFindNext</vh></v>
<v t="T2067"><vh>reFindPrev</vh></v>
<v t="T2068"><vh>lineAtPos</vh></v>
<v t="T2069"><vh>printFindList</vh></v>
</v>
<v t="T2070"><vh>@file openLeo.py</vh></v>
<v t="T2071"><vh>@file setup.py</vh>
<v t="T2072" a="C"><vh>&lt;&lt; setup info for setup.py &gt;&gt; (version number)</vh></v>
</v>
<v t="T2073"><vh>@file untangle_done.py</vh></v>
<v t="T2074" a="C"><vh>importFiles</vh></v>
</v>
<v t="T2075"><vh> Version stuff (update this for every release)</vh>
<v t="T1146" a="C"><vh>OnAbout (version number &amp; date)</vh></v>
<v t="T2072" a="C"><vh>&lt;&lt; setup info for setup.py &gt;&gt; (version number)</vh></v>
<v t="T1956" a="C"><vh> Distribution &amp; files</vh>
<v t="T1957"><vh>leo.nsi</vh>
<v t="T1958"><vh>@root leo.nsi</vh>
<v t="T1959"><vh>&lt;&lt; installer settings &gt;&gt;</vh>
<v t="T1960"><vh>&lt;&lt; icons used by the installer &gt;&gt;</vh></v>
<v t="T1961"><vh>&lt;&lt; the installation dir &gt;&gt;</vh></v>
<v t="T1962"><vh>&lt;&lt; the user license &gt;&gt;</vh></v>
<v t="T1963"><vh>&lt;&lt; Additional Installer Settings &gt;&gt;</vh></v>
</v>
<v t="T1964"><vh>&lt;&lt; required files section&gt;&gt;</vh>
<v t="T1965"><vh>&lt;&lt; check to see whether Python is installed &gt;&gt;</vh></v>
</v>
<v t="T1966"><vh>&lt;&lt; optional files section&gt;&gt;</vh></v>
<v t="T1967"><vh>&lt;&lt; file association &gt;&gt;</vh></v>
<v t="T1968"><vh>&lt;&lt; post install section &gt;&gt;</vh></v>
<v t="T1969"><vh>&lt;&lt; uninstall section &gt;&gt;</vh>
<v t="T1970"><vh>&lt;&lt; remove file association &gt;&gt;</vh></v>
<v t="T1971"><vh>&lt;&lt; remove program folder &gt;&gt;</vh></v>
<v t="T1972"><vh>&lt;&lt; remove shortcuts &gt;&gt;</vh></v>
</v>
</v>
<v t="T1973"><vh>Unused</vh>
<v t="T1974"><vh>&lt;&lt; get the path to pythonw.exe &gt;&gt;</vh></v>
</v>
</v>
<v t="T1975"><vh>@silentfile LICENSE.TXT</vh></v>
<v t="T1976"><vh>@silentfile INSTALL.TXT</vh>
<v t="T1977"><vh>&lt;&lt; installing leo.py &gt;&gt;</vh></v>
<v t="T1978"><vh>&lt;&lt; shell &amp; batch scripts &gt;&gt;</vh></v>
<v t="T1979"><vh>&lt;&lt; Borland &gt;&gt;</vh></v>
<v t="T1980"><vh>&lt;&lt; MacOS &gt;&gt;</vh></v>
</v>
<v t="T1981"><vh>@silentfile PKG-INFO.TXT</vh></v>
<v t="T1982"><vh>@silentfile README.TXT</vh></v>
<v t="T1983"><vh>@silentfile manifest.in</vh></v>
</v>
</v>
<v t="T2076"><vh>@file __init__.py</vh></v>
<v t="T2077"><vh>@file leo.py </vh>
<v t="T2078"><vh>&lt;&lt; Import pychecker &gt;&gt;</vh></v>
<v t="T2079"><vh>go</vh></v>
<v t="T2080"><vh>init_sherlock</vh></v>
<v t="T1286" a="C"><vh>leo.leoOpen</vh>
<v t="T1287" a="C"><vh>&lt;&lt; set the icon image &gt;&gt;</vh></v>
</v>
<v t="T1288" a="C"><vh>leo.run</vh>
<v t="T1287" a="C"><vh>&lt;&lt; set the icon image &gt;&gt;</vh></v>
</v>
<v t="T2081"><vh>profile</vh></v>
</v>
<v t="T2082"><vh>@file leoApp.py</vh>
<v t="T869" a="C"><vh>app.__init__</vh>
<v t="T522" a="C"><vh>&lt;&lt; define global constants &gt;&gt;</vh></v>
<v t="T870"><vh>&lt;&lt; define global data structures &gt;&gt;</vh></v>
</v>
<v t="T2083"><vh>app.destroyAllGlobalWindows</vh></v>
<v t="T2084"><vh>app.finishCreate</vh>
<v t="T2085"><vh>&lt;&lt; return false if not v2.1 or above &gt;&gt;</vh></v>
<v t="T2086"><vh>&lt;&lt; set loadDir &gt;&gt;</vh></v>
<v t="T2087"><vh>&lt;&lt; set the default Leo icon &gt;&gt;</vh>
<v t="T2088"><vh>&lt;&lt; set v834 if version is 8.3.4 or greater &gt;&gt;</vh></v>
</v>
</v>
<v t="T871" a="C"><vh>app.handleOpenTempFiles</vh></v>
<v t="T889" a="C"><vh>app.quit</vh></v>
<v t="T2089"><vh>app.get/setRealMenuName</vh></v>
<v t="T2090"><vh>app.testDialogs</vh></v>
</v>
<v t="T2091"><vh>@file leoAtFile.py</vh>
<v t="T2092"><vh>&lt;&lt; atFile constants &gt;&gt;</vh></v>
<v t="T1821" a="C"><vh>atFile ctor</vh>
<v t="T1822"><vh>&lt;&lt; initialize atFile ivars &gt;&gt;</vh></v>
</v>
<v><vh>Sentinels</vh>
<v t="T653" a="C"><vh>nodeSentinelText</vh></v>
<v t="T2093"><vh>putCloseNodeSentinel</vh></v>
<v t="T2094"><vh>putCloseSentinels</vh></v>
<v t="T1778" a="C"><vh>putOpenLeoSentinel</vh></v>
<v t="T2095"><vh>putOpenNodeSentinel</vh></v>
<v t="T2096"><vh>putOpenSentinels</vh></v>
<v t="T650" a="C"><vh>putSentinel (applies cweb hack)</vh></v>
<v t="T652" a="C"><vh>sentinelKind</vh></v>
<v t="T1775" a="C"><vh>sentinelName</vh></v>
<v t="T651" a="C"><vh>skipSentinelStart</vh></v>
</v>
<v><vh>Utilites</vh>
<v t="T1692" a="C"><vh>atFile.scanAllDirectives (calls writeError on errors)</vh>
<v t="T1331" a="C"><vh>&lt;&lt; Set ivars &gt;&gt;</vh></v>
<v t="T1693"><vh>&lt;&lt; Set path from @file node &gt;&gt;</vh></v>
<v t="T1694"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="T1695"><vh>&lt;&lt; Test for @header and @noheader &gt;&gt;</vh></v>
<v t="T1696"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="T1697"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
<v t="T1698"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
<v t="T1330" a="C"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="T1699"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="T1700"><vh>&lt;&lt; Set current directory &gt;&gt;</vh></v>
<v t="T1701"><vh>&lt;&lt; Set comment Strings from delims &gt;&gt;</vh></v>
</v>
<v t="T657" a="C"><vh>directiveKind</vh></v>
<v t="T2097"><vh>error</vh></v>
<v t="T2098"><vh>skipIndent</vh></v>
<v t="T2099"><vh>readError</vh></v>
<v t="T2100"><vh>updateCloneIndices</vh></v>
<v t="T2101"><vh>writeError</vh></v>
</v>
<v><vh>Reading</vh>
<v t="T2102"><vh>createNthChild</vh></v>
<v t="T2103"><vh>joinTrees</vh></v>
<v t="T2104"><vh>atFile.read</vh>
<v t="T2105"><vh>&lt;&lt; open file &gt;&gt;</vh>
<v t="T2106"><vh>&lt;&lt; warn on read-only file &gt;&gt;</vh></v>
</v>
<v t="T2107"><vh>&lt;&lt; Scan the file buffer  &gt;&gt;</vh></v>
<v t="T2108"><vh>&lt;&lt; Bump mStructureErrors if any vnodes are unvisited &gt;&gt;</vh></v>
<v t="T2109"><vh>&lt;&lt; Delete root's tree and body text &gt;&gt;</vh></v>
<v t="T2110"><vh>&lt;&lt; Handle clone bits &gt;&gt;</vh></v>
<v t="T2111"><vh>&lt;&lt; Join cloned trees &gt;&gt;</vh></v>
<v t="T2112"><vh>&lt;&lt; Handle all status bits &gt;&gt;</vh></v>
</v>
<v t="T2113"><vh>readAll (Leo2)</vh></v>
<v t="T1394" a="C"><vh>scanDoc</vh>
<v t="T1395"><vh>&lt;&lt; Skip the opening sentinel &gt;&gt;</vh></v>
<v t="T1396"><vh>&lt;&lt; Skip an opening block delim &gt;&gt;</vh></v>
<v t="T1397"><vh>&lt;&lt; set kind, nextLine &gt;&gt;</vh></v>
<v t="T1398"><vh>&lt;&lt; Skip the leading stuff &gt;&gt;</vh></v>
<v t="T1399"><vh>&lt;&lt; Append s to out &gt;&gt;</vh></v>
<v t="T1400"><vh>&lt;&lt; Remove a closing block delim from out &gt;&gt;</vh></v>
</v>
<v t="T1173" a="C"><vh>scanHeader</vh></v>
<v t="T2114"><vh>completeFirstDirectives (Dave Hein)</vh></v>
<v t="T2115"><vh>completeLastDirectives (Dave Hein)</vh></v>
<v t="T2116"><vh>scanText</vh>
<v t="T2117"><vh>&lt;&lt; set kind, nextKind &gt;&gt;</vh></v>
<v t="T2118"><vh>&lt;&lt; Set lineIndent, linep and leading_ws &gt;&gt;</vh></v>
<v t="T2119"><vh>&lt;&lt; append non-sentinel line &gt;&gt;</vh></v>
<v t="T2120"><vh>&lt;&lt; handle an ending sentinel &gt;&gt; (new read code)</vh></v>
<v t="T2121"><vh>&lt;&lt; handle unexpected end of text &gt;&gt;</vh></v>
<v><vh>start sentinels</vh>
<v t="T2122"><vh>&lt;&lt; scan @+at &gt;&gt;</vh></v>
<v t="T1777" a="C"><vh>&lt;&lt; scan @+body &gt;&gt; (revised read code)</vh></v>
<v t="T2123"><vh>&lt;&lt; scan @+doc &gt;&gt;</vh></v>
<v t="T2124"><vh>&lt;&lt; scan @+leo &gt;&gt;</vh></v>
<v t="T1425" a="C"><vh>&lt;&lt; scan @+node &gt;&gt; (revised read code)</vh>
<v t="T1426"><vh>&lt;&lt; Set childIndex &gt;&gt;</vh></v>
<v t="T1427"><vh>&lt;&lt; Set cloneIndex &gt;&gt;</vh></v>
<v t="T654" a="C"><vh>&lt;&lt; Set headline and ref &gt;&gt;</vh></v>
<v t="T1428"><vh>&lt;&lt; Check the filename in the sentinel &gt;&gt;</vh></v>
<v t="T1429"><vh>&lt;&lt; look for sentinels that may follow a reference &gt;&gt;</vh></v>
</v>
<v t="T1776" a="C"><vh>&lt;&lt; scan @+others &gt;&gt;</vh></v>
</v>
<v><vh>unpaired sentinels</vh>
<v t="T656" a="C"><vh>&lt;&lt; scan @@ &gt;&gt;</vh></v>
<v t="T2125"><vh>&lt;&lt; scan @comment &gt;&gt;</vh></v>
<v t="T1379" a="C"><vh>&lt;&lt; scan @delims &gt;&gt;</vh></v>
<v t="T655" a="C"><vh>&lt;&lt; scan @ref &gt;&gt;</vh></v>
<v t="T2126"><vh>&lt;&lt; scan @verbatim &gt;&gt;</vh></v>
</v>
<v t="T2127"><vh>&lt;&lt; warn about unknown sentinel &gt;&gt;</vh></v>
</v>
</v>
<v><vh>Writing</vh>
<v t="T963" a="C"><vh>os, onl, etc. (leoAtFile)</vh></v>
<v t="T1385" a="C"><vh>putBodyPart (removes trailing lines)</vh>
<v t="T1386"><vh>&lt;&lt; put code/doc parts and sentinels &gt;&gt;</vh>
<v t="T1387"><vh>&lt;&lt; initialize lookingForFirst/Last &amp; initialLastDirective &gt;&gt;</vh></v>
<v t="T1388"><vh>&lt;&lt; set lookingForFirst/Last &amp; initialLastDirective &gt;&gt;</vh></v>
<v t="T1389"><vh>&lt;&lt; handle misc directives &gt;&gt;</vh></v>
<v t="T1390"><vh>&lt;&lt; put out the last directives, if any &gt;&gt;</vh></v>
</v>
</v>
<v t="T1430" a="C"><vh>putCodePart &amp; allies</vh>
<v t="T1431" a="C"><vh>&lt;&lt; handle the start of a line &gt;&gt;</vh>
<v t="T1432" a="C"><vh>&lt;&lt; handle @others &gt;&gt;</vh></v>
<v t="T1433"><vh>&lt;&lt; handle @raw &gt;&gt;</vh></v>
<v t="T1434"><vh>&lt;&lt; handle @end_raw &gt;&gt;</vh></v>
<v t="T1265" a="C"><vh>&lt;&lt; put @verbatim sentinel if necessary &gt;&gt;</vh></v>
</v>
<v t="T1435"><vh>&lt;&lt; put the line &gt;&gt;</vh>
<v t="T1436"><vh>&lt;&lt; put possible section reference &gt;&gt;</vh></v>
</v>
<v t="T1437"><vh>isSectionName</vh></v>
<v t="T1226" a="C"><vh>inAtOthers</vh></v>
<v t="T1227" a="C"><vh>putAtOthers</vh></v>
<v t="T1228" a="C"><vh>putAtOthersChild</vh></v>
<v t="T1438" a="C"><vh>putRef</vh>
<v t="T1439"><vh>&lt;&lt; Generate the expansion of the reference &gt;&gt;</vh></v>
</v>
</v>
<v t="T648" a="C"><vh>putDirective  (handles @delims)</vh>
<v t="T649"><vh>&lt;&lt; handle @delims &gt;&gt;</vh></v>
</v>
<v t="T2128"><vh>putEmptyDirective (Dave Hein)</vh></v>
<v t="T2129"><vh>putDoc</vh></v>
<v t="T964" a="C"><vh>putDocPart</vh>
<v t="T965"><vh>&lt;&lt; copy words, splitting the line if needed &gt;&gt;</vh></v>
</v>
<v t="T1210" a="C"><vh>putIndent</vh></v>
<v t="T2130"><vh>atFile.checkForLeoCustomize</vh></v>
<v t="T2131"><vh>atFile.closeWriteFile</vh></v>
<v t="T2132"><vh>atFile.handleWriteException</vh></v>
<v t="T2133"><vh>atFile.openWriteFile</vh></v>
<v t="T2134"><vh>atFile.replaceTargetFileIfDifferent</vh>
<v t="T2135"><vh>&lt;&lt; delete the output file &gt;&gt;</vh></v>
<v t="T2136"><vh>&lt;&lt; replace the target file with the output file &gt;&gt;</vh></v>
<v t="T2137"><vh>&lt;&lt; rename the output file to be the target file &gt;&gt;</vh></v>
</v>
<v t="T1164" a="C"><vh>atFile.write</vh>
<v t="T1165"><vh>&lt;&lt; initialize &gt;&gt;</vh></v>
<v t="T1166"><vh>&lt;&lt; open the file; return on error &gt;&gt;</vh></v>
<v t="T1167"><vh>&lt;&lt; write then entire @file tree &gt;&gt;</vh>
<v t="T1168" a="C"><vh>&lt;&lt; put all @first lines in root &gt;&gt;</vh></v>
<v t="T1169"><vh>&lt;&lt; put optional @comment sentinel lines &gt;&gt;</vh></v>
<v t="T1170" a="C"><vh>&lt;&lt; put all @last lines in root &gt;&gt;</vh></v>
</v>
<v t="T1171"><vh>&lt;&lt; Warn about @ignored and orphans  &gt;&gt;</vh></v>
<v t="T1172"><vh>&lt;&lt; finish writing &gt;&gt;</vh></v>
</v>
<v t="T2138"><vh>atFile.rawWrite</vh>
<v t="T2139"><vh>&lt;&lt; write root's tree &gt;&gt;</vh>
<v t="T2140"><vh>&lt;&lt; put all @first lines in root &gt;&gt;</vh></v>
<v t="T2141"><vh>&lt;&lt; put optional @comment sentinel lines &gt;&gt;</vh></v>
<v t="T2142"><vh>&lt;&lt; Write v's node &gt;&gt;</vh></v>
<v t="T2143"><vh>&lt;&lt; put all @last lines in root &gt;&gt;</vh></v>
</v>
</v>
<v t="T2144"><vh>atFile.silentWrite</vh>
<v t="T2145"><vh>&lt;&lt; Write v's headline if it starts with @@ &gt;&gt;</vh></v>
<v t="T2146"><vh>&lt;&lt; Write v's body &gt;&gt;</vh></v>
</v>
<v t="T1823" a="C"><vh>atFile.writeAll</vh>
<v t="T1824"><vh>&lt;&lt; Clear all orphan bits &gt;&gt;</vh></v>
</v>
</v>
<v><vh>Testing</vh>
<v t="T2147"><vh>scanAll</vh></v>
<v t="T2148"><vh>scanFile</vh>
<v t="T2149"><vh>&lt;&lt; open file &gt;&gt;</vh></v>
<v t="T2150"><vh>&lt;&lt; Scan the file buffer  &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T2151"><vh>@file leoColor.py</vh>
<v t="T524" a="C"><vh>&lt;&lt; define colorizer keywords &gt;&gt;</vh>
<v t="T525"><vh>&lt;&lt; leo keywords &gt;&gt;</vh></v>
<v t="T526"><vh>&lt;&lt; c keywords &gt;&gt;</vh></v>
<v t="T527"><vh>&lt;&lt; html keywords &gt;&gt;</vh></v>
<v t="T528"><vh>&lt;&lt; java keywords &gt;&gt;</vh></v>
<v t="T529"><vh>&lt;&lt; latex keywords &gt;&gt;</vh></v>
<v t="T530"><vh>&lt;&lt; pascal keywords &gt;&gt;</vh></v>
<v t="T531"><vh>&lt;&lt; perl keywords &gt;&gt;</vh></v>
<v t="T532"><vh>&lt;&lt; python keywords &gt;&gt;</vh></v>
<v t="T533"><vh>&lt;&lt; tcl/tk keywords &gt;&gt;</vh></v>
<v t="T534"><vh>&lt;&lt; php keywords &gt;&gt;</vh></v>
</v>
<v t="T2152"><vh>&lt;&lt; define colorizer constants &gt;&gt;</vh></v>
<v t="T2153"><vh>&lt;&lt; define colorizer functions &gt;&gt;</vh></v>
<v t="T2154"><vh>&lt;&lt; define color panel data &gt;&gt;</vh></v>
<v t="T2155"><vh>class colorizer</vh>
<v t="T2156"><vh>color.__init__</vh>
<v t="T2157"><vh>&lt;&lt; ivars for communication between colorAllDirectives and its allies &gt;&gt;</vh></v>
<v t="T2158"><vh>&lt;&lt; define dispatch dicts &gt;&gt;</vh></v>
</v>
<v><vh>color.callbacks...</vh>
<v t="T2159"><vh>OnHyperLinkControlClick</vh></v>
<v t="T2160"><vh>OnHyperLinkEnter</vh></v>
<v t="T2161"><vh>OnHyperLinkLeave</vh></v>
</v>
<v t="T2162"><vh>colorize &amp; recolor_range</vh></v>
<v t="T540" a="C"><vh>colorizeAnyLanguage &amp; allies</vh>
<v t="T541"><vh>&lt;&lt; initialize ivars &amp; tags &gt;&gt;</vh>
<v t="T542"><vh>&lt;&lt; configure tags &gt;&gt;</vh></v>
<v t="T543"><vh>&lt;&lt; configure language-specific settings &gt;&gt;</vh></v>
</v>
<v t="T544"><vh>&lt;&lt; incrementally color the text &gt;&gt;</vh>
<v t="T545"><vh>&lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;</vh></v>
<v t="T546"><vh>&lt;&lt; clear leading_lines if middle lines involve @color or @recolor  &gt;&gt;</vh></v>
<v t="T547"><vh>&lt;&lt; initialize new states &gt;&gt;</vh></v>
<v t="T548"><vh>&lt;&lt; colorize until the states match &gt;&gt;</vh></v>
</v>
<v t="T549"><vh>colorizeLine &amp; allies</vh>
<v t="T550"><vh>continueBlockComment</vh></v>
<v t="T551"><vh>continueSingle/DoubleString</vh></v>
<v t="T552"><vh>continueDocPart</vh>
<v t="T553"><vh>&lt;&lt; handle cweb doc part &gt;&gt;</vh></v>
<v t="T554"><vh>&lt;&lt; handle noweb doc part &gt;&gt;</vh></v>
</v>
<v t="T555"><vh>continueNocolor</vh></v>
<v t="T556"><vh>continueSingle/DoublePythonString</vh></v>
<v t="T557"><vh>doAtKeyword: NOT for cweb keywords</vh></v>
<v t="T558"><vh>doLatexLine</vh></v>
<v t="T559"><vh>doNormalState</vh>
<v t="T560"><vh>Valid regardless of latex mode</vh>
<v t="T561"><vh>&lt;&lt; handle possible  keyword &gt;&gt;</vh></v>
<v t="T562"><vh>&lt;&lt; handle at keyword &gt;&gt;</vh>
<v t="T563"><vh>&lt;&lt; Handle cweb control word &gt;&gt;</vh></v>
<v t="T564"><vh>&lt;&lt; handle cweb ref or def &gt;&gt;</vh></v>
</v>
<v t="T565"><vh>&lt;&lt; handle single-line comment &gt;&gt;</vh></v>
<v t="T566"><vh>&lt;&lt; start block comment &gt;&gt;</vh></v>
<v t="T567"><vh>&lt;&lt; handle latex line &gt;&gt;</vh></v>
</v>
<v t="T568"><vh>Vaid only in latex mode</vh>
<v t="T569"><vh>&lt;&lt; handle latex normal character &gt;&gt;</vh></v>
</v>
<v t="T570"><vh>Valid when not in latex_mode</vh>
<v t="T571"><vh>&lt;&lt; handle string &gt;&gt;</vh></v>
<v t="T572"><vh>&lt;&lt; handle C preprocessor line &gt;&gt;</vh></v>
<v t="T573"><vh>&lt;&lt; handle special php keywords &gt;&gt;</vh></v>
<v t="T574"><vh>&lt;&lt; handle blank &gt;&gt;</vh></v>
<v t="T575"><vh>&lt;&lt; handle tab &gt;&gt;</vh></v>
<v t="T576"><vh>&lt;&lt; handle normal character &gt;&gt;</vh></v>
</v>
</v>
<v t="T577"><vh>doNowebSecRef</vh>
<v t="T578"><vh>&lt;&lt; set the hyperlink &gt;&gt;</vh></v>
</v>
<v t="T579"><vh>removeAllTags &amp; removeTagsFromLines</vh></v>
</v>
</v>
<v t="T1715" a="C"><vh>scanColorDirectives</vh>
<v t="T1716"><vh>&lt;&lt; Test for @comment or @language &gt;&gt;</vh></v>
<v t="T1717"><vh>&lt;&lt; Test for @root, @root-doc or @root-code &gt;&gt;</vh></v>
</v>
<v t="T2163"><vh>color.schedule</vh></v>
<v t="T2164"><vh>getCwebWord</vh></v>
<v t="T2165"><vh>updateSyntaxColorer</vh></v>
<v t="T2166"><vh>useSyntaxColoring</vh></v>
<v t="T2167"><vh>Utils</vh>
<v t="T2168"><vh>setFirstLineState</vh></v>
<v t="T2169"><vh>skip_id</vh></v>
<v t="T2170"><vh>skip_python_string</vh></v>
<v t="T2171"><vh>skip_string</vh></v>
</v>
</v>
<v t="T1133" a="C"><vh>class leoColorPanel</vh>
<v t="T1134"><vh>colorPanel.__init__</vh></v>
<v t="T1135"><vh>run</vh>
<v t="T1136"><vh>&lt;&lt; create color panel &gt;&gt;</vh></v>
</v>
<v t="T1137"><vh>showColorPicker</vh></v>
<v t="T1138"><vh>showColorName</vh></v>
<v t="T1139" a="C"><vh>colorPanel.onOk, onCancel, onRevert</vh></v>
<v t="T1140"><vh>update</vh></v>
</v>
<v t="T2172"><vh>class leoColorNamePanel</vh>
<v t="T2173"><vh>namePanel.__init__</vh></v>
<v t="T2174"><vh>getSelection</vh></v>
<v t="T2175"><vh>run</vh>
<v t="T2176"><vh>&lt;&lt; create color name panel &gt;&gt;</vh></v>
</v>
<v t="T2177"><vh>onOk, onCancel, onRevert, OnApply</vh></v>
<v t="T2178"><vh>select</vh></v>
</v>
</v>
<v t="T2179"><vh>@file leoCommands.py</vh>
<v t="T2180"><vh>c.__del__</vh></v>
<v t="T1284" a="C"><vh>c.__init__</vh>
<v t="T1285"><vh>&lt;&lt; initialize ivars &gt;&gt;</vh></v>
</v>
<v t="T2181"><vh>c.__repr__</vh></v>
<v t="T883" a="C"><vh>c.destroy</vh></v>
<v t="T1124" a="C"><vh>c.setIvarsFromFind</vh></v>
<v t="T2182"><vh>c.setIvarsFromPrefs</vh></v>
<v t="T947" a="C"><vh>Cut &amp; Paste Outlines</vh>
<v t="T948"><vh>cutOutline</vh></v>
<v t="T949"><vh>copyOutline</vh></v>
<v t="T950"><vh>pasteOutline</vh></v>
</v>
<v><vh>Drawing Utilities</vh>
<v t="T2183"><vh>beginUpdate</vh></v>
<v t="T2184"><vh>bringToFront</vh></v>
<v t="T2185"><vh>endUpdate</vh></v>
<v t="T2186"><vh>recolor</vh></v>
<v t="T2187"><vh>redraw &amp; repaint</vh></v>
</v>
<v><vh>Edit Body Text</vh>
<v t="T940" a="C"><vh>convertAllBlanks</vh></v>
<v t="T941" a="C"><vh>convertAllTabs</vh></v>
<v t="T943" a="C"><vh>convertBlanks</vh></v>
<v t="T942" a="C"><vh>convertTabs</vh></v>
<v t="T2188"><vh>createLastChildNode</vh></v>
<v t="T2189"><vh>dedentBody</vh></v>
<v t="T2190"><vh>extract</vh>
<v t="T2191"><vh>&lt;&lt; Set headline for extract &gt;&gt;</vh></v>
</v>
<v t="T2192"><vh>extractSection</vh>
<v t="T2193"><vh>&lt;&lt; Set headline for extractSection &gt;&gt;</vh></v>
</v>
<v t="T2194"><vh>extractSectionNames</vh>
<v t="T2195"><vh>&lt;&lt; Find the next section name &gt;&gt;</vh></v>
</v>
<v t="T1029" a="C"><vh>getBodyLines</vh></v>
<v t="T2196"><vh>getBodySelection</vh></v>
<v t="T2197"><vh>indentBody</vh></v>
<v t="T1030" a="C"><vh>reformatParagraph</vh>
<v t="T1031"><vh>&lt;&lt; Set the new insert at the start of the next paragraph &gt;&gt;</vh></v>
</v>
<v t="T930" a="C"><vh>updateBodyPane (handles undo)</vh></v>
</v>
<v t="T1457" a="C"><vh>Enabling Menu Items (Commands)</vh>
<v t="T1458"><vh>canContractAllHeadlines</vh></v>
<v t="T1459"><vh>canContractAllSubheads</vh></v>
<v t="T1460"><vh>canContractParent</vh></v>
<v t="T1461"><vh>canContractSubheads</vh></v>
<v t="T1462"><vh>canCutOutline &amp; canDeleteHeadline</vh></v>
<v t="T1463"><vh>canDemote</vh></v>
<v t="T1464"><vh>canExpandAllHeadlines</vh></v>
<v t="T1465"><vh>canExpandAllSubheads</vh></v>
<v t="T1466"><vh>canExpandSubheads</vh></v>
<v t="T1467"><vh>canExtract, canExtractSection &amp; canExtractSectionNames</vh></v>
<v t="T1468"><vh>canFindMatchingBracket</vh></v>
<v t="T1469"><vh>canGoToNextDirtyHeadline</vh></v>
<v t="T1470"><vh>canGoToNextMarkedHeadline</vh></v>
<v t="T1471"><vh>canMarkChangedHeadline</vh></v>
<v t="T1472"><vh>canMarkChangedRoots</vh></v>
<v t="T1473"><vh>canMoveOutlineDown</vh></v>
<v t="T1474"><vh>canMoveOutlineLeft</vh></v>
<v t="T1475"><vh>canMoveOutlineRight</vh></v>
<v t="T1476"><vh>canMoveOutlineUp</vh></v>
<v t="T946" a="C"><vh>canPasteOutline</vh></v>
<v t="T1477"><vh>canPromote</vh></v>
<v t="T966" a="C"><vh>canRevert</vh></v>
<v t="T1478"><vh>canSelect....</vh></v>
<v t="T1479"><vh>canShiftBodyLeft/Right</vh></v>
<v t="T1480"><vh>canSortChildren, canSortSiblings</vh></v>
<v t="T1481"><vh>canUndo &amp; canRedo</vh></v>
<v t="T1482"><vh>canUnmarkAll</vh></v>
</v>
<v><vh>Expand &amp; Contract</vh>
<v><vh>Commands</vh>
<v t="T2198"><vh>contractAllHeadlines</vh></v>
<v t="T2199"><vh>contractAllSubheads</vh></v>
<v t="T2200"><vh>contractParent</vh></v>
<v t="T1100" a="C"><vh>contractSubheads</vh></v>
<v t="T2201"><vh>expandLevel1</vh></v>
<v t="T2202"><vh>expandLevel2</vh></v>
<v t="T2203"><vh>expandLevel3</vh></v>
<v t="T2204"><vh>expandLevel4</vh></v>
<v t="T2205"><vh>expandLevel5</vh></v>
<v t="T2206"><vh>expandLevel6</vh></v>
<v t="T2207"><vh>expandLevel7</vh></v>
<v t="T2208"><vh>expandLevel8</vh></v>
<v t="T2209"><vh>expandLevel9</vh></v>
<v t="T2210"><vh>expandNextLevel</vh></v>
<v t="T2211"><vh>expandAllHeadlines</vh></v>
<v t="T2212"><vh>expandAllSubheads</vh></v>
<v t="T2213"><vh>expandSubheads</vh></v>
</v>
<v><vh>Utilities</vh>
<v t="T2214"><vh>contractSubtree</vh></v>
<v t="T2215"><vh>contractVnode</vh></v>
<v t="T2216"><vh>expandSubtree</vh></v>
<v t="T2217"><vh>expandToLevel</vh></v>
<v t="T2218"><vh>expandVnode</vh></v>
<v t="T2219"><vh>expandTreeToLevelFromLevel</vh></v>
</v>
</v>
<v><vh>Getters &amp; Setters</vh>
<v t="T2220"><vh>c.currentVnode</vh></v>
<v t="T2221"><vh>clearAllMarked</vh></v>
<v t="T2222"><vh>clearAllVisited</vh></v>
<v t="T2223"><vh>fileName</vh></v>
<v t="T2224"><vh>isChanged</vh></v>
<v t="T2225"><vh>rootVnode</vh></v>
<v t="T1292" a="C"><vh>setChanged</vh></v>
</v>
<v><vh>Insert, Delete &amp; Clone (Commands)</vh>
<v t="T1805" a="C"><vh>c.checkMoveWithParentWithWarning</vh></v>
<v t="T1055" a="C"><vh>c.deleteHeadline</vh></v>
<v t="T1056" a="C"><vh>c.insertHeadline</vh></v>
<v t="T1862" a="C"><vh>c.clone</vh></v>
<v t="T2226"><vh>c.copyTree</vh></v>
<v t="T2227"><vh>initAllCloneBits</vh></v>
<v t="T2228"><vh>initJoinedClonedBits</vh>
<v t="T2229"><vh>&lt;&lt; init clone bit for v &gt;&gt;</vh></v>
</v>
<v t="T2230"><vh>validateOutline</vh></v>
</v>
<v><vh>Mark &amp; Unmark &amp; goto</vh>
<v t="T2231"><vh>goToNextDirtyHeadline</vh></v>
<v t="T2232"><vh>goToNextMarkedHeadline</vh></v>
<v t="T1890" a="C"><vh>goToNextClone</vh></v>
<v t="T2233"><vh>markChangedHeadlines</vh></v>
<v t="T2234"><vh>markChangedRoots</vh></v>
<v t="T2235"><vh>markAllAtFileNodesDirty</vh></v>
<v t="T2236"><vh>markAtFileNodesDirty</vh></v>
<v t="T1889" a="C"><vh>markClones</vh></v>
<v t="T2237"><vh>markHeadline</vh></v>
<v t="T2238"><vh>markSubheads</vh></v>
<v t="T2239"><vh>unmarkAll</vh></v>
</v>
<v t="T1057" a="C"><vh>Moving, Dragging, Promote, Demote, Sort</vh>
<v t="T1058" a="C"><vh>c.dragAfter</vh></v>
<v t="T1059" a="C"><vh>c.dragToNthChildOf</vh></v>
<v t="T1060" a="C"><vh>c.dragCloneAfter</vh></v>
<v t="T1061" a="C"><vh>c.dragCloneToNthChildOf</vh></v>
<v t="T1062" a="C"><vh>c.sortChildren, sortSiblings</vh>
<v t="T1063"><vh>&lt;&lt; Set the undo info for sortChildren &gt;&gt;</vh></v>
<v t="T1064"><vh>&lt;&lt; Set the undo info for sortSiblings &gt;&gt;</vh></v>
</v>
<v t="T1065"><vh>demote</vh></v>
<v t="T1066"><vh>moveOutlineDown</vh>
<v t="T1067"><vh>&lt;&lt; Move v down &gt;&gt;</vh></v>
</v>
<v t="T1068"><vh>moveOutlineLeft</vh></v>
<v t="T1069"><vh>moveOutlineRight</vh></v>
<v t="T1070"><vh>moveOutlineUp</vh>
<v t="T1071"><vh>&lt;&lt; Move v up &gt;&gt;</vh></v>
</v>
<v t="T1072"><vh>promote</vh></v>
</v>
<v><vh>Selecting &amp; Updating (commands)</vh>
<v t="T1339" a="C"><vh>editVnode (calls tree.editLabel)</vh></v>
<v t="T2240"><vh>endEditing (calls tree.endEditLabel)</vh></v>
<v t="T2241"><vh>selectThreadBack</vh></v>
<v t="T2242"><vh>selectThreadNext</vh></v>
<v t="T2243"><vh>selectVisBack</vh></v>
<v t="T2244"><vh>selectVisNext</vh></v>
<v t="T1300" a="C"><vh>c.selectVnode (calls tree.select)</vh></v>
<v t="T2245"><vh>selectVnodeWithEditing</vh></v>
</v>
<v t="T2246"><vh>Syntax coloring interface</vh>
<v t="T2247"><vh>updateSyntaxColorer</vh></v>
</v>
</v>
<v t="T2248"><vh>@file leoCompare.py</vh>
<v t="T2249"><vh>choose</vh></v>
<v t="T2250"><vh>go</vh></v>
<v t="T2251"><vh>class leoCompare</vh>
<v t="T2252"><vh>compare.__init__</vh></v>
<v t="T2253"><vh>compare_directories (entry)</vh></v>
<v t="T1144" a="C"><vh>compare_files (entry)</vh></v>
<v t="T2254"><vh>compare_lines</vh></v>
<v t="T2255"><vh>compare_open_files</vh>
<v t="T2256"><vh>&lt;&lt; handle opening lines &gt;&gt;</vh></v>
<v t="T2257"><vh>&lt;&lt; ignore blank lines and/or sentinels &gt;&gt;</vh></v>
<v t="T2258"><vh>&lt;&lt; print matches and/or mismatches &gt;&gt;</vh></v>
<v t="T2259"><vh>&lt;&lt; warn if mismatch limit reached &gt;&gt;</vh></v>
<v t="T2260"><vh>&lt;&lt; handle reporting after at least one eof is seen &gt;&gt;</vh></v>
</v>
<v t="T2261"><vh>filecmp</vh></v>
<v><vh>utils...</vh>
<v t="T2262"><vh>doOpen</vh></v>
<v t="T2263"><vh>dump</vh></v>
<v t="T2264"><vh>dumpToEndOfFile</vh></v>
<v t="T2265"><vh>isLeoHeader &amp; isSentinel</vh></v>
<v t="T1145" a="C"><vh>openOutputFile (compare)</vh></v>
<v t="T2266"><vh>show</vh></v>
<v t="T2267"><vh>showIvars</vh></v>
</v>
</v>
<v t="T2268"><vh>class leoComparePanel</vh>
<v t="T2269"><vh>browser</vh></v>
<v t="T2270"><vh>comparePanel.__init__</vh></v>
<v t="T1142" a="C"><vh>finishCreate</vh></v>
<v t="T2271"><vh>run</vh>
<v t="T2272"><vh>&lt;&lt; create the organizer frames &gt;&gt;</vh></v>
<v t="T2273"><vh>&lt;&lt; create the browser rows &gt;&gt;</vh></v>
<v t="T2274"><vh>&lt;&lt; create the extension row &gt;&gt;</vh></v>
<v t="T2275"><vh>&lt;&lt; create the whitespace options frame &gt;&gt;</vh></v>
<v t="T2276"><vh>&lt;&lt; create the print options frame &gt;&gt;</vh></v>
<v t="T2277"><vh>&lt;&lt; create the compare buttons &gt;&gt;</vh></v>
</v>
<v t="T2278"><vh>show</vh></v>
<v t="T1143" a="C"><vh>setIvarsFromWidgets</vh></v>
<v><vh>Event handlers...</vh>
<v t="T2279"><vh>onBrowse...</vh></v>
<v t="T2280"><vh>onClose</vh></v>
<v t="T2281"><vh>onCompare...</vh></v>
<v t="T2282"><vh>onPrintMatchedLines</vh></v>
</v>
</v>
</v>
<v t="T2283"><vh>@file leoConfig.py</vh>
<v t="T2284"><vh>&lt;&lt; define defaultsDict &gt;&gt;</vh></v>
<v t="T1364" a="C"><vh>config.__init__</vh>
<v t="T1365"><vh>&lt;&lt; get the default font &gt;&gt;</vh></v>
<v t="T537" a="C"><vh>&lt;&lt; initialize constant ivars, lists &amp; dicts &gt;&gt; (leoConfig)</vh></v>
<v t="T1366"><vh>&lt;&lt; initialize ivars that may be set by config options &gt;&gt;</vh></v>
</v>
<v><vh>getters/setters</vh>
<v t="T2285"><vh>get...FromDict &amp; setDict</vh></v>
<v t="T2286"><vh>get/setColors</vh></v>
<v t="T2287"><vh>get/setComparePref</vh></v>
<v t="T2288"><vh>get/setFindPref</vh></v>
<v t="T2289"><vh>get/setPref</vh></v>
<v t="T2290"><vh>get/setRecentFiles</vh></v>
<v t="T2291"><vh>get/setWindowPrefs</vh></v>
<v t="T1111" a="C"><vh>config.getFontFromParams</vh></v>
<v t="T2292"><vh>getShortcut</vh></v>
<v t="T2293"><vh>init/Boolean/ConfigParam</vh></v>
<v t="T1884" a="C"><vh>setCommandsFindIvars</vh></v>
<v t="T2294"><vh>setCommandsIvars</vh>
<v t="T2295"><vh>&lt;&lt; set prefs ivars &gt;&gt;</vh></v>
</v>
<v t="T1123" a="C"><vh>setConfigFindIvars</vh></v>
<v t="T2296"><vh>setConfigIvars</vh></v>
</v>
<v t="T2297"><vh>open</vh>
<v t="T2298"><vh>&lt;&lt; get config options &gt;&gt;</vh></v>
<v t="T2299"><vh>&lt;&lt; get recent files &gt;&gt;</vh></v>
<v t="T2300"><vh>&lt;&lt; print options &gt;&gt;</vh></v>
</v>
<v t="T1352" a="C"><vh>update (config)</vh>
<v t="T1353"><vh>&lt;&lt; write recent files section &gt;&gt;</vh></v>
</v>
<v t="T2301"><vh>update_section</vh></v>
</v>
<v t="T2302"><vh>@file leoDialog.py</vh>
<v t="T2303"><vh>dialog.__init__</vh></v>
<v t="T1147" a="C"><vh>aboutLeo</vh>
<v t="T1148"><vh>onAboutLeoUrl</vh></v>
<v t="T1149"><vh>onAboutLeoEmail</vh></v>
</v>
<v t="T2304"><vh>askOk</vh></v>
<v t="T2305"><vh>askOkCancel</vh></v>
<v t="T2306"><vh>askOkCancelNumber</vh></v>
<v t="T2307"><vh>askYesNo</vh></v>
<v t="T2308"><vh>askYesNoCancel</vh></v>
<v t="T2309"><vh>dialog.center</vh></v>
<v t="T2310"><vh>Event handlers &amp; command handlers</vh>
<v t="T2311"><vh>cancelButton, noButton, okButton, yesButton</vh></v>
<v t="T2312"><vh>OnOkCancelKey, OnYesNoKey, OnYesNoCancelKey</vh></v>
<v t="T2313"><vh>setArrowCursor, setDefaultCursor</vh></v>
<v t="T2314"><vh>okNumberButton, cancelNumberButton</vh></v>
</v>
</v>
<v t="T2315"><vh>@file leoFileCommands.py</vh>
<v t="T2316"><vh>leoFileCommands._init_</vh></v>
<v t="T1835" a="C"><vh>Reading</vh>
<v t="T1836"><vh>createVnode</vh></v>
<v t="T1837"><vh>finishPaste (creating join lists could be a problem)</vh>
<v t="T1838"><vh>&lt;&lt; Create join lists of all pasted vnodes &gt;&gt;</vh></v>
<v t="T1839"><vh>&lt;&lt; Recompute clone bits for pasted vnodes &gt;&gt;</vh></v>
</v>
<v t="T1840"><vh>get routines</vh>
<v t="T1443" a="C"><vh>get &amp; match (basic)(leoFileCommands)</vh>
<v t="T1444"><vh>get routines</vh></v>
<v t="T1445"><vh>match routines</vh></v>
</v>
<v t="T1841"><vh>getClipboardHeader</vh></v>
<v t="T1842"><vh>getCloneWindows</vh></v>
<v t="T1843"><vh>getEscapedString</vh></v>
<v t="T1844" a="C"><vh>getFindPanelSettings</vh>
<v t="T1845"><vh>&lt;&lt; Set defaults of all flags &gt;&gt;</vh></v>
</v>
<v t="T1289" a="C"><vh>getGlobals</vh></v>
<v t="T1372" a="C"><vh>getLeoFile (Leo2)</vh>
<v t="T1373"><vh>&lt;&lt; warn on read-only files &gt;&gt;</vh></v>
<v t="T1374"><vh>&lt;&lt; Create join lists of all vnodes &gt;&gt;</vh></v>
</v>
<v t="T1846"><vh>getLeoHeader</vh></v>
<v t="T1371" a="C"><vh>getLeoOutline (from clipboard)</vh></v>
<v t="T1847"><vh>getPosition</vh></v>
<v t="T580" a="C"><vh>getPrefs</vh>
<v t="T536" a="C"><vh>&lt;&lt; check for syntax coloring prefs &gt;&gt; (getPrefs)</vh></v>
</v>
<v t="T1848"><vh>getSize</vh></v>
<v t="T1849"><vh>getT</vh></v>
<v t="T1850"><vh>getTnode</vh></v>
<v t="T1851"><vh>getTnodes</vh></v>
<v t="T1852"><vh>getVnode (Leo2)</vh>
<v t="T1853"><vh>&lt;&lt; Handle vnode attribute bits  &gt;&gt;</vh></v>
</v>
<v t="T1854"><vh>getVnodes</vh></v>
<v t="T1446" a="C"><vh>getXmlStylesheetTag</vh></v>
<v t="T1367" a="C"><vh>getXmlVersionTag</vh></v>
<v t="T1855"><vh>skipWs</vh></v>
<v t="T1856"><vh>skipWsAndNl</vh></v>
</v>
<v t="T1857"><vh>newTnode</vh></v>
<v t="T1858"><vh>readAtFileNodes</vh></v>
<v t="T1859"><vh>fileCommands.readOutlineOnly</vh>
<v t="T1322" a="C"><vh>&lt;&lt; Set the default directory &gt;&gt;</vh></v>
</v>
<v t="T1321" a="C"><vh>fileCommands.open</vh>
<v t="T1322" a="C"><vh>&lt;&lt; Set the default directory &gt;&gt;</vh></v>
</v>
<v t="T1860"><vh>xmlUnescape</vh></v>
</v>
<v><vh>Writing</vh>
<v t="T2317"><vh>assignFileIndices</vh></v>
<v t="T2318"><vh>compactFileIndices</vh></v>
<v t="T2319"><vh>shouldCompactOnSave</vh></v>
<v><vh>put routines</vh>
<v t="T2320"><vh>putClipboardHeader</vh>
<v t="T2321"><vh>&lt;&lt; count the number of tnodes &gt;&gt;</vh></v>
</v>
<v t="T1117" a="C"><vh>put (basic)(leoFileCommands)</vh></v>
<v t="T2322"><vh>putEscapedString</vh></v>
<v t="T1118" a="C"><vh>putFindSettings</vh>
<v t="T1119"><vh>&lt;&lt; put find settings that may exist in leoConfig.txt &gt;&gt;</vh></v>
</v>
<v t="T2323"><vh>putGlobals</vh>
<v t="T2324"><vh>&lt;&lt; put the body/outline ratio &gt;&gt;</vh></v>
<v t="T2325"><vh>&lt;&lt; put the position of this frame &gt;&gt;</vh></v>
<v t="T2326"><vh>&lt;&lt; put the position of the log window &gt;&gt;</vh></v>
</v>
<v t="T2327"><vh>putHeader</vh></v>
<v t="T2328"><vh>putLeoOutline (to clipboard)</vh></v>
<v t="T1120" a="C"><vh>putPrefs</vh>
<v t="T1121"><vh>&lt;&lt; put prefs that may exist in leoConfig.txt &gt;&gt; (putPrefs)</vh>
<v t="T1122"><vh>&lt;&lt; put default directory &gt;&gt;</vh></v>
</v>
</v>
<v t="T1368" a="C"><vh>putProlog</vh>
<v t="T1369"><vh>&lt;&lt; Put the &lt;?xml...?&gt; line &gt;&gt;</vh></v>
<v t="T1370"><vh>&lt;&lt; Put the optional &lt;?xml-stylesheet...?&gt; line &gt;&gt;</vh></v>
</v>
<v t="T2329"><vh>putPostlog</vh></v>
<v t="T2330"><vh>putTnodes (Leo2)</vh></v>
<v t="T2331"><vh>putTnode</vh></v>
<v t="T2332"><vh>putVnodes (Leo2)</vh></v>
<v t="T2333"><vh>putVnode (Leo2)</vh>
<v t="T2334"><vh>&lt;&lt; Put tnode index if this vnode has body text &gt;&gt;</vh></v>
<v t="T2335"><vh>&lt;&lt; Put attribute bits &gt;&gt;</vh></v>
<v t="T2336"><vh>&lt;&lt; write the head text &gt;&gt;</vh></v>
</v>
</v>
<v t="T2337"><vh>save</vh>
<v t="T2338"><vh>&lt;&lt; Set the default directory for new files &gt;&gt;</vh></v>
</v>
<v t="T2339"><vh>saveAs</vh></v>
<v t="T2340"><vh>saveTo</vh></v>
<v t="T2341"><vh>xmlEscape</vh></v>
<v t="T2342"><vh>writeAtFileNodes</vh></v>
<v t="T2343"><vh>writeOutlineOnly</vh></v>
<v t="T1126" a="C"><vh>write_LEO_file</vh>
<v t="T1127"><vh>&lt;&lt; create backup file &gt;&gt;</vh></v>
<v t="T1128"><vh>&lt;&lt; delete backup file &gt;&gt;</vh></v>
<v t="T1129"><vh>&lt;&lt; erase filename and rename backupName to fileName &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T2344"><vh>@file leoFind.py</vh>
<v t="T976" a="C"><vh>&lt;&lt; Theory of operation of find/change &gt;&gt;</vh></v>
<v t="T977" a="C"><vh>find.__init__ (creates find panel)</vh>
<v t="T978"><vh>&lt;&lt; Initialize the leoFind ivars &gt;&gt;</vh></v>
<v t="T979"><vh>&lt;&lt; Create the Find and Change panes &gt;&gt;</vh></v>
<v t="T980"><vh>&lt;&lt; Create two columns of checkboxes &gt;&gt;</vh></v>
<v t="T981"><vh>&lt;&lt; Create two rows of buttons &gt;&gt;</vh></v>
</v>
<v t="T982" a="C"><vh>find.init</vh>
<v t="T983"><vh>&lt;&lt; set widgets &gt;&gt;</vh></v>
</v>
<v t="T1125" a="C"><vh>find.set_ivars</vh></v>
<v t="T984" a="C"><vh>resetWrap</vh></v>
<v t="T2345"><vh>OnCloseFindEvent</vh></v>
<v t="T985" a="C"><vh>Top Level Commands</vh>
<v t="T986"><vh>changeButton</vh></v>
<v t="T987"><vh>changeAllButton</vh></v>
<v t="T988"><vh>changeThenFindButton</vh></v>
<v t="T989"><vh>findButton</vh></v>
<v t="T990"><vh>findAllButton</vh></v>
<v t="T991"><vh>changeCommand</vh></v>
<v t="T992"><vh>changeThenFindCommandd</vh></v>
<v t="T993"><vh>findNextCommand</vh></v>
<v t="T994"><vh>fndPreviousCommand</vh></v>
<v t="T995"><vh>setup_button</vh></v>
<v t="T996"><vh>setup_command</vh></v>
</v>
<v t="T997" a="C"><vh>Utilities</vh>
<v t="T998" a="C"><vh>batchChange</vh>
<v t="T999"><vh>&lt;&lt; set the undo head params &gt;&gt;</vh></v>
<v t="T1000"><vh>&lt;&lt; set the undo body typing params &gt;&gt;</vh></v>
</v>
<v t="T1001"><vh>change</vh></v>
<v t="T1002" a="C"><vh>changeAll</vh></v>
<v t="T1003" a="C"><vh>changeSelection</vh></v>
<v t="T1004"><vh>changeThenFind</vh></v>
<v t="T1005"><vh>findAll</vh></v>
<v t="T1006"><vh>findNext</vh></v>
<v t="T1007" a="C"><vh>findNextMatch</vh></v>
<v t="T1008"><vh>selectNextVnode</vh></v>
<v t="T1009"><vh>search</vh>
<v t="T1010"><vh>&lt;&lt; search again after getting stuck going backward &gt;&gt;</vh></v>
<v t="T1011"><vh>&lt;&lt; return if we are passed the wrap point &gt;&gt;</vh></v>
<v t="T1012"><vh>&lt;&lt; test for whole word match &gt;&gt;</vh></v>
</v>
<v t="T1013"><vh>Initializing &amp; finalizing &amp; selecting</vh>
<v t="T1014"><vh>checkArgs</vh></v>
<v t="T1015"><vh>initBatchCommands</vh></v>
<v t="T1016"><vh>initBatchText &amp; initNextText</vh></v>
<v t="T1017"><vh>initInHeadline</vh></v>
<v t="T1018"><vh>initInteractiveCommands</vh></v>
<v t="T1019"><vh>printLine</vh></v>
<v t="T1020"><vh>restore</vh></v>
<v t="T1021"><vh>save</vh></v>
<v t="T1022"><vh>showSuccess</vh></v>
</v>
</v>
</v>
<v t="T2346"><vh>@file leoFontPanel.py</vh>
<v t="T2347"><vh>fontPanel.__init__</vh></v>
<v t="T2348"><vh>create_outer</vh>
<v t="T2349"><vh>&lt;&lt; create the organizer frames &gt;&gt;</vh></v>
<v t="T2350"><vh>&lt;&lt; create the font pane &gt;&gt;</vh></v>
<v t="T2351"><vh>&lt;&lt; create the checkboxes &gt;&gt;</vh></v>
<v t="T2352"><vh>&lt;&lt; create Ok, Cancel and Revert buttons &gt;&gt;</vh></v>
</v>
<v t="T2353"><vh>finishCreate</vh></v>
<v t="T2354"><vh>getActiveFont</vh></v>
<v t="T2355"><vh>getFontSettings</vh></v>
<v t="T2356"><vh>getImpliedFont</vh></v>
<v t="T2357"><vh>on...BoxChanged</vh></v>
<v t="T1155" a="C"><vh>leoFont.onOk, onCancel, onRevert</vh>
<v t="T1156"><vh>&lt;&lt; update the configuration settings &gt;&gt;</vh></v>
</v>
<v t="T2358"><vh>onSizeEntryKey</vh></v>
<v t="T2359"><vh>revertIvars</vh></v>
<v t="T2360"><vh>run</vh></v>
<v t="T2361"><vh>selectFont</vh></v>
<v t="T2362"><vh>setRevertVars</vh></v>
<v t="T2363"><vh>showSettings</vh></v>
<v t="T2364"><vh>update</vh></v>
</v>
<v t="T2365"><vh>@file leoFrame.py</vh>
<v><vh>Birth &amp; Death</vh>
<v t="T1483" a="C"><vh>frame.__del__</vh></v>
<v t="T954" a="C"><vh>frame.__init__</vh>
<v t="T955" a="C"><vh>&lt;&lt; set the LeoFrame ivars &gt;&gt;</vh></v>
<v t="T956"><vh>&lt;&lt; create the first tree node &gt;&gt;</vh></v>
</v>
<v t="T2366"><vh>frame.__repr__</vh></v>
<v t="T884" a="C"><vh>frame.destroy</vh></v>
</v>
<v><vh>Configuration</vh>
<v t="T2367"><vh>f.configureBar</vh></v>
<v t="T1656" a="C"><vh>f.configureBarsFromConfig</vh></v>
<v t="T1657" a="C"><vh>f.reconfigureFromConfig</vh></v>
<v t="T1658" a="C"><vh>f.setBodyFontFromConfig</vh></v>
<v t="T1659" a="C"><vh>f.setLogFontFromConfig</vh></v>
<v t="T1337" a="C"><vh>f.setTabWidth</vh></v>
<v t="T2368"><vh>f.setTreeColorsFromConfig</vh></v>
<v t="T2369"><vh>reconfigurePanes (use config bar_width)</vh></v>
</v>
<v t="T1313" a="C"><vh>Event handlers</vh>
<v t="T885" a="C"><vh>frame.OnCloseLeoEvent</vh>
<v t="T886"><vh>&lt;&lt; Prompt for change.  Set veto if the user cancels &gt;&gt;</vh>
<v t="T887"><vh>&lt;&lt; Put up a file save dialog; set veto if the user cancels &gt;&gt;</vh></v>
</v>
</v>
<v t="T1314"><vh>OnActivateBody &amp; OnBodyDoubleClick</vh></v>
<v t="T1315"><vh>OnActivateLeoEvent, OnDeactivateLeoEvent</vh></v>
<v t="T1316"><vh>OnActivateLog</vh></v>
<v t="T1317"><vh>OnActivateTree</vh></v>
<v t="T1318" a="C"><vh>frame.OnControlKeyUp/Down</vh></v>
<v t="T1319"><vh>OnMouseWheel (Tomaz Ficko)</vh></v>
<v t="T1320" a="C"><vh>frame.OnVisibility</vh></v>
</v>
<v t="T1484" a="C"><vh>Menus, Commands &amp; Shortcuts</vh>
<v t="T1485" a="C"><vh>canonicalizeShortcut</vh>
<v t="T1486"><vh>&lt;&lt; canonicalize the last field &gt;&gt;</vh>
<v t="T1487"><vh>&lt;&lt; define dict of Tk bind names &gt;&gt;</vh></v>
<v t="T1488"><vh>&lt;&lt; define dict of special names &gt;&gt;</vh></v>
</v>
<v t="T1489"><vh>&lt;&lt; set the last field, preserving case &gt;&gt;</vh></v>
<v t="T1490"><vh>&lt;&lt; synthesize the shortcuts from the information &gt;&gt;</vh></v>
</v>
<v t="T1491" a="C"><vh>createMenuBar</vh>
<v t="T1492"><vh>&lt;&lt; create the edit menu &gt;&gt;</vh>
<v t="T1493"><vh>&lt;&lt; create the first top-level edit entries &gt;&gt;</vh></v>
<v t="T1494"><vh>&lt;&lt; create the edit body submenu &gt;&gt;</vh></v>
<v t="T1495"><vh>&lt;&lt; create the edit headline submenu &gt;&gt;</vh></v>
<v t="T1496"><vh>&lt;&lt; create the find submenu &gt;&gt;</vh></v>
<v t="T1497"><vh>&lt;&lt; create the last top-level edit entries &gt;&gt;</vh></v>
</v>
<v t="T1498"><vh>&lt;&lt; create the file menu &gt;&gt;</vh>
<v t="T1499"><vh>&lt;&lt; create the top-level file entries &gt;&gt;</vh></v>
<v t="T1500"><vh>&lt;&lt; create the recent files submenu &gt;&gt;</vh></v>
<v t="T1501"><vh>&lt;&lt; create the read/write submenu &gt;&gt;</vh></v>
<v t="T1502"><vh>&lt;&lt; create the tangle submenu &gt;&gt;</vh></v>
<v t="T1503"><vh>&lt;&lt; create the untangle submenu &gt;&gt;</vh></v>
<v t="T1504"><vh>&lt;&lt; create the import submenu &gt;&gt;</vh></v>
<v t="T1505"><vh>&lt;&lt; create the export submenu &gt;&gt;</vh></v>
</v>
<v t="T1506"><vh>&lt;&lt; create the outline menu &gt;&gt;</vh>
<v t="T1507"><vh>&lt;&lt; create top-level outline menu &gt;&gt;</vh></v>
<v t="T1508"><vh>&lt;&lt; create expand submenu &gt;&gt;</vh></v>
<v t="T1509"><vh>&lt;&lt; create contract submenu &gt;&gt;</vh></v>
<v t="T1510"><vh>&lt;&lt; create move submenu &gt;&gt;</vh></v>
<v t="T1511"><vh>&lt;&lt; create mark submenu &gt;&gt;</vh></v>
<v t="T1512"><vh>&lt;&lt; create goto submenu &gt;&gt;</vh></v>
</v>
<v t="T1513"><vh>&lt;&lt; create the window menu &gt;&gt;</vh></v>
<v t="T1514"><vh>&lt;&lt; create the help menu &gt;&gt;</vh></v>
</v>
<v t="T872" a="C"><vh>createMenuEntries</vh>
<v t="T873"><vh>&lt;&lt; get menu and bind shortcuts &gt;&gt;</vh></v>
</v>
<v t="T1515" a="C"><vh>createRecentFilesMenuItems</vh></v>
<v t="T864" a="C"><vh>frame.doCommand</vh></v>
<v t="T1516" a="C"><vh>get/set/destroyMenu</vh></v>
<v t="T1517"><vh>Menu Command Handlers</vh>
<v t="T1518"><vh>File Menu</vh>
<v t="T1519"><vh>top level</vh>
<v t="T1283" a="C"><vh>OnNew</vh></v>
<v t="T1520"><vh>frame.OnOpen</vh>
<v t="T1521"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="T877" a="C"><vh>frame.OnOpenWith</vh>
<v t="T878"><vh>&lt;&lt; set ext based on the present language &gt;&gt;</vh></v>
<v t="T879"><vh>&lt;&lt; set path to the full pathname of a temp file using ext &gt;&gt;</vh></v>
<v t="T880"><vh>&lt;&lt; execute a command to open path &gt;&gt;</vh></v>
</v>
<v t="T1347" a="C"><vh>frame.OpenWithFileName</vh>
<v t="T1348"><vh>&lt;&lt; make fileName the most recent file of frame &gt;&gt;</vh></v>
</v>
<v t="T1050" a="C"><vh>OnClose</vh></v>
<v t="T1522"><vh>OnSave</vh></v>
<v t="T1523"><vh>OnSaveAs</vh></v>
<v t="T1524"><vh>OnSaveTo</vh></v>
<v t="T967" a="C"><vh>OnRevert</vh></v>
<v t="T888" a="C"><vh>frame.OnQuit</vh></v>
</v>
<v t="T1525" a="C"><vh>Recent Files submenu</vh>
<v t="T1347" a="C"><vh>frame.OpenWithFileName</vh>
<v t="T1348"><vh>&lt;&lt; make fileName the most recent file of frame &gt;&gt;</vh></v>
</v>
<v t="T1345" a="C"><vh>frame.OnOpenRecentFile</vh>
<v t="T1346"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
</v>
<v t="T1526"><vh>Read/Write submenu</vh>
<v t="T1527"><vh>fileCommands.OnReadOutlineOnly</vh></v>
<v t="T1528"><vh>OnReadAtFileNodes</vh></v>
<v t="T1529"><vh>OnWriteOutlineOnly</vh></v>
<v t="T1530"><vh>OnWriteAtFileNodes</vh></v>
</v>
<v t="T1531"><vh>Tangle submenu</vh>
<v t="T1532"><vh>OnTangleAll</vh></v>
<v t="T1533"><vh>OnTangleMarked</vh></v>
<v t="T1534"><vh>OnTangle</vh></v>
</v>
<v t="T1535"><vh>Untangle submenu</vh>
<v t="T1536"><vh>OnUntangleAll</vh></v>
<v t="T1537"><vh>OnUntangleMarked</vh></v>
<v t="T1538"><vh>OnUntangle</vh></v>
</v>
<v t="T1539"><vh>Import&amp;Export submenu</vh>
<v t="T1540" a="C"><vh>OnExportHeadlines</vh></v>
<v t="T1541"><vh>OnFlattenOutline</vh></v>
<v t="T1542"><vh>OnImportAtRoot</vh></v>
<v t="T1543"><vh>OnImportAtFile</vh></v>
<v t="T1544"><vh>OnImportCWEBFiles</vh></v>
<v t="T1545"><vh>OnImportFlattenedOutline</vh></v>
<v t="T1546"><vh>OnImportNowebFiles</vh></v>
<v t="T1547"><vh>OnOutlineToCWEB</vh></v>
<v t="T1548"><vh>OnOutlineToNoweb</vh></v>
<v t="T1549"><vh>OnRemoveSentinels</vh></v>
<v t="T1550"><vh>OnWeave</vh></v>
</v>
</v>
<v t="T1551"><vh>Edit Menu (change to handle log pane too)</vh>
<v t="T1552"><vh>Edit top level</vh>
<v t="T1553"><vh>OnUndo</vh></v>
<v t="T1554"><vh>OnRedo</vh></v>
<v t="T953" a="C"><vh>frame.OnCut, OnCutFrom Menu</vh></v>
<v t="T952" a="C"><vh>frame.OnCopy, OnCopyFromMenu</vh></v>
<v t="T951" a="C"><vh>frame.OnPaste, OnPasteNode, OnPasteFromMenu</vh></v>
<v t="T968" a="C"><vh>OnDelete</vh></v>
<v t="T970" a="C"><vh>OnExecuteScript</vh></v>
<v t="T736" a="C"><vh>OnGoToLineNumber &amp; allies</vh>
<v t="T737"><vh>&lt;&lt; set root to the nearest @file, @silentfile or @rawfile ancestor node &gt;&gt;</vh></v>
<v t="T738"><vh>&lt;&lt; read the file into lines &gt;&gt;</vh></v>
<v t="T739"><vh>&lt;&lt; get n, the line number, from a dialog &gt;&gt;</vh></v>
<v t="T740"><vh>&lt;&lt; count outline lines, setting v,n2,found &gt;&gt;</vh></v>
<v t="T741"><vh>&lt;&lt; set v to the node whose headline is vnodeName &gt;&gt;</vh></v>
<v t="T742"><vh>&lt;&lt; select v and make it visible &gt;&gt;</vh></v>
<v t="T743"><vh>&lt;&lt; put the cursor on line n2 of the body text &gt;&gt;</vh></v>
<v t="T744"><vh>convertLineToVnodeAndLine</vh>
<v t="T745"><vh>&lt;&lt; set delim, leoLine from the @+leo line &gt;&gt;</vh></v>
<v t="T746"><vh>&lt;&lt; scan back to  @+node, setting offset,nodeSentinelLine &gt;&gt;</vh>
<v t="T747"><vh>&lt;&lt; handle delim while scanning backward &gt;&gt;</vh></v>
</v>
<v t="T748"><vh>&lt;&lt; set vnodeName from s &gt;&gt;</vh></v>
</v>
<v t="T749"><vh>skipToMatchingSentinel</vh></v>
</v>
<v t="T1555"><vh>OnSelectAll</vh></v>
<v t="T1154" a="C"><vh>OnFontPanel</vh></v>
<v t="T1153" a="C"><vh>OnColorPanel</vh></v>
<v t="T1556"><vh>OnViewAllCharacters</vh></v>
<v t="T1152" a="C"><vh>OnPreferences</vh></v>
</v>
<v t="T1557"><vh>Edit Body submenu</vh>
<v t="T1558"><vh>OnConvertBlanks &amp; OnConvertAllBlanks</vh></v>
<v t="T1559"><vh>OnConvertTabs &amp; OnConvertAllTabs</vh></v>
<v t="T1560"><vh>OnDedent</vh></v>
<v t="T1561"><vh>OnExtract</vh></v>
<v t="T1562"><vh>OnExtractNames</vh></v>
<v t="T1563"><vh>OnExtractSection</vh></v>
<v t="T1564"><vh>OnFindMatchingBracket</vh>
<v t="T1565"><vh>findMatchingBracket</vh></v>
</v>
<v t="T1566"><vh>OnIndent</vh></v>
<v t="T1567" a="C"><vh>OnInsertGraphicFile</vh></v>
</v>
<v t="T1568"><vh>Edit Headline submenu</vh>
<v t="T1569"><vh>OnEditHeadline</vh></v>
<v t="T1570"><vh>OnEndEditHeadline</vh></v>
<v t="T1571"><vh>OnAbortEditHeadline</vh></v>
</v>
<v t="T1572"><vh>Find submenu (frame methods)</vh>
<v t="T1573"><vh>OnFindPanel</vh></v>
<v t="T1574"><vh>OnFindNext</vh></v>
<v t="T1575"><vh>OnFindPrevious</vh></v>
<v t="T1576"><vh>OnReplace</vh></v>
<v t="T1577"><vh>OnReplaceThenFind</vh></v>
</v>
</v>
<v t="T1578"><vh>Outline Menu</vh>
<v t="T1579"><vh>top level</vh>
<v t="T1580"><vh>OnCutNode</vh></v>
<v t="T1581"><vh>OnCopyNode</vh></v>
<v t="T1582"><vh>OnPasteNodee</vh></v>
<v t="T1583"><vh>OnDeleteNode</vh></v>
<v t="T1584"><vh>OnInsertNode</vh></v>
<v t="T1585"><vh>OnCloneNode</vh></v>
<v t="T1586"><vh>OnSortChildren, OnSortSiblings</vh></v>
</v>
<v t="T1587"><vh>Expand/Contract</vh>
<v t="T1588"><vh>OnContractParent</vh></v>
<v t="T1589"><vh>OnExpandAll</vh></v>
<v t="T1590"><vh>OnExpandAllChildren</vh></v>
<v t="T1591"><vh>OnExpandChildren</vh></v>
<v t="T1592"><vh>OnContractAll</vh></v>
<v t="T1593"><vh>OnContractAllChildren</vh></v>
<v t="T1099" a="C"><vh>OnContractChildren</vh></v>
<v t="T1594"><vh>OnExpandNextLevel</vh></v>
<v t="T1595"><vh>OnExpandToLevel1</vh></v>
<v t="T1596"><vh>OnExpandToLevel2</vh></v>
<v t="T1597"><vh>OnExpandToLevel3</vh></v>
<v t="T1598"><vh>OnExpandToLevel4</vh></v>
<v t="T1599"><vh>OnExpandToLevel5</vh></v>
<v t="T1600"><vh>OnExpandToLevel6</vh></v>
<v t="T1601"><vh>OnExpandToLevel7</vh></v>
<v t="T1602"><vh>OnExpandToLevel8</vh></v>
<v t="T1603"><vh>OnExpandToLevel9</vh></v>
</v>
<v t="T1604"><vh>Move/Select</vh>
<v t="T1605"><vh>OnMoveDownwn</vh></v>
<v t="T1606"><vh>OnMoveLeft</vh></v>
<v t="T1607"><vh>OnMoveRight</vh></v>
<v t="T1608"><vh>OnMoveUp</vh></v>
<v t="T1609"><vh>OnPromote</vh></v>
<v t="T1610"><vh>OnDemote</vh></v>
<v t="T1611"><vh>OnGoPrevVisible</vh></v>
<v t="T1612"><vh>OnGoNextVisible</vh></v>
<v t="T1613"><vh>OnGoBack</vh></v>
<v t="T1614"><vh>OnGoNext</vh></v>
</v>
<v t="T1615"><vh>Mark/Goto</vh>
<v t="T1616"><vh>OnMark</vh></v>
<v t="T1617"><vh>OnMarkSubheads</vh></v>
<v t="T1618"><vh>OnMarkChangedItems</vh></v>
<v t="T1619"><vh>OnMarkChangedRoots</vh></v>
<v t="T1620" a="C"><vh>OnMarkClones</vh></v>
<v t="T1621"><vh>OnUnmarkAll</vh></v>
<v t="T1622"><vh>OnGoToNextMarked</vh></v>
<v t="T1623"><vh>OnGoToNextChanged</vh></v>
<v t="T1624" a="C"><vh>OnGoToNextClone</vh></v>
</v>
</v>
<v t="T1625"><vh>Window Menu</vh>
<v t="T1626"><vh>OnEqualSizedPanes</vh></v>
<v t="T1627"><vh>OnToggleActivePane</vh></v>
<v t="T1324" a="C"><vh>OnToggleSplitDirection</vh></v>
<v t="T1628"><vh>OnCascade</vh></v>
<v t="T1629"><vh>OnMinimizeAll</vh></v>
<v t="T1630"><vh>OnHideLogWindow</vh></v>
<v t="T1141" a="C"><vh>OnOpenCompareWindow</vh></v>
<v t="T1106" a="C"><vh>OnOpenPythonWindow (Dave Hein)</vh>
<v t="T1107"><vh>&lt;&lt; open idle in Linux &gt;&gt;</vh></v>
<v t="T1108"><vh>&lt;&lt; open idle in Windows &gt;&gt;</vh></v>
<v t="T1109"><vh>leoPyShellMain</vh></v>
</v>
</v>
<v t="T1631"><vh>Help Menu</vh>
<v t="T1146" a="C"><vh>OnAbout (version number &amp; date)</vh></v>
<v t="T1632"><vh>OnLeoDocumentation</vh></v>
<v t="T1633"><vh>OnLeoHome</vh></v>
<v t="T1634"><vh>OnLeoHelp</vh>
<v t="T1635"><vh>showProgressBar</vh>
<v t="T1636"><vh>&lt;&lt; create the scale widget &gt;&gt;</vh></v>
</v>
</v>
<v t="T1637"><vh>OnLeoTutorial (version number)</vh></v>
<v t="T1638" a="C"><vh>OnLeoConfig, OnApplyConfig</vh></v>
</v>
</v>
<v t="T1639" a="C"><vh>Menu Convenience Routines</vh>
<v t="T874" a="C"><vh>createMenuItemsFromTable</vh></v>
<v t="T1640" a="C"><vh>createNewMenu</vh></v>
<v t="T875" a="C"><vh>createOpenWithMenuFromTable</vh></v>
<v t="T1641"><vh>deleteMenu</vh></v>
<v t="T1642"><vh>deleteMenuItem</vh></v>
<v t="T1643"><vh>setRealMenuNamesFromTable</vh></v>
</v>
<v t="T1644" a="C"><vh>Menu enablers (Frame)</vh>
<v t="T865" a="C"><vh>frame.OnMenuClick (enables and disables all menu items)</vh></v>
<v t="T1645"><vh>hasSelection</vh></v>
<v t="T1646"><vh>updateFileMenu</vh></v>
<v t="T1647"><vh>updateEditMenu</vh></v>
<v t="T1648"><vh>updateOutlineMenu</vh></v>
</v>
</v>
<v t="T1649" a="C"><vh>Splitter stuff</vh>
<v t="T1325" a="C"><vh>resizePanesToRatio</vh></v>
<v t="T1650"><vh>bindBar</vh></v>
<v t="T1112" a="C"><vh>createBothLeoSplitters</vh>
<v t="T1113" a="C"><vh>&lt;&lt; create the body pane &gt;&gt;</vh></v>
<v t="T1114"><vh>&lt;&lt; create the tree pane &gt;&gt;</vh></v>
<v t="T1115"><vh>&lt;&lt; create the log pane &gt;&gt;</vh></v>
</v>
<v t="T1651"><vh>createLeoSplitter</vh></v>
<v t="T1652"><vh>divideAnySplitter</vh></v>
<v t="T1653"><vh>divideLeoSplitter</vh></v>
<v t="T1323" a="C"><vh>initialRatios</vh></v>
<v t="T1654"><vh>onDrag...</vh></v>
<v t="T1655"><vh>placeSplitter</vh></v>
</v>
<v t="T2370"><vh>frame.longFileName &amp; shortFileName</vh></v>
<v t="T890" a="C"><vh>frame.put, putnl</vh></v>
<v t="T2371"><vh>getFocus</vh></v>
<v t="T2372"><vh>notYet</vh></v>
</v>
<v t="T2373"><vh>@file leoGlobals.py</vh>
<v t="T2374"><vh>&lt;&lt; define general constants &gt;&gt;</vh></v>
<v t="T1868" a="C"><vh>collectGarbage</vh></v>
<v><vh>Commands, Dialogs, Directives, &amp; Menus...</vh>
<v><vh>Dialog utils...</vh>
<v t="T1886" a="C"><vh>attachLeoIcon &amp; allies</vh>
<v t="T1887"><vh>createLeoIcon</vh></v>
<v t="T1888"><vh>onVisibility</vh></v>
</v>
<v t="T2375"><vh>get_window_info</vh></v>
<v t="T2376"><vh>center_dialog</vh></v>
<v t="T1132" a="C"><vh>create_labeled_frame</vh></v>
</v>
<v><vh>Directives...</vh>
<v><vh>@language and @comment directives (leoUtils)</vh>
<v t="T538" a="C"><vh>set_delims_from_language</vh></v>
<v t="T2377"><vh>set_delims_from_string</vh></v>
<v t="T539" a="C"><vh>set_language</vh></v>
</v>
<v t="T1454" a="C"><vh>get_directives_dict</vh>
<v t="T1455"><vh>&lt;&lt; set dict for @ directives &gt;&gt;</vh></v>
<v t="T1456"><vh>&lt;&lt; set dict["root"] for noweb * chunks &gt;&gt;</vh></v>
</v>
<v t="T1718" a="C"><vh>scanDirectives (utils)</vh>
<v t="T1719"><vh>&lt;&lt; Set local vars &gt;&gt;</vh></v>
<v t="T1720"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="T1721"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="T1722"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="T1723"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
</v>
<v t="T1724"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
</v>
<v t="T2378"><vh>findReference</vh></v>
</v>
<v><vh>Menus...</vh>
<v t="T1921" a="C"><vh>canonicalizeMenuName</vh></v>
<v t="T1922" a="C"><vh>enableMenu &amp; disableMenu &amp; setMenuLabel</vh></v>
</v>
<v t="T2379"><vh>sortSequence</vh></v>
<v t="T1026" a="C"><vh>wrap_lines</vh>
<v t="T1027"><vh>&lt;&lt; place blank and word on the present line &gt;&gt;</vh></v>
<v t="T1028"><vh>&lt;&lt; place word on a new line &gt;&gt;</vh></v>
</v>
</v>
<v><vh>Dumping, Timing, Tracing &amp; Sherlock</vh>
<v t="T2380"><vh>alert</vh></v>
<v t="T2381"><vh>angleBrackets &amp; virtual_event_name</vh></v>
<v t="T2382"><vh>dump</vh></v>
<v t="T2383"><vh>es_exception</vh></v>
<v t="T2384"><vh>get_line &amp; get_line_after</vh></v>
<v t="T2385"><vh>printBindings</vh></v>
<v t="T2386"><vh>printGlobals</vh></v>
<v t="T2387"><vh>printLeoModules</vh></v>
<v t="T2388"><vh>Sherlock...</vh>
<v t="T2389"><vh>get_Sherlock_args</vh></v>
<v t="T2390"><vh>init_trace</vh></v>
<v t="T2391"><vh>trace</vh></v>
</v>
<v t="T2392"><vh>Timing</vh></v>
</v>
<v><vh>Files &amp; Directories...</vh>
<v t="T2393"><vh>create_temp_name</vh></v>
<v t="T2394"><vh>ensure_extension</vh></v>
<v t="T1177" a="C"><vh>getBaseDirectory</vh></v>
<v t="T1662" a="C"><vh>getUserNewline</vh></v>
<v t="T1205" a="C"><vh>makeAllNonExistentDirectories</vh></v>
<v t="T2395"><vh>readlineForceUnixNewline (Steven P. Schaefer)</vh></v>
<v t="T876" a="C"><vh>sanitize_filename</vh></v>
<v t="T2396"><vh>shortFileName</vh></v>
<v t="T1441" a="C"><vh>update_file_if_changed</vh></v>
<v t="T1208" a="C"><vh>utils_rename</vh></v>
</v>
<v><vh>Hooks</vh>
<v t="T1343" a="C"><vh>enableIdleTimeHook, disableIdleTimeHook, idleTimeHookHandler</vh></v>
<v t="T1344" a="C"><vh>handleLeoHook</vh></v>
</v>
<v><vh>Lists...</vh>
<v t="T2397"><vh>appendToList</vh></v>
<v t="T2398"><vh>flattenList</vh></v>
<v t="T2399"><vh>listToString</vh></v>
</v>
<v t="T2400"><vh>Most common functions</vh>
<v t="T2401"><vh>app, setApp</vh></v>
<v t="T2402"><vh>choose</vh></v>
<v t="T1735" a="C"><vh>es, enl, ecnl</vh></v>
<v t="T41" a="C"><vh>top</vh></v>
<v><vh>trace is defined below</vh></v>
<v t="T2403"><vh>windows</vh></v>
</v>
<v><vh>Scanning, selection &amp; whitespace...</vh>
<v t="T1905" a="C"><vh>scanAtFileOptions</vh>
<v t="T1906"><vh>&lt;&lt; scan another @file option &gt;&gt;</vh></v>
</v>
<v t="T1907" a="C"><vh>scanAtRootOptions</vh>
<v t="T1908"><vh>&lt;&lt; scan another @root option &gt;&gt;</vh></v>
</v>
<v t="T2404"><vh>scanError</vh></v>
<v t="T2405"><vh>Scanners: calling scanError</vh>
<v t="T2406"><vh>skip_block_comment</vh></v>
<v t="T927" a="C"><vh>skip_braces</vh></v>
<v t="T2407"><vh>skip_php_braces (Dave Hein)</vh></v>
<v t="T2408"><vh>skip_parens</vh></v>
<v t="T2409"><vh>skip_pascal_begin_end</vh></v>
<v t="T2410"><vh>skip_pascal_block_comment</vh></v>
<v t="T2411"><vh>skip_pascal_string : called by tangle</vh></v>
<v t="T2412"><vh>skip_heredoc_string : called by php import (Dave Hein)</vh></v>
<v t="T2413"><vh>skip_pp_directive</vh></v>
<v t="T2414"><vh>skip_pp_if</vh></v>
<v t="T2415"><vh>skip_pp_part</vh></v>
<v t="T2416"><vh>skip_python_string</vh></v>
<v t="T2417"><vh>skip_string : called by tangle</vh></v>
<v t="T2418"><vh>skip_to_semicolon</vh></v>
<v t="T2419"><vh>skip_typedef</vh></v>
</v>
<v><vh>Scanners: no error messages</vh>
<v t="T2420"><vh>escaped</vh></v>
<v t="T928" a="C"><vh>find_line_start</vh></v>
<v t="T2421"><vh>find_on_line</vh></v>
<v t="T2422"><vh>is_c_id</vh></v>
<v t="T2423"><vh>is_nl</vh></v>
<v t="T2424"><vh>is_special</vh></v>
<v t="T2425"><vh>is_ws &amp; is_ws_or_nl</vh></v>
<v t="T2426"><vh>match</vh></v>
<v t="T2427"><vh>match_c_word</vh></v>
<v t="T2428"><vh>match_ignoring_case</vh></v>
<v t="T2429"><vh>match_word</vh></v>
<v t="T2430"><vh>skip_blank_lines</vh></v>
<v t="T2431"><vh>skip_c_id</vh></v>
<v t="T2432"><vh>skip_line, skip_to_end_of_line</vh></v>
<v t="T2433"><vh>skip_long</vh></v>
<v t="T2434"><vh>skip_matching_delims</vh></v>
<v t="T2435"><vh>skip_nl</vh></v>
<v t="T1025" a="C"><vh>skip_non_ws</vh></v>
<v t="T2436"><vh>skip_pascal_braces</vh></v>
<v t="T2437"><vh>skip_ws, skip_ws_and_nl</vh></v>
</v>
<v t="T957" a="C"><vh>Tk.Text selection (utils)</vh>
<v t="T958" a="C"><vh>bound_paragraph</vh></v>
<v t="T959"><vh>getTextSelection</vh></v>
<v t="T960"><vh>getSelectedText</vh></v>
<v t="T961"><vh>setTextSelection</vh></v>
</v>
<v t="T931" a="C"><vh>Whitespace...</vh>
<v t="T932"><vh>computeLeadingWhitespace</vh></v>
<v t="T933" a="C"><vh>computeWidth</vh></v>
<v t="T934" a="C"><vh>get_leading_ws</vh></v>
<v t="T935"><vh>optimizeLeadingWhitespace</vh></v>
<v t="T936"><vh>removeLeadingWhitespace</vh></v>
<v t="T937"><vh>removeTrailingWs</vh></v>
<v t="T938"><vh>skip_leading_ws</vh></v>
<v t="T939"><vh>skip_leading_ws_with_indent</vh></v>
</v>
</v>
<v><vh>Startup &amp; initialization...</vh>
<v t="T2438"><vh>CheckVersion (Dave Hein)</vh></v>
<v t="T2439"><vh>unloadAll</vh></v>
</v>
<v t="T1727" a="C"><vh>Unicode... (utils)</vh>
<v t="T1728"><vh>convertChar/String/ToXMLCharRef</vh></v>
<v t="T1729"><vh>convertStringToUnicode</vh></v>
<v t="T1730"><vh>convertUnicodeToString</vh></v>
<v t="T1731"><vh>es_nonEncodingChar, returnNonEncodingChar</vh></v>
<v t="T1732"><vh>replaceNonEncodingChar/s</vh></v>
</v>
</v>
<v t="T2440"><vh>@file leoImport.py</vh>
<v t="T2441"><vh>import.__init__</vh></v>
<v t="T2442"><vh>&lt;&lt; scripts &gt;&gt;</vh>
<v t="T2074" a="C"><vh>importFiles</vh></v>
</v>
<v><vh>Import</vh>
<v t="T2443"><vh>createOutline</vh>
<v t="T2444"><vh>&lt;&lt; Read file into s &gt;&gt;</vh></v>
</v>
<v t="T2445"><vh>importFilesCommand</vh>
<v t="T2446"><vh>&lt;&lt; Create a parent for two files having a common prefix &gt;&gt;</vh></v>
</v>
<v><vh>importFlattenedOutline &amp; allies</vh>
<v t="T2447"><vh>convertMoreString/StringsToOutlineAfter</vh>
<v t="T2448"><vh>&lt;&lt; Link a new vnode v into the outline &gt;&gt;</vh></v>
<v t="T2449"><vh>&lt;&lt; Set the headline string, skipping over the leader &gt;&gt;</vh></v>
<v t="T2450"><vh>&lt;&lt; Count the number of following body lines &gt;&gt;</vh></v>
<v t="T2451"><vh>&lt;&lt; Add the lines to the body text of v &gt;&gt;</vh></v>
</v>
<v t="T2452"><vh>importFlattenedOutline</vh>
<v t="T2453"><vh>&lt;&lt; Read the file into array &gt;&gt;</vh></v>
</v>
<v t="T2454"><vh>moreHeadlineLevel</vh></v>
<v t="T2455"><vh>stringIs/stringsAreValidMoreFile</vh></v>
</v>
<v><vh>importWebCommand &amp; allies</vh>
<v t="T2456"><vh>createOutlineFromWeb</vh></v>
<v t="T2457"><vh>importWebCommand</vh></v>
<v t="T2458"><vh>findFunctionDef</vh></v>
<v t="T2459"><vh>scanBodyForHeadline</vh>
<v t="T2460"><vh>&lt;&lt; scan cweb body for headline &gt;&gt;</vh></v>
<v t="T2461"><vh>&lt;&lt; scan noweb body for headline &gt;&gt;</vh></v>
</v>
<v t="T2462"><vh>scanWebFile (handles limbo)</vh>
<v t="T2463"><vh>&lt;&lt; Create a symbol table of all section names &gt;&gt;</vh></v>
<v t="T2464"><vh>&lt;&lt; Create nodes for limbo text and the root section &gt;&gt;</vh></v>
<v t="T2465"><vh>&lt;&lt; Create a node for the next module &gt;&gt;</vh>
<v t="T2466"><vh>&lt;&lt; Handle cweb @d, @f, @c and @p directives &gt;&gt;</vh></v>
</v>
</v>
<v><vh>Symbol table</vh>
<v t="T2467"><vh>cstCanonicalize</vh></v>
<v t="T2468"><vh>cstDump</vh></v>
<v t="T2469"><vh>cstEnter</vh></v>
<v t="T2470"><vh>cstLookup</vh></v>
</v>
</v>
<v><vh>Scanners for createOutline</vh>
<v><vh>Python scanners</vh>
<v t="T2471"><vh>scanPythonClass</vh>
<v t="T2472"><vh>&lt;&lt; set classname and headline, or return i &gt;&gt;</vh></v>
<v t="T2473"><vh>&lt;&lt; create class_vnode  &gt;&gt;</vh></v>
<v t="T1230" a="C"><vh>&lt;&lt; create nodes for all defs of the class &gt;&gt;</vh>
<v t="T1231"><vh>&lt;&lt; create parent_vnode &gt;&gt;</vh></v>
</v>
</v>
<v t="T2474"><vh>scanPythonDef</vh>
<v t="T2475"><vh>&lt;&lt; set headline or return i &gt;&gt;</vh></v>
<v t="T2476"><vh>&lt;&lt; skip the Python def &gt;&gt;</vh></v>
<v t="T2477"><vh>&lt;&lt; Create def node &gt;&gt;</vh></v>
</v>
<v t="T2478"><vh>scanPythonDecls</vh>
<v t="T2479"><vh>&lt;&lt; break on def or class &gt;&gt;</vh></v>
<v t="T2480"><vh>&lt;&lt; Create a child node for declarations &gt;&gt;</vh></v>
</v>
<v t="T2481"><vh>scanPythonText</vh>
<v t="T2482"><vh>&lt;&lt; handle possible Python function or class &gt;&gt;</vh></v>
<v t="T2483"><vh>&lt;&lt; Append a reference to the methods of this file &gt;&gt;</vh></v>
<v t="T2484"><vh>&lt;&lt; Append any unused python text to the parent's body text &gt;&gt;</vh></v>
</v>
</v>
<v t="T2485"><vh>scanPHPText (Dave Hein)</vh>
<v t="T2486"><vh>&lt;&lt; Append file if not pure PHP &gt;&gt;</vh></v>
<v t="T2487"><vh>&lt;&lt; define scanPHPText vars &gt;&gt;</vh></v>
<v t="T2488"><vh>&lt;&lt; handle possible heredoc string &gt;&gt;</vh></v>
<v t="T2489"><vh>&lt;&lt; handle possible PHP comments &gt;&gt;</vh></v>
<v t="T2490"><vh>&lt;&lt; handle possible class or function &gt;&gt;</vh></v>
<v t="T2491"><vh>&lt;&lt; handle end of class &gt;&gt;</vh></v>
<v t="T2492"><vh>&lt;&lt; Append any unused text to the parent's body text &gt;&gt;</vh></v>
</v>
<v t="T1232" a="C"><vh>scanCText</vh>
<v t="T1233"><vh>&lt;&lt; define scanCText vars &gt;&gt;</vh></v>
<v t="T1234"><vh>&lt;&lt; handle # sign &gt;&gt;</vh>
<v t="T1235"><vh>&lt;&lt; create a child node for all #include statements &gt;&gt;</vh></v>
</v>
<v t="T1236"><vh>&lt;&lt; handle open curly bracket in C &gt;&gt; (scans function)</vh>
<v t="T1237"><vh>&lt;&lt; create a declaration node &gt;&gt;</vh></v>
<v t="T1238"><vh>&lt;&lt; append C function/method reference to parent node &gt;&gt;</vh></v>
</v>
<v t="T1239"><vh>&lt;&lt; handle id, class, typedef, struct, union, namespace &gt;&gt;</vh>
<v t="T1240"><vh>&lt;&lt; create children for the namespace &gt;&gt;</vh></v>
<v t="T1241"><vh>&lt;&lt; test for operator keyword &gt;&gt;</vh></v>
</v>
<v t="T1242"><vh>&lt;&lt; handle possible C comments &gt;&gt;</vh></v>
<v t="T1243"><vh>&lt;&lt; handle equal sign in C&gt;&gt;</vh></v>
<v t="T1244"><vh>&lt;&lt; handle open paren in C &gt;&gt;</vh></v>
<v t="T1245"><vh>&lt;&lt; handle semicolon in C &gt;&gt;</vh></v>
<v t="T1246" a="C"><vh>&lt;&lt; Append any unused text to the parent's body text &gt;&gt;</vh></v>
</v>
<v t="T1247" a="C"><vh>scanJavaText</vh>
<v t="T1248"><vh>&lt;&lt; define scanJavaText vars &gt;&gt;</vh></v>
<v t="T1249"><vh>&lt;&lt; handle open curly bracket in Java &gt;&gt;</vh>
<v t="T1250"><vh>&lt;&lt; create a Java declaration node &gt;&gt;</vh></v>
<v t="T1229" a="C"><vh>&lt;&lt; append Java method reference to parent node &gt;&gt;</vh></v>
<v t="T1251"><vh>&lt;&lt; recursively scan the text &gt;&gt;</vh></v>
</v>
<v t="T1252"><vh>&lt;&lt; skip and remember the Java id &gt;&gt;</vh></v>
<v t="T1253"><vh>&lt;&lt; handle possible Java comments &gt;&gt;</vh></v>
<v t="T1254"><vh>&lt;&lt; handle equal sign in Java &gt;&gt;</vh></v>
<v t="T1255"><vh>&lt;&lt; handle open paren in Java &gt;&gt;</vh></v>
<v t="T1256"><vh>&lt;&lt; handle semicolon in Java &gt;&gt;</vh></v>
<v t="T1246" a="C"><vh>&lt;&lt; Append any unused text to the parent's body text &gt;&gt;</vh></v>
</v>
<v t="T2493"><vh>scanPascalText</vh>
<v t="T2494"><vh>&lt;&lt; handle possible Pascal function &gt;&gt;</vh>
<v t="T2495"><vh>&lt;&lt; create a child node for leading declarations &gt;&gt;</vh></v>
<v t="T2496"><vh>&lt;&lt; create a child node for the function &gt;&gt;</vh></v>
<v t="T2497"><vh>&lt;&lt; remember the function name, or continue &gt;&gt;</vh></v>
<v t="T2498"><vh>&lt;&lt; skip the function definition, or continue &gt;&gt;</vh>
<v t="T2499"><vh>&lt;&lt; skip past the semicolon &gt;&gt;</vh></v>
</v>
<v t="T2500"><vh>&lt;&lt; append noweb method reference to the parent node &gt;&gt;</vh></v>
</v>
<v t="T1246" a="C"><vh>&lt;&lt; Append any unused text to the parent's body text &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T1663" a="C"><vh>Export</vh>
<v t="T1664"><vh>convertCodePartToWeb</vh>
<v t="T1665"><vh>&lt;&lt; put v's headline ref in head_ref&gt;&gt;</vh></v>
<v t="T1666"><vh>&lt;&lt; put name following @root or @file in file_name &gt;&gt;</vh>
<v t="T1667"><vh>&lt;&lt; Set file_name &gt;&gt;</vh></v>
</v>
<v t="T1668"><vh>&lt;&lt; append ref to file_name &gt;&gt;</vh></v>
<v t="T1669"><vh>&lt;&lt; append head_ref &gt;&gt;</vh></v>
</v>
<v t="T1670"><vh>convertDocPartToWeb (handle @ %def)</vh></v>
<v t="T1671"><vh>convertVnodeToWeb</vh>
<v t="T1672"><vh>&lt;&lt; Supply a missing doc part &gt;&gt;</vh></v>
</v>
<v t="T1673"><vh>copyPart</vh></v>
<v t="T1674" a="C"><vh>exportHeadlines</vh></v>
<v t="T1354" a="C"><vh>flattenOutline</vh></v>
<v t="T1355" a="C"><vh>outlineToWeb</vh></v>
<v t="T1675"><vh>removeSentinelsCommand</vh>
<v t="T1676"><vh>&lt;&lt; Read file into s &gt;&gt;</vh></v>
<v t="T1677"><vh>&lt;&lt; set delims from the header line &gt;&gt;</vh></v>
<v t="T1356" a="C"><vh>&lt;&lt; Write s into newFileName &gt;&gt;</vh></v>
</v>
<v t="T1678"><vh>removeSentinelLines</vh>
<v t="T1679"><vh>&lt;&lt; handle possible sentinel &gt;&gt;</vh></v>
</v>
<v t="T1680"><vh>weave</vh>
<v t="T1357" a="C"><vh>&lt;&lt; open filename to f, or return &gt;&gt;</vh></v>
<v t="T1681"><vh>&lt;&lt; write the context of v to f &gt;&gt;</vh></v>
</v>
</v>
<v><vh>Utilities</vh>
<v t="T2501"><vh>createHeadline</vh></v>
<v t="T2502"><vh>error</vh></v>
<v t="T2503"><vh>getLeadingIndent</vh></v>
<v t="T2504"><vh>isDocStart and isModuleStart</vh></v>
<v t="T2505"><vh>massageBody</vh></v>
<v t="T2506"><vh>massageComment</vh></v>
<v t="T2507"><vh>massageWebBody</vh>
<v t="T2508"><vh>&lt;&lt; Remove most newlines from @space and @* sections &gt;&gt;</vh></v>
<v t="T2509"><vh>&lt;&lt; Replace abbreviated names with full names &gt;&gt;</vh></v>
</v>
<v t="T2510"><vh>skipLeadingComments</vh>
<v t="T2511"><vh>&lt;&lt; scan for C-style comments &gt;&gt;</vh></v>
<v t="T2512"><vh>&lt;&lt; scan for Pascal comments &gt;&gt;</vh></v>
<v t="T2513"><vh>&lt;&lt; scan for Python comments &gt;&gt;</vh></v>
</v>
<v t="T2514"><vh>undentBody</vh></v>
</v>
</v>
<v t="T2515"><vh>@file leoNodes.py</vh>
<v t="T1928" a="C"><vh>&lt;&lt; About the vnode and tnode classes &gt;&gt;</vh></v>
<v t="T1925" a="C"><vh>&lt;&lt; About clones &gt;&gt;</vh></v>
<v t="T2516"><vh>class tnode</vh>
<v t="T2517"><vh>&lt;&lt; tnode constants &gt;&gt;</vh></v>
<v t="T1299" a="C"><vh>t.__init__</vh></v>
<v t="T2518"><vh>t.__del__</vh></v>
<v t="T2519"><vh>t.destroy</vh></v>
<v><vh>Getters</vh>
<v t="T2520"><vh>hasBody</vh></v>
<v t="T1302" a="C"><vh>loadBodyPaneFromTnode</vh></v>
<v><vh>Status bits</vh>
<v t="T2521"><vh>isDirty</vh></v>
<v t="T2522"><vh>isRichTextBit</vh></v>
<v t="T2523"><vh>isVisited</vh></v>
</v>
</v>
<v><vh>Setters</vh>
<v t="T1303" a="C"><vh>Setting body text</vh>
<v t="T1304"><vh>saveBodyPaneToTnode</vh></v>
<v t="T1053" a="C"><vh>setTnodeText</vh></v>
<v t="T1305"><vh>setSelection</vh></v>
</v>
<v><vh>Status bits</vh>
<v t="T2524"><vh>clearDirty</vh></v>
<v t="T2525"><vh>clearRichTextBit</vh></v>
<v t="T2526"><vh>clearVisited</vh></v>
<v t="T2527"><vh>setDirty</vh></v>
<v t="T2528"><vh>setRichTextBit</vh></v>
<v t="T2529"><vh>setVisited</vh></v>
</v>
<v t="T2530"><vh>setCloneIndex</vh></v>
<v t="T2531"><vh>setFileIndex</vh></v>
<v t="T2532"><vh>setJoinHead</vh></v>
</v>
</v>
<v t="T2533"><vh>class vnode</vh>
<v t="T2534"><vh>&lt;&lt; vnode constants &gt;&gt;</vh></v>
<v t="T1350" a="C"><vh>v.__init__</vh>
<v t="T1351"><vh>&lt;&lt; initialize vnode data members &gt;&gt;</vh></v>
</v>
<v t="T2535"><vh>v.__del__</vh></v>
<v t="T2536"><vh>vnode.__repr__</vh></v>
<v t="T2537"><vh>vnode.__cmp__ (not used)</vh></v>
<v t="T882" a="C"><vh>v.destroy</vh></v>
<v t="T2538"><vh>v.Callbacks</vh>
<v t="T2539"><vh>OnBoxClick, OnIconDoubleClick</vh></v>
<v t="T2540"><vh>OnDrag</vh></v>
<v t="T2541"><vh>OnEndDrag</vh></v>
<v t="T1296" a="C"><vh>OnHeadlineClick &amp; OnHeadlinePopup</vh></v>
<v t="T2542"><vh>OnHeadlineKey</vh></v>
<v t="T2543"><vh>OnHyperLinkControlClick</vh></v>
<v t="T2544"><vh>OnHyperLinkEnter</vh></v>
<v t="T2545"><vh>OnHyperLinkLeave</vh></v>
<v t="T2546"><vh>v.OnIconClick</vh></v>
</v>
<v t="T1898" a="C"><vh>Comparisons (vnode)</vh>
<v t="T1899"><vh>afterHeadlineMatch</vh></v>
<v t="T1900"><vh>at/../NodeName</vh></v>
<v t="T1901"><vh>isAt/../Node</vh></v>
<v t="T1902"><vh>isAtIgnoreNode</vh></v>
<v t="T1903"><vh>isAtOthersNode</vh></v>
<v t="T1904"><vh>matchHeadline</vh></v>
</v>
<v><vh>File Conversion (vnode)</vh>
<v t="T2547"><vh>convertTreeToString</vh></v>
<v t="T2548"><vh>moreHead</vh></v>
<v t="T2549"><vh>v.moreBody</vh></v>
</v>
<v><vh>Getters</vh>
<v t="T2550"><vh>bodyString</vh></v>
<v><vh>Children</vh>
<v t="T2551"><vh>childIndex</vh></v>
<v t="T2552"><vh>firstChild</vh></v>
<v t="T2553"><vh>hasChildren</vh></v>
<v t="T2554"><vh>lastChild</vh></v>
<v t="T2555"><vh>nthChild</vh></v>
<v t="T2556"><vh>numberOfChildren (n)</vh></v>
</v>
<v t="T2557"><vh>currentVnode (vnode)</vh></v>
<v t="T2558"><vh>findRoot</vh></v>
<v t="T2559"><vh>getJoinList</vh></v>
<v t="T2560"><vh>headString</vh></v>
<v t="T2561"><vh>isAncestorOf</vh></v>
<v t="T2562"><vh>isRoot</vh></v>
<v><vh>Status Bits</vh>
<v t="T2563"><vh>isCloned</vh></v>
<v t="T2564"><vh>isDirty</vh></v>
<v t="T2565"><vh>isExpanded</vh></v>
<v t="T2566"><vh>isMarked</vh></v>
<v t="T2567"><vh>isOrphan</vh></v>
<v t="T2568"><vh>isSelected</vh></v>
<v t="T2569"><vh>isTopBitSet</vh></v>
<v t="T2570"><vh>isVisible</vh></v>
<v t="T2571"><vh>isVisited</vh></v>
<v t="T2572"><vh>status</vh></v>
</v>
<v><vh>Structure Links</vh>
<v t="T2573"><vh>back</vh></v>
<v t="T2574"><vh>lastNode</vh></v>
<v t="T2575"><vh>level</vh></v>
<v t="T2576"><vh>next</vh></v>
<v t="T2577"><vh>nodeAfterTree</vh></v>
<v t="T2578"><vh>parent</vh></v>
<v t="T2579"><vh>threadBack</vh></v>
<v t="T2580"><vh>threadNext</vh></v>
<v t="T2581"><vh>visBack</vh></v>
<v t="T2582"><vh>visNext</vh></v>
</v>
</v>
<v><vh>Setters</vh>
<v><vh>Head and body text</vh>
<v t="T2583"><vh>appendStringToBody</vh></v>
<v t="T1052" a="C"><vh>setBodyStringOrPane &amp; setBodyTextOrPane</vh></v>
<v t="T1733" a="C"><vh>setHeadString &amp; initHeadString</vh></v>
<v t="T2584"><vh>setHeadStringOrHeadline</vh></v>
</v>
<v t="T2585"><vh>computeIcon &amp; setIcon</vh></v>
<v><vh>Status bits</vh>
<v t="T2586"><vh>clearAllVisited</vh></v>
<v t="T2587"><vh>clearAllVisitedInTree</vh></v>
<v t="T2588"><vh>clearClonedBit</vh></v>
<v t="T2589"><vh>clearDirty &amp; clearDirtyJoined</vh></v>
<v t="T2590"><vh>clearMarked</vh></v>
<v t="T2591"><vh>clearOrphan</vh></v>
<v t="T2592"><vh>clearVisited</vh></v>
<v t="T2593"><vh>clearVisitedInTree</vh></v>
<v t="T2594"><vh>contract &amp; expand &amp; initExpandedBit</vh></v>
<v t="T2595"><vh>initStatus</vh></v>
<v t="T1294" a="C"><vh>setAncestorsOfClonedNodesInTreeDirty</vh></v>
<v t="T1293" a="C"><vh>setAncestorAtFileNodeDirty</vh></v>
<v t="T2596"><vh>setClonedBit &amp; initClonedBit</vh></v>
<v t="T1291" a="C"><vh>setDirty, setDirtyDeleted &amp; initDirtyBit</vh></v>
<v t="T2597"><vh>setMarked &amp; initMarkedBit</vh></v>
<v t="T2598"><vh>setOrphan</vh></v>
<v t="T2599"><vh>setSelected (vnode, new)</vh></v>
<v t="T2600"><vh>setVisited</vh></v>
</v>
<v t="T2601"><vh>setJoinList</vh></v>
<v t="T2602"><vh>setSelection</vh></v>
<v t="T2603"><vh>setT</vh></v>
<v t="T1402" a="C"><vh>v.sortChildren</vh></v>
<v t="T2604"><vh>trimTrailingLines</vh></v>
</v>
<v><vh>Moving, Inserting, Deleting, Cloning</vh>
<v><vh>Entry Points (vnode)</vh>
<v t="T1866" a="C"><vh>v.clone</vh></v>
<v t="T2605"><vh>doDelete</vh></v>
<v t="T2606"><vh>insertAfter</vh></v>
<v t="T2607"><vh>insertAsLastChild</vh></v>
<v t="T2608"><vh>insertAsNthChild</vh></v>
<v t="T2609"><vh>moveAfter</vh></v>
<v t="T2610"><vh>moveToRoot</vh></v>
<v t="T1403" a="C"><vh>moveToNthChildOf</vh></v>
<v t="T2611"><vh>restoreOutlineFromDVnodes (test)</vh></v>
<v t="T2612"><vh>swap_links</vh></v>
</v>
<v><vh>Public helper functions</vh>
<v t="T2613"><vh>v.copyTree</vh></v>
<v t="T2614"><vh>joinTreeTo</vh></v>
<v t="T2615"><vh>shouldBeClone</vh></v>
<v t="T2616"><vh>validateOutlineWithParent</vh>
<v t="T2617"><vh>&lt;&lt; validate parent ivar &gt;&gt;</vh></v>
<v t="T2618"><vh>&lt;&lt; validate childIndex ivar &gt;&gt;</vh></v>
<v t="T2619"><vh>&lt;&lt; validate x ivar &gt;&gt;</vh></v>
</v>
</v>
<v><vh>Private helper functions</vh>
<v t="T2620"><vh>cloneTree</vh></v>
<v t="T2621"><vh>copyCloneBitsTo</vh></v>
<v t="T2622"><vh>v.copyNode</vh></v>
<v t="T2623"><vh>createDependents (bug fix: 4/22/01)</vh></v>
<v t="T2624"><vh>destroyDependents</vh></v>
<v t="T2625"><vh>destroyTree (does nothing!)</vh></v>
<v t="T2626"><vh>invalidOutline</vh></v>
<v t="T2627"><vh>isJoinedTo</vh></v>
<v t="T2628"><vh>isOnJoinListOf</vh></v>
<v t="T2629"><vh>joinNodeTo</vh></v>
<v t="T2630"><vh>linkAfter</vh></v>
<v t="T2631"><vh>linkAsNthChild</vh></v>
<v t="T2632"><vh>linkAsRoot</vh></v>
<v t="T2633"><vh>unlink</vh></v>
<v t="T2634"><vh>unjoinNode</vh>
<v t="T2635"><vh>&lt;&lt; Set prev to the node that points to self &gt;&gt;</vh></v>
</v>
<v t="T2636"><vh>unjoinTree</vh></v>
</v>
</v>
</v>
</v>
<v t="T2637"><vh>@file leoPrefs.py</vh>
<v t="T2638"><vh>prefs.__init__</vh>
<v t="T2639"><vh>&lt;&lt; Set ivars &gt;&gt;</vh></v>
<v t="T2640"><vh>&lt;&lt; Create the Global Options frame &gt;&gt;</vh></v>
<v t="T2641"><vh>&lt;&lt; Create the Tangle Options frame &gt;&gt;</vh></v>
<v t="T523" a="C"><vh>&lt;&lt; Create the Target Language frame &gt;&gt;</vh></v>
<v t="T2642"><vh>&lt;&lt; Create the Ok, Cancel &amp; Revert buttons &gt;&gt;</vh></v>
</v>
<v t="T1332" a="C"><vh>prefs.init</vh>
<v t="T1333"><vh>&lt;&lt; remember values for revert &gt;&gt;</vh></v>
<v t="T1334"><vh>&lt;&lt; set widgets &gt;&gt;</vh></v>
</v>
<v><vh>Event handlers</vh>
<v t="T1335" a="C"><vh>prefs.set_ivars &amp; idle_set_ivars &amp; print_ivars</vh>
<v t="T1336"><vh>&lt;&lt; update ivars &gt;&gt;</vh></v>
</v>
<v t="T2643"><vh>set_lang</vh></v>
<v t="T1157" a="C"><vh>OnClosePrefsFrame</vh></v>
<v t="T1158" a="C"><vh>prefs.onOK, onCancel, onRevert</vh>
<v t="T1159"><vh>&lt;&lt; restore options &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T2644"><vh>@file leoTangle.py</vh>
<v t="T1927" a="C"><vh>&lt;&lt; About Tangle and Untangle &gt;&gt;</vh></v>
<v t="T663" a="C"><vh>&lt;&lt; constants &amp; synonyms &gt;&gt;</vh></v>
<v><vh>node classes</vh>
<v t="T2645"><vh>class tst_node</vh>
<v t="T2646"><vh>tst_node.__init__</vh></v>
<v t="T2647"><vh>tst_node.__repr__</vh></v>
</v>
<v t="T2648"><vh>class part_node</vh>
<v t="T2649"><vh>part_node.__init__</vh></v>
<v t="T2650"><vh>part_node.__repr__</vh></v>
</v>
<v t="T2651"><vh>class ust_node</vh>
<v t="T2652"><vh>ust_node.__init__</vh></v>
<v t="T2653"><vh>ust_node.__repr__</vh></v>
</v>
<v t="T2654"><vh>class def_node</vh>
<v t="T2655"><vh>def_node.__init__</vh></v>
<v t="T2656"><vh>def_node.__repr__</vh></v>
</v>
<v t="T2657"><vh>class root_attributes (Stephen P. Schaefer)</vh>
<v t="T2658"><vh>root_attributes.__init__</vh>
<v t="T2659"><vh>&lt;&lt; trace the state &gt;&gt;</vh></v>
</v>
<v t="T2660"><vh>root_attributes.__repr__</vh></v>
</v>
</v>
<v t="T2661"><vh>class tangleCommands methods</vh>
<v t="T2662"><vh>tangle.__init__</vh></v>
<v t="T2663"><vh>tangle.init_ivars &amp; init_directive_ivars</vh>
<v t="T2664"><vh>&lt;&lt; init tangle ivars &gt;&gt;</vh></v>
<v t="T2665"><vh>&lt;&lt; init untangle ivars &gt;&gt;</vh></v>
<v t="T664" a="C"><vh>&lt;&lt; init directive ivars &gt;&gt; (tangle)</vh></v>
</v>
<v t="T2666"><vh>top level</vh>
<v t="T1916" a="C"><vh>cleanup</vh>
<v t="T1917"><vh>&lt;&lt; call tangle_done.run() or untangle_done.run() &gt;&gt;</vh></v>
</v>
<v t="T2667"><vh>initTangleCommand</vh></v>
<v t="T2668"><vh>initUntangleCommand</vh></v>
<v t="T2669"><vh>tangle</vh></v>
<v t="T2670"><vh>tangleAll</vh></v>
<v t="T2671"><vh>tangleMarked</vh></v>
<v t="T2672"><vh>tanglePass1</vh></v>
<v t="T2673"><vh>tanglePass2</vh></v>
<v t="T2674"><vh>tangleTree (calls cleanup)</vh></v>
<v t="T2675"><vh>untangle</vh></v>
<v t="T2676"><vh>untangleAll</vh></v>
<v t="T2677"><vh>untangleMarked</vh></v>
<v t="T2678"><vh>untangleRoot (calls cleanup)</vh>
<v t="T2679"><vh>&lt;&lt; return if @silent or unknown language &gt;&gt;</vh></v>
<v t="T2680"><vh>&lt;&lt; Set path &amp; root_name to the file specified in the @root directive &gt;&gt;</vh></v>
<v t="T2681"><vh>&lt;&lt; Read the file into file_buf  &gt;&gt;</vh></v>
<v t="T2682"><vh>&lt;&lt; Pass 2:  Untangle the outline using the UST and a newly-created TST &gt;&gt;</vh></v>
</v>
<v t="T2683"><vh>untangleTree</vh>
<v t="T2684"><vh>&lt;&lt; set end to the next root in the unit &gt;&gt;</vh></v>
</v>
</v>
<v><vh>tangle</vh>
<v><vh>Pass 1</vh>
<v t="T670" a="C"><vh>handle_newline</vh></v>
<v t="T671" a="C"><vh>skip_body</vh>
<v t="T672"><vh>The interface between tangle and untangle</vh>
<v t="T673"><vh>&lt;&lt; Define a section containing only an @doc part &gt;&gt;</vh></v>
<v t="T674"><vh>&lt;&lt; Define a section for a leading code part &gt;&gt;</vh></v>
<v t="T675"><vh>&lt;&lt; Scan and define a section definition &gt;&gt;</vh></v>
<v t="T676"><vh>&lt;&lt; Scan and define an @code defininition &gt;&gt;</vh></v>
<v t="T677"><vh>&lt;&lt; Scan and define a root section &gt;&gt;</vh></v>
</v>
</v>
<v t="T678" a="C"><vh>skip_code</vh>
<v t="T679"><vh>&lt;&lt; skip a noweb code section &gt;&gt;</vh>
<v t="T680"><vh>&lt;&lt; handle possible noweb section reference &gt;&gt;</vh></v>
</v>
<v t="T681"><vh>&lt;&lt; skip a CWEB code section &gt;&gt;</vh>
<v t="T682"><vh>&lt;&lt; handle CWEB control code &gt;&gt;</vh></v>
</v>
</v>
<v t="T1833" a="C"><vh>skip_doc</vh></v>
<v t="T2685"><vh>skip_headline</vh></v>
</v>
<v><vh>Pass 2</vh>
<v t="T1212" a="C"><vh>oblank, oblanks, os, otab, otabs (Tangle)</vh></v>
<v t="T1358" a="C"><vh>tangle.put_all_roots</vh>
<v t="T1359"><vh>&lt;&lt;Get root specific attributes&gt;&gt;</vh></v>
<v t="T1360"><vh>&lt;&lt;Put @first lines&gt;&gt;</vh></v>
<v t="T1361"><vh>&lt;&lt;Write a banner at the start of the output file&gt;&gt;</vh></v>
<v t="T1362"><vh>&lt;&lt; Erase the temporary file &gt;&gt;</vh></v>
</v>
<v t="T683" a="C"><vh>put_code</vh>
<v t="T684"><vh>&lt;&lt;put possible section reference &gt;&gt;</vh></v>
<v t="T685"><vh>&lt;&lt; handle 2-character CWEB control codes &gt;&gt;</vh></v>
<v t="T686"><vh>&lt;&lt; handle noweb @ &lt; &lt; convention &gt;&gt;</vh></v>
</v>
<v t="T2686"><vh>put_doc</vh>
<v t="T2687"><vh>&lt;&lt;put the doc part&gt;&gt;</vh>
<v t="T2688"><vh>&lt;&lt;output or skip whitespace or newlines&gt;&gt;</vh></v>
<v t="T2689"><vh>&lt;&lt;compute the width of the next word&gt;&gt;</vh></v>
<v t="T2690"><vh>&lt;&lt;output next word&gt;&gt;</vh></v>
</v>
</v>
<v t="T1211" a="C"><vh>put_leading_ws</vh></v>
<v t="T687" a="C"><vh>put_newline</vh>
<v t="T688"><vh>&lt;&lt; Output leading white space except for blank lines &gt;&gt;</vh></v>
</v>
<v t="T2691"><vh>put_part_node</vh></v>
<v t="T689" a="C"><vh>put_section</vh>
<v t="T690"><vh>&lt;&lt; Calculate the new value of tangle_indent &gt;&gt;</vh></v>
<v t="T691"><vh>&lt;&lt; Set 'newline_flag' if the line ends with the reference &gt;&gt;</vh></v>
<v t="T692"><vh>&lt;&lt;put all parts of the section definition&gt;&gt;</vh>
<v t="T693"><vh>&lt;&lt; Put the section name in a comment &gt;&gt;</vh>
<v t="T694"><vh>&lt;&lt; put ( n of m ) &gt;&gt;</vh></v>
</v>
<v t="T695"><vh>&lt;&lt; Put the ending comment &gt;&gt;</vh></v>
</v>
<v t="T696"><vh>&lt;&lt;Put a comment about the undefined section&gt;&gt;</vh></v>
</v>
<v t="T2692"><vh>section_check</vh></v>
</v>
</v>
<v><vh>tst</vh>
<v t="T725" a="C"><vh>st_check</vh></v>
<v t="T2693"><vh>st_dump</vh></v>
<v t="T2694"><vh>st_dump_node</vh></v>
<v t="T2695"><vh>st_enter</vh>
<v t="T2696"><vh>&lt;&lt;check for duplicate code definitions &gt;&gt;</vh></v>
<v t="T2697"><vh>&lt;&lt;remember root node attributes&gt;&gt;</vh></v>
</v>
<v t="T2698"><vh>st_enter_root_name</vh></v>
<v t="T2699"><vh>st_enter_section_name</vh></v>
<v t="T2700"><vh>st_lookup</vh></v>
</v>
<v><vh>ust</vh>
<v t="T2701"><vh>ust_dump</vh></v>
<v t="T2702"><vh>ust_enter</vh>
<v t="T2703"><vh>&lt;&lt; remove blank lines from the start and end of the text &gt;&gt;</vh></v>
</v>
<v t="T2704"><vh>ust_lookup</vh></v>
<v t="T724" a="C"><vh>ust_warn_about_orphans</vh></v>
</v>
<v><vh>untangle</vh>
<v t="T723" a="C"><vh>compare_comments</vh>
<v t="T710" a="C"><vh>&lt;&lt; Check both parts for @ comment conventions &gt;&gt;</vh></v>
</v>
<v t="T2705"><vh>massage_block_comment (no longer used)</vh></v>
<v t="T708" a="C"><vh>forgiving_compare</vh>
<v t="T709"><vh>&lt;&lt; Define forgiving_compare vars &gt;&gt;</vh></v>
<v t="T710" a="C"><vh>&lt;&lt; Check both parts for @ comment conventions &gt;&gt;</vh></v>
<v t="T711"><vh>&lt;&lt; Compare non-critical newlines &gt;&gt;</vh></v>
<v t="T712"><vh>&lt;&lt; Compare non-critical whitespace &gt;&gt;</vh></v>
<v t="T713"><vh>&lt;&lt; Compare possible preprocessor directives &gt;&gt;</vh>
<v t="T714" a="C"><vh>&lt;&lt; Compare single characters &gt;&gt;</vh></v>
<v t="T715"><vh>&lt;&lt; Compare preprocessor directives &gt;&gt;</vh></v>
</v>
<v t="T716"><vh>&lt;&lt; Compare possible strings &gt;&gt;</vh>
<v t="T714" a="C"><vh>&lt;&lt; Compare single characters &gt;&gt;</vh></v>
<v t="T717"><vh>&lt;&lt; Compare C strings &gt;&gt;</vh></v>
<v t="T718"><vh>&lt;&lt; Compare Pascal strings &gt;&gt;</vh></v>
</v>
<v t="T719"><vh>&lt;&lt; Compare possible section references &gt;&gt;</vh></v>
<v t="T720"><vh>&lt;&lt; Compare comments or single characters &gt;&gt;</vh>
<v t="T714" a="C"><vh>&lt;&lt; Compare single characters &gt;&gt;</vh></v>
</v>
<v t="T721"><vh>&lt;&lt; Make sure both parts have ended &gt;&gt;</vh></v>
<v t="T722"><vh>&lt;&lt; Trace the mismatch &gt;&gt;</vh></v>
</v>
<v t="T2706"><vh>mismatch</vh></v>
<v t="T2707"><vh>scan_derived_file (pass 1)</vh>
<v t="T2708"><vh>&lt;&lt; set the private global matching vars &gt;&gt;</vh></v>
<v t="T2709"><vh>&lt;&lt; Skip the header line output by tangle &gt;&gt;</vh></v>
<v t="T2710"><vh>&lt;&lt; handle the start of a new line &gt;&gt;</vh></v>
<v t="T2711"><vh>&lt;&lt; handle a sentinel line &gt;&gt;</vh>
<v t="T2712"><vh>&lt;&lt; terminate the previous part of this section if it exists &gt;&gt;</vh></v>
</v>
<v t="T2713"><vh>&lt;&lt; copy the entire line &gt;&gt;</vh></v>
<v t="T2714"><vh>&lt;&lt; copy a string &gt;&gt;</vh></v>
<v t="T2715"><vh>&lt;&lt; copy a multi-line comment &gt;&gt;</vh></v>
<v t="T2716"><vh>&lt;&lt; copy an alternate multi-line comment &gt;&gt;</vh></v>
<v t="T2717"><vh>&lt;&lt; end all open sections &gt;&gt;</vh></v>
</v>
<v t="T2718"><vh>update_def (pass 2)</vh>
<v t="T2719"><vh>&lt;&lt; Remove leading blank lines and comments from ucode &gt;&gt;</vh></v>
</v>
<v t="T2720"><vh>update_current_vnode</vh></v>
</v>
<v t="T2721"><vh>utility methods</vh>
<v t="T697" a="C"><vh>compare_section_names</vh></v>
<v t="T2722"><vh>copy</vh></v>
<v t="T2723"><vh>error, pathError, warning</vh></v>
<v t="T2724"><vh>is_end_of_directive</vh></v>
<v t="T2725"><vh>is_end_of_string</vh></v>
<v t="T2726"><vh>is_escaped</vh></v>
<v t="T698" a="C"><vh>is_section_name</vh></v>
<v t="T699" a="C"><vh>is_sentinel_line &amp; is_sentinel_line_with_data</vh>
<v t="T700"><vh>&lt;&lt; Initialize the return values  &gt;&gt;</vh></v>
<v t="T701"><vh>&lt;&lt; Make sure the line starts with start_sentinel &gt;&gt;</vh></v>
<v t="T702"><vh>&lt;&lt; Set end_flag if we have -- end -- &gt;&gt;</vh></v>
<v t="T703"><vh>&lt;&lt; Make sure we have a section reference &gt;&gt;</vh></v>
<v t="T704"><vh>&lt;&lt; Set part and of if they exist &gt;&gt;</vh></v>
<v t="T705"><vh>&lt;&lt; Set nl_flag to false if !newline exists &gt;&gt;</vh></v>
<v t="T706"><vh>&lt;&lt; Make sure the line ends with end_sentinel &gt;&gt;</vh></v>
</v>
<v t="T2727"><vh>push_new_def_node</vh></v>
<v t="T2728"><vh>scan_short_val</vh></v>
<v t="T1909" a="C"><vh>setRootFromHeadline</vh></v>
<v t="T1453" a="C"><vh>setRootFromText</vh></v>
<v t="T2729"><vh>skip_CWEB_section_name</vh></v>
<v t="T2730"><vh>skip_noweb_section_name</vh></v>
<v t="T707" a="C"><vh>skip_section_name</vh></v>
<v t="T2731"><vh>standardize_name</vh></v>
<v t="T1702" a="C"><vh>tangle.scanAllDirectives</vh>
<v t="T1703"><vh>&lt;&lt; Collect @first attributes &gt;&gt;</vh></v>
<v t="T1704"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="T1705"><vh>&lt;&lt; Test for print modes directives &gt;&gt;</vh></v>
<v t="T1706"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="T1707"><vh>&lt;&lt; compute dir and relative_path from s[k:] &gt;&gt;</vh></v>
<v t="T1708"><vh>&lt;&lt; handle absolute @path &gt;&gt;</vh></v>
</v>
<v t="T1709"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="T1710"><vh>&lt;&lt; Test for @root &gt;&gt;</vh></v>
<v t="T1711"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="T1712"><vh>&lt;&lt; Test for @header and @noheader &gt;&gt;</vh></v>
<v t="T1713"><vh>&lt;&lt; Set self.tangle_directory &gt;&gt;</vh>
<v t="T1714"><vh>&lt;&lt; handle absolute path &gt;&gt;</vh></v>
</v>
</v>
<v t="T665" a="C"><vh>token_type</vh>
<v t="T666"><vh>&lt;&lt; set token_type in noweb mode &gt;&gt;</vh></v>
<v t="T667"><vh>&lt;&lt; set token_type for CWEB mode &gt;&gt;</vh></v>
<v t="T668"><vh>&lt;&lt; set kind for directive &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="T2732"><vh>@file leoTree.py</vh>
<v t="T1926" a="C"><vh>&lt;&lt; About drawing and events &gt;&gt;</vh></v>
<v t="T1266" a="C"><vh>&lt;&lt; drawing constants &gt;&gt;</vh></v>
<v><vh>Birth &amp; death</vh>
<v t="T2733"><vh>tree.__del__</vh></v>
<v t="T1269" a="C"><vh>tree.__init__</vh></v>
<v t="T1879" a="C"><vh>tree.deleteBindings</vh></v>
<v t="T881" a="C"><vh>tree.destroy</vh></v>
</v>
<v t="T1869" a="C"><vh>Drawing</vh>
<v t="T1870"><vh>About drawing and updating</vh></v>
<v t="T1327" a="C"><vh>beginUpdate</vh></v>
<v t="T1871" a="C"><vh>drawBox (tag_bind)</vh></v>
<v t="T1872"><vh>drawNode</vh></v>
<v t="T1103" a="C"><vh>drawText (bind)</vh>
<v t="T1104"><vh>&lt;&lt; configure the text depending on state &gt;&gt;</vh></v>
</v>
<v t="T1873"><vh>drawTree</vh>
<v t="T1874"><vh>&lt;&lt; draw vertical line &gt;&gt;</vh></v>
</v>
<v t="T1328" a="C"><vh>endUpdate</vh></v>
<v t="T1875"><vh>headWidth</vh></v>
<v t="T1876"><vh>hideAllChildren</vh></v>
<v t="T1877"><vh>hideNode (no longer used)</vh></v>
<v t="T1878"><vh>hideTree (no longer used)</vh></v>
<v t="T1278" a="C"><vh>lastVisible</vh></v>
<v t="T1268" a="C"><vh>setLineHeight</vh></v>
<v t="T1863" a="C"><vh>tree.drawIcon (tag_bind))</vh></v>
<v t="T1267" a="C"><vh>tree.getFont,setFont,setFontFromConfig</vh></v>
<v t="T1150" a="C"><vh>tree.getIconImage</vh></v>
<v t="T1281" a="C"><vh>tree.idle_scrollTo</vh></v>
<v t="T1864" a="C"><vh>tree.numberOfVisibleNodes</vh></v>
<v t="T849" a="C"><vh>tree.recolor, recolor_now, recolor_range</vh></v>
<v t="T971" a="C"><vh>tree.redraw , force_redraw, redraw_now</vh></v>
<v t="T1279" a="C"><vh>tree.yoffset</vh></v>
</v>
<v><vh>Event handers</vh>
<v t="T1301" a="C"><vh>OnActivate</vh></v>
<v t="T2734"><vh>OnBoxClick</vh></v>
<v t="T2735"><vh>OnDeactivate</vh></v>
<v t="T1270" a="C"><vh>tree.findVnodeWithIconId</vh></v>
<v t="T1684" a="C"><vh>tree.onBodyChanged, onBodyWillChange, OnBodyKey, idle_body_key</vh>
<v t="T1685"><vh>&lt;&lt; replace body text by u &gt;&gt;</vh></v>
<v t="T1686"><vh>&lt;&lt; set removeTrailing &gt;&gt;</vh></v>
<v t="T1687"><vh>&lt;&lt; Do auto indent &gt;&gt; (David McNab)</vh></v>
<v t="T1688"><vh>&lt;&lt; convert leading tab to blanks &gt;&gt;</vh></v>
</v>
<v t="T1274" a="C"><vh>tree.OnContinueDrag</vh>
<v t="T1275"><vh>&lt;&lt; expand vdrag and redraw &gt;&gt; (not used)</vh></v>
<v t="T1276"><vh>&lt;&lt; scroll the canvas as needed &gt;&gt;</vh></v>
</v>
<v t="T1102" a="C"><vh>tree.OnCtontrolT</vh></v>
<v t="T1273" a="C"><vh>tree.OnDrag</vh></v>
<v t="T1271" a="C"><vh>tree.OnEndDrag</vh>
<v t="T1272"><vh>&lt;&lt; set vdrag, childFlag &gt;&gt;</vh></v>
</v>
<v t="T1689" a="C"><vh>tree.OnHeadlineKey, onHeadlineChanged, idle_head_key</vh>
<v t="T1690"><vh>&lt;&lt; Make sure that the headline text is valid in the encoding &gt;&gt;</vh></v>
</v>
<v t="T1865" a="C"><vh>tree.OnIconClick</vh></v>
<v t="T1199" a="C"><vh>tree.OnIconDoubleClick (@url)</vh>
<v t="T1200"><vh>&lt;&lt; stop the url after any embedded blank and issue warning &gt;&gt;</vh></v>
<v t="T1201"><vh>&lt;&lt; check the url; return if bad &gt;&gt;</vh></v>
<v t="T1202"><vh>&lt;&lt; pass the url to the web browser &gt;&gt;</vh></v>
</v>
<v t="T1297" a="C"><vh>tree.OnPopup</vh>
<v t="T867" a="C"><vh>&lt;&lt; create the popup menu &gt;&gt;</vh>
<v t="T868"><vh>&lt;&lt; set isAtRoot and isAtFile if v's tree contains @root or @file nodes &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T1306" a="C"><vh>Selecting &amp; editing (tree)</vh>
<v t="T1307"><vh>abortEditLabelCommand</vh></v>
<v t="T1308"><vh>dimEditLabel, undimEditLabel</vh></v>
<v t="T1309" a="C"><vh>editLabel</vh></v>
<v t="T1290" a="C"><vh>endEditLabel &amp; endEditLabelCommand</vh></v>
<v t="T1280" a="C"><vh>tree.expandAllAncestors</vh></v>
<v t="T1310"><vh>tree.scanForTabWidth</vh>
<v t="T1311"><vh>&lt;&lt; set w and break on @tabwidth &gt;&gt;</vh></v>
</v>
<v t="T848" a="C"><vh>tree.select</vh></v>
<v t="T972" a="C"><vh>tree.set...LabelState</vh>
<v t="T973"><vh>&lt;&lt; set editing headline colors &gt;&gt;</vh></v>
<v t="T974"><vh>&lt;&lt; set selected, disabled headline colors &gt;&gt;</vh></v>
<v t="T975"><vh>&lt;&lt; set unselected headline colors &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T2736"><vh>@file leoUndo.py</vh>
<v t="T1929" a="C"><vh>&lt;&lt; How Leo implements unlimited undo &gt;&gt;</vh></v>
<v t="T2737"><vh>&lt;&lt; Define optionl ivars &gt;&gt;</vh></v>
<v t="T1037" a="C"><vh>undo.__init__</vh>
<v t="T1038"><vh>clearUndoState &amp; clearIvars</vh></v>
</v>
<v t="T1081" a="C"><vh>State routines...</vh>
<v t="T1082"><vh>canRedo &amp; canUndo</vh></v>
<v t="T1083"><vh>enableMenuItems</vh></v>
<v t="T1084"><vh>getBead, peekBead, setBead</vh></v>
<v t="T1085"><vh>redoMenuName, undoMenuName</vh></v>
<v t="T1086" a="C"><vh>setRedoType, setUndoType</vh></v>
<v t="T1087"><vh>setUndoParams</vh></v>
<v t="T1042" a="C"><vh>setUndoTypingParams</vh>
<v t="T1043"><vh>&lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;</vh></v>
<v t="T1044" a="C"><vh>&lt;&lt; save undo text info &gt;&gt;</vh></v>
</v>
<v t="T1041" a="C"><vh>setUndoTypes</vh></v>
</v>
<v t="T1073" a="C"><vh>u.redo</vh>
<v t="T1074"><vh>&lt;&lt; redo clone cases &gt;&gt;</vh></v>
<v t="T1075"><vh>&lt;&lt; redo delete cases &gt;&gt;</vh></v>
<v t="T1076"><vh>&lt;&lt; redo insert cases &gt;&gt;</vh></v>
<v t="T1077"><vh>&lt;&lt; redo move &amp; drag cases &gt;&gt;</vh></v>
<v t="T1078"><vh>&lt;&lt; redo promote and demote cases &gt;&gt;</vh></v>
<v t="T1079"><vh>&lt;&lt; redo replace cases &gt;&gt;</vh></v>
<v t="T1080"><vh>&lt;&lt; redo sort cases &gt;&gt;</vh></v>
<v t="T1039" a="C"><vh>&lt;&lt; redo typing cases &gt;&gt;</vh></v>
</v>
<v t="T1088" a="C"><vh>u.undo</vh>
<v t="T1089"><vh>&lt;&lt; undo clone cases &gt;&gt;</vh></v>
<v t="T1090"><vh>&lt;&lt; undo delete cases &gt;&gt;</vh></v>
<v t="T1091"><vh>&lt;&lt; undo insert cases &gt;&gt;</vh></v>
<v t="T1092"><vh>&lt;&lt; undo move  &amp; drag cases &gt;&gt;</vh></v>
<v t="T1093"><vh>&lt;&lt; undo promote and demote cases &gt;&gt;</vh></v>
<v t="T1094"><vh>&lt;&lt; undo replace cases &gt;&gt;</vh></v>
<v t="T1095"><vh>&lt;&lt; undo sort cases &gt;&gt;</vh></v>
<v t="T1040" a="C"><vh>&lt;&lt; undo typing cases &gt;&gt;</vh></v>
</v>
<v><vh>Undo helpers</vh>
<v t="T2738"><vh>findSharedVnode</vh></v>
<v t="T1096" a="C"><vh>undoDemote</vh></v>
<v t="T1097" a="C"><vh>undoPromote</vh></v>
<v t="T2739"><vh>undoReplace</vh></v>
<v t="T1045" a="C"><vh>undoRedoText</vh>
<v t="T1046"><vh>&lt;&lt; Incrementally update the Tk.Text widget &gt;&gt;</vh></v>
<v t="T1047"><vh>&lt;&lt; Compute the result using v's body text &gt;&gt;</vh></v>
<v t="T1048"><vh>&lt;&lt; Get textResult from the Tk.Text widget &gt;&gt;</vh></v>
<v t="T1049"><vh>&lt;&lt; print mismatch trace &gt;&gt;</vh></v>
</v>
<v t="T2740"><vh>undoSortChildren</vh></v>
<v t="T2741"><vh>undoSortSiblings</vh></v>
</v>
</v>
</v>
<v t="T2742"><vh>@file tangle_done.py</vh>
<v t="T2743"><vh>run</vh></v>
<v t="T2744"><vh>convertRSTfilesToHTML</vh>
<v t="T2745"><vh>&lt;&lt; Convert root to corresponding .html file &gt;&gt;</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="T1">@ignore
@nocolor
</t>
<t tx="T2">The lambda functions for callbacks were not working properly.  While I was at it I simplified the code</t>
<t tx="T3">The original bug report:

"The sample code to invoke idle via "Open With" does not work if leo 
is installed in a path with a blank, for example "program files/leo". 
On windows, the pathname needs to be quoted in this case."

I did not find this to be the case.  However, there were problems with the sample Open With code in customizeLeo.py and I corrected these.
</t>
<t tx="T4">We scanning for the initial state we must make sure that i &lt; old_len and i &lt; new_len.</t>
<t tx="T5">This was reported by David LeBlank and fixed with major hints from Chad Netzer.
</t>
<t tx="T6">Apparently the F4 shortcuts interferes with the Alt-F4 shortcut.</t>
<t tx="T7">The content formerly on evisa.com, including the Leo tutorials is now on 3dtree.com.</t>
<t tx="T8">Use keyword params instead of synonym constants.

- import
	- removed dont_indent_refs and indent_refs synonyms.

- tangle
	- removed verbose and brief synonyms to st_dump.
	- left other flags alone: they are complex.</t>
<t tx="T9">Added options for @file and @root.

The options to @root are more important (and potentially more buggy).  For the first time Leo allows you to choose whether body text in @root trees will start in code mode or doc mode by default.  Ever since I created @file trees I've regretted the choice of making doc mode the default.  Just last week I realized I'm not stuck with that old choice.

This is a little tricky, so please pay attention :-)

1. @root-doc filename and @root-code filename specify that body text is assumed to start in doc mode or code mode respectively.  The options (-doc and -code) must follow @root immediately with no intervening whitespace.  In effect, @root-code and @root-doc are two new directives.  (They aren't syntax colored yet: they will be today or tomorrow.)

2. These @root options override the new at_root_bodies_start_in_doc_mode option in leoConfig.py.  This option affects only @root trees without options.  Such "plain" @root trees are now deprecated, which only means that it is now better style to use either @root-code or @root-doc.  The reason is simple: the meaning of plain @root trees will depend on the at_root_bodies_start_in_doc_mode option, and that isn't good.

3. By default, at_root_bodies_start_in_doc_mode = 1 for compatibility for old @root trees.  I actually don't think this option is good for much; I created it before I created @root-doc and @root-code, and I decided it wouldn't hurt to leave it in.  Anyway, you now have complete flexibility about how @root works, and in particular you can make @root work just like @file.

Only minor changes were made to the Tangle and Untangle code, and the new code appears to work.  However, it has not been extensively tested.  I would like to get 3.9.1 out the door this week so the latest "official" version of Leo won't crash when PIL or tkIcon are not present.  So please report any problems with the new code immediately.</t>
<t tx="T10">Untangle was warning about a missing section if the section had only an @doc part.</t>
<t tx="T11">There is a good reason why os.path.normpath does not mess with slashes on Linux, and there is no reason to create another routine to do so.
</t>
<t tx="T12">Used .gif file so transparency info used by tkIcon code.
Rewrote tkIcon code so it doesn't try to resize the icon.
Created custom 16x16 LeoWin.gif.</t>
<t tx="T13">The code now uses the list leoConfig.ivars to generate exec statements that do the work.  This makes it possible to add ivars to leoConfig.ivars without changing code in leoConfig.py.
</t>
<t tx="T14">It might be beter if the Suboutline Only and Node Only checkboxes were Radio buttons, but then we would need yet another radio button to say "Search Entire Outline", which is a bit pedantic.

Note that Node Only takes precedence over Suboutline Only if they are both checked.</t>
<t tx="T15">This works just like the Flatten Outline command except it writes only headlines.</t>
<t tx="T16">How did I ever live without this.

Also improved messages and fixed a major performance bug: tree.numberOfVisibleNodes was being called repeatedly!</t>
<t tx="T17">Leo was not handling the class keyword properly.

The fix was to change match(s,i,"class") to match_word(s,i,"class") in
&lt; &lt; handle possible Python function or class &gt; &gt;
</t>
<t tx="T18">Both command are enabled only if the presently selected node is a clone.  Mark Clones marks all nodes that are clones of the present node.  Go To Next Clone goes to the next node that is a clone of the present node. A little experimentation convinced me that this command should wrap.  So this command endlessly cycles among the nodes.  Trying to end the this endless cycling would not be easy, as my experience with the Find command shows.

These are straightforward (and surprisingly useful) commands.  Please report any problems immediately.</t>
<t tx="T19">@nosentinelsfile nodes were not being marked dirty properly.

Also, the message in atFile.writeAll about "no @file node found"  did not include these nodes.  The message was generalized.</t>
<t tx="T20">The old code did not allow &lt;tag /&gt; in many cases.  The new code reads minimal.leo without complaint.  It is:

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;leo_file&gt;
&lt;leo_header file_format="2" /&gt;
&lt;globals /&gt;
&lt;preferences /&gt;
&lt;find_panel_settings /&gt;
&lt;vnodes /&gt;
&lt;tnodes /&gt;
&lt;/leo_file&gt;
</t>
<t tx="T21">raise EnvironmentError instead of string exception in CheckVersion.

c:\prog\leoCVS\leo\leoFrame.py:2211: Variable (after) used before being set
	added after=nodeAfterTree() in one place.

c:\prog\leoCVS\leo\leoColor.py:1261: Invalid arguments to (continuePythonString), got 4, expected 5
	added j argument.</t>
<t tx="T22">The code that checks whether leading and trailing have been supplied must check against None.  Otherwise, a leading or trailing value of zero will cause middle_lines to be miscalculated.</t>
<t tx="T23">The commands now remember the scroll position so the screen doesn't hope around.</t>
<t tx="T24">Created the long-overdue convertUnicodeToString utility.</t>
<t tx="T25">This is called from atFile.scanAllDirectives, tangle.scanAllDirectives and utils_rename.</t>
<t tx="T26">@ test

@nocolor

@ test

@color</t>
<t tx="T27">This may or may not solve a crash under Python 2.1.</t>
<t tx="T28">Leo now ensures that u.oldText and u.newText are set to None when using the new undo scheme.  This means that Python now has a chance of reclaiming much more memory.</t>
<t tx="T29">Leo now forces a full update and redraw if there is a mismatch between the expected value and the result calculated from the Tk.Text widget.  This is safe, and won't happen often.</t>
<t tx="T30">This was making it impossible to specify trailing newlines.  It also seems to have helped undo.</t>
<t tx="T31">We can't use after_idle because that completely overloads the system.  On my machine a delay of 500-1000 msec between calls would be sufficient to handle most "periodic" tasks.</t>
<t tx="T32">It's not perfect, and it will do for now.</t>
<t tx="T33">Noweb section refs and defs _are_ valid in cweb mode!
Allow LaTex coloring in cweb @space, @* and @** doc parts.</t>
<t tx="T34">Cweb prefs panel setting was overriding @language python (!)</t>
<t tx="T35">This makes it much easier to pass parameters to hooks.
</t>
<t tx="T36">@language pascal
@color

private
uses</t>
<t tx="T37">We can only suppress redraws in undo/redo under very special conditions, namely that we are undoing typing in the same node.

The recent code will leave the screen in the wrong state!</t>
<t tx="T38">Eliminated the self.delim ivar.  This can't be set correctly when coloring incrementally.

Realized that full, non-incremental coloring must _always_ be done when switching nodes.  Even if we move from one cloned node to another, the context can be different:  different @color, @nocolor, @language and @comment directives may be in effect.

Used incremental syntax coloring when undoing.  This speed up undo tremendously.</t>
<t tx="T39">The principle is this: people should see the scripts they are executed.
</t>
<t tx="T40">@color

@ See the actual code in the child node for complete notes.</t>
<t tx="T41">@ 11/6/02: app().log is now set correctly when there are multiple windows.

Before 11/6/02, app().log depended on activate events, and was not reliable.  The following routines now set app().log:

- frame.doCommand
- frame.OnMenuClick

Thus, top() will be reliable after any command is executed.  Creating a new window and opening a .leo file also set app().log correctly, so it appears that all holes have now been plugged.

Note 1: handleLeoHook calls top(), so the wrong hook function might be dispatched if this routine does not return the proper value.

Note 2: The value of top() may change during a new or open command, which may change the routine used to execute the "command1" and "command2" hooks.  This is not a bug, and hook routines must be aware of this fact.
@c

def top():

	# 11/6/02: app().log is now set correctly when there are multiple windows.
	frame = app().log # the current frame
	if frame:
		return frame.commands
	else:
		return None
</t>
<t tx="T42">The old code jumped through hoops not to duplicate code.  The new code just uses a new doAtKeyword routine.</t>
<t tx="T43">The key invarient:  frame.menus contains _untranslated_ names.  The translated names are used only in the label param to the Tk.menu routines.</t>
<t tx="T44">The menu hooks make it easy to customize menus.

The open hooks make it easy to perform custom actions when opening already-existing files.</t>
<t tx="T45">Finished convenience routines.

Used createNewMenu to create Leo's menus.</t>
<t tx="T46">This will allow users to create new menus without creating new ivars, an important generalization.

self.menus["top"] represents the top-level menu.  All other menus are represented by their menu name.</t>
<t tx="T47">This is long overdue:

- put the entire command in a try: except: block.
- eliminates the need for return "break"
- provides the natural place for hooks.

It was quite easy now that we have createMenuEntries.</t>
<t tx="T48">At present, only the start1, start2 and end1 hooks are handled, and many more could be added easily.</t>
<t tx="T49">This was almost too easy :-)</t>
<t tx="T50">Leo no longer massages comments when importing Java files.

There was a bug in massageBody that prevented text from being undented properly.  There was a bug in find_line_start (!!) that caused the start of the _previous_ line to be found if s[i] was a newline.  It's amazing that these bugs were undiscovered for so long.

Treat interface like class.</t>
<t tx="T51">It was moving past the present line if the s[i] was a newline.

This caused problems in the Java scanner, and could also cause problems in other places.</t>
<t tx="T52">The trailing @ in @q@ "doubles" the first @ in a sentinel, so putSentinel should not do this, and sentinelKind needs no special code to test for sentinels.

The tcweb.py script tests cweb files.  Invoke as follows:

python tcweb.py file1 file2...</t>
<t tx="T53">@ What I did:
	
- Changed g to geom or glob.
- Removed print_stack.
- Moved alert, handleLeoHook &amp; unloadAll to leoUtils.
- Moved all leoUtils routines into leoGlobals.py.
- Removed all instances of "from leoUtils import *"
- Removed "script functions" from leo.py: getCommands, topCommands, topCommand.
	These are no longer used anywhere in the code.
- Made the prolog_xxx constants ivars of leoApp.
- Made language_delims_dict and language_extension_dict ivars of leoApp.

I have decided to leave the present scheme pretty much in place,
except to move the variables in leoGlobals.py to leoApp.py.

This will allow us to say the following:
	
1. any function f() is defined in leoGlobals.py.
2. any variable v not of the form x.f is a local variable.


</t>
<t tx="T54">We must double _all_ @ signs following the @q@, so, e.g., a @@color sentinel gets turned into @q@@@@@color@&gt;.

This is easy to do in putSentinel, but a bit harder to undo:

1. sentinelKind locally adjusts the string in cweb mode.
2. skipSentinelStart skips both @@ signs in cweb mode.
3. All sections in scanText that deal with variable text must change @@ to @ within that text.</t>
<t tx="T55">Only rarely does a routine as elegant as wrap_lines come along.</t>
<t tx="T56">Added return "break" to body and headline key handlers.
Added unreachable return 0 to end of findMatchingBracket.</t>
<t tx="T57">@nocolor

This is miserable code to get just right because there are so many paths through the code.  In addition, making informative error messages is a bit tricky too.

Changes made:

1. Removed unhelpful warnings about non-existent paths.  Only errors are given now.
2. Added logic to set self.root_name if it has not already been set.  Without this, it is impossible to test for relative filenames in @root directives, and errors happen only after tangling is complete, which is quite confusing.
3. Added error messages when a "computed" file name does not exist.
4. Removed unused self.default_directory ivar from leoTangle.py.
5. Set self.tangle_directory ivar to base directory when @root node specifies a relative directory.  This is required so the later code will try to create the proper file.
6. Renamed the path_directive_creates_directories option to create_nonexistent_directories.  This makes clearer what is going on.
</t>
<t tx="T58">The old name was too misleading.</t>
<t tx="T59">Leo was not warning about orphan nodes in cweb mode.

There was new code in atFile.write _not_ to check for orphan nodes in cweb mode.  I just removed the test for language=="cweb".</t>
<t tx="T60">The present code explicitly eliminates control-T processing in headlines, which means that control-T does not switch panes when editing headline text.  Control-T _does_ switch panes in all other cases.

This appears to be another Tk bug.</t>
<t tx="T61">The old code scanned the moved tree once for every parent.  The new code scans the tree only once.  This can result in a significant speedup.</t>
<t tx="T62">This is taken from Python Cookbook.
It's not clear how useful this is with Tk programs.</t>
<t tx="T63">1. Eliminated special-case code (putCWEB) in atFile.write code.
2. Changed directiveKind so it returns noDirective for @space and @c when language=="cweb".
3. Changed colorizer to recognize both cweb and noweb section definitions and references when language == "cweb"</t>
<t tx="T64">Leo preserves the &lt;?xml-stylesheet...?&gt; line if it is already present in the .leo file.

Otherwise, Leo writes a &lt;?xml-stylesheet...?&gt; line only if the stylesheet option is present in the configuration file.  The stylesheet option specifies s in &lt;?xml-stylesheet s?&gt;</t>
<t tx="T65">Changed find to rfind in &lt;&lt; Set headline and ref &gt;&gt;</t>
<t tx="T66">scanAllDirectives just about must be called on the root of the tree, so directives are recognized.  Not @first or @last though.</t>
<t tx="T67">The aha, just concatenate a unique user id with any local timestamp.</t>
<t tx="T68">This may complete raw cweb mode.</t>
<t tx="T69">It appears that nobody ever used @delims in @file trees!</t>
<t tx="T70">Only shortcut pastes worked before.</t>
<t tx="T71">1. Changed "c" to "." in

methodKind = choose(self.fileType==".c","functions","methods")

2. Added self.rootLine logic to add @root self.fileName when importing to @root nodes.</t>
<t tx="T72">Previously, Java only had block comments, and the ending delim wasn't being removed from doc parts.</t>
<t tx="T73">As usual, I am leary of changing the Untangle logic.

To be effective, the @comment directive should follow the @language directive.</t>
<t tx="T74">The warning for "unknown language" had an unbound var.</t>
<t tx="T75">The new code must check for @raw and @end_raw directives.</t>
<t tx="T76">The &lt;&lt; Set path from @file node &gt;&gt; code was assuming that v.isAtFileNode() was non-Null.  This is no longer true with @rawfile.  The traceback was:

 File "c:\prog\leoCvs\leo\leoAtFile.py", line 424, in scanAllDirectives
    name = v.atFileNodeName()
AttributeError: 'NoneType' object has no attribute 'atFileNodeName'

The correct code is:

if v.isAtFileNode():
	name = v.atFileNodeName()
else:
	name = v.atRawFileNodeName()

dir = choose(name,os.path.dirname(name),None)</t>
<t tx="T77">A small convenience urgently requested.</t>
<t tx="T78">It wasn't always completely clear when the command was complete.</t>
<t tx="T79">atFile.directiveKind returned miscDirective on _any_ line that starts with @.</t>
<t tx="T80">This entailed using lots of ivars for communication between routines.</t>
<t tx="T81">A recent change was not writing language names properly (double quotes were ommitted) in the &lt;preferences&gt; element of .leo files.</t>
<t tx="T82">The new code is much simpler and more rational than the old, without affecting the defaults that are delivered by the module.

In addition, fixed a but that was causing most new params not to be written.</t>
<t tx="T83">This directive only applies to @root trees.  Like @silent, it inhibits untangling.</t>
<t tx="T84">Added missing comma before the keyword.</t>
<t tx="T85">Another major reorganization.</t>
<t tx="T86">This was a major reorganization.</t>
<t tx="T87">Replaced almost all calls to traceback.print_exc by calls to es_exception.</t>
<t tx="T88">We call scanAllDirectives on the _parent_ node, so no directives are recognized in the @rawfile tree itself, and directives _are_ recognized in ancestor nodes.  atFile::writeAll has new logic that recognizes @ignore in ancestors of @rawfile nodes, but not in @rawfile nodes themselves.

Writing the file was easy; updating the screen was harder.  We must redraw the screen whenever a headline changes, regardless of whether a node is joined to another.  The reason is that we must redraw the dirty bits of ancestor @file and @rawfile nodes.</t>
<t tx="T89">Removed v22 var from leoApp.py.
Removed ch3 var from getCwebWord() in leoColor.py
Removed self and name args from go function in leoCompare.py.
Added from leoUtils import * and from leoGlobals import * to leoCompare.py
Removed ok from onCompareFiles in leoCompare.py
Removed c from setAncestorsOfClonedNodesInTreeDirty in leoNodes.py
Removed import leoPrefs from leoAtFile.py
Moved unused assignment to top into #if 0 block in open in leoFileCommands.py
Removed unused name var from scanPHPText in leoImport.py
Bug fix: changed tangle_state to self in several places in root_attributes.__repr__
Bug fix: converted represent_print_bits to a method
	(It was indented as a method under class root_attributes)
Removed language,single_comment_string,start_comment_string,end_comment_string params from st_enter in leoTangle.py.
Bug fix (Major?): restored code to return part number at end of st_enter.
Latent bug fix: changed self.font to font in tree.setLineHeight.
Bug fix: all paths through idle_body_key and idle_head_key now return "break"
Removed topMenu var from tree.OnPopup.
Removed config var from leoFrame.__init__
Latent bug fix: changed editHeadlineMenu to self.editHeadlineMenu in leoFrame.__init__ 
Real bug fix: changed editHeadlineMenu to self.editHeadlineMenu in leoFrame.__del__
	(This affects how storage is freed)
Removed interp var from leoPyShellMain.</t>
<t tx="T90">Asumming that python and tcl are installed, It shouldn't take familiarity with python to be able to use leo. I want to be able to type

leo foo

and have leo start up on a new [outline] named foo.leo, or open the existing one if it's there.</t>
<t tx="T91">Leo now does the following: 

1. Leo checks all characters that are entered (via typing or via paste) into headline and body text to see whether they can be represented in the encoding specified in leoConfig.txt. 

2. Leo issues a message and _disallows_ the entry of the character if it can't be represented in the encoding specified in leoConfig.txt. 

In practice, this draconian behavior shouldn't be too much of a nuisance, at least temporarily. Note that _all_ characters are valid in UTF-8 encoding, so the present version of Leo will allow you to specify all characters if you must. But the Latin-1 (iso-8859-1) encoding, being a one-byte encoding, limits you to at most 256 separate characters. 

In 3.8 I plan to allow you to use _all_ Unicode characters, regardless of encoding, by using so-called character references.  This will require some reorganization of the present code, so I don't want to delay 3.7 to handle them.</t>
<t tx="T92">It is much more convenient to set these to proper defaults than it would be for the callers to do so.  Nevertheless, perhaps the caller should do so, but not now...</t>
<t tx="T93">This makes the present code compatible with Python 2.1.</t>
<t tx="T94">I needed this clarification.</t>
<t tx="T95">&gt; # Tk always uses utf-8 encoding.

You may get that impression, but it is slightly wrong. It is more
reliable if you pass Unicode strings to Tk, instead of UTF-8 encoded
byte strings.

For a byte string, Tk will guess the encoding. If it looks like UTF-8,
it is taken treated UTF-8. Otherwise, it is treated as the locale's
encoding. Unfortunately, if you ever manage to mix the two, you get
byte salad that you can't ever chew. By using Unicode strings to
interface with Tk only, you can avoid those problems.

&gt; print `s`,"tk"
&gt; s = s.encode("utf-8") # result is a string.
&gt; print `s`,"utf-8"
&gt; s = s.decode(xml_encoding) # result is unicode.
&gt; s = s.encode(xml_encoding) # result is a string.

Since xml_encoding is iso-8859-1, you are making a mistake here. You
have UTF-8 data, but you are decoding them as Latin-1. This will
succeed, but it will give an incorrect result. It will succeed since
iso-8859-1 is an single-byte code where every byte value is valid.
That means an arbitrary byte sequence can be interpreted as Latin-1,
but for many byte sequences, the resulting string is non-sense
(mojibake, as the Japanese say).

&gt; BTW, with out the first encode/decode pair I can take exceptions in
&gt; the last encode.

Nevertheless, this is the correct processing. If you have a Unicode
object, as originally obtained from Tk, you should encode as Latin-1
using

s = s.encode("iso-8859-1")

Now, for this specific string (u'a\u0102\xdf\xc9\n'), you will get a
Unicode error. The reason is that one character (\u0102) is not
supported in Latin-1 - this encoding supports only the first 256
Unicode characters.

So, when saving this as XML, the proper representation would be

'a&amp;#x102;\xdf\xc9\n'

i.e. you'll have to use a character reference. Python 2.2 does not
support generating such text very well - you'll have to catch the
Unicode error yourself, find the offending character, encode it as a
character reference, and encode all other characters as requested.

Alternatively, you can refuse encoding a document in a certain
encoding (such as Latin-1), and fall back to UTF-8.

PEP 293 (http://www.python.org/peps/pep-0293.html) will provide a
mechanism to generate character references more conveniently - in
Python 2.3, you can specify

  s.encode('iso-8859-1',errors='xmlcharrefreplace')

HTH,
Martin</t>
<t tx="T96">The Find Previous command could not go to previous nodes.</t>
<t tx="T97">It would be good to have a prefix option too.</t>
<t tx="T98">This fix was suggested by Rich Ries.  The original report follows:

I found the culprit; it's in the node &lt;&lt; scan @@ &gt;&gt; that reads: 

k = string.find(s,self.endSentinelComment,i) 

This means it stops at the FIRST endSentinelComment, which is the "*/". The rest of the line (with the correct "*/") gets chucked. Changing the line to: 

k = string.rfind(s,self.endSentinelComment,i) 

(note the "r" before "find") seems to fix the problem. 
</t>
<t tx="T99">The new code in putOpenLeoSentinel follows the example of putSentinel.</t>
<t tx="T100">They are simply relative representations of absolute indices, and so are basically useless.</t>
<t tx="T101">This is a huge step, and I hope it is forward. In any event, the change is simple and reversable.

I am now considering whether to use relative node indices instead of absolute node indices.

These would have the form +n and -n.  This would eliminate the cascade of changes when nodes were inserted.  The key question is whether the read logic can handle them.  I believe it can, with just a single ivar.</t>
<t tx="T102">Amazingly, the only change required to allow reads and writes of cloned @file nodes was to eliminate the error in updateCloneIndices.  I also fixed a bug: set self.errors = 0 in atFile.read.</t>
<t tx="T103">The upshot: both =pod and =cut must be preceded and followed by blank lines.  The simple tests have this.

Added perlpod hack to set_delims_from_string and changed delims to use double underscores in set_delims_from_language.</t>
<t tx="T104">This affects @path, @file and @root code.  This is probably the code with the most separate paths in all of Leo.  I would be amazed if there were no bugs here, and it does seem mostly to work.

The getBaseDirectory utility routine implements the relative_path_base_directory option:

"!" means relative to leo.py
"." means relative to .leo file.
anything else should be absolute path.</t>
<t tx="T105">This was just too horrible to keep straight, and bodyKeepsFocus should always be true anyway.</t>
<t tx="T106">It looks like the undo command does not fully undo changes to cloned nodes. Follow these steps to experience this effect: 

1) clone a node (same effect whether @file / @root or other) 
2) change the headline of either node. 
3) Edit-&gt;Undo change Headline (or ctrl-Z) 

Only the node that was changed will go back to the original headline. The undo command appears to be the problem since it does not properly undo changes to all cloned nodes' headlines. </t>
<t tx="T107">The new code is much more elegant than the old, and does a better job of reporting errors.

One new restriction has been imposed: at most one shortcut can be associated with a command.  If one really wanted to have two shortcuts, one would have to use two different command names.

In particular, there is now only one shortcut for the Find Next command.  This should not be a problem.

It is now possible to bind the arrow keys as desired.  See the complete discussion in leoConfig.leo.

Note that all bindings are made both to the body pane and the top-level pane. This keeps things consistent.</t>
<t tx="T108">There was a missing comma.</t>
<t tx="T109">It was remembering it only if set as the result of a keystroke.  The present code is redundant, but what the heck.</t>
<t tx="T110">1. Use the present body font in frame.setTabWidth.

2. Do not call frame.setTabWidth in setCommandsIvars.  Just set the ivar.  This fixes the following bug:

"If you set the @tabwidth to something other than the Preference value, you'll
see the body displayed appropriately.  However, if you do a Ctrl-s to save the
leo file, the body is redisplayed using the Preferences setting -- of course,
clicking on another node and then back to the original node displays with the
correct tab setting again.  The redisplay on save must not go through precisely
the same body display logic."
</t>
<t tx="T111">This was too confusing to users.</t>
<t tx="T112">This was done simply by opening derived files and .leo files in "wb" mode.</t>
<t tx="T113">Essentially I moved the code that updates body text from the @+node logic to the @+body logic.

This can not be completely correct.  It breaks verbatimAfterRef

From the forum message:

I have just uploaded a major change to the logic that reads derived files. Indeed, this is the first change to that logic that has ever been made since I first invented @file trees. This change is needed to correct a bug reported by Rich Ries involving referencing a section defined in a grandchild of the referencing node. 

WARNING: although this code is similar to previous code, and passes all the tests that I can think of, you
should still consider this code experimental for a while. 

The problem: Body text was being updated as the result of @+node sentinels rather than @+body sentinels.
This was stupid, as extra @+node sentinels are often generated when no body text is generated. The result is
that the body text was being cleared. 

The fix: I simply moved the code that creates body text from the @+node logic to the @+body logic in
scanText. This was relatively straightforward, and I do have some hopes that everything will once again be rock
solid. However, the context in which this code is executing is obviously changed (that is, after all, the whole
point), so no guarantees can be given at this point. 

Everything appears to work (all files derived from this file appear to be OK), and this code must be considered experimental for now.</t>
<t tx="T114">At this point there are no known issues with Leo and Python 2.1.

Python 2.1 gave the following warnings when importing Leo:

Python 2.1.3 (#35, Apr  8 2002, 17:47:50) [MSC 32 bit (Intel)] on win32
Type "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import leo

leoFrame.py:197: SyntaxWarning: local name 'self' in 'createMenuBar' shadows use of 'self' as
global in nested scope 'lambda'
  def createMenuBar(self, top):

leoFrame.py:1262: SyntaxWarning: local name 'self' in 'OpenWithFileName' shadows use of 'self' as
global in nested scope
 'lambda'
  def OpenWithFileName(self, fileName):

leoColor.py:1367: SyntaxWarning: local name 'self' in 'run' shadows use of 'self' as
global in nested scope 'lambda'
  def run (self):
</t>
<t tx="T115">It was just a matter of binding some unbound vars to defaults.</t>
<t tx="T116">- The font settings in leoConfig.txt are not active when I open Leo. They instantly activate when opening the Edit|Set Font... dialog, without having to click anything in said dialog. Then, once the .leo file is saved, the problem goes away.</t>
<t tx="T117">This code improperly removed trailing whitespace, including newlines, from the "middle" text.  Clearly this is wrong, regardless of what other effects it might have.

Affected commands are indent, dedent, extract and extract section.</t>
<t tx="T118">This makes it convenient to update the version number in this file properly.</t>
<t tx="T119">We now look through the entire tree looking for @root and @file nodes.</t>
<t tx="T120">single quote colorized text in plain text mode.  This was due to missing parentheses.</t>
<t tx="T121">CVS conflict files produce so many error messages that these errors are useless.</t>
<t tx="T122">1. Created a new sandbox and updated CVS into it.  This did not update LeoPy.leo.
2. Opened LeoPY.leo.  There were read errors in leoImport.py and leoUtils.py.
3. Used diff on CVS to determine which routines had been added to these files.
4. Cut and pasted from updated LeoPy.leo to my "real" copy of LeoPy.leo.

This is most annoying, though it is helpful to pay attention to the added code.

The read errors themselves are useless, and I removed them.

I forgot to do an update first, so after I opened LeoPy.leo with Read Outline Only, saving all files with Write @file Nodes reverted Dave Hein's changes.  So I reloaded them from the temporary sandbox.  This is very bad.</t>
<t tx="T123">The code is now functionally identical to the similar code in atFile.scanAllDirectives.  The old code did not handle relative paths properly in all cases.</t>
<t tx="T124">This code crashes on some Windows systems, including my XP system.  It may work on Win98.</t>
<t tx="T125">This involved calling readlineForceUnixNewline instead of readline in the atFile:read logic.</t>
<t tx="T126">Only the last directive was in effect in @root trees.  The new code allows node-by-node control.</t>
<t tx="T127">This routine does a better job of checking the Tk version than the old code in leoApp.py</t>
<t tx="T128">With Tk/Tcl 8.4, the Preferences window is empty (no buttons, fields, labels). 

Tcl 8.4 complains about using "col" in the grid() calls.</t>
<t tx="T129">Removed calls to c.frame.canvas.focus_force() selectThreadBack/Next, selectVisBack/Next.

I have no idea why this code was there originally.</t>
<t tx="T130">This may or may not fix Rich Reis's problems.</t>
<t tx="T131">How did I ever live without this?</t>
<t tx="T132">Changed:

bitmap_name = os.path.join(self.loadDir,"Icons\LeoApp.ico") 

to:

bitmap_name = os.path.join(self.loadDir,"Icons","LeoApp.ico") 
</t>
<t tx="T133">&gt; I'd love to open a node and be in the same place as when I was last there.
</t>
<t tx="T134">Everything appears to be working properly.</t>
<t tx="T135">When starting Leo with no arguments the 'NewHeadline' node was not displayed. </t>
<t tx="T136">os.rename can fail on some Linux systems.</t>
<t tx="T137">@nocolor

The new code is as follows.  This is extremely ugly, and I'm not sure there is any workaround.  The problem is that open is really just a stand-in for C's fopen routine, and the mode param is not uniform across platforms.

@color

# 9/1/02: apparently Linux requires w+ and XP requires w.
mode = choose(sys.platform=="win32","w","w+")
cf = open(self.configFileName,mode)</t>
<t tx="T138">This will allow Joe Orr to keep track of hits.</t>
<t tx="T139">The cursor now changes to an arrow when it moves over a link.</t>
<t tx="T140">1.  The link now takes the user to the SourceForge download page.
2.  Called os.setcwd(app().loadDir) to set the working directory for the download.</t>
<t tx="T141">This is still not working, and I am beginning to doubt that it can be done.

Notes:

1. In Tk terminology, bitmaps are 2-color only.  Most .bmp files must be considered _photo_ files.
2. I have figured out how to read .bmp and .gif files using image create photo.
3. All tests were run using tcl/tk 8.3.4, and wm iconbitmap has never worked.</t>
<t tx="T142">It already works in the other panes, but the recommended code crashes tk83.dll!</t>
<t tx="T143">There were a couple of botches in the new code:

1. leoTangle.scanAllDirectives should not issue any warning when it sees a relative path name in the @root directive.  (Which is the only place it will see it).  This is not an error.

2. leoTangle.pathError would create an exception when called.</t>
<t tx="T144">Amazing!</t>
<t tx="T145">1. Simplified the path logic in the various scanAllDirectives routines.

2. Distinguished between absolute and relative paths.  Relative paths do _not_ set the global defaults: they are handled by the file open logic which does os.path.join(default_path,file_name).

The logic is still quite complex, and for the first time the code may be simple enough to work.</t>
<t tx="T146">This should end most of the confusion.</t>
<t tx="T147">There are several problems here:

1. os.path.join(dir,file) won't work if both dir and file contain a partial path name.  I'm not sure whether this is a bug--there is probably no behavior that makes sense in all cases.

2. Unless os.path.join works above there is no way to see whether the directory is valid.</t>
<t tx="T148">Removed '\r' characters when reading.  The write logic is unchanged, which makes the changes slightly safer.</t>
<t tx="T149">An arg got dropped out when I added a flag.</t>
<t tx="T150">Found several bugs while doing so.  What else is new...

Use this script as follows:

- Select the node under which you want the imported files to appear.
- Open the Python window within Leo.
- Type the following in the Python window:

import leoImport
dir = "c:/prog/test"  # or some other directory
type = ".py"  # Type of files you want to import, or None for all files.
leoImport.importFiles(dir,type)</t>
<t tx="T151">The new code properly deletes previous entries regardless of case or path separators.</t>
<t tx="T152">Changed idle_body_key and idle_head_key so the old values are also checked for Unicode strings.  I don't understand why that is needed, and after a cut and paste operation it is needed.

Also fixed Tangle's version of the os routine.

Also changed the assertion and converted to unicode in tnode::setTnodeText.</t>
<t tx="T153">The calls to config.setX in the put routines in leoFileCommands.py were happening _after_ the calls to config.update().  There is not need to call the config.set routines in putPrefs and putFindSettings provided we do the following in write_LEO_file:

	c.setIvarsFromFind()
	config.setConfigFindIvars(c)
	c.setIvarsFromPrefs()
	config.setCommandsIvars(c)
	config.update()</t>
<t tx="T154">This creates leoConfig.txt</t>
<t tx="T155">The old code was totally brain dead.  If a setting was missing or "ignore" it could never be set!!  Sheesh.  This is a major bug because _all_ writes to leoConfig.txt go throught this routine.</t>
<t tx="T156">Otherwise there is no way to change the prefs!</t>
<t tx="T157">There were a couple of bugs here.

Note that the ratio (whichever the direction) is stored in the .leo file.  The initial_splitter_orientation setting in leoConfig.txt applies to _all_ files.  The initial_vertical_ratio and the corresponding initial_horizontal_ratio  apply only to new files, so are essentially useless.

Yes, this is pretty stupid; it's the result of not wanting to add more stuff to Leo's file format.</t>
<t tx="T158">This makes selected text look much better and makes Show Invisibles look much better as well.  

This was not easy to do.  Apparently tag settings interfer with the Tk.Text settings.  I have not found a way to specify the selectbackground color for tags.  The only way I could get things to work is only define whitespace tags when in showInvisibles mode.</t>
<t tx="T159">Added setRevertVars to update revert settings.  This is called from __init__ and onOk.</t>
<t tx="T160">This is consistent with what the Import commands do for the other file types.  It's also much safer.</t>
<t tx="T161">.tmp files disappear On Windows XP after Leo exits!</t>
<t tx="T162">The new spelling is to limit_directory_search_extension.  Note that this affects the valid entries in leoConfig.txt.</t>
<t tx="T163">Repeated double-clicking (without intervening single-click) caused the selection to move to the left.</t>
<t tx="T164">We must remove backticks from messages that might contain unicode characters so they will print properly.  There were only a few instances, and they are all error messages that hardly ever get executed, so I hope I was careful putting them in.  I should be able to find them all by looking for '"'.</t>
<t tx="T165">Simplified leoCompare.py and leoTangle.py.</t>
<t tx="T166">Now at last it is clear why Leo hasn't been writing derived files affected by clones.  It's not enough to mark v dirty.  We must mark all the cloned nodes of v's tree dirty as well.

However, we only need do this when a node is deleted, and we definitely do _not_ want to do this otherwise, for that would mark far too many nodes dirty.  To get around this, we leave v.setDirty() as it was, and use the new code only in v.setDirtyDeleted.

Note that the undo and redo cases handle this automatically because they call c.doDelete.</t>
<t tx="T167">Amazing.  All that was needed was some code to force conversion on write, and code in the event handlers to convert "real" unicode to UTF-8.  We are talking about 10 lines of code!

There was a problem in leoFind.findNext: it was backquoting the search string when reporting search failures.  Removing the back quotes made the message appear properly.

What was needed was simply to do:

	if type(s) == types.UnicodeType:
		xml_encoding = app().config.xml_version_string
		s = s.encode(xml_encoding)

On the string s gotten from the Text widgets in the event handlers.

As a defensive measure, I also changed the write code in two places to:

	try:
		self.outputFile.write(s)
	except UnicodeError: # This might never happen.
		xml_encoding = app().config.xml_version_string
		s = s.encode(xml_encoding)
		self.outputFile.write(s)

The old code wrote `s` instead of s.encode(xml_encoding).</t>
<t tx="T168">Also changed the calling code to check for val != None and val &gt; 0 or val != 0.  The only callers of skip_long are the various places that handle the @pagewidth and @tabwidth code.  Negative tab widths are allowed, but not negative page widths.</t>
<t tx="T169">Initializing to something else was preventing a lot of code from being used!

Retested the @path logic.  Everything seems good.</t>
<t tx="T170">These were used only to set the delim1, delim2 and delim3 locals in atFile.scanAllDirectives.  Getting rid of these two useless ivars greatly clarifies the code.</t>
<t tx="T171">This is weird.  set_language would set the delims to the default_language delims if the lanuage was "default"</t>
<t tx="T172">We can't use choose because both branches are evaluated.

self.single_comment_string was never None before because all languages had either 1 or 3 delims.  But Java now has only 2 delims to force block comments.</t>
<t tx="T173">The same bug appeared in leoAtFile.putIndent and leoTangle.put_leading_ws.  These routines should not do w = abs(tab_width) before the test.  I was confused that n (the desired indentation) might be negative.

Anyway, as a defensive measure, I used ' ' * abs(n) and '\t' * abs(n) in the routines in leoAtFile and leoTangle that put tabs and spaces.

Also, changed n / w to int(n/w) to avoid problems with future division.</t>
<t tx="T174">1. The botch was this: set_delims_from_language used to return
	delim1 = start_block_comment_string
	delim2 = end_block_comment_string
if there were only two delims.  But the callers thought that delim1 was _always_ the single_comment_string.

This actually never caused problems with @language, because all languages had either 1 or 3 delimiters.  However, it appeared when I forced block comments in Java by using only two delims.  And it could always have caused problems when people used the @comment directive.

2. Issued a warning and do nothing when no delims specified with @comment.  This could have caused crashes.

3. set_delims_from_string no longer returns hard-coded defaults.  Instead it returns None.  Callers must now beware, but this is the correct action to take.</t>
<t tx="T175">The change was made to leoFrame.py::reconfigurePanes.</t>
<t tx="T176">If a name table has only one name, it must be defined like

name = ("x",)

rather than

name = ("x")

This affected the following options:

"read_only"
"xml_version_string"
"limit_count"
"body_pane_wraps"</t>
<t tx="T177">1. Removed the following ivars.  They were never used.

self.singleCommentString = "#"
self.startCommentString = ""
self.endCommentString = ""

2. Initialized the following ivars to None in the ctor:

self.default_directory = None
self.page_width = None
self.tab_width  = None
self.presentLanguage = None
self.targetLanguage = None
self.startSentinelComment = None
self.endSentinelComment = None

This makes clear that they are really initialized in leoAtFile.scanAllDirectives.

3. Renamed leoAtFile.scanAllDirectives.&lt;&lt; Set delims to default values &gt;&gt; to &lt;&lt; Set ivars &gt;&gt;.  It's contents is now:

if 1: # 8/2/02
	self.page_width = self.commands.page_width
	self.tab_width = self.commands.tab_width
	self.presentLanguage = self.targetLanguage = c.target_language
else:
	self.page_width = leoPrefs.default_page_width
	self.tab_width = leoPrefs.default_tab_width
	self.presentLanguage = self.targetLanguage = leoPrefs.default_target_language
	
self.default_directory = leoPrefs.default_default_directory
delim1, delim2, delim3 = set_delims_from_language(self.presentLanguage)</t>
<t tx="T178">There were many, many problems in the old color panel.

- Completely revised the Revert logic in the main Color panel.
- The color name picker now reverts properly.
- Color names and color swatches are now properly updated in all cases.
  As a result, there is no need to write color values to the log window.
- Used str(name) rather than `name` to eliminate quotation marks around color names and values.
- The color picker now shows the value of the present color, not the revert color.
- Increased the width of name buttons to handle long color names.
</t>
<t tx="T179">See the child node for a proof.</t>
<t tx="T180">@nocolor

The test code shows that all normal cases are handled correctly.  Nevertheless, we must prove that Leo can properly read and write @file nodes with nested @others directives.

Writing:

putAtOthers writes all nodes to be generated by @others.  inAtOthers returns false if the node has already been visited.  Nodes will not be visited when expanding the "outer" or "upper" @others, and will be visited thereafter.  Thus, nodes will be written at most once.

putAtOthers writes only sibling nodes and nodes descending from sibling nodes.  The expansion of inner @others nodes will never include parent nodes.  The expansion of an @others directive at @file node will write all unwritten nodes in the @file node.

In short,

1. all nodes in the "range" of an @others directive are written once and only once.
2. all nodes in the "range" of an @others directive are written enclosed in @+-others sentinels.
3. No orpan nodes are written.

Reading:

The read logic is unchanged.  Everything will work as before.  In particular, note that @+-others sentinels create trees under nodes containing the @others directive, just as before.  The read logic naturally handles nesting!</t>
<t tx="T181">The bug was testing for ifdef instead of #ifdef at the start of skip_pp_if.  However, I thought the bug might be related to something else, so I ended up being much more careful about brace levels in different branches of an #if statement.  The result was the skip_pp_part routine.</t>
<t tx="T182">I think this is most reasonable: we don't wan't people generating files from imported files unless they take some positive action.</t>
<t tx="T183">This bug caused following defs to be included in the current def if the line ended in a comment that was followed immediately by another def.</t>
<t tx="T184">I wanted to generate the following if a class declaration is in a separate node:

class x:
	@others

Instead of:

class x:
	&lt;&lt; class x methods &gt;&gt;

+ &lt;&lt; class x methods &gt;&gt;
@others

This doesn't work at first: all nodes under class x become orphans.  However, the new version of 
</t>
<t tx="T185">In order to make the new import code work, I have _experimentally_ allowed a change to how leoAtFile writes code.  This is the first such change in about a year.

The old code in leoAtFile.inAtOthers did not write nodes in @others trees if such nodes descended from another @others node.  The new code allows such nodes.  Apparently the write code handles this case just fine and the old restriction was unnecessary...</t>
<t tx="T186">Added entries for default target language, outline, promote and demote.</t>
<t tx="T187">The code now makes sure that c.target_language and related vars are not None.  This should fix the problem, and I wouldn't bet my life on it.</t>
<t tx="T188">It's too confusing to have arrow keys mean different things in different panes.

For one thing, we want to leave the focus in the body pane after the first click in the outline pane, but that means that the arrow keys must still be functional in the _body_ pane!

Alas, all the various combinations of key bindings of arrow keys appear to do something; there are none left to use for moving around in the outline pane.  So we are stuck with poor shortcuts.</t>
<t tx="T189">The @others directive was appearing before &lt;&lt; declarations &gt;&gt; reference.

The bug report and the fix were from Walter H. Rauser.</t>
<t tx="T190">I used the dis module as a base.  It was remarkably easy.  All I needed was

1. dis.opname, the names of the opcodes and
2. some code in the dis module to use as a starting point.</t>
<t tx="T191">The performance of Leo is as I expected.  In particular, reading files is the biggest bottleneck, and scanning string.find, isAtFileNode, is_ws, etc. are called frequently.</t>
<t tx="T192">@nocolor

Bernhard Mulder suggested the following code for adding the path to idle to sys.path.  I used this code with only trivial modifications.  I retained the previous error handling code in case there are further exceptions...

@color

try: 
	import idle 
except: 
	executable_dir = os.path.split(sys.executable)[0]
	idledir=os.path.join(executable_dir, "tools/idle") 
	sys.path.append(idledir)
</t>
<t tx="T193">The fix was to put a call to frame.top.deiconify() in run() right after the call to the frame ctor.

Apparently I only use openLeo.py to open Leo.</t>
<t tx="T194">The Compare panel is much easier to use than the old scripts in leoCompare.py.</t>
<t tx="T195">It is remarkable how recasting the code as two classes clarifies and fortifies the code.</t>
<t tx="T196">@nocolor

The new rules allow leo.py 3.1 to read and write .leo files more like leo.py 2.x when there is no leoConfig.txt file.  The scheme used in leo.py 3.0 meant that preferences were _never_ written to .leo files.  It's advantage was that all defaults were specified in:

	leoConfig.&lt;&lt; define default tables for settings &gt;&gt;

I think the present scheme is more natural, but we shall see...

In effect, Leo sets and gets various options in the following order of precedence:

1. Use explicit settings in leoConfig.txt if they exist.

2. Use defaults for leoConfig.txt, but only if leoConfig.txt exists.  These defaults are found in:

	leoConfig.&lt;&lt; define default tables for settings &gt;&gt;

3. Use settings in .leo files if leoConfig.txt does not exist.

4. If leoConfig.txt does not exist, and the .leo file does not specify a setting, use hard-coded settings in the various classes, just as leo.py 2.x did.

Added the config.configsExist ivar to tell whether leoConfig.txt exists (as far as Leo is concerned).</t>
<t tx="T197">Also added tcl keywords for syntax coloring.</t>
<t tx="T198">The @pagewidth, @tabwidth and @language directives could not have worked while tangling!  Apparently nobody has every used these directives in @root trees!

1. Apparently, skip_long had never been executed successfully (!!)  Indeed, it computed the value of a string character by character using (s[i] - '0') which has no chance of ever working!

2. The code in tangle.scanAllDirectives that handles @pagewidth and @tabwidth could not have ever worked. is_special_bits sets the dict entries for "page_width" and "tab_width", but tangle.scanAllDirectives looks for dict["pagewidth"] and dict["tab_width"], both of which will cause exceptions!

3. The code in tangle.scanAllDirectives that handles @language failed to set the self.x copies of the c.x ivars relating to language! This bug may have dated from fairly recent times when I changed the tangle code to use the self.x ivars rather than the c.x ivars.</t>
<t tx="T199">This affects Flatten Outline and Import Flattened Outline.</t>
<t tx="T200">While I was at it, I made a few minor changes to leoDialog.py.

1.  Added padx and pady padding in dialogs.
2.  Added text="OK" param to AskOk.
3.  Used center_dialog utility in leoDialog.center.

The leoDialog code is still ugly, but not ugly enough to fix.</t>
<t tx="T201">I wanted to see if this would corrupt any derived files by interrupting the write.  I doubted that this would be so: events do not work like interrupts.

What happened was that the pending event seemed to slow the writing, and all derived files were written correctly.</t>
<t tx="T202">The answer to the question, "why not just improve compare scripts?" is that people rarely use scripts.  A compare window would be much more convenient.  And convenience matters here: it is very important that people feel comfortable importing and exporing files.</t>
<t tx="T203">Found many spelling errors and repeated words.</t>
<t tx="T204">We can't just keep getting the x,y coordinates from the event, because then we can't stop.</t>
<t tx="T205">All files now pass.  I changed the followoing:

	leoAtFile.py:   found bug: unbound c in read()
	leoColor.py:    removed import keyword
	leoCommands.py: removed unused vars from Convert Blanks.
</t>
<t tx="T206">It was amazingly easy to do this.  We need only compute self.line_height from self.font.metrics().</t>
<t tx="T207">Also fixed a but that resulted in Convert Tabs being undoable.</t>
<t tx="T208">There were several important optimizations:

1. OnDrag precomputes self.numberOfVisibleNodes().
2. Eliminate all calls to findVnodeWithIconId() in OnContinueDrag.</t>
<t tx="T209">Including the split direction and split ration.

Leo now uses all configuration settings from leoConfig.txt.</t>
<t tx="T210">Just putting a call to update() in leoFileCommands.getGlobals() does 90% of what we want.  Moving the calls to

	frame.top.deiconify()
	frame.top.lift()
	
from OpenWithFileName to getGlobals gets us to 99% of perfection.  There is a tiny flash when the frame created in leoFrame.__init__ is drawn then withdrawn.

The last 1% is accomplished by withdrawing the newly-created frame in frame.__init__.  With this last change there is no perceptable flash when a window is opened.  Of course, all callers of frame.__init__ must now call deiconify as needed.

Trying not to create a frame at all until its size is known would be much, much harder, because the frame and commands classes initialize each other.
</t>
<t tx="T211">The bug was in leoFileCommands.getGlobals.

This was a _really_ irritating bug.  Now windows open where they were when closed.</t>
<t tx="T212">This saves the "user" code a lot of work.

Note: if leoConfig.txt does not exist, the default tables in the section called:

&lt;&lt; define default tables for settings &gt;&gt;

in leoConfig.py take effect, so modifying these tables is yet another way of managing preferences.</t>
<t tx="T213">The present code works wether we destroy the prefs, font and color panels when we close them, or just withdraw them.  It is best to withdraw them, because this preserves their location on the screen when we bring them back.

Some things to keep in mind about this code:

1.  There must be code in frame.OnCloseLeoEvent to destroy these frames if present.  The reason is that these are now non-modal frames, so they could still be open when we close the Leo window that "owns" them.
This is true Regardless of whether these frames are withdrawn or destroyed when closed.

2.  Since the window are no longer modal, we might try creating them after they exist.  In that case, we must simply deiconify the panel, even if we destroy panels when they are closed.

In both cases, we _must_ maintain ivars accurately telling whether the panels have been created or not.  These ivars are owned by the leoFrame class.  They are created by leoFrame when creating a frame, and set to Null by panel code if panels are destroyed when closed.  Since the leoFrame class owns these ivars, a cleaner way would be to create a frameDestroy method for each kind of panel.  But that borders on the pedantic...</t>
<t tx="T214">so code can say getXparam("name") and always get a proper value.</t>
<t tx="T215">This was easy to do and useful.</t>
<t tx="T216">This was much more work than it "ought" to have been, due mainly to the fact that Tk.ListBox does not have a callback for changed selection.  So the selection becomes active only on a double-click or a change to the size or bold or italics boxes.

The present frame seems to handle all cases properly and without surprise.  The code to do so is tricky.</t>
<t tx="T217">All that is needed is that each Font and Color panel be firmly connected to a particular Leo window.  In fact, we must have separate Font &amp; Color panels for each Leo window.  The point isn't that we want all these window: in practice there is almost always just one Leo around. The point is that we can eliminate the irritation of modal windows!

This insight also applies to the Preferences panel.  It's not so important for the Find/Change window.</t>
<t tx="T218">This was a _huge_ amount of work.  I am quite proud of the result.  The present font panel is much more elegant and less cluttered than the examples I have looked at.  Indeed, the font panel pack a lot of power in a very small space.  I think this is really elegant design.

I spent hours and hours experimenting with different looks.  I finally realized that there is no need for radiobuttons:  they just add clutter.  More importantly, there is no need for an example frame!  The entire Leo window becomes an example.</t>
<t tx="T219">Leo keywords were mostly being coloring under the keyword settings.</t>
<t tx="T220">Using Ok, Cancel &amp; Revert buttons is _much_ better than Ok, Apply, Cancel because changes are made instantly.  The only problem is that the modal dialog makes it impossible to change text.  But with just a little foresight the user could create a "test" document beforehand.</t>
<t tx="T221">Leo now uses the xml_version_string configuration setting, if present, to override the UTF-8 setting used in all previous versions of Leo.  The usual value of the setting is = ISO-8859-1.  This effective changes Leo's file format: older versions of Leo will not be able to read the new files.

If the setting does not exist, whatever value is present in the .leo file will be written when the file is written.  For new files, a value of ISO-8859-1 will be used when this setting is not present.

Notice that this also affects what is written to the clipboard.</t>
<t tx="T222">Used the following to bind callbac:

@color

for i in xrange(len(self.recentFiles)):
	name = self.recentFiles[i]
	callback = lambda n=i: self.OnOpenRecentFile(n)
	recentFilesMenu.add_command(label=name,command=callback)
	
@nocolor
</t>
<t tx="T223">1. The @comment directive no longer suppresses syntax coloring.

2. Directives (but not doc parts) are colored when @language plain is in effect.  The user can, as always, suppress all coloring by using @nocolor.

The new rules are much more natural than the old, and much less confusing.</t>
<t tx="T224">This was a bit of a fiasco.  I updated CVS without a real test.  Hopefully I'll learn from this.

Anyway, the REM hack is as follows:  Leo will convert underscores in the @comment directives to significant spaces.  For example,

@comment REM_

causes the comment delimiter to be "REM " (Note the trailing space).

I originally inserted a skip_space in sentinelKind where the comment was "Do not skip spaces here!".  However, I eventually settled on a better solution, namely making spaces significant in scanHeader. To quote from scanHeader:

"Leading whitespace is now significant here before the @+leo.  This is part of the "REM hack".  We do this so that sentinelKind need not skip whitespace following self.startSentinelComment.  This is correct: we want to be as restrictive as possible about what is recognized as a sentinel.  This minimizes false matches."</t>
<t tx="T225">The "comment" code was looking for "language", not "comment" in dict.</t>
<t tx="T226">I'm proud of the code: it is simpler, clearer and more general than the previous code.

There were several important breakthroughs:

1. The old divideSplitter routine had hard binding to various panes.  This was wrong.  The new divideAnySplitter routine uses params for all frames, so it can be general.

2. The key invariant is that self.splitVerticalFlag tells the alignment of the main splitter.  Getting clear about this was crucial to making everything work.  I could then split the old divideSplitter routine into divideLeoSplitter and divideAnySplitter.  Once that happened, everything just worked when I changed self.splitVerticalFlag from true to false in frame.__init__ (!!)

3. We shouldn't ever delete any frames when toggling the split direction.  It's just too hard to reinitialize them.  The key to making this happen are:

a) the calls to pack_forget and
b) creating placeSplitter from the old createSplitter (now createLeoSplitter) code.

4. The key invariant allows us to define onDragMainSplitBar and onDragMainSplitBar instead of the old onDragVSplitBar and onDragHSplitBar. The new routines work regardless of split direction, so we don't have to rebind the split bars when the split direction changes.</t>
<t tx="T227">Change c.initJoinedCloneBit to c.initJoinedCloneBits.</t>
<t tx="T228">Added @root node to root of tree and eliminated @language and @others directives.</t>
<t tx="T229">Importing a Python file containing classes without methods results in nested classes.  A workaround is to insert a dummy method in each class.

The fix was to define classIndent and defIndent variables, and to ensure that we break on equality with these values.  Also changed code to generate reference to methods only if methods or nested classes were seen.

There is still a minor bug:  The following

class A:
	pass

Puts the pass statement in &lt;&lt; class A declarations &gt;&gt;.  This bug is not so easy to fix, and it is easy to correct by hand.</t>
<t tx="T230">Importing the following file creates orphan nodes for declaration.

import sys # This line becomes an orphaned node
class C:
    xyz = 'xyz' # This line becomes an orphaned node
    def __init__(self):
        pass

The fix was in &lt;&lt; Create a child node for declarations &gt;&gt;.</t>
<t tx="T231">Importing the following script

class C:
    def __init__(self):
        pass

created an outline with class C appearing in two nodes, something like:

class C:
        class C:
                def __init__(self):
                    pass

The fix was to &lt;&lt; Append a reference to class_vnode's methods &gt;&gt;.</t>
<t tx="T232">This fixes a bug involving clone bits, and is much faster than calling c.initAllCloneBits.  The code involves c.moveOutlineRight and similar code in the undo and redo logic.</t>
<t tx="T233">Verified that u.undoReplace will handle all clones properly.  c.copyTree simply makes copies of all tnodes after v.copyTree has actually copied the tree.  These are really simple and elegant routines.</t>
<t tx="T234">The new "replace" paradigm greatly simplifies complex undo.  The ahas:

1. swap_links is a very simple way of replacing trees.
2. The caller of swap_links can easily redo join lists and clone info.
3. We need to use new tnodes in copied trees.  This hasn't been done yet.
4. Undo and redo use exactly the same code.</t>
<t tx="T235">The aha is this: the import commands are in essence nothing but an insertion of a tree rather than a single node, so exactly the same code will work for undo and redo!</t>
<t tx="T236">@ It is often useful to print a traceback message when a try block unexpected fails.  This can be done as follows:
@color

import traceback
try:
	...
except:
	# traceback.print_exc()
	pass</t>
<t tx="T237">This is important, because it means that invalid entries in, say, the Default Tangle Directory preference will no longer abort an attempted read.</t>
<t tx="T238">This is a little tricky.  The general rules are:

1. Settings in the [override .leo file prefs] section of leoConfig.txt override similar settings that exist in the &lt;preferences&gt; element in .leo files.

2. You may cancel this overriding by using "ignore" (without the quotes) as the value of a setting in leoConfig.txt.  For example:

[override .leo file prefs]
tab_width = ignore

In this example, Leo will use the tab width in each .leo file, or a default value if it doesn't exist.

3. Leo won't write overridden settings to .leo files.

The actual rules are as follows:

1. If a setting is not found in either the [override .leo file prefs] section of leoConfig.txt or the preferences section of the .leo file, Leo uses a default, hard-coded value.

2. When reading a .leo file, Leo will use settings in the [override .leo file prefs] section of leoConfig.txt unless the value of the setting is "ignore" (without the quotes).  Case is insignificant when specifying the value of default_target_language.

3. When writing leoConfig.txt, Leo will write settings in the [override .leo file prefs] section of leoConfig.txt if the setting exists in leoConfig.txt and its value is not "ignore" (without the quotes).

4. When Leo saves a .leo file, Leo updates leoConfig.txt (using rule 3) and Leo will write a Preferences setting to the .leo file only if the setting will not be written to leoConfig.txt using rule 3.  NB: this rule does not change Leo's file format because all atrributes of the &lt;preferences&gt; element have always been optional.

5. Leo will update leoConfig.txt (using rule 3) whenever the user closes the Preferences Panel successfully.

As the result of these rules, changes made in the Preferences Panel will become permanent immediately if the the setting will be written under rule 3.  Otherwise, the change will become permanent when any .leo file is saved.

I believe these rules are flexible and good.</t>
<t tx="T239">These commands convert an entire tree.</t>
<t tx="T240">It is important not to change the c. copies of these ivars.</t>
<t tx="T241">These are actually quite nice to have, and they are possible only because we have a modal dialog.</t>
<t tx="T242">This makes it absolutely clear what is happening.</t>
<t tx="T243">Added @language to all @file nodes.  This is good style.</t>
<t tx="T244">Gary Herron suggested this change.  This affects a number of commands.  Apparently this makes a difference in Linux...</t>
<t tx="T245">This allows us to remove the c.setIvarsFromPrefs routine.  I have left it in as a reminder of what needed to be done formerly.

Removed app().prefs and all references to it.</t>
<t tx="T246">This variable should _not_ be eliminated!  It is needed when reading the .leo file for the first time.</t>
<t tx="T247">These commands now set self.mFileName only if the dialog succeeds.  This is much more natural.</t>
<t tx="T248">This was a weird one.  I have no idea what I was thinking about!  Using c.openDirectory makes absolutely no sense.  Probably the c.openDirectory ivar should go away!</t>
<t tx="T249">The whole preferences issue needs rethinking and reworking...</t>
<t tx="T250">DEMOTE:

  Doc: The Demote command makes all the siblings of a node children of
  the node.

  Reality: Not quite: it makes all sibilings WHICH FOLLOW a node into
  children
</t>
<t tx="T251">LOG WINDOW:

  Doc: The Open Log Window command opens the window, and the Close Log
  Window command closes it.  Only one of these commands is present in
  the Window menu at any time.

  Reality: These don't seem to exist.
</t>
<t tx="T252">INSERT HEADLINE:

  Doc: The Insert Headline command inserts a new headline as the next
  sibling of the currently selected headline.  If the root headline is
  selected, this command inserts the new headline as the first child
  of the root.

  Reality: Insert Headline appears to insert a child if the current
  headline has any children, and it appears to insert a sibling
  otherwise.
</t>
<t tx="T253">EXTRACT SECTION COMMAND:

  Doc: The Extract Section command creates a new node ...

  Reality: The menu item is highlighted (no mater what the first line
  contains), but NOTHING HAPPENS (no mater what the first line
  contains).

Leo.py works correctly.  Fixed docs.</t>
<t tx="T254">SYNTAX COLORING

  Is never highlighted so can't be used


FONT PANEL:

  Is never highlighted so can't be used

</t>
<t tx="T255">At long last cut/paste works properly!

1.  The way to get the contents of the clipboard is:

s = app().root.selection_get(selection="CLIPBOARD")

The following does _not_ work:

s = app().root.selection_get(selection="clipboard")

2.  Added stringIsValidMoreFile and convertMoreStringToOutlineAfter to leoImport.py.  These routines just convert the string to an array and call stringsAreValidMoreFile and convertMoreStringsToOutlineAfter.

3.  Removed app().clipboard ivar.</t>
<t tx="T256">Once again, things are easier with Python than I expect.  The ConfigParser class is quite nice: it gives a flexible framework for all kinds of preferences.  It would be good to move most, if not all, preferences into this framework.

Note: we no longer need to change the format of .leo files to handle new kinds of preferences!  Indeed, we can just define new sections of leoConfig.txt!

Leo reads and writes leoConfig.txt.  Leo looks first in sys.leo_config_directory.  If that has not been set in sitecustomize.py, then Leo looks in app().loaddir.

</t>
<t tx="T257">This assert isn't useful and doesn't have to be true.</t>
<t tx="T258">Added code to recover the old .leo file if the write fails.  We create a backup (.bak) file by renaming the .leo file if it exists.  If there is a write error, we rename the .bak file back to .leo.  Otherwise, we just delete the .bak file.</t>
<t tx="T259">This was so easy...It should have been done ages ago.</t>
<t tx="T260">LeoDocs.leo now matches Leo's web site as closely as possible.  At this point, I consider Leo's documentation completely finished.</t>
<t tx="T261">The solutions to the control-H bug was to call v.edit_text.focus_force() in tree.editLabel().

Adding a call to es() in endEditLabel() makes everything work, at least on XP, but this is too strange.  I finaly fixed the problem by having c.insertHeadline call c.endUpdate(false) followed by c.tree.redraw_now().  This is pretty kludgy. Apparently the call to c.endUpdate() was redrawing the outline after the headline had been selected, with the usual bad results.  </t>
<t tx="T262">I removed a binding that resulted in double-clicks in headlines expanding or contracting nodes.  You can expand or contract headlines now by double-clicking a node's headline or by clicking its plus/minus box.

This change was requested by Bill Drissel.</t>
<t tx="T263">I have spent quite a bit of time on getting dragging to work as smoothly as possible.  This has been made more difficult because I know of know way of reading the state of the mouse button without generating a mouse-moved event.

To start a drag, press the main (left) mouse button while the cursor is over the icon for a node.  The cursor will change to a hand icon. Continuing to drag the mouse will scroll the outline pane if the hand cursor moves above or below the outline pane.  If you release the mouse button while the hand cursor is above another icon, Leo will move the dragged node after the node over which the cursor rests.  If you release the mouse button when the hand cursor is not over an icon, Leo will print "not moved" and leave the outline pane as it is.  This can result in the dragged node not being visible on the screen, but it seems less alarming not to force the current node to become visible as that would undo any scrolling that has just been done.

As usual, there are a number of details.  

1. Leo only allows dragging from one icon to another.  In particular, you can't move a node to the first child of another node unless that node is already expanded.   I experimented with automatically open nodes when the cursor moves over an unexpanded node with children.  However, this was highly confusing.  It seems less alarming to expand and contract nodes explicitly. 

2. Leo scrolls the outline pane as the result of mouse-moved events, so to continue scrolling you must keep moving the mouse.  I experimented with scrolling the outline pane whenever the cursor is dragged outside it, but the results are not good.  There was a noticable delay between releasing the cursors and halting the scrolling.  The present code is simpler and more likely to work on all platforms.</t>
<t tx="T264">Note that tangle.scanAllDirectives already did this.</t>
<t tx="T265">es() failed if log is None because log.newlines does not exist.  The new code alters log.newlines only if log is not None.</t>
<t tx="T266">Leo takes an exception.  It may be because tcl 8.3.4+ is required.  The download tcl is 8.3.4.2, but I'm not sure what version is included in Python 2.2.1.</t>
<t tx="T267">In particular, the theory of operation for Tangle and Untangle was eliminated by mistake several months ago.</t>
<t tx="T268">There were two problems in this area.  First, v.moveToRoot wasn't preserving the tree when a node was moved to the root.  This caused nodes to disappear.  Second, the code wasn't taking care to change c.tree.rootVnode as needed when nodes moved up or down.

Several important routines had to be changed.  v.moveAfter and v.moveToNthChild now are careful to set c.tree.rootVnode if the root changes.  I hacked v.moveToRoot and v.linkAsRoot so that they update c.tree.rootVnode only if the oldRoot param is not None.  This allows the init code to work properly, and allows the v.moveToRoot routine to properly link in the rest of the tree.  The undo and redo code now use the new param to v.moveToRoot.</t>
<t tx="T269">@nocolor

The new code isn't great, and it seems to solve the immediate problem.

@color

try: # 5/27/02: We can get Unicode strings here via cut/paste.
	try:
		self.outputFile.write(s)
	except UnicodeError:
		self.outputFile.write(`s`)
except:
	es("error writing:" + `s`)</t>
<t tx="T270">After creating some clone nodes with the Borland version of Leo, LeoPy.leo was corrupted.  Reading the damaged file with Read Outline Only works, so apparently the problem involves the clone indices in the derived files.

The problem was that not all the code in atFile::updateCloneIndices got copied back to the Borland code.  In particular, clone indices were not cleared before being reassigned!</t>
<t tx="T271">Added skip_matching_delims utility function.</t>
<t tx="T272">Removed extra whitespace between sections.

Fixed bug in convertCodePartToWeb: added code to skip @file line.</t>
<t tx="T273">This was an attempt (probably futile) to fix a crash in cut/paste logic.</t>
<t tx="T274">This allows the the last filename used to be the default for the Outline To Noweb dialog.</t>
<t tx="T275">We generate &lt;&lt;*&gt;&gt;= only if no file name is given in @root or @file.  The old code always generated * for @root.

Also, changed &lt;&lt; append head_ref &gt;&gt; so that @c generates &lt;&lt;fileName&gt;&gt;= instead of &lt;&lt;*&gt;&gt;= whenever possible.</t>
<t tx="T276">I rewrote isDocStart.</t>
<t tx="T277">Moving an outline up before the "root" node hung in v.setDirty.

The fix was in c.moveOutlineUp: we must call v.moveToRoot, followed by back.moveAfter.  To make this work, v.moveToRoot must leave the mFirstChild link unchanged.

Fixes were also needed in undo.undo() and undo.redo() to handle this special case.</t>
<t tx="T278">This fixed a bug that caused Leo to hang when syntax coloring noweb code with the CWEB syntax colorer.</t>
<t tx="T279">This routine must take into account the kind of file being imported.</t>
<t tx="T280">There are many details here.  The present code handles substantial code well, and looks good.</t>
<t tx="T281">The green used by IDLE looks really good to me.</t>
<t tx="T282">The code now purports to work for both CWEB and noweb files.</t>
<t tx="T283">Outline To Noweb creates &lt;&lt; * &gt;&gt; sections when it doesn't know what name to give something.  This may be partially correct, or entirely wrong.</t>
<t tx="T284">Please note that the same mechanisms work unchnaged for both @root and @file trees.</t>
<t tx="T285">I hacked the Python and Java code (hacks on hacks) to insert nodes to carry @others commands when generating @file trees.  The Python code now handles nested classes fairly well.

At this point I'm not sure what is a bigger kludge, the "parsing" parts or the "code generation" parts.  I really don't want to do full parsing here, but the present code is pretty wild.  OTOH, it works.

Fixed bug in skip_pascal_string.

Split the Import Files command into Import To @file and Import To @root.</t>
<t tx="T286">Debugged the Import Files command for .py files.  The main problems were getting the params to the scanPythonX routines correct: these were just transcription problems.

Fixed 2 bugs in the colorizer: it wasn't handling Python triple strings or C preprocessor directives properly.

Fixed a bug in skip_python_string.  It was returning the start of the ending delim, not past it.</t>
<t tx="T287">It only took an hour.  I am amazed this hasn't been done long ago.</t>
<t tx="T288">Issue the "reading:" message only if the file can be opened.
Eliminated the #--- error reading x" message before read errors.</t>
<t tx="T289">Added a return value to update_def so that skip_body can tell if a node has been changed.  skip_body now calls v.trimTrailingLines only if the node has changed.</t>
<t tx="T290">Untangle was setting the pane changed even when not reporting any changes.  This was due to a call to v.trimTrailingLines.  Changed v.setBodyStringOrPane so that it calls c.setChanged and v.setDirty only if the new text is different from the old, but this doesn't completely solve the problem.</t>
<t tx="T291">These are helpful in leo.py because the commands are slower than in LeoCB.</t>
<t tx="T292">The code mistakenly set part to zero before calling update_def, with the result that the wrong parts were compared.  This simple blunder took several hours to find.</t>
<t tx="T293">Documented new file format, unlimited undo/redo, auto indent, Contract Parent and Sort Siblings commands.</t>
<t tx="T294">Note: this code is still untested and very likely has major bugs.</t>
<t tx="T295">I did this to reasssure myself that such changes were benign, and they are: all files Tangle and Untangle as before.  Also, @space (or @doc) is needed at the start of all doc parts so that Leo2 will syntax color them properly.

This took quite a bit of time, and I really should do this for all of LeoCB.leo, or alternatively, convert all of LeoCB.leo to @file trees.  I'll probably leave this as an exercise for someone else to do ;-)  Actually, the proper way to do this is probably to write a Python script.</t>
<t tx="T296">The code is straightforward.</t>
<t tx="T297">Fixed &lt;&lt; Scan and define an @code defininition &gt;&gt; and &lt;&lt; Scan and define a section definition &gt;&gt; in skip_body.  The calls to skip_code were setting k, not i.  I'm not sure how Tangle could ever have worked before.  Perhaps a reversion of some kind.

With these fixes, all files are tangled identically by LeoCB and leo.py.

Removed trailing lines in code part in st_enter.  With this change almost all files compare identical except those containing (!newline).  Fixed a bug in put_section which caused whitespace not to be properly output after (!newline).  With this fix leo.py tangles all files in tangleTest.leo exactly the same as LeoCB!</t>
<t tx="T298">One bug remains in the Borland version and will probably never be fixed: Preferences settings do not stick to windows.  This is a result of using the arg_xxx vars rather than ivars.</t>
<t tx="T299">It is intolerable to have misleading syntax coloring.  The syntax colorer treats @c just like @code.  Tangle must do the same.</t>
<t tx="T300">Made the root arg optional.  If present it is a list with one element and is_special_bits checks for @root.  We pass a list of one element to is_special_bits so we can distinguish between None and [None].

Removed @owncolor code.</t>
<t tx="T301">In leoFrame.py: make the font size platform-dependent.
In leoTree.py: use os.path.join to join Icons and file names.</t>
<t tx="T302">''' wasn't handled like """</t>
<t tx="T303">pychecker is a marvelous tool.  It fixes most of the problems that compilers fix.</t>
<t tx="T304">Caught by pychecker:  the call to special_bits was missing the i param.  This would cause a fault when executed.</t>
<t tx="T305">changed mStartSentinelComment to self.startSentinelComment.
changed mEndSentinelComment to self.endSentinelComment.</t>
<t tx="T306">changed writeError to self.writeError.</t>
<t tx="T307">Changed message to self.message in BadLeoFile.__init__.

Changed param to es in getTnode().</t>
<t tx="T308">Initialized s to "" in moreHead.

Note: v.trimTrailingLines does nothing(!)

removed v.saveOutlineWithLevel.  This uses dvnodes and is old, old code.

removed v.setThreadLinks.  This was a bad idea that should have gone away a long time ago.</t>
<t tx="T309">x Changed all arg_ vars to ivars in scanAllDirectives:
	arg_present_language --&gt; self.language
	arg_tab_width --&gt; self.tab_width
	arg_page_width --&gt; self.page_width
	arg_use_header_flag -&gt; self.use_header_flag
	These will affect the @comment and @language directives!
x Changed set_root_delims() to self.set_root_delims()
x Changed end_sentinel_len to len(end_sentinel)
x Changed sentinel_end to self.sentinel_end in scanDerivedFile.
x Added c = self.commands in massage_block_comment. (This routine is never used, though).
x Removed extra param to match in put_section.
x Initialized code = None in skip_body.
x Initialized path in untangleRoot before error messages that use path.
x Used marked_flag properly in untangleMarked.</t>
<t tx="T310">A weird one: LeoCB was removing the last character (typically half of a cr-lf combination), probably in the mistaken belief that it was an end-of-file character.  Geeze:  how do C++ programs ever work when you have to deal with minutia like eof marks and 2-character newlines.  Tk has really spoiled me.

I added code to leo.py to ensure that even compressed derived files end in a newline, which will help.</t>
<t tx="T311">Emailed Guido.  He indicated that the fix just involves filenames, so I took a look at it immediately.  Used Leo to study the code and made a simple fix.</t>
<t tx="T312">This fixes a serious hole in Leo:  The read logic would crash (report corrupted sentinels) if what follows a reference looked like a sentinel line!</t>
<t tx="T313">It turns out to be easy to suppress newlines between sentinels.  It is a bit harder to make the read logic work properly.

By single-stepping through the Borland code (which also fails when newlines are suppressed) I see that there is logic in scanText that checks for a non-blank line after a +body sentinel!  By adding a check to see that the next line is not another sentinel line we can make the read logic work properly.

I wonder: suppose the text after a reference looks like a sentinel?  What happens then?</t>
<t tx="T314">Fixed a bug that for all languages (like Python and Perl) that do not have block comments.  The change was to update_def.</t>
<t tx="T315">Three characters were colored blue at the start of a section def in:
  &lt;&lt;name&gt;&gt;=
The fix was to change k to 2 in one spot.</t>
<t tx="T316">This is the only undoable command.  Now it puts up a dialog saying that.</t>
<t tx="T317">Optimize Undo Typing by suppressing the "oldText" entry in the dict if the previous entry was "Typing" and the vnode match.  This optimization saves almost half the space used in the bead list!

Verified that the Change All and Read @file Nodes commands call clearUndoState().

The "Cut", "Copy", "Delete", "Change", "Convert Blanks", "Indent", "Undent" are now undoable.  The only change was a new param to the body key handler.

Created onBodyWillChange event handler.  We must distinguish between commands like "Find, Then Change", which must call onBodyChanged, and commands like "Cut" and "Paste" that must call onBodyWillChange.  The former commands have already changed the body text, and that change must be captured immediately.  The latter commands have not changed the body text, and that change may only be captured at idle time.

Keystrokes in the headline are now undoable.</t>
<t tx="T318">The code is hardly more complex than the old limited code.  In many places it is simpler.

The code now saves only the "optional" ivars that are non-None.  This should be an important space optimization for "Undo Typing".

While messing with Undo in the body pane I realized I could simplify idle_body_key a bit.  I believe this is important.</t>
<t tx="T319">alt-v now work in @nocolor mode.</t>
<t tx="T320">Almost all of the logic is language independent!

Added keywords for c,pascal,perl &amp; python.</t>
<t tx="T321">skip_doc must test for actual strings, not the return value from token_type.</t>
<t tx="T322">This was a fix to the syntax colorer only.

Also colored the equal sign in &lt;&lt;name&gt;&gt;=.</t>
<t tx="T323">Added undoers for Cut/Past Node commands and Sort commands.

Apparently the Copy Node command has no undo consequences.

Added calls to clearUndoState for Read and Import commands.  Actually, the Import commands could easily be undone: they are just like insert commands.

Decided not to clear the undo state after Save commands.  Do so is confusing and seems pointless.  I may revisit this issue when implementing Unlimited Undo.</t>
<t tx="T324">These are not present in the CVS tree.  They should be.

c2py.py, openLeo.py, tangle_done.py, untangle_done.py, __init__.py.</t>
<t tx="T325">Most problems had to do with changing c.undoX to c.undoer.undoX or u.undoX.

Everything with an undoer now works.

Cut/Copy/Paste Nodes have no undoers.
Sort commands have no undoers.</t>
<t tx="T326">Apparently WinCVS is set up appropriately.  Remember to use my corrct password

Did a checkout from the create menu and everything went well!</t>
<t tx="T327">It is clear that broken clone links can't be mended automatically.  That is, Leo can't be made significantly more CVS friendly.  That being so, let us consider how to use CVS with Leo.

Our goal is this: we don't want clone links to break when we check derived files into or out of the repository.  In general, clone links will break whenever we a read derived file from a .leo file different from the .leo file that created it.  So to meet our goal we must obey the following rules:

Rules for using Leo files with CVS:
	
1. All derived files in a particular revision in the CVS repository must be generated by a single .leo file. Call that file the _generating_ .leo file (for the revision as a whole and for each derived file in particular).
	
2. When we check out files from the repository we must check out the generating .leo file in addition to the derived files that we are checking out.

3. When we check in files to the repository we must check in the single .leo file that generated the derived files that we are checking in.

4. When CVS detect update conflicts in derived files, developers must resolve those conflicts in a "merged" .leo file.  All derived files that are later checked in must be derived from this .leo file.  When creating this merged .leo files, developers should take care to retain clone links.  

These rules make a virtue out of necessity.  I always envisioned that update conflicts would have to be resolved in .leo files rather than derived files.  What I now see is that this is the also the only way to prevent clone links from being broken.</t>
<t tx="T328">Just after I completed the Mending Dialog I realized that the concept behind this dialog was fatally flawed: cloned nodes must have the same structure!

Indeed, at the time the Mend Clone dialog is put up, the user would have no way of knowing whether any joins made sense.  Conceivably Leo could test for structural simularity, and in that case this dialog would be useless.  Note: many read errors arise from structural mismatches; clones could never be mended properly in those cases.

About the only situation in which mending would be possible is if the only differences between trees were outline differences.  This suggests that we don't test headline text at all and just rely on structure identity.</t>
<t tx="T329">This dialog returns a list of pairs of names.  It is up to the caller to associate the names with vnodes.</t>
<t tx="T330">Moved these out of the frame class: the undo class also uses them.</t>
<t tx="T331">We want to remove only the leading whitespace present on the first line, not all leading whitespace!

Also, the Extract Section command was deleting the section reference line.

I could have sworn I tested these commands.  Apparently not.</t>
<t tx="T332">It appears that DnD will be straightforward: probably less then 100 lines of code!</t>
<t tx="T333">Removed "blank" and "tab" tags on entry.  I thought I did this!  Anyway, it remains to be seen whether this has any effect on the "disappearing" selection bug.

I did some perfunctory tests on the various find/change commands and everything appears to be working well.  We shall see...</t>
<t tx="T334">Made headlines longer in tree.headWidth(). Sometimes the right edge of a headline was being cut off.  This must be a Tk bug, and the workaround is easy enough.</t>
<t tx="T335">Cleaned up the code in several ways.  Some of these have been bugging me for a while.

Yesturday I realized that the proper time to clean up code is just _after_ a release.  That way the new code will be thoroughly tested before the next release.

c.tree.currentVnode -&gt; c.currentVnode()
Used keyword.iskeyword() in leoColor.py to test whether a word is a Python keyword.
Used string.endswith() in Import code.
Renamed is_c_word() to match_c_word() to be compatible with the match and match_word names.</t>
<t tx="T336">This is used in v.sortChildren and in leoImport.sort testing routine.  Apparently the latest code is about the best that can be done.  Passing a param to the list.sort() routine might seem elegant, and apparently it is slow.  Also, it is not clear how to pass the "n" param to the sort routine. I might challenge the net to do better, but the present code works and is fast, general, elegant and clear.</t>
<t tx="T337">Experimented with using Python's inspect module.  However, it doesn't provide nearly the level of parsing needed for Leo's import commands.  We need access to the entire parse tree.  It is probably possible...</t>
<t tx="T338">Removing from leoUtils import * from reload_all() will cause problems.  The only workaround appears to quit Python when modifying leoUtils.  Sigh.</t>
<t tx="T339">This is a really useful command!</t>
<t tx="T340">This is quite tricky code.  To capture changed values we typically must set a commands method that calls an idle routine. We can't capture the values by binding Button clicks because values haven't changed yet, or so it seems.

Anyway, the preferences panel settings now appear to "stick" to the presently active window.

The print_prefs routine was vital to sorting out what was happening.</t>
<t tx="T341">Now the real work begins.</t>
<t tx="T342">This will serve as a start for CVS.</t>
<t tx="T343">Added commands handler for all radio buttons.  There was a timing problem: it took 2 clicks to set the current language.  Also added code to recolor the body pane immediately.</t>
<t tx="T344">It is vital that @file nodes remain dirty until they are written without errors.  Otherwise, a Save command will succeeed without warning, and a later read may cause the dreaded "clones have been cleared" message.</t>
<t tx="T345">The settings in the Preferences panel now "stick" to the current window.  This turns out to be very important for Tangling: I ran into serious problems with Tangling to the wrong directory when more than one window was open.</t>
<t tx="T346">This turns out to be more useful than Sort Children.</t>
<t tx="T347">All the "Tangle" Constants must be defined in the same place.  It turns out that leoUtils no longer use any of these constants anyway, so I moved them to leoTangle where they have always belonged.

scanError() is now the only part of leoUtils that uses Tangle data.  It accesses the commands instances using the top() function.  A kludge...

In any event, when I split them I also defined some new values, so values from leoGlobals.py overlapped with values from leoTangle.py.  It is a good thing I caught the problem now...</t>
<t tx="T348">Moved the tangle constants into the tangle class.

Changed header to self.header in an error message in scanAllDirective.

The source of the "mismatch" in Utils.h was that somehow I inserted @c into the root of Utils.h, which should produce errors, and eventually it did.</t>
<t tx="T349">I reset the default tangle directory while doing regression testing, then saved LeoPy.leo.  This destroyed files LeoPy directory, I'm not sure how, so I had to revert.  All looks well now.</t>
<t tx="T350">There was a problem with a global change command.  I'll have to do a full regression test of Tangle.  This would be a good time to use the new whitespace utility routines.</t>
<t tx="T351">This was the result of a Change All disaster.</t>
<t tx="T352">We have to update s_text as well as c.body so that another call to search on the same line will find the updated text.</t>
<t tx="T353">Newlines now set the dirty bit.

We increase auto indent after a colon.  This should happen only for Python mode...</t>
<t tx="T354">Once again, I am astounded at how easy this is.</t>
<t tx="T355">Convert Blanks now converts the entire body pane if there is no selected text.</t>
<t tx="T356">It is doubtful that leo.py will ever support a Print command directly.  Rather, users can use export commands to create text files that may then be formatted and printed as desired.  Tk does provide print support.</t>
<t tx="T357">Only blanks and tabs are shown, and they not very well.

What we need is a font that shows blanks and tabs as descent symbols for blanks, tabs and newlines.</t>
<t tx="T358">The key is that two things have to happen:

1. Menu items should be enabled only when focus is in the canvas pane.
2. Bindings for for the outline commands should be added only to the canvas pane.</t>
<t tx="T359">A useful convenience method that makes it much clearer what is going on.</t>
<t tx="T360">Sherlock attempts to read the file SherlockArgs.  If found, each line is assumed to be a separate sherlock argument.

However, the main improvement is defaulting empty arguments to "+*".  This makes tracing as easy to use as print statements.

Could trace accept multiple arguments, just like print?  No: we would lose the ability to specify tracepoints by default.  There is no need to duplicate print!</t>
<t tx="T361">Very easy to do, compared with other systems.</t>
<t tx="T362">This should solve some compatibility problems.</t>
<t tx="T363">Alt-1 refers to Alt-Button-1, not Alt-Key-1 (!)</t>
<t tx="T364">Changed frame.put routines so that they return during quitting.

Also removed trace statements from __del__ routines.</t>
<t tx="T365">We must be careful to enclose all find/change code in c.beginUpdate/c.endUpdate(false) so a redraw after the call to tree.redraw_now() in find.showSuccess won't deselect the headline text.

It would be elegant to cancel any pending redraw in tree.redraw_now, and that does not seem to work.

Because we don't always redraw the screen, we must update icons "by hand" by calling c.tree.drawIcon.

It is very tricky to compute self.in_headline correctly.

Perhaps a more sensible approach would be to have the tree.redraw routine save and restore the editing status and selection of the current headline.  However, the present code works and minimizes redraws, so there isn't much incentive...</t>
<t tx="T366">The idea was that if all drawing happens at idle time we could do the following:

	Eliminate all c.beginUpdate()
	Eliminate all c.endUpdate(false)
	Replace c.endUpdate() with c.redraw()
	Replace c.endUpdate(flag) with if flag: c.redraw()
	
However, the find command needs to _prohibit_ drawing, and there doesn't seem to be a clean way to do this, so using c.endUpdate(false) seems to be needed.

In other words, without c.endUpdate(false) we would need c.cancelDrawing(), and this doesn't seem any cleaner than the present code.</t>
<t tx="T367">I messed things up when I "optimized" the redraw code.  The Find code must redraw the screen _before_ making selections in the headline--otherwise the headline becomes inactive.</t>
<t tx="T368">Altered the Cut/Copy routines so they set Leo's internal clipboard (app().clipboard).  So to cut from LeoCB to leo.py do the following:

Copy the tree in LeoCB.
Paste the tree into empty body text of leo.py.
Select all the body text and paste.
Move to the tree view, and do a Paste Node.

Yes, this is very clumsy, but how often do we want to transfer information between LeoCB and leo.py?</t>
<t tx="T369">This is defensive programming.  Only a few event handlers override body handlers:  These include Control-I, Control-T and Control-D.

Exception: the command handlers for cut/copy/paste must _not_ return "break"!  The actual work is done by the Tk.Text widget.</t>
<t tx="T370">Now that event handlers return "break" they can do things involving focus that they could not do before.</t>
<t tx="T371">This is done in frame.createAccelerators().  For the first time leo.py handles keystrokes properly!

We could override _all_ body pane keys, and this would be dangerous until all event handlers return "break."  Indeed, doing so would create duplicate bindings, one for frame.top and one for frame.body, so without a "break" the command would be done twice!</t>
<t tx="T372">Event scripts need only return the string "break" to inhibit all further event processing!  This is what I have been missing all along, and it was staring me right in the face.  Sheesh.

This eliminates the need for several kludgy workarounds:
	The double-click event handler no longer needs to wait till idle time.
	The c.moveDown routine no longer needs to call c.select.

Another breakthrough.  Way down at the bottom of the Tk.Text documentation I discovered a list of all the key bindings defined by default in Text widgets.  This includes Control-O, which explains why body text sometimes had blanks lines inserted at the top. (Amazingly, Control-O never seems to have split lines, purely by luck.)

I can now use control-I to insert nodes again!</t>
<t tx="T373">This is similar to the double-click logic!</t>
<t tx="T374">We must compute the word to be selected before the Tk.Text widget does its default double-click handling, then actually select the text at idle-time.</t>
<t tx="T375">The code was easy to write and worked the first time.  I love Python.  I chose to ignore case in the comparison.

A more elegant solution would be to define a v.__cmp__ method, but the present code is clear enough and works.</t>
<t tx="T376">Fixed the Tangle Marked command.  It had numerous problems.

The code that executes Leo_done.bat and Leo_un.bat didn't work.  Now these options specify Python scripts to execute, and these scripts are passed a list of filenames that were tangled or untangled.</t>
<t tx="T377">Created go.bat and openLeo.py.  These simplify the process of starting leo.  Just open a console window and type go.

Added "c:\prog\LeoPy\LeoPy.leo" as default to filename argument to leo.open().</t>
<t tx="T378">The whole-word search only fails if there are two consecutive "in-word" characters at the beginning or end of the supposed match.

Added some logic to make suboutline-only searches work correctly.

In the process, discovered a bug in is_c_id.  It was testing for blank instead of underscore!</t>
<t tx="T379">tree.select now calls tree.recolor_now instead of tree.recolor.  The result is much better than before.

Did add the tree.updateScheduled ivar and logic.  This ensures that only one redraw ever happens at idle time.  It seems like the body text is drawn much faster now.  This may have been a big performance bug!

At present the performance of leo.py seems excellent.</t>
<t tx="T380">When the "Move Down" command did nothing the control-d ate the character at the cursor!  The workaround is to have c.moveOutlineDown call c.selectVnode(v) even if nothing happens.  This forces the body text to be restored.</t>
<t tx="T381">c.makeVisible and even c.beginUpdate/c.endUpdate can be eliminated!  Indeed, the tree class can work as follows:

1. All ancestors of the current node are expanded at the start of tree.redraw.
2. The current node is scrolled into view at the end of tree.redraw.

We want to do the expansion of nodes before drawing so offsets are computed properly.  We must do scrolling after idle tasks are complete so Tk.Scrollbar.get() will return proper values.

Note: we still may want to inhibit drawing even though all drawing happens at idle time.  We don't really need begin/endUpdate to do that:  just keep a flag and call c.redraw() only if the flag is true.

I'm not going to eliminate c.beginUpdate/c.endUpdate just yet.</t>
<t tx="T382">Eliminated redundant error messages.
All path problems now generate an error.  This seems safest.</t>
<t tx="T383">tree.makeVisible and tree.scrollTo are called before the tree is redrawn, so we can't get accurate measurements from the canvas class.  I created tree.yoffset() and tree.lastVisible() to get proper measurements.  The final code is deceptively simple; it took several hours to get it all right.

This is an important step forward because now the screen is drawn properly during interactive search commands.  It would have been intolerable to release Leo with only partly functional Find commands.

There are still "policy" questions about when and how to scroll.  The present code doesn't work smoothly in all cases.  It may be that the Tk.canvas.yview routine doesn nothing in certain unexpected situations.</t>
<t tx="T384">I have spent several pleasant hours preparing setup.py, manifest.in and sdist.bat.

Create a source distribution (.zip file) by running sdist.bat from c:\prog\LeoPy.

I have not been able to create a .gzip file yet.</t>
<t tx="T385">There was an assignment kind = kind in the section &lt;&lt; set kind for directive &gt;&gt;, so @chapter, @section were never recognized.  Amazingly, this blunder did not seem to affect anything else.

With this this bug fixed, all files in LeoCB.leo are tangled the same by LeoCB and leo.py, except for the first line and whitespace.  The first line is different because LeoCB puts slashes differently than leo.py.

When ignoring only trailing whitespace and blank lines, we see that LeoCB and leo.py differ in how they output (!newline).  LeoCB outputs a single space before (!newline) in put_section(), so this is what leo.py must do as well.

With this bugs fixed, the only differences between LeoCB.leo and leo.py involve leading and trailing whitespace and blank lines.  Tangle works!  Actually, leo.py now does a better job than LeoCB, for the following reasons:

1. leo.py does a good job of deleting trailing blank lines in sections, and this should simplify Untangle.
2. leo.py does a better job of putting leading whitespace than LeoCB, because leo.py more accurately computes the effective width of leading whitespace than does LeoCB.</t>
<t tx="T386">This allows us to open a file when leo starts.  From the Python interpreter do the following:

import leo
fn = "c:\prog\LeoPy\LeoPy.leo"
leo.open(fn)

The open script is the companion to the run and go scripts.  leo.run() just runs leo.  leo.go() reloads all modules before running. For reasons that I don't fully understand, leo.go() does not always handle leoUtils properly: it is sometimes necessary to do

from leoUtils import *</t>
<t tx="T387">Actually, clicking on another node should probably reset the "wrap_node", but it doesn't.  Only changing something in the Find panel does that.</t>
<t tx="T388">Tested paths when Leo invoked directly.
Tested explicit paths in @file nodes
Tested paths in prefs panel.
Tested paths in @path directive.
Tested no path anywhere.

As a result, changed writeError by error in atFile.scanAllDirectives.</t>
<t tx="T389">frame.defaultDirectory was never being used.</t>
<t tx="T390">It appears that putting the following in app.finishCreate will work:

	import leo
	loaddir = os.path.dirname(leo.__file__)

Apparently we can not reference leo.__file__ reliably until leo has been completely imported.  The workaround is to do so in app.finishCreate.  This is a bit mysterious, and it appears to work.</t>
<t tx="T391">The new path philosophy is as follows:

1. Leo will not call os.chdir except possibly after file dialogs that are not cancelled.  This will leave the file system's current directory (returned by os.getcwd()) unchanged by tangling, importing, reading or writing.

2. Commands that access files (tangling, untangling, reading, writing, importing) call either os.getcwd(), atFile.scanAllDirectives or tangle.scanAllDirectives to set appropriate ivars indicating what the proper default directory will be.

3. These commands open a file as follows, where self.default_directory is set in step 2:

	fn = os.path.join(self.default_directory, fileName)
	f = open(fn,...)</t>
<t tx="T392">@file trees were not being marked as dirty when cloned headlines outside those trees were changed.  This definitely would have caused errors while reading @file trees!  Fixing this bug is a big step forward.

The fix was to to have v.setDirty() ensure that all cloned nodes are set dirty and that all ancestor @file nodes are set dirty.  I eliminated v.setDirtyJoined() entirely, and eliminated all calls to v.setAncestorAtFileNodeDirty() outside of v.setDirty().  The result is much safer, cleaner and simpler code.

As a side effect, nodes now become dirty when they move.</t>
<t tx="T393">leo.py used to call chdir from many places to indicate which default directory should be in effect.  That was wrong. From now on, leo.py will call chdir only file dialogs return without being cancelled, that is, for Open, Save and Import commands.

Otherwise, directives will set ivars, and the code will compute full path names using
os.path.join(directory_ivar, pathname).  The neat thing about this is that if pathname already contains a full path name it will override the path in directory_ivar.

For example, the Tangle code now writes the final file like this:

	file_name = os.path.join(self.tangle_directory,section.name)
	... # tangle into temp file
	update_file_if_changed(file_name,temp_name)

This works properly whether or not section.name contains a full path name.</t>
<t tx="T394">If the present node is expanded, the Paste Nodes command now pastes the pasted node as the first child of the present node, rather than as the next sibling of the present node.</t>
<t tx="T395">trace(a) prints a if s is a string and executes a() if a is a function.</t>
<t tx="T396">The symptom of the bug was that it was taking a _long_ time to close windows after doing many interactive find commands.  Actually, it was redrawing the tree that was the real problem.

Disable the recycling of nodes made no difference.  By removing code I isolated the performance bug to the call to tree.redraw in find.showSuccess().  This was very good news, as it meant that the bug was in the tree code rather than in Tk or Tkinter.

The bug was caused by "extra" links to the Tk.text widgets in the vnode, specifically, the v.box_id, v.edit_text_id, v.icon_id and v.box_id ivars.  These links apparently created permanent references that prevented widgets from being deallocated when the tree was redrawn, so a large number of widgets and their binding had to be deleted when the tree was deleted.

The fix was just to eliminate these vnode ivars entirely: they were not being used!  The v.edit_text ivar could not be eliminated, so I added a call to self.edit_text.destroy() just before reallocating.  Perhaps just moving the edit_text would be better than destroying and reallocating it, but that wouldn't be so easy because of the call to self.canvas.destroy("all").</t>
<t tx="T397">If a clone problem is reported, the @file node is not marked dirty again, so if we save the .leo file and then quit the problem will still exist in the derived file.

This happened in Borland Leo, so it is clear if it is a problem in leo.py.

I recovered by doing a Read Outline Only.</t>
<t tx="T398">Moved Tangle utils into Tangle leoTangle.py.  These should be methods because they deal with tangle ivars.

Separated utils that call scanError from other utils.</t>
<t tx="T399">This happened after deleting a clone outside of the tree for @file leoColor.py.  I am not sure of the exact sequence.  Perhaps LeoCB was involved.</t>
<t tx="T400">This was pretty easy.  I think underlining hyperlinked section references looks good.

Still to do:

1. We need browser-style navigation: forward, up, back, home.

2. We may have to change things for Leo1.</t>
<t tx="T401">I finally realized why c.redraw and c.endUpdate wiped out the edit status:

1.  tree.redraw does not preserve the edit status (it probably should)
2.  tree.redraw only causes queuing of the redraw.  It doesn't happen immediately.

This was causing problems in find.show_success.  My quick fix was to create tree.redraw_now, and then to restore the status as needed.  Another, probably better, way would be to have tree.redraw restore edit status.  Duh.

However, in this case tree.redraw_now is exactly what is needed, so I feel a bit less stupid...</t>
<t tx="T402">There are a huge number of details to get exactly correct.  It appears that the code is close to working.</t>
<t tx="T403">I finally realized that v.edit_text is defined only if v is visible on the screen, that is, only if all of v's ancestors are expanded.</t>
<t tx="T404">Previously, cloned headlines were not updated in unison.  This could have been the source of some apparent "lost data".  It is remarkable how complex this logic is.

I finally chose to do a redraw in tree.endUpdate() to force headlines in synch.  We can't typically just do a redraw() in idle_headline because that messes up the editing state of v.edit_text.

I also fixed a bug in idle_body that caused control-Q to call c.setChanged() again.  The new code just sees whether the code has caused the text to change: it does not need the value of ch to do that.

idle_headline also now handles all details of marking nodes dirty.  This used to be done partly in undimHeadline.</t>
<t tx="T405">I made terrible blunder: I eliminated a commands ivar that was involved in writing, so the write failed and wiped out the .leo file.  Since I didn't have a recent backup .leo file, I lost todays notes.

Let this be a lesson to myself:

1.  Backup .leo files _are_ useful for backing up ouline only data.
2.  Make backup of entire LeoPy folder when there are problems.  I came very close to all of today's programming work, which would have been hard to bear.</t>
<t tx="T406">We don't need to keep track of the status of control or alt keys!  Instead, we let idle_body_key and idle_head_key compare the old with the new value.  They do nothing on a match.

An important point:  idle_body_key must make sure that v == c.currentVnode.  If it doesn't make this check we will lose data when the user types Control-K to create a new node.

The new code also takes care not to allow any newlines in headline text.</t>
<t tx="T407">This code is _vastly_ superior to the Borland code, for several reasons:

1.  Unlike the Borland code, the Python code uses no "state" variables.  This not only greatly simplifies the code, it makes it possible to restart incremental searches after the user has changed nodes or changed postion in body text.

Instead of using state variables in the find class, the code uses the c.currentVnode and the "insert" and "sel" tags of the Tk.text widgets.  This automatically ensures that the state of the search matches the state of the outline and body panes!

2. At last!  I know how to restart incremental searches without using state variables.  The trick is _not_ to call c.endEditing() in the setup routines, so set_in_headline() can use c.tree.editVnode to see if we are editing a headline.  If so, we start there.  OTOH, select_next_v _does_ call c.endEditing() and c.editVnode() to force c.tree.editVnode to have the proper value.

3. Leo now uses Tk.Text widgets for both headline and body text.  This eliminates all the special case code that selects between headline and body searches.  Moreover, the same regular expressions are now used for searches in both headlines and body text.  I doubt I could ever have produced bug-free code without this simplification.</t>
<t tx="T408">This hugely simplfies the find/change commands, and makes them more capable.

This also solves the "Control-K" problem in headlines.</t>
<t tx="T409">The ensure_extension routine was adding a .leo extension, thereby defeating the test for an empty file name.</t>
<t tx="T410">This code is much cleaner than the Borland code.  The search commands keep almost no state variables now: we always search from the present location.  This hugely simplifies the logic, and makes the code do what is expected more often.

In particular, is no longer any "first_v" or "first_position" state.  The various find and change commands will save the present state on entry, and restore that state if no finds are found.  This "local" save/restore makes much clearer what is happening.

Still to do: searching in headlines.</t>
<t tx="T411">The save message immediately showed a Save bug.  After doing a Save To, a following Save command used the Save To file name!  This explains why some saves "didn't take".</t>
<t tx="T412">This probably should depend on the size of the window, and at present it does not.</t>
<t tx="T413">I have a new toy: Python's exec statement.  This allows one to have all the flexibility found in tcl scripts.  For example, one can treat the name of variables as variables themselves.  Building statements from strings isn't quite as simple as in tcl, but the effect is exactly the same.

The added flexibily is useful when loading and saving many variables, as in the prefs and find code.  For example:

ivars = [ "tangle_batch_flag", "untangle_batch_flag",
	"use_header_flag", "output_doc_flag",
	"tangle_directory", "page_width", "tab_width" ]
	
for var in ivars:
	exec("self." + var + " = c." + var)  # self.var = c.var
	
This exec statement expresses the pattern directly.  Moreover, once the ivars list is defined many similar exec statements are possible.  Using the % operator might be even clearer:

	exec("self.%s = c.%s" % (var,var))</t>
<t tx="T414">This is tedious code, and Tk makes it much simpler than with other systems.</t>
<t tx="T415">Replaced global with app().idle_imported.

Replaced global with fileCommands.dummy_v.  This fixed a big memory botch: previously a new dummy vnode was allocated for every vnode created!

Replaced es_newline global with app().log.es_newline, i.e., frame.es_newline.  This is better than before because each log stream has its own count.</t>
<t tx="T416">These allow us to reclaim memory when closing a window.  It also showed a that we are wasting lots of space allocating dummy vnodes in the read logic.

With these routines in place, all __del__ routines are eventually being called, which indicates that all circular references are being destroyed by the destroy() routines.  Note that it is _not_ necessary to do any of the following:  del v, del tree, del commands or del frame.  Setting the pointers to None is enough.

Added tree.vnode_alloc_list.  v.__init__ adds items to this list.  tree.destroy removes items from this list.  This is an elegant and powerful solution: all vnodes will be reclaimed eventually, and we don't need to worry about reclaiming them while the window is open.  In particular, this avoids all problems with undo.

Added two new app() ivars to control memory management and tracing.
	self.deleteOnClose	# true: delete all frame objects when a frame closes.
	self.printDel		# true: enable prints in __del__ routines</t>
<t tx="T417">The frame dtor is never being called because (I think) of circular references throughout the vnode, commands and frame classes.  There are several possible approaches:

1.  Ignore the problem completely.  This makes a lot of sense, for several reasons.
	A: Memory is not an issue, and reclaiming memory at termination time doesn't help!
	B: Memory reclamation can legitimately be called a Python implementation issue.
	C: It takes time and memory to reclaim memory.
	D: Errors in reclaiming memory can lead to intermittent crashes.
	
2.  Create destroy() routine for vnodes, tnodes, commands and frames.  These routines would eliminate links between nodes, thereby freeing Python's references.  The frame.destroy() routine would also call self.top.destroy() to force the closing of the frame's window.  The destroy() routine would also do a del self to reduce the reference count of the object.

Note:  deleting vnodes and tnodes is tricky because of undo.  By far the safest course of action is never to delete these nodes until a window closes.  The easy way to do this is put every vnode in a vnode allocation list, an ivar of the tree class.  Calling tree.destroy() would do the following:

	for v in self.vnode_alloc_list:
		v.destroy()
		del v
		
With this structure in place, the __del__ routines would do nothing.  We could insert a print statement in the routines to show when the routines are actually called.  This would indicate whether circular references remain.</t>
<t tx="T418">The old code marked the loading headline as changed.  Added c.loading ivar to disable update of window title during loading.</t>
<t tx="T419">This happens when a save is quickly followed by a quit.  I can get this error when in the Python window, which is reassuring, I suppose.

frame in app().windowList trick doesn't work: very weird.

I enclosed the code in idle_redraw() in a try/except block.  I'm not sure whether this will cure all problems, but it seems like it should.</t>
<t tx="T420">The old code never got around to deleting the frame, tree and commands objects.

However, del self just decrements the reference count; it does not guarantee that self.__del__ is called.  In fact, it doesn't seem that __del_ is _ever_ called!  So much for cleaning up memory.

There may be a bug here, or perhaps this is just a weirdness of usint Tk or Tkinter.  At this point I haven't a clue.</t>
<t tx="T421">This is a strange one.  The problem happens when a save is quickly followed by a quit.  It appears that there is a fault in idle_redraw(), even when the code is locked out with if self in app().windowList.  This is very weird.  Even stranger is that the error traceback never happens when the Python window is opened first (so it stays open).</t>
<t tx="T422">Tested c2py.leo1to2() on LeoCB.  The script now works on both Borland and leo.py.

There is a problem with the v.commands method on Borland. The workaround was to pass the value from top() to convertLeo1to2(v,c).</t>
<t tx="T423">Once again, I am making faster progress with Python than expected.  Amazing.</t>
<t tx="T424">I just imported idle and voila: the IDLE IDE is available!

I did have to add r"c:\Python21\Tools\Idle" to sys.path.  I also removed the wxPython stuff from the path: they interfered with the include.

I added a few top-level functions to leo.py that were described in the scripting documentation.

I added the public commands and vnodes methods described in the scripting documentation.  Several of these routines had names that conflicted with ivars.  In those cases I changed x to mX.  The changed vnode ivars were back, firstChild, headString, next and parent.

I also added several vnode and commands methods that were described in the documentation but that did not presently exist.  Like c.findRoot, c.currentVnode, etc.

The script c2py.convertLeoTree(v) appears to work, so leo.py appears to be largely compatible with scripting in LeoCB.</t>
<t tx="T425">I spent almost an entire day messing with focus issues.  There are two choices:

1.  If tree.bodyKeepsFocus is true the body pane will always have focus unless we are editing a headline.  The current headline is highlighted in grey to indicate the tree has no focus.

2.  If tree.bodyKeepsFocus is false the body pane will not have focus if we select a headline by clicking on it.  In that case the curren headline will be white text on a dark blue background.  When focus shifts to the body pane, the current headline will be greyed.

After much experimentation, it seems that the first way is more convenient, though slightly less accurate as far as visual protocol goes.  I think the convenience of having focus in the body pane (where it is useful) outweighs the small visual incongruity of having the current headline be grayed even when the tree canvas is selected.

Warning: Using frame.getFocus() is much less good than using the tree.active flag, because we can edit a headline with at most two clicks.  That is not true when using frame.getFocus()

The bodyKeepsFocus logic affects all routines that alter the highlighting of headlines.</t>
<t tx="T426">Changed OnCloseLeoEvent so it returns not veto.</t>
<t tx="T427">TThe body handler didn't call setDirtyJoined.  Changed setDirtyJoined so it returns a redraw flag.</t>
<t tx="T428">Added virtual_event_name utility to generate &lt; &lt; name &gt; &gt;.  Sigh.

The OnCut, OnCopy and OnPaste routines just call the body key event handler to do syntax coloring and set the various dirty/changed bits.

There is a small glitch: choosing cut/copy/paste "by hand" from the menu doesn't work when the focus is in an edit label in a headline.  I'm not sure how to fix this and it is extremely minor anyway.</t>
<t tx="T429">Added v param to tree.recolor so we don't assume that v is the current vnode.</t>
<t tx="T430">I tried several options, with no luck: selectborderwidth, selectbackground, selectforground.</t>
<t tx="T431">Added code to leo.py to set the window icon.  Alas, the documentation is poor enough so that I don't know what the arguments to iconbitmap should be.</t>
<t tx="T432">I tried a lot of experiments in fileCommands.getGlobals(), and it is still not possible to set the height and width of the top level window properly.  It is still too large, and its size does not depend on the requrested width.

Note that the size of the window is set in createSplitter, by setting the size of a Frame object.  Perhaps this is interfering with matters.

The present situation is poor, but tolerable.</t>
<t tx="T433">Changed bd="2m" to bd=2.  This makes a big difference in how the panel looks.</t>
<t tx="T434">The syntax colorers can use tag_config to show tabs and spaces.  This isn't perfect (it doesn't look good now) and does not work for newlines.  It may be better than nothing, however.</t>
<t tx="T435">I just forgot to add it to the list of @keywords.</t>
<t tx="T436">These "bugs" may be appearing because these commands are always enabled in the menu.  In any case, the fixes were straightforward.</t>
<t tx="T437">The problem was that the body key handler was being scheduled before the new node was inserted and being called at idle time after the new node was inserted, so the body text disappeared.  The fix was to disabling scheduling if control or alt keys are down.</t>
<t tx="T438">All it took was the following:

font = tkFont.Font(family="Courier",size=9)
tabw = font.measure("    ")
self.body = body = Tk.Text(...font=font,tabs=tabw...)

This hard codes tabs as 4 spaces.  Later I'll make it more general.</t>
<t tx="T439">I am getting closer to getting the look of the splitter panes just right.  Setting bg="white",relief="flat",bd=0 in createSplitter helps quite a bit.

The problem with the tree pane is clearly in the Canvas widget.  If that widget is not packed the pane looks fine.  There seems to be no way to eliminate the canvas's border, and no way to prevent the border from being overwritten by the Entry widget.

Maybe there is a way: the problem may be that Entry widgets are embedded in their own windows...</t>
<t tx="T440">I will use leo.py from now on to develop leo.py.  It is the only way to really get the bugs out.

Changed the code that computes the length of the edit box for headlines.  We always use len(v.headString) now.  This still does not quite work properly, but it is better.

Fixed a bug in the selection logic.  The colors for the previous headline are changed only if the previous is not the same as the current.  This can happen if we click in the icon or plus/minus icon of the current headline.

Added the v.iconx and v.icony ivars so the tree.OnHeadlineKey routine can just redraw the cursor in place if it needs to change.  This is a workaround to a problem that I haven't been able to solve: namely, how to force the cursor to be visible again after the headline loses focus.  This is more than a little kludgy, especially after creating the elegant endUpdate mechanisim.  OTOH, it may point a way towards incremental redrawing of the screen.</t>
<t tx="T441">Changed "darkblue" to "DarkBlue".  The colors known to Tk are listed at
	http://tcl.activestate.com/man/tcl8.4/TkCmd/colors.htm 

Changed print_stack() to Print statements in es() logic.  This was more confusing than helpful.

Eliminated some accelerators (Linux only)

Added loaddir code to leo.py.
</t>
<t tx="T442">Added many terms to the Glossary.

Improved description of Leo2.  Partially merged Leo1 and Leo2 documentation.  It still isn't perfect.</t>
<t tx="T443">Probably very few people could understand the description of Leo2.</t>
<t tx="T444">I fixed the "last" serious bug in this version.  What was happening was that the clone information in leoFileCommands.py and leoCommands.py was alternatively being written and not being written.  The fix was to v.joinNodeTo:  there was a bug that was fixed in the Borland version that had not been fixed in this version.</t>
<t tx="T445">It turns out the updateCloneIndices routines in both LeoCB and leo.py are slightly buggy.  Both can increment indices multiple times for the same tnode.  In addition, LeoCB computes indices for parts of the tree beyond the actual tree, so that would increase the indices further, which is why the LeoCB version sometimes has a larger clone indices.

Neither of these "bugs" really makes a difference.  In either case, nodes are joined properly.

To "minimize" the clone indices we would do the following:

	index = 0
	v = root
	# Zero all indices.
	while v and v != next:
		v.t.cloneIndex = 0
	# Set clone index only if it has not already been set.
	while v and v != next:
		if v.t.cloneIndex == 0 and v.isCloned() and v.shouldBeClone():
			index += 1
			v.t.cloneIndex = index
		v = v.threadNext()
		
This might be just slightly slower than the "wasteful" way.</t>
<t tx="T446">The directory compare routines in the Python lib do not seem to exist.  The new routines compare only .py files.</t>
<t tx="T447">The lineIndent var was not set properly in &lt;&lt; Set lineIndent, linep and leading_ws &gt;&gt;, with the result that some sections contained extra leading whitespace in their body parts.

With this bug fixed, leo.py reads and writes all files correctly!</t>
<t tx="T448">Fixed a bug that was causing the last newline of doc parts to be deleted.  The problem was that string.rstrip() also strips newlines!  With this bug fixed it appears that Leo.py can read and write @file nodes just like Leo2CB does.

Created the removeTrailingWs() in leoUtils that strips trailing blanks and tabs.</t>
<t tx="T449">Rewrote the code in scanText and scanDoc that figures out where sentinels start.

The new nextLine and nextKind vars clarify what is going on.  When a non-sentinel line is output, the trailing newline is part of a sentinel if and only if nextKind is some kind of sentinel.

I'm not convinced the code in scanDoc is correct...

</t>
<t tx="T450">This is a very useful comparison tool.  It allows me to compare whitespace easily.</t>
<t tx="T451">This puts up a model dialog.  The hardest part was writing the code that centers the dialog on the screen.  Sheesh.</t>
<t tx="T452">I fixed many minor problems in preparation for releasing the first usable version of Leo.py.</t>
<t tx="T453">These bugs were simple transcription errors; they do not occur in LeoCB.

v.childIndex() was always returning 0, so naturally v.createDependents() was not working well.

Added a call to v.unlink() in v.destroyDependents.  The call to v.destroyTree() no longer does anything.</t>
<t tx="T454">We no longer need setIcon!!  Indeed, setIcon just calls c.redraw(), so as long as the callers enclose code in beginUpdate/endUpdate all will be well.  This eliminates a _major_ mess, and will result in further simplifications: we no longer need the distinction between the setX and initX routines!</t>
<t tx="T455">It turned out that tree.idle_body_key was the bottleneck, _not_ syntax coloring!

What was happening was this:  tree.redraw was being called on _every_ keystroke, and that was causing a huge amount of memory allocation and deallocation.  After a while everything ground to a halt.

The fix was very clever: I added a flag to c.endUpdate and tree.endUpdate, true by default.  tree.redraw is called only if count==0 and flag==true. So calling endUpdate(false) prevents all redraws from happening in a range of code.  This is a wonderful addition to the beginUpdate/endUpdate pattern.

Both tree.idle_body_key and v.setAncestorAtFileNodeDirty use this pattern.  The result is that tree.redraw() is called only when the icon really and truly must change.
</t>
<t tx="T456">Amazing.  I wrote some dummy code last night, read up on indices this morning, and got everything to work in a couple of hours. The result is very fast: no optimization is needed for Leo. I love Tkinter!

Added c.recolor and tree.recolor routines.  This hooks should be called whenever the body text changes.  Apparently there is no "OnTextChanged" event in Tk.</t>
<t tx="T457">Implementing this was trivial: we use a app.clipboard ivar, a string.  Using an internal clipboard means that we can't inadvertantly paste the XML representation of a string into body text.</t>
<t tx="T458">The only major step left before releasing a functional version of Leo is to check the @file write code.
</t>
<t tx="T459">The Tk clipboard handling is confusing: there are routines for clearing and setting the clipboard, but no obvious way to get the contents of the clipboard.  I could use an internal clipboard (part of the LeoApp class) for leo nodes, which would work pretty well.  If I did that I might want other commands: cut, copy and paste between node clipboard and the text widgets...

There doesn't seem to be any Python support for the clipboard, which is weird.</t>
<t tx="T460">This is a tedious task, no matter how it is done.</t>
<t tx="T461">Simplified the code that sets the current vnode and initializes icons.  Having tree.redraw update icons automatically helps a lot.

Added tree.initing hack to disable endEditLabel from marking the tree as changed. Actually, this probably isn't necessary, as top.title probably won't be redrawn until idle time anyway.</t>
<t tx="T462">Here is how to get accelerators working:

fileMenu.add_command(label="New", accelerator="Ctrl+N", command=self.OnNew)
self.top.bind("&lt;Control-n&gt;", self.OnNew)

Warning: using top.bind_all would not work well with multiple windows.

The accelerator="Ctrl+N" option merely sets the menu text(!).  The bind_all method actually does the work.  BTW, I had to change (self) to (self,event=None) in all the command handlers.  When an accelerator is used the handler is called with two args.  When the menu is used the handler is called with only one arg.

IDLE shows how to be a bit more clever with initialization.  I probably should study the Idle code and be clever ;-)  IDLE also use the configuration data base, and I probably should study that too.</t>
<t tx="T463">There are now just two routines, v.computeIcon() and v.setIcon().

v.setIcon just does c.tree.redraw() (!)

c.tree.redraw() now does nothing if the update count &gt; 0, so this is safe. Moreover, we can now enclose any code in c.beginUpdate()/c.endUpdate() without worry.

This is the way it is written in the Book.</t>
<t tx="T464">The &lt;Key&gt; event is called _before_ the body text is updated, so it is not possible to properly update syntax coloring, icons or tnodes there.  Instead, the &lt;Key&gt; event handler just registers an idle-time event to do the real work.  Very simple!</t>
<t tx="T465">The canvas widget appears to have an improper 1 or 2 pixel gray border.  I have worked around this by limiting the size of the Tk.Entry widget: expanding it only when editing is enabled.</t>
<t tx="T466">Following the IDLE code lead me astray.  IDLE does not allow the headline text to be edited!  At last some of the confusion is gone.</t>
<t tx="T467">openWithFileName now shows the window before loading, so that reading messages become visible.  To do this, we call app().root.update().

Made leoFrames bigger: this is done in createSplitter(!)</t>
<t tx="T468">We close the initial open window if it has not been changed.

app.quit() now closes the hidden root window to close the app.

Close processing now calls the close event handler.

There are no bugs as in wxWindows!  Everything is straightforward.</t>
<t tx="T469">I have rewritten the code to draw the tree, and it seems to work reliably.  However, expanding an entire tree is slow, and redrawing the tree is also slow is many nodes are visible.  I'm not sure what is causing this...

Disabling drawNode speeds up the redraw greatly.
Disabling only tags also speeds up the redraw greatly.  Indeed, way too many tags appear to be created...

Still to do: I have not been able to create edit windows in the canvas properly...</t>
<t tx="T470">I'm not sure whether Tkinter can read .bmp icons, so I created .gif icons, which work well.</t>
<t tx="T471">Rewrote v.restoreOutlineFromDVnodes.  It is now very simple because undo no longer creates dvnodes; vnodes now contain all tree information.  So when we "delete" a tree we just unlink and unjoin it, and when we "restore a tree we just relink and rejoin it.  It is truly amazing how simple the tree code now is.</t>
<t tx="T472">It now takes about 3 seconds to read this file, rather than the 9+ seconds needed by wxPython!  Apparently the wxPython tree class was very slow.

The _old_ bottleneck was as follows:
	Most of the time is spent in atFile scanning code
		.. c.clearAllVisited is very slow(!!) because it clears the entire tree.
			c.clearAllVisited takes about 1/3 time of the entire scanning phase (!!)
		.. Reading the file itself, is very fast, scanning in atFile::read is slow.
		.. es calls are fast.
</t>
<t tx="T473">A milestone.  It is now possible to read a .leo file and to draw the tree at least partially.  Most of the conversion to Tkinter has now been completed.

I removed vnode and commands getters that merely returned ivars.  Also converted wxWindows calls to Tk calls.  It is remarkable how easily the changes went.  
</t>
<t tx="T474">Converted all Tk prototype code to Tkinter.  It was straightforward for the most part.  The Leo window works: scrollbars work and the text panes work.  However, the tree pane is a text pane at present.

Copied menu code from Leo.py version 0.04.  Somehow the old code was lost, I have no idea why.  The copied code is wxWindows code, so it will have to be rewritten for Python.  Still, it is much easier to use the properly converted Python code.  Perhaps I deleted the code thinking that it would all have to be rewritten.  If so, that was a minor mistake.</t>
<t tx="T475">The use_tk global indicates whether Leo will use wxPython or Tkinter.  The next step is to transliterate the Tk code that creates the Leo window into Tkinter.</t>
<t tx="T476">After much experimentation, adding a -padx param to the log window pane seems like the only way to handle the width of the vertical scroll bar.  Without this extra padding, the scroll bar obscures the left edge of the log window.</t>
<t tx="T477">It simplifies and speeds up the code to use file.readline to process lines as a unit.  This way I never have to scan to the end of a line.  However, it turns out that scanning is not really the bottleneck.  In addition, we no longer read entire derived files into memory at once.

BTW, it may be possible to use readline() in the getLeoFile logic as well.  I have no idea whether this would help or not.

The problem is the _second_ half of atFile::read, that is, after the derived file has been completely scanned and all vnodes have been created!  Apparently, something (maybe shouldBeClone?) involved with setting bits is horribly slow.  I'm not sure why earlier testing didn't show this problem.  I must have been mistaken somehow in my earlier conclusions.

This actually is very good news.  It means that the raw file code is good enough as it is.  Note:  reading derived files will not slow down when I switch to Tk because we don't create vnodes unless there are file errors!

I have just found that a single call to c.clearAllVisited() in read() _substantially_ slows down the read!  Amazing.

Create v.clearVisitedInTree() and v.clearAllVisitedInTree()</t>
<t tx="T478">@nocolor
@ignore

This is a _very_ easy class.

Ivars
	self.root: the root vnode
	self.update: update count
		tree::beginUpdate increments.  tree::endUpdate decrements.
		Disable redraw if &gt; 0
		Redraw when falls to 0.
	self.selected: the selected vnode
	self.top the top vnode on the screen (needed?)

Tree methods know about vnodes(!) Greatly simplifies both tree and vnode classes.
tree:endUpdate does nothing if self.update &gt; 0
	User code should not call tree::redraw directly.
	Most tree methods call redraw
Insert methods create a vnode, set links and redraw.
Move methods just set links and redraw
Commands methods enclose complex operations in tree.beginUpdate/endUpdate, as they do now.
tree::delete(v) just unlinks v's tree
	vnodes are not deleted until window goes away: unlimited undo!
	v.threadNext ivar makes deleting a list trivial.

vnodes

vnodes contain headString, expanded, firstChild, parent, back, next and threadNext ivars
	tree::getThreadNext() used to set v.threadNext
	no need for dvnodes: vnodes contain all undo info!


		</t>
<t tx="T479">added use_tk constant in leoGlobals.</t>
<t tx="T480">es now outputs a newline, which makes most uses of enl and ecnl superfluous.  We can do this be string concatenation is so easy.</t>
<t tx="T481">There was a transliteration error in computing the line to be output which mangled long lines.</t>
<t tx="T482">This code has not been tested.</t>
<t tx="T483">There was a bug in sentinelKind.  skip_c_id won't handle @@, so @@ must be handled separately.</t>
<t tx="T484">It is not possible to access global _variables_ using from leoGlobals import * because that creates copies of the data.  The new way is simpler and more modular.

Revised how the prefs panel works.  The new code just sets the prefs ivars.  It is up to the caller to access the prefs panel as needed. Added tab_width preference and prefs.tab_width ivar.  This should have been done long ago.</t>
<t tx="T485">Fixed problems with at_xxx_ptr globals.  The problem that from leoGlobals import * doesn't work, so I changed is_special_bits so it returns a dictionary containing name:value pairs rather than setting globals.

Fixed many problems in scanAllDirectives involving paths.  Also rewrote the code in atFile::write that opens files.

At this point leo.py can read and write files except files containing @first.
</t>
<t tx="T486">.. initAllCloneBits had several errors.
.. self.structureErrors wasn't being initialized in atFile::Read
.. createNthChild must mark nodes as visited to suppress unvisited node logic later.
.. Added log messages any time self.structureErrors is incremented in createNthChild

At this point leo.py can read a simple test file properly, except files containing @first.</t>
<t tx="T487">It wasn't too hard to create a proper splitter window.  After that, creating a Leo window was trivial.</t>
<t tx="T488">I am beginning to think that globals should _never_ be used.

The @language bug appears to be a problem of not setting globals properly.</t>
<t tx="T489">Added assert in tnode::setTnodeText that we are getting a string.  This assert was not always true before I added a call to listToString in &lt;&lt; copy new_out to child's body t't' in scanText.</t>
<t tx="T490">The read code is slow.  I'll have to see why.

3 seconds with read doing nothing (reads leoPy.leo)
5 seconds with read reading files but not scanning them.
9 seconds with read fully enabled.

Therefore:

3 sec to read and scan LeoPy.leo
2 sec for reading all derived files
4 sec to scan all derived files.

So scanning derived files is pretty slow.

BTW, LeoCB can do everything in about 2 sec.
</t>
<t tx="T491">There was the usual assortment of minor problems.

.. The write code was writing flags using `flag`, and this fails if false is None.
.. Added code to make sure None is never passed to wxFileDialog as a file name.  I wonder if this could have caused problems earlier.  Once again, the C++ code is shown to be radically unsafe.

.. I think false should be defined as 0, not None.  There are several advantages:

1.  not 0 == not None, so various tests work as before.
2.  `0` is very different from `None`, and this affects the file format.

I'll make this change.  Hope it works ;-)</t>
<t tx="T492">A major milestone:  the read command works and so do most outline commands.  It is now clear that reading a file is fast enough so that no further work is required!

The main problems today:

1.  The code must use the test: id and id.IsOk().  Failure to make _both_ tests will cause the code to fail, possibly in an unbounded loop.  This was ultimately the problem with the Move Down command:  the threadNext code didn't make these test.  I finally called wxGetThreadNext inside threadNext and that solved the problem.

2.  I added the self.changing lockout in the LeoFrame OnTextUpdate handler so that tnodes would not be erroneously updated while switching tnodes.  The new code seems simple and robust.</t>
<t tx="T493">A case can be made for getters of the form:

	def getX():
		return x
		
In particular, they are a reaonable place to put asserts.  However, such getters do not seem good style in Python because all ivars are public anyway.  Moreover, getters like

	def x():
		return x
		
are invalid in Python, so there is a problem.  The simplest approach seems to be to get rid of all such redundant getters, and that is what I have just done.  Note that assert's aren't so important in wxPython, because nothing bad can happen anyway.</t>
<t tx="T494">This was a very interesting experience, for the following reason.

1.  The weakness of a non-compiled language is that problems don't show up until code is actually executed.
2.  Python is very safe.  The only real problem are unbounded loops.
3.  In particular, the continue statement will _always_ loop in Python unless progress the loop variable is incremented.  So care must be taken when translating C for loops into Python while loops.
4.  Even without the ability to set breakpoints (which means that single-stepping is impossible in wxPython!) it wasn't too hard to trace with print statements.  Amazing.
5.  The biggest mess came with getters that return an ivar of the same name.  I'll sleep on this, and I think the thing to do is get rid of the getter entirely:  convert x.getY() x.Y.
6.  Defining constants in a class is nice: they are accessed by class name.  For example: vnode.dirtyBit.

Status:
1.  The outline is being read in correctly.
2.  The atFile::read logic hasn't been tested.
3.  The body pane (and probably all the tnode text) is not being set properly.
4.  It is possible that we might be able to get rid of join lists!  They are used:
	a) To update the headline text
	b) For shouldBeClone.
	We could replace join lists by a reference count and temporary join lists.
	This could be really cool, and I'll have to think about this more...
	</t>
<t tx="T495">Created leoFileCommands.py.  We use com=self.mCommands to access the "real" commander for this class.  It would be wrong to make fileCommands a subclass of Commands; we must have exactly one commander per frame so that mCurrentVnode, mRootVnode, etc. are updated properly.

In short, the ivars of fileCommands are mFrame, mCommands and any ivars used exclusively by fileCommands.  This pattern will be used to create outlineCommands.py, findCommands.py, etc.</t>
<t tx="T496">The info class was confusing.  All the ivars from that class now become ivars in the fileCommands class.  The mTnodes array is now a Python dict, so there is no need for the mNumberOfTnodes or mMaxTnodeIndex ivars!  The new clode is _much_ clearer.  A major victory.</t>
<t tx="T497">Fixed several bugs in c2py.

Greatly simplified handlePossibleFunctionHeader; there is no need to compute a delta there:  we munge the head, args and body separately, then replace the original all at once with the new lists.  This is bullet proof.

Fixed some bugs in safeReplace and matchWord.

Fixed bugs in convertCStringToPython that caused skipDoc and skipCode to be called in the wrong places.  That was really messing things up!

Tested the speed of tests by writing speedTest.  This is so much fun!</t>
<t tx="T498">I have been happily converting, with the help of c2py, Leo's C++ code to python.  The new code is far, far easier to understand.</t>
<t tx="T499">Fixed several bugs in c2py:

1. removeExcessWS was sometimes skipping past a newline, thereby removing leading whitespace in the following line.  This made it look like the code for "if", "while" and "for" was bad.

2. the function scanning code had several bugs.  Added new code to ignore "if", "while" and "for" code.  Added new code to ignore # lines (preprocessor directives).  Added the firstOpen variable to eliminate scanning later.  This is pretty tricky code.

3. Added code to replace " . " by "." and "\t " by "\t".

4. Fixed skipPastWord so it handles underscores and digits.  This helped a lot ;-)

5. @code was not always properly converted to @c.

I think I will leave c2py as is for now.  It has the following rough edges:

1.  I don't know how to break long scripts.
2.  c2py doesn't handle : initializers in constructors well; they inhibit processing of the initializer.
3.  c2py doesn't place self. in all the places it is needed.  I'm not sure there is an elegant way to do this...</t>
<t tx="T500">Worked on c2py.  As documented in LeoCB.leo, had to add a __cmp__ routine in leo.py so that vnodes compare equal properly.  Fixed some minor bugs in c2py.

We now have two separate routines called leo.py.  The one used by LeoCB and LeoWX is the python expression evaluator.  The leo.py in LeoPy is the top level of leo.py.

Added signed, unsigned and bool to the list of type names.</t>
<t tx="T501">Documented the theory of operation of c2py.  This is a remarkably simple program!  Converting from string to list representation turns out to be a very good choice.</t>
<t tx="T502">For the last two days I have been working on c2py.py.  I am totally in love with Python.  Everything is so much easier:  Automatic debugging, no declarations, no types, no compilation. Great data structures. Even without single stepping the debugging is easy.

All major aspects of c2py are now complete.</t>
<t tx="T503">It has been staring me right in the face.  Idle.py supports tree views and syntax coloring!  All I need do is adapt the Idle code for Leo.  The only remaining piece of the puzzle is a good splitter window (and splitter events?)
</t>
<t tx="T504">All menu work is now complete, with stubs for many calls to Commands routines...
The Python menu is functional.
The Find Panel can be opened.
The Find Panel can be opened.

Still to do:
	Icons for outline
	Nodes classes
	Commands classes:
		outline commands
		file commands,
		find commands,
		tangle/untangle commands</t>
<t tx="T505">@ignore
@nocolor</t>
<t tx="T506">&gt; "package" is a Python term.  If you make a subdirectory "leo" in
&gt; site-packages and put an "__init__.py" file in it, Python will
&gt; recognize "import leo.dialog" or "from leo.dialog import Dialog".
&gt; There's an option in distutils to do this.

Thanks.  Leo already has an __init__.py file (Monkey see, monkey do) and I was wondering what good it was :-)  I really am a Python newbie.  The think about Python is that total newbies can do some pretty nifty stuff.

&gt; But of course, it depends on whether you want to use distutils at all.
&gt; We used it for Cheetah because third-party programs have reason to 
&gt; import modules from it.

OK.  This gives me some material to think about.  Thanks very much.</t>
<t tx="T507">sys.settrace(func) sets the global trace function. there can also a local trace function (see later)

Trace functions have three arguments: frame, event, and arg.
frame is the current stack frame.
event is a string: 'call', 'line', 'return' or 'exception'.
arg depends on the event type. 

The global trace function is invoked (with event set to 'call') whenever a new local scope is entered; it should return a reference to the local trace function to be used that scope, or None if the scope shouldn't be traced. 

The local trace function should return a reference to itself (or to another function for further tracing in that scope), or None to turn off tracing in that scope. 

Instance methods are accepted (and very useful!) as trace functions. 

The events have the following meaning: 

'call' 
A function is called (or some other code block entered). The global trace function is called
arg is the argument list to the function
the return value specifies the local trace function. 

'line' 
The interpreter is about to execute a new line of code (sometimes multiple line events on one line exist). The local trace function is called
arg is None
the return value specifies the new local trace function. 

'return' 
A function (or other code block) is about to return. The local trace function is called
arg is the value that will be returned.
The trace function's return value is ignored. 

'exception' 
An exception has occurred. The local trace function is called.
arg is a triple (exception, value, traceback)
the return value specifies the new local trace function 

Note that as an exception is propagated down the chain of callers, an 'exception' event is generated at each level. 

For more information on code and frame objects, refer to the Python Reference Manual.</t>
<t tx="T508">Leo is: a programmer's editor; an outlining editor and a flexible browser; a literate programming tool, compatible with noweb and CWEB; a data organizer and project manager; fully scriptable using Python; portable--leo.py is 100% pure Python (requires Python v2.2+ and Tk/tcl 8.3+); Open Software, distributed under the Python License.</t>
<t tx="T509">@nocolor

leo.py 3.1 contains Python code that may be of interest to some Python programmers.  This is the first and last time I shall be mentioning this code on comp.lang.python.announce.

----- c2py.py

This script does much of the grunt work of converting from C/C++ syntax to Python syntax.  It was surprisingly effective in converting Leo from C++ to Python.  These scripts don't need to be perfect to save a _lot_ of work.  And of course you can always add your own improvements...

As written, the script converts an entire Leo tree.  It would be easy to write an entry that would convert plain text files, but it's probably best to import the files to be converted into Leo first.  That way the slow algorithms in c2py.py will work on smaller pieces of text.  

----- disStats.py

This code gathers and prints static statistics about Python bytecode.

----- Tkinter utilities in leoUtils.py

w,h,x,y = get_window_info(top) returns the width, height, x and y positions of the Tkinter window top.

center_dialog(top) centers the Tkinter window top on the screen.

w,f = create_labeled_frame(parent...) creates a labeled Tkinter window as a child of parent.  The caller packs widgets into f to create the frame.

leoUtils.py contains many other routines that may be of interest, or not, including an Python version of the Sherlock tracing package.

----- Font dialog

leoFontPanel.py puts up a Font dialog.  This dialog dispenses with the typical "sample" pane and instead changes text immediately directly on the screen.  Comes with Ok, Cancel and Revert buttons.  IMO, this dialog is much better than the sample Tk/Tkinter font dialogs available on the web.

----- Syntax coloring code

leoColor.py contains code to syntax color Tk.Text widgets for a variety of languages.  Supporting a new language here is mostly a matter of adding another table of keywords.

----- Tree code

Leo supports powerful outlining features, including clones.  Clones are challenging to implement, to say the least.  The vnode and tnode classes, defined in leoNodes.py, represent the underlying data.  vnodes represent nodes on the screen.  vnodes may share text, the tnode class is the "unit of sharing" of such text.  The leoTree class draws the tree and handles events, including dragging nodes around the screen.  The Commands class calls the vnode, tnode and leoTree classes to handle menu commands.  In Smalltalk's model/view/controller terminology, the vnode and tnode classes are model class, the leoTree class is a view class, and the Commands class is a controller class.

How to get this code
--------------------

All of this code is contained in the distribution of leo.py 3.1.  All Python files are derived from LeoPy.leo.

leo.py itself requires Python 2.2 and tcl/tk 8.3 or above.  The scripts above will probably work on earlier versions of Python.

What is Leo?
------------
 - A programmer's editor, an outlining editor and a flexible browser.
 - A literate programming tool, compatible with noweb and CWEB.
 - A data organizer and project manager. Leo provides multiple views
   of projects within a single outline.
 - Fully scriptable using Python. Leo saves its files in XML format.
 - Portable. leo.py is 100% pure Python.
 - Open Software, distributed under the Python License.

Links:
------
Leo:      http://personalpages.tds.net/~edream/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458</t>
<t tx="T510">leo.py 3.3 is now available at:  http://sourceforge.net/projects/leo/

The highlights of 3.3:
----------------------

- Added support for Unicode.
- Improved the Import commands.
- Fixed numerous bugs related to configuration settings.
- Fixed the "Javadoc" bug and several latent bugs related to it.

leo.py requires Python 2.2 and tcl/tk 8.3 or above.

What is Leo?
------------
 - A programmer's editor, an outlining editor and a flexible browser.
 - A literate programming tool, compatible with noweb and CWEB.
 - A data organizer and project manager. Leo provides multiple views
   of projects within a single outline.
 - Fully scriptable using Python. Leo saves its files in XML format.
 - Portable. leo.py is 100% pure Python.
 - Open Software, distributed under the Python License.

Links:
------
Leo:      http://personalpages.tds.net/~edream/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458
</t>
<t tx="T511">leo.py 3.5 is now available at:  http://sourceforge.net/projects/leo/

The many bugs reported in 3.4 show that leo.py is being heavily used.  leo.py 3.5 corrects all known bugs and adds some new features:

The highlights of 3.5:
----------------------

- Added new entries in the help menu,
  (Including a link to Joe Orr's excellent ScreenBook tutorial).
- Added configuration options for horizontal scrollbars.
- Added an importFiles script for mass imports.
- Added better warnings for read-only files.
- Removed all '\r' characters when reading derived files.
- Fixed crasher in Read Outline Only command.
- Fixed crasher when leoConfig.txt did not exist.
- Many small improvements and bug fixes.

Version 3.4 has not been announced previously.

The highlights of 3.4:
----------------------

- Fixed several crashers involving Unicode.
- The Show Invisibles command now makes blanks and tabs look much better.
- Created leoConfig.leo, from which leoConfig.txt is now derived.
- Added save_clears_undo_buffer configuration option.
- Fixed a large number of problems with the configuration code.
- The usual minor improvements and bug fixes.

leo.py requires Python 2.2 and tcl/tk 8.3 or above.

What is Leo?
------------
 - A programmer's editor, an outlining editor and a flexible browser.
 - A literate programming tool, compatible with noweb and CWEB.
 - A data organizer and project manager. Leo provides multiple views
   of projects within a single outline.
 - Fully scriptable using Python. Leo saves its files in XML format.
 - Portable. leo.py is 100% pure Python.
 - Open Software, distributed under the Python License.

Links:
------
Leo:      http://personalpages.tds.net/~edream/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458

</t>
<t tx="T512">leo.py 3.6 is now available at:  http://sourceforge.net/projects/leo/
leo.py requires Python 2.2 and tcl/tk 8.3 or above.

A slashdot article about Leo appeared soon after 3.5 was released.  Leo now has many more users and developers; 3.6 is considerably more friendly to Linux as a result.

The highlights of 3.6:
----------------------

- Fixed several bugs that appear only on Linux.
- Added Match Brackets command.
- Added support for MouseWheel (Linux only).
- Added support for LaTex and PHP languages.
- Improved all aspects of the Help menu.
- Discovered a minor bug involving the Python (Idle) window and documented a workaround.
- Leo remembers the previous insertion point and scrollbar position when switching between nodes.
- The usual small improvements and bug fixes.

What is Leo?
------------
 - A programmer's editor, an outlining editor and a flexible browser.
 - A literate programming tool, compatible with noweb and CWEB.
 - A data organizer and project manager. Leo provides multiple views
   of projects within a single outline.
 - Fully scriptable using Python. Leo saves its files in XML format.
 - Portable. leo.py is 100% pure Python.
 - Open Software, distributed under the Python License.

Links:
------
Leo:      http://personalpages.tds.net/~edream/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458</t>
<t tx="T513">leo.py 3.7 is now available at:  http://sourceforge.net/projects/leo/
leo.py requires Python 2.1 and tcl/tk 8.3 or above.

The highlights of 3.7:
----------------------

- Now works with Python 2.1.  Previous versions required Python 2.2.
- Many new user options, including user-definable shortcuts for all commands
  and colors for all parts of Leo's windows.
  As a result, it is now possible to use arrow keys as you desire.
- Minimal support for Unicode. Better support is coming.
- Improved handling of relative path names.
- The @first directive allows lines to precede the opening @+leo sentinel line.
- The @last  directive allows lines to follow  the closing @-leo sentinel line.
- Better support for Perl+pod.
- Leo now ends all lines with '\n' regardless of platform.
- Leo is now compatible with Python 2.1.
- Simplified sentinels reduce spurious CVS diffs.
- Many other minor improvements and bug fixes.

What is Leo?
------------
 - A programmer's editor, an outlining editor and a flexible browser.
 - A literate programming tool, compatible with noweb and CWEB.
 - A data organizer and project manager. Leo provides multiple views
   of projects within a single outline.
 - Fully scriptable using Python. Leo saves its files in XML format.
 - Portable. leo.py is 100% pure Python.
 - Open Software, distributed under the Python License.

Links:
------
Leo:      http://personalpages.tds.net/~edream/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458</t>
<t tx="T514">leo.py 3.8 is now available at:  http://sourceforge.net/projects/leo/
leo.py requires Python 2.1 or above and tcl/tk 8.3 or above.

Many major improvements have been made to Leo, all made as the result of user requests:

The highlights of 3.8:
----------------------

- New @rawfile and @silentfile trees complement @file trees.
  @rawfile and @silentfile trees create derived files without using sections.
  @rawfile files contain only those sentinels needed to automatically untangle them.
  @silentfile trees contain no sentinels at all.
- New @raw and @end_raw directives allow unformatted code within @file trees.
- Much better support for CWEB.  You may organize .w files using noweb!
- The @comment and @language directives may now apply simultaneously.
- Leo can now read, remember and write &lt;?xml-stylesheet...?&gt; lines,
  under control of the new stylesheet option.
- The new output_newline option specifies the line endings used when writing files.
- The new output_initial_comment option specifies the text to appear
  in an @comment sentinel at the start of each derived file.
- New commands in the help menu make it much easier to change configuration options.
- Dozens of minor improvements and bug fixes.

What is Leo?
------------
 - A programmer's editor, an outlining editor and a flexible browser.
 - A literate programming tool, compatible with noweb and CWEB.
 - A data organizer and project manager. Leo provides multiple views
   of projects within a single outline.
 - Fully scriptable using Python. Leo saves its files in XML format.
 - Portable. leo.py is 100% pure Python.
 - Open Software, distributed under the Python License.

Links:
------
Leo:      http://personalpages.tds.net/~edream/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458</t>
<t tx="T515">leo.py 3.9 is now available at:  http://sourceforge.net/projects/leo/
leo.py requires Python 2.1 or above and tcl/tk 8.3 or above.

This is one of the most interesting versions of Leo ever released:

The highlights of 3.9:
----------------------
* Major performance improvements:
  - Incremental syntax coloring speeds response when typing.
  - Incremental undo drastically reduces memory used.

* Major improvements in customizing Leo:
  - Leo looks in the file customizeLeo.py for user-specific customizations.
  - Leo calls "hook routines" in customizeLeo.py for all commands and events.
    These hook routines can modify or replace any command or event.
  - New convenience routines simplify creating and modifying menus.
  - Easy translation of menus to other languages using customizeLeo.py.

* Better integration with other tools:
  - The Open With command allows you to communicate back and forth with other editors.
  - The Go To Line Number command converts lines numbers in derived files
    to locations in the outline.
  - Double-clicking the icon of a @url node launches any url in your web browser.
  - The Execute Script command executes Python code in any body pane.
    This is much more convenient than opening Leo's Idle window.
  - Much better support for cweb. At last, Leo has a power user of cweb.
    By default, @space, @* and @** sections are colored as latex text.
    Leo properly generates @q..@&gt; sentinels.
  - @nosentinelfile is like @file except Leo writes no sentinel lines.

* Other improvements:
  - Optional Emacs-style auto-indent.
  - Reformat Paragraph command.
  - Leo will optionally create nonexistent directories specified in
    @file, @root or @path, including all nonexistent parent directories.
  - Leo will place its own icon in Leo windows provided that you have
    installed Fredrik Lundh's PIL and tkIcon packages.
  - The usual assortment of bug fixes.

Quote of the month
------------------
"When first I opened Leo, it was out of curiosity. But having used it...
I'LL NEVER GO BACK. THEY'LL HAVE TO PRY LEO OUT OF MY COLD, DEAD FINGERS!
Seriously,it should be renamed 'Crack Cocaine' because it's that addictive.
I'm ready to start a 12-Step group." -- Travers A. Hough

What is Leo?
------------
 - A programmer's editor, an outlining editor and a flexible browser.
 - A literate programming tool, compatible with noweb and CWEB.
 - A data organizer and project manager. Leo provides multiple views
   of projects within a single outline.
 - Fully scriptable using Python. Leo saves its files in XML format.
 - Portable. leo.py is 100% pure Python.
 - Open Software, distributed under the Python License.

Links:
------
Leo:      http://personalpages.tds.net/~edream/front.html
Home:     http://sourceforge.net/projects/leo/
Download: http://sourceforge.net/project/showfiles.php?group_id=3458
CVS:      http://sourceforge.net/cvs/?group_id=3458</t>
<t tx="T516">Check code
	Run pychecker
		import pychecker.checker from idle, then just import Leo.
Documentation
	- Update readme.txt
		Make sure to mention single-click installer.
		Make sure to mention INSTALL.TXT.
	- Update LeoDocs.leo
		Create clone of latest announcement.
		Remove clone of previous announcement.
	- Update web site.
Version numbers
	- Update version number in Help menu.
	- Update version number in setup.py
Create files
    - Create zip file of all Leo web docs.
	- Make sure read_only = 0 in leoConfig.txt
	- Make sure use_customizeLeo_dot_py = 0 in leoConfig.txt
	- Make sure xml_version_string = UTF-8 in leoConfig.txt
	- Tangle leoConfig.leo giving leoConfig.txt
		(Don't run Leo until the next steps are complete)
	- Run sdist.bat giving leo-x-y.zip
	- Compile leo.nsi giving leosetup.exe
	- Run leosetup.exe
	- test the files created in c:\program files\leo
Create Release on SourceForge
Uploads
    - Upload leodocs.zip (put it in a separate place)
	- Upload leosetup.exe
	- Upload leo-x-y.zip
	- Upload sbook.chm if it has been changed.
Announcements
	- Announce to SourceForge itself.
	- Announce to Leo's SourceForce site.
		Make sure to mention single-click installer.
	- Announce to comp.lang.python
	- Announce to comp.programming.literate</t>
<t tx="T517">Have you thought about the publicity of 3.6? 
- News item on sourceforge 
- Freshmeat 
- http://www.python.org 
Vaults of Parnassus 
Vault: __main__ . Python Tools/Extensions . Editor / IDE 
- http://www.linux.org 
Development tools 
- http://www.gnu.org 
Just kidding :) 
</t>
<t tx="T518">Edwardian script (any size)

courier 9
Ms Sans Serif 9
Microsoft Sans Serif (very good)

Arial 16
Garamond 16
Courier New CE 16
Microsoft Sans Serif 16
Verdana 16</t>
<t tx="T519">use the command line option in the admin menu to do the following:

add leoConfig.py and leoConfig.txt
	cvs add leoConfig.txt
	cvs add leoConfig.py
	(then do commit)

remove readme*.doc
	remove files from working area (done)
	cvs remove readme1.doc
	cvs remove readme2.doc
	...
	(then do commit)</t>
<t tx="T520">@nocolor

Here are the steps involved in adding a new language.

- Add a new language constant in leoGlobals.&lt;&lt;define global constants&gt;&gt;

- Add a new Tk.Radiobutton in leoPrefs.&lt;&lt;create the Target Language frame&gt;&gt;

- Add a new entry for the language in self.languageNameDict in leoConfig.py.&lt;&lt;initialize constant ivars&gt;&gt;.

This entry represents the name of the language in leoConfig.txt.

- Modify the utility routines set_delims_from_language and set_language to handle the new language.

- Modify the code in leoFileCommands.getPrefs.&lt;&lt; check for syntax coloring prefs &gt;&gt; to support the new language.

This involves making new entries in lists in each function.

- Modyify leoColor.py so that colorizeAnyLanguage will handle the new language:

a. Add an entry in the list called "languages" defined  in
	leoColor.&lt;&lt;configure language-specific settings&gt;&gt;

b. Add a list containing the keywords of the new language to
	leoColor.&lt;&lt; define colorizer keywords &gt;&gt;
	
Note: the name of this list must be x_keywords, where x is the entry in language in step a.
	
For example, to add tcltk:
	
	languages = (..., "tcltk",...) # list of names of keyword lists.
	tcltk_keywords = ("after", "append", ...) # The keyword list for the tcl/tk language.
		
c. Add any language-specifig code to leoColor.colorizeAnyLanguage.

For most languages nothing need be done in this step because colorizeAnyLanguage gets the comment delimiters from set_delims_from_language.

-  Make the following tests:

1. Test the syntax coloring for the new language by using the @language directive.

2. Test workings of the Preferences Panel by choosing the language in the panel and by looking at code that is _not_ under control of an @language directive.

3. Test the leoConfig.txt by setting default_target_language to the name of the new language.  When you restart Leo, the new language should be selected in the Prefs panel.

4. Remove leoConfig.txt, select the new language in the Prefs panel, and save the .leo file.  Open the file with a text editor and check to make sure that the &lt;preferences&gt; tag (near the top) contains an entry like this:

&lt;preferences allow_rich_text="0" defaultTargetLanguage="Python"&gt;
&lt;/preferences&gt;

but with the name of your new language instead of "Python".

5. Create an @root node and verify that you can Tangle it.

</t>
<t tx="T521"># We put an @color here so it is unambiguous.

@ignore
@language python
@color</t>
<t tx="T522">self.prolog_string = "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;"

# New in leo.py 3.0
self.prolog_prefix_string = "&lt;?xml version=\"1.0\" encoding="
self.prolog_version_string1 = "UTF-8" # for leo.py 2.x
self.prolog_version_string2 = "ISO-8859-1" # for leo.py 3.x
self.prolog_postfix_string = "?&gt;"
</t>
<t tx="T523"># Frame and title
w,target = create_labeled_frame (outer,caption="Default Target Language")
w.pack(padx=2,pady=2,expand=1,fill="x")

# Frames for two columns of radio buttons
lt = Tk.Frame(target)
rt = Tk.Frame(target)
lt.pack(side="left")
rt.pack(side="right")

# Left column of radio buttons.
left_data = [
	("C/C++","c"), ("CWEB", "cweb"),
	("HTML", "html"), ("Java", "java"),
	("LaTeX", "latex"), ("Pascal", "pascal") ]

for text,value in left_data:
	button = Tk.Radiobutton(lt,anchor="w",text=text,
		variable=self.lang_var,value=value,command=self.set_lang)
	button.pack(fill="x") 
	
# Right column of radio buttons.
right_data = [
	("Perl", "perl"), ("Perl+POD", "perlpod"),
	("PHP", "php"),
	("Plain Text", "plain"), ("Python", "python"),
	("tcl/tk", "tcltk") ]
	
for text,value in right_data:
	button = Tk.Radiobutton(rt,anchor="w",text=text,
		variable=self.lang_var,value=value,command=self.set_lang)
	button.pack(fill="x")</t>
<t tx="T524">&lt;&lt; leo keywords &gt;&gt;
&lt;&lt; c keywords &gt;&gt;
cweb_keywords = c_keywords
&lt;&lt; html keywords &gt;&gt;
&lt;&lt; java keywords &gt;&gt;
&lt;&lt; latex keywords &gt;&gt;
&lt;&lt; pascal keywords &gt;&gt;
&lt;&lt; perl keywords &gt;&gt;
perlpod_keywords = perl_keywords
&lt;&lt; python keywords &gt;&gt;
&lt;&lt; tcl/tk keywords &gt;&gt;
&lt;&lt; php keywords &gt;&gt;</t>
<t tx="T525">leoKeywords = (
	"@","@c","@code","@color","@comment",
	"@delims","@doc","@end_raw",
	"@first","@header","@ignore",
	"@language","@last",
	"@nocolor","@noheader","@others",
	"@pagewidth","@path","@quiet","@raw","@root","@root-code","@root-doc",
	"@silent","@tabwidth","@terse",
	"@unit","@verbose")</t>
<t tx="T526">c_keywords = (
	# C keywords
	"auto","break","case","char","continue",
	"default","do","double","else","enum","extern",
	"float","for","goto","if","int","long","register","return",
	"short","signed","sizeof","static","struct","switch",
	"typedef","union","unsigned","void","volatile","while",
	# C++ keywords
	"asm","bool","catch","class","const_cast",
	"delete","dynamic_cast","explicit","false","friend",
	"inline","mutable","namespace","new","operator",
	"private","protected","public","reinterpret_cast","static_cast",
	"template","this","throw","true","try",
	"typeid","typename","using","virtual","wchar_t")</t>
<t tx="T527">html_keywords = (
	# HTML constructs.
	"&lt;","&lt;/","&gt;",
	'"',
	"&lt;!---","&lt;!--","&lt;!",
	"&lt;%","%&gt;",
	"&lt;a","&lt;/a",
	"&lt;img",
	"&lt;cf","&lt;/cf",
	# Common tags: tables
	"&lt;table","&lt;/table",
	"&lt;td","&lt;/td",
	"&lt;th","&lt;/th",
	"&lt;tr","&lt;/tr",
	"&lt;caption","&lt;/caption",
	"&lt;col","&lt;/col",
	"&lt;colgroup","&lt;/colgroup",
	"&lt;tbody","&lt;/tbody",
	"&lt;tfoot","&lt;/tfoot",
	"&lt;thead","&lt;/thead",	
	# Common tags: styles
	"&lt;style","&lt;/style",
	# Common tags: scripts
	"&lt;script","&lt;/script",
	# Escapes
	"&amp;amp;", "&amp;lt;", "&amp;gt;", "&amp;quot;" )</t>
<t tx="T528">java_keywords = (
	"abstract","boolean","break","byte","byvalue",
	"case","cast","catch","char","class","const","continue",
	"default","do","double","else","extends",
	"false","final","finally","float","for","future",
	"generic","goto","if","implements","import","inner",
	"instanceof","int","interface","long","native",
	"new","null","operator","outer",
	"package","private","protected","public","rest","return",
	"short","static","super","switch","synchronized",
	"this","throw","transient","true","try",
	"var","void","volatile","while")</t>
<t tx="T529">#If you see two idenitical words, with minor capitalization differences
#DO NOT ASSUME that they are the same word. For example \vert produces
#a single vertical line and \Vert produces a double vertical line
#Marcus A. Martin.

latex_keywords = (
	#special keyworlds
	"\\@", "\\(", "\\)", "\\{", "\\}",
	#A
	"\\acute", "\\addcontentsline", "\\addtocontents", "\\addtocounter", "\\address",
	"\\addtolength", "\\addvspace", "\\AE", "\\ae", "\\aleph", "\\alph", "\\angle",
	"\\appendix", 
	"\\approx",	"\\arabic", "\\arccos", "\\arcsin", "\\arctan", "\\ast", "\\author",
	#B
	"\\b", "\\backmatter", "\\backslash", "\\bar", "\\baselineskip", "\\baselinestretch",
	"\\begin", "\\beta", "\\bezier", "\\bf", "\\bfseries", "\\bibitem", "\\bigcap", 
	"\\bigcup", "\\bigodot", "\\bigoplus", "\\bigotimes", "\\bigskip", "\\biguplus", 
	"\\bigvee", "\\bigwedge",	"\\bmod", "\\boldmath", "\\Box", "\\breve", "\\bullet",
	#C
	"\\c", "\\cal", "\\caption", "\\cdot", "\\cdots", "\\centering", "\\chapter", 
	"\\check", "\\chi", "\\circ", "\\circle", "\\cite", "\\cleardoublepage", "\\clearpage", 
	"\\cline",	"\\closing", "\\clubsuit", "\\coprod", "\\copywright", "\\cos", "\\cosh", 
	"\\cot", "\\coth",	"csc",
	#D
	"\\d", "\\dag", "\\dashbox", "\\date", "\\ddag", "\\ddot", "\\ddots", "\\decl", 
	"\\deg", "\\Delta", 
	"\\delta", "\\depthits", "\\det", 
	"\\DH", "\\dh", "\\Diamond", "\\diamondsuit", "\\dim", "\\div", "\\DJ", "\\dj", 
	"\\documentclass", "\\documentstyle", 
	"\\dot", "\\dotfil", "\\downarrow",
	#E
	"\\ell", "\\em", "\\emph", "\\end", "\\enlargethispage", "\\ensuremath", 
	"\\enumi", "\\enuii", "\\enumiii", "\\enuiv", "\\epsilon", "\\equation", "\\equiv",	
	"\\eta", "\\example", "\\exists", "\\exp",
	#F
	"\\fbox", "\\figure", "\\flat", "\\flushbottom", "\\fnsymbol", "\\footnote", 
	"\\footnotemark", "\\fotenotesize", 
	"\\footnotetext", "\\forall", "\\frac", "\\frame", "\\framebox", "\\frenchspacing", 
	"\\frontmatter",
	#G
	"\\Gamma", "\\gamma", "\\gcd", "\\geq", "\\gg", "\\grave", "\\guillemotleft", 
	"\\guillemotright",	"\\guilsinglleft", "\\guilsinglright",
	#H
	"\\H", "\\hat", "\\hbar", "\\heartsuit", "\\heightits", "\\hfill", "\\hline", "\\hom",
	"\\hrulefill",	"\\hspace", "\\huge",	"\\Huge",	"\\hyphenation"
	#I
	"\\Im", "\\imath", "\\include", "includeonly", "indent", "\\index", "\\inf", "\\infty", 
	"\\input", "\\int", "\\iota",	"\\it", "\\item", "\\itshape",
	#J
	"\\jmath", "\\Join",
	#K
	"\\k", "\\kappa", "\\ker", "\\kill",
	#L
	"\\label", "\\Lambda", "\\lambda", "\\langle", "\\large", "\\Large", "\\LARGE", 
	"\\LaTeX", "\\LaTeXe", 
	"\\ldots", "\\leadsto", "\\left", "\\Leftarrow", "\\leftarrow", "\\lefteqn", "\\leq",
	"\\lg", "\\lhd", "\\lim", "\\liminf", "\\limsup", "\\line", 	"\\linebreak", 
	"\\linethickness", "\\linewidth",	"\\listfiles",
	"\\ll", "\\ln", "\\location", "\\log", "\\Longleftarrow", "\\longleftarrow", 
	"\\Longrightarrow",	"longrightarrow",
	#M
	"\\mainmatter", "\\makebox", "\\makeglossary", "\\makeindex","\\maketitle", "\\markboth", "\\markright",
	"\\mathbf", "\\mathcal", "\\mathit", "\\mathnormal", "\\mathop",
	"\\mathrm", "\\mathsf", "\\mathtt", "\\max", "\\mbox", "\\mdseries", "\\medskip",
	"\\mho", "\\min", "\\mp", "\\mpfootnote", "\\mu", "\\multicolumn", "\\multiput",
	#N
	"\\nabla", "\\natural", "\\nearrow", "\\neq", "\\newcommand", "\\newcounter", 
	"\\newenvironment", "\\newfont",
	"\\newlength",	"\\newline", "\\newpage", "\\newsavebox", "\\newtheorem", "\\NG", "\\ng",
	"\\nocite", "\\noindent", "\\nolinbreak", "\\nopagebreak", "\\normalsize",
	"\\not", "\\nu", "nwarrow",
	#O
	"\\Omega", "\\omega", "\\onecolumn", "\\oint", "\\opening", "\\oval", 
	"\\overbrace", "\\overline",
	#P
	"\\P", "\\page", "\\pagebreak", "\\pagenumbering", "\\pageref", "\\pagestyle", 
	"\\par", "\\parbox",	"\\paragraph", "\\parindent", "\\parskip", "\\part", 
	"\\partial", "\\per", "\\Phi", 	"\\phi",	"\\Pi", "\\pi", "\\pm", 
	"\\pmod", "\\pounds", "\\prime", "\\printindex", "\\prod", "\\propto", "\\protext", 
	"\\providecomamnd", "\\Psi",	"\\psi", "\\put",
	#Q
	"\\qbezier", "\\quoteblbase", "\\quotesinglbase",
	#R
	"\\r", "\\raggedbottom", "\\raggedleft", "\\raggedright", "\\raisebox", "\\rangle", 
	"\\Re", "\\ref", 	"\\renewcommand", "\\renewenvironment", "\\rhd", "\\rho", "\\right", 
	"\\Rightarrow",	"\\rightarrow", "\\rm", "\\rmfamily",
	"\\Roman", "\\roman", "\\rule", 
	#S
	"\\s", "\\samepage", "\\savebox", "\\sbox", "\\sc", "\\scriptsize", "\\scshape", 
	"\\searrow",	"\\sec", "\\section",
	"\\setcounter", "\\setlength", "\\settowidth", "\\settodepth", "\\settoheight", 
	"\\settowidth", "\\sf", "\\sffamily", "\\sharp", "\\shortstack", "\\Sigma", "\\sigma", 
	"\\signature", "\\sim", "\\simeq", "\\sin", "\\sinh", "\\sl", "\\SLiTeX",
	"\\slshape", "\\small", "\\smallskip", "\\spadesuit", "\\sqrt", "\\sqsubset",	
	"\\sqsupset", "\\SS",
	"\\stackrel", "\\star", "\\subsection", "\\subset", 
	"\\subsubsection", "\\sum", "\\sup", "\\supressfloats", "\\surd", "\\swarrow",
	#T
	"\\t", "\\table", "\\tableofcontents", "\\tabularnewline", "\\tan", "\\tanh", 
	"\\tau", "\\telephone",	"\\TeX", "\\textbf",
	"\\textbullet", "\\textcircled", "\\textcompworkmark",	"\\textemdash", 
	"\\textendash", "\\textexclamdown", "\\textheight", "\\textquestiondown", 
	"\\textquoteblleft", "\\textquoteblright", "\\textquoteleft",
	"\\textperiod", "\\textquotebl", "\\textquoteright", "\\textmd", "\\textit", "\\textrm", 
	"\\textsc", "\\textsl", "\\textsf", "\\textsuperscript", "\\texttt", "\\textup",
	"\\textvisiblespace", "\\textwidth", "\\TH", "\\th", "\\thanks", "\\thebibligraphy",
	"\\Theta", "theta", 
	"\\tilde", "\\thinlines", 
	"\\thispagestyle", "\\times", "\\tiny", "\\title",	"\\today", "\\totalheightits", 
	"\\triangle", "\\tt", 
	"\\ttfamily", "\\twocoloumn", "\\typeout", "\\typein",
	#U
	"\\u", "\\underbrace", "\\underline", "\\unitlength", "\\unlhd", "\\unrhd", "\\Uparrow",
	"\\uparrow",	"\\updownarrow", "\\upshape", "\\Upsilon", "\\upsilon", "\\usebox",	
	"\\usecounter", "\\usepackage", 
	#V
	"\\v", "\\value", "\\varepsilon", "\\varphi", "\\varpi", "\\varrho", "\\varsigma", 
	"\\vartheta", "\\vdots", "\\vec", "\\vector", "\\verb", "\\Vert", "\\vert", 	"\\vfill",
	"\\vline", "\\vphantom", "\\vspace",
	#W
	"\\widehat", "\\widetilde", "\\widthits", "\\wp",
	#X
	"\\Xi", "\\xi",
	#Z
	"\\zeta" )</t>
<t tx="T530">pascal_keywords = (
	"and","array","as","begin",
	"case","const","class","constructor","cdecl"
	"div","do","downto","destructor","dispid","dynamic",
	"else","end","except","external",
	"false","file","for","forward","function","finally",
	"goto","if","in","is","label","library",
	"mod","message","nil","not","nodefault""of","or","on",
	"procedure","program","packed","pascal",
	"private","protected","public","published",
	"record","repeat","raise","read","register",
	"set","string","shl","shr","stdcall",
	"then","to","true","type","try","until","unit","uses",
	"var","virtual","while","with","xor"
	# object pascal
	"asm","absolute","abstract","assembler","at","automated",
	"finalization",
	"implementation","inherited","initialization","inline","interface",
	"object","override","resident","resourcestring",
	"threadvar",
	# limited contexts
	"exports","property","default","write","stored","index","name" )</t>
<t tx="T531">perl_keywords = (
	"continue","do","else","elsif","format","for","format","for","foreach",
	"if","local","package","sub","tr","unless","until","while","y",
	# Comparison operators
	"cmp","eq","ge","gt","le","lt","ne",
	# Matching ooperators
	"m","s",
	# Unary functions
	"alarm","caller","chdir","cos","chroot","exit","eval","exp",
	"getpgrp","getprotobyname","gethostbyname","getnetbyname","gmtime",
	"hex","int","length","localtime","log","ord","oct",
	"require","reset","rand","rmdir","readlink",
	"scalar","sin","sleep","sqrt","srand","umask",
	# Transfer ops
	"next","last","redo","go","dump",
	# File operations...
	"select","open",
	# FL ops
	"binmode","close","closedir","eof",
	"fileno","getc","getpeername","getsockname","lstat",
	"readdir","rewinddir","stat","tell","telldir","write",
	# FL2 ops
	"bind","connect","flock","listen","opendir",
	"seekdir","shutdown","truncate",
	# FL32 ops
	"accept","pipe",
	# FL3 ops
	"fcntl","getsockopt","ioctl","read",
	"seek","send","sysread","syswrite",
	# FL4 &amp; FL5 ops
	"recv","setsocket","socket","socketpair",
	# Array operations
	"pop","shift","split","delete",
	# FLIST ops
	"sprintf","grep","join","pack",
	# LVAL ops
	"chop","defined","study","undef",
	# f0 ops
	"endhostent","endnetent","endservent","endprotoent",
	"endpwent","endgrent","fork",
	"getgrent","gethostent","getlogin","getnetent","getppid",
	"getprotoent","getpwent","getservent",
	"setgrent","setpwent","time","times","wait","wantarray",
	# f1 ops
	"getgrgid","getgrnam","getprotobynumber","getpwnam","getpwuid",
	"sethostent","setnetent","setprotoent","setservent",
	# f2 ops
	"atan2","crypt",
	"gethostbyaddr","getnetbyaddr","getpriority","getservbyname","getservbyport",
	"index","link","mkdir","msgget","rename",
	"semop","setpgrp","symlink","unpack","waitpid",
	# f2 or 3 ops
	"index","rindex","substr",
	# f3 ops
	"msgctl","msgsnd","semget","setpriority","shmctl","shmget","vec",
	# f4 &amp; f5 ops
	"semctl","shmread","shmwrite","msgrcv",
	# Assoc ops
	"dbmclose","each","keys","values",
	# List ops
	"chmod","chown","die","exec","kill",
	"print","printf","return","reverse",
	"sort","system","syscall","unlink","utime","warn")</t>
<t tx="T532">python_keywords = (
	"and",       "del",       "for",       "is",        "raise",    
	"assert",    "elif",      "from",      "lambda",    "return",   
	"break",     "else",      "global",    "not",       "try",      
	"class",     "except",    "if",        "or",        "yield",   
	"continue",  "exec",      "import",    "pass",      "while",
	"def",       "finally",   "in",        "print")</t>
<t tx="T533">tcltk_keywords = ( # Only the tcl keywords are here.
	"after",     "append",    "array",
	"bgerror",   "binary",    "break",
	"catch",     "cd",        "clock",
	"close",     "concat",    "continue",
	"dde",
	"encoding",  "eof",       "eval",
	"exec",      "exit",      "expr",
	"fblocked",  "fconfigure","fcopy",     "file",      "fileevent",
	"filename",  "flush",     "for",       "foreach",   "format",
	"gets",      "glob",      "global",
	"history",
	"if",        "incr",      "info",      "interp",
	"join",
	"lappend",   "lindex",    "linsert",   "list",      "llength",
	"load",      "lrange",    "lreplace",  "lsearch",   "lsort",
	"memory",    "msgcat",
	"namespace",
	"open",
	"package",   "parray",    "pid",
	"proc",      "puts",      "pwd",
	"read",      "regexp",    "registry",   "regsub",
	"rename",    "resource",  "return",
	"scan",      "seek",      "set",        "socket",   "source",
	"split",     "string",    "subst",      "switch",
	"tell",      "time",      "trace",
	"unknown",   "unset",     "update",     "uplevel",   "upvar",
	"variable",  "vwait",
	"while" )</t>
<t tx="T534">php_keywords = ( # 08-SEP-2002 DTHEIN
	"__CLASS__", "__FILE__", "__FUNCTION__", "__LINE__",
	"and", "as", "break",
	"case", "cfunction", "class", "const", "continue",
	"declare", "default", "do",
	"else", "elseif", "enddeclare", "endfor", "endforeach",
	"endif", "endswitch",  "endwhile", "eval", "extends",
	"for", "foreach", "function", "global", "if",
	"new", "old_function", "or", "static", "switch",
	"use", "var", "while", "xor" )
	
# The following are supposed to be followed by ()
php_paren_keywords = (
	"array", "die", "echo", "empty", "exit",
	"include", "include_once", "isset", "list",
	"print", "require", "require_once", "return",
	"unset" )
	
# The following are handled by special case code:
# "&lt;?php", "?&gt;"
</t>
<t tx="T535"># Define has_string, keywords, single_comment_start, block_comment_start, block_comment_end.

if language == "plain": # 9/12/02
	delim1,delim2,delim3 = None,None,None
elif self.comment_string: # 8/11/02
	delim1,delim2,delim3 = set_delims_from_string(self.comment_string)
else:
	delim1,delim2,delim3 = set_delims_from_language(language)

# 8/1/02: this now works as expected.
single_comment_start = delim1
block_comment_start = delim2
block_comment_end = delim3
self.block_comment_end = block_comment_end # for callback

# A strong case can be made for making this code as fast as possible.
# Whether this is compatible with general language descriptions remains to be seen.
has_string = language != "plain"
has_pp_directives = language in ["c","cweb"]
is_cweb = language == "cweb"
is_latex = language == "latex"
is_php = language == "php"
is_plain = language == "plain"
is_python = language == "python"

# The list of languages for which keywords exist.
# Eventually we might just use language_delims_dict.keys()
languages = ["c","cweb","html","java","latex", "pascal","perl","perlpod","python","tcltk","php"]

keywords = []
if is_cweb:
	for i in c_keywords:
		keywords.append(i)
	for i in cweb_keywords:
		keywords.append(i)
else:
	for name in languages:
		exec("if language==name: keywords=%s_keywords" % name)

# Color plain text unless we are under the control of @nocolor.
state = choose(flag,normalState,nocolorState)

lb = choose(is_cweb,"@&lt;","&lt;&lt;")
rb = choose(is_cweb,"@&gt;","&gt;&gt;")</t>
<t tx="T536"># Must match longer tags before short prefixes.

language = "c" # default

for name in a.language_delims_dict.keys():
	if self.matchTagWordIgnoringCase(name):
		s = string.lower(name)
		language = string.replace(name,"/","")
		self.getDquote()
		break

c.target_language = language</t>
<t tx="T537"># Names of sections.
self.configSection = "config options"
self.compareSection = "compare options"
self.findSection = "find/change options"
self.keysSection = "keyboard shortcuts"
self.prefsSection = "prefs panel options"
self.recentFilesSection = "recent files"
self.colorsSection = "syntax coloring options"
self.windowSection = "window options"

# List of recent files.
self.recentFiles = []

# Section dictionaries
self.compareDict = {}
self.configDict = {} # 10/11/02: we use a dict even for ivars.
self.findDict = {}
self.keysDict = {}
self.prefsDict = {}
self.colorsDict = {}
self.windowDict = {}

# Associations of sections and dictionaries.
self.sectionInfo = (
	(self.configSection,self.configDict),
	(self.compareSection,self.compareDict),
	(self.findSection,self.findDict),
	(self.keysSection,self.keysDict),
	(self.prefsSection,self.prefsDict),
	(self.recentFilesSection,None),
	(self.colorsSection,self.colorsDict),
	(self.windowSection,self.windowDict) )</t>
<t tx="T538"># Returns a tuple (single,start,end) of comment delims

def set_delims_from_language(language):
	
	a = app()
	
	val = a.language_delims_dict.get(language)
	if val:
		delim1,delim2,delim3 = set_delims_from_string(val)
		if delim2 and not delim3:
			return None,delim1,delim2
		else: # 0,1 or 3 params.
			return delim1,delim2,delim3
	else:
		return None, None, None # Indicate that no change should be made
</t>
<t tx="T539">@  Scans the @language directive that appears at s[i].

Returns (language, delim1, delim2, delim3)
@c

def set_language(s,i,issue_errors_flag=false):

	a = app()
	tag = "@language"
	# trace(`get_line(s,i)`)
	assert(i != None)
	assert(match_word(s,i,tag))
	i += len(tag) ; i = skip_ws(s, i)
	# Get the argument.
	j = i ; i = skip_c_id(s,i)
	# Allow tcl/tk.
	arg = string.lower(s[j:i])
	if a.language_delims_dict.get(arg):
		language = arg
		delim1, delim2, delim3 = set_delims_from_language(language)
		return language, delim1, delim2, delim3
	
	if issue_errors_flag:
		es("ignoring: " + get_line(s,i))

	return None, None, None, None,</t>
<t tx="T540">@ Leo needs both incremental and non-incremental colorizing; this routine does both.
@c

def colorizeAnyLanguage (self,v,body,language,flag,leading=None,trailing=None):
	
	try:
		if 0:
			if not self.incremental:
				print "incremental: 0"
				#import traceback ; traceback.print_stack()
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental and self.last_language==language:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
		self.last_language = language
	except:
		self.last_language = "unknown"
		es_exception()</t>
<t tx="T541"># Copy the arguments.
self.v = v
self.body = body
self.language = language
self.flag = flag

s = body.get("1.0", "end")
sel = body.index("insert") # get the location of the insert point
start, end = string.split(sel,'.')
start = int(start)

# trace(`self.language`)
# trace(`self.count` + `self.v`)
# trace(`body.tag_names()`)

if not self.incremental:
	self.removeAllTags()

&lt;&lt; configure tags &gt;&gt;
&lt;&lt; configure language-specific settings &gt;&gt;

self.hyperCount = 0 # Number of hypertext tags
self.count += 1
lines = string.split(s,'\n')</t>
<t tx="T542">config = app().config
assert(config)

for name in default_colors_dict.keys(): # Python 2.1 support.
	option_name,default_color = default_colors_dict[name]
	option_color = config.getColorsPref(option_name)
	color = choose(option_color,option_color,default_color)
	# Must use foreground, not fg.
	try:
		body.tag_config(name, foreground=color)
	except: # Recover after a user error.
		body.tag_config(name, foreground=default_color)

underline_undefined = config.getBoolColorsPref("underline_undefined_section_names")
use_hyperlinks      = config.getBoolColorsPref("use_hyperlinks")
self.use_hyperlinks = use_hyperlinks

# underline=var doesn't seem to work.
if use_hyperlinks: 
	body.tag_config("link",underline=1) # defined
	body.tag_config("name",underline=0) # undefined
else:
	body.tag_config("link",underline=0)
	if underline_undefined:
		body.tag_config("name",underline=1)
	else:
		body.tag_config("name",underline=0)
		
# 8/4/02: we only create tags for whitespace when showing invisibles.
if self.showInvisibles:
	body.tag_config("blank",background="Gray90")
	body.tag_config("tab",background="Gray80")
	
# 11/15/02: Colors for latex characters.  Should be user options...

if 1: # Alas, the selection doesn't show if a background color is specified.
	body.tag_configure("latexModeBackground",foreground="black")
	body.tag_configure("latexModeKeyword",foreground="blue")
	body.tag_configure("latexBackground",foreground="black")
	body.tag_configure("latexKeyword",foreground="blue")
else: # Looks cool, and good for debugging.
	body.tag_configure("latexModeBackground",foreground="black",background="seashell1")
	body.tag_configure("latexModeKeyword",foreground="blue",background="seashell1")
	body.tag_configure("latexBackground",foreground="black",background="white")
	body.tag_configure("latexKeyword",foreground="blue",background="white")</t>
<t tx="T543"># Define has_string, keywords, single_comment_start, block_comment_start, block_comment_end.

if self.language == "plain": # 9/12/02
	delim1,delim2,delim3 = None,None,None
elif self.language == "cweb": # 11/14/02: Use C comments, not cweb sentinel comments.
	delim1,delim2,delim3 = set_delims_from_language("c")
elif self.comment_string: # 8/11/02
	delim1,delim2,delim3 = set_delims_from_string(self.comment_string)
else:
	delim1,delim2,delim3 = set_delims_from_language(self.language)

# 8/1/02: this now works as expected.
self.single_comment_start = delim1
self.block_comment_start = delim2
self.block_comment_end = delim3

# A strong case can be made for making this code as fast as possible.
# Whether this is compatible with general language descriptions remains to be seen.
self.has_string = self.language != "plain"
self.has_pp_directives = self.language in ("c","cweb","latex")

# The list of languages for which keywords exist.
# Eventually we might just use language_delims_dict.keys()
languages = [
	"c","cweb","html","java","latex",
	"pascal","perl","perlpod","php","python","tcltk"]

self.keywords = []
if self.language == "cweb":
	for i in c_keywords:
		self.keywords.append(i)
	for i in cweb_keywords:
		self.keywords.append(i)
else:
	for name in languages:
		exec("if self.language==name: self.keywords=%s_keywords" % name)

# Color plain text unless we are under the control of @nocolor.
# state = choose(self.flag,"normal","nocolor")
state = self.setFirstLineState()

if 1: # 10/25/02: we color both kinds of references in cweb mode.
	self.lb = "&lt;&lt;"
	self.rb = "&gt;&gt;"
else:
	self.lb = choose(self.language == "cweb","@&lt;","&lt;&lt;")
	self.rb = choose(self.language == "cweb","@&gt;","&gt;&gt;")</t>
<t tx="T544">@  Each line has a starting state.  The starting state for the first line is always "normal".

We need remember only self.lines and self.states between colorizing.  It is not necessary to know where the text comes from, only what the previous text was!  We must always colorize everything when changing nodes, even if all lines match, because the context may be different.

We compute the range of lines to be recolored by comparing leading lines and trailing lines of old and new text.  All other lines (the middle lines) must be colorized, as well as any trailing lines whose states may have changed as the result of changes to the middle lines.
@c

old_lines = self.lines
old_states = self.states
new_lines = lines
new_states = []

new_len = len(new_lines)
old_len = len(old_lines)

if new_len == 0:
	self.states = []
	self.lines = []
	return

# Bug fix: 11/21/02: must test against None.
if leading != None and trailing != None:
	# print "leading,trailing:",leading,trailing
	leading_lines = leading
	trailing_lines = trailing
else:
	&lt;&lt; compute leading, middle &amp; trailing lines &gt;&gt;
	
middle_lines = new_len - leading_lines - trailing_lines
# print "middle lines", middle_lines

&lt;&lt; clear leading_lines if middle lines involve @color or @recolor  &gt;&gt;
&lt;&lt; initialize new states &gt;&gt;
&lt;&lt; colorize until the states match &gt;&gt;</t>
<t tx="T545">@ The leading lines are the leading matching lines.  The trailing lines are the trailing matching lines.  The middle lines are all other new lines.  We will color at least all the middle lines.  There may be no middle lines if we delete lines.
@c

min_len = min(old_len,new_len)

i = 0
while i &lt; min_len:
	if old_lines[i] != new_lines[i]:
		break
	i += 1
leading_lines = i

if leading_lines == new_len:
	# All lines match, and we must color _everything_.
	# (several routine delete, then insert the text again,
	# deleting all tags in the process).
	# print "recolor all"
	leading_lines = trailing_lines = 0
else:
	i = 0
	while i &lt; min_len - leading_lines:
		if old_lines[old_len-i-1] != new_lines[new_len-i-1]:
			break
		i += 1
	trailing_lines = i
</t>
<t tx="T546">@ 11/19/02: Changing @color or @nocolor directives requires we recolor all leading states as well.
@c
if trailing_lines == 0:
	m1 = new_lines[leading_lines:]
	m2 = old_lines[leading_lines:]
else:
	m1 = new_lines[leading_lines:-trailing_lines]
	m2 = old_lines[leading_lines:-trailing_lines]
m1.extend(m2) # m1 now contains all old and new middle lines.
if m1:
	for s in m1:
		i = skip_ws(s,0)
		if match_word(s,i,"@color") or match_word(s,i,"@nocolor"):
			leading_lines = 0
			break
</t>
<t tx="T547"># Copy the leading states from the old to the new lines.
i = 0
while i &lt; leading_lines:
	new_states.append(old_states[i])
	i += 1
	
# We know the starting state of the first middle line!
if middle_lines &gt; 0 and i &lt; old_len:
	new_states.append(old_states[i])
	i += 1
	
# Set the state of all other middle lines to "unknown".
first_trailing_line = new_len - trailing_lines
while i &lt; first_trailing_line:
	new_states.append("unknown")
	i += 1

# Copy the trailing states from the old to the new lines.
j = old_len - trailing_lines
while j &lt; old_len and j &lt; len(old_states):
	new_states.append(old_states[j])
	j += 1
	i += 1 # for the assert below.\

while j &lt; len(old_states):
	new_states.append("unknown")
	j += 1
	i += 1 # for the assert below.
	
# A crucial assertion.  If it fails we won't handle continued states properly.
assert(i == new_len)
	# Step 1 writes leading_lines lines
	# Step 2 writes (new_len - trailing_lines - leading_lines) lines.
	# Step 3 writes trailing_lines lines.

# print "i:", i
if 0:
	for i in xrange(len(new_lines)):
		print new_states[i],new_lines[i]</t>
<t tx="T548"># Colorize until the states match.
# All middle lines have "unknown" state, so they will all be colored.

# Start in the state _after_ the last leading line, which may be unknown.
i = leading_lines
while i &gt; 0:
	if i &lt; old_len and i &lt; new_len:
		state = new_states[i]
		assert(state!="unknown")
		break
	else:
		i -= 1

if i == 0:
	# Color plain text unless we are under the control of @nocolor.
	# state = choose(self.flag,"normal","nocolor")
	state = self.setFirstLineState()
	new_states[0] = state

# The new_states[] will be "unknown" unless the lines match,
# so we do not need to compare lines here.
while i &lt; new_len:
	state = self.colorizeLine(new_lines[i],i+1,state)
	i += 1
	# Set the state of the _next_ line.
	if i &lt; new_len and state != new_states[i]:
		new_states[i] = state
	else: break
	
# Update the ivars
self.states = new_states
self.lines = new_lines</t>
<t tx="T549">def colorizeLine (self,s,n,state):

	# print "inc,state,s:",self.incremental,state,s

	if self.incremental:
		self.removeTagsFromLine(n)

	i = 0
	while i &lt; len(s):
		self.progress = i
		func = self.state_dict[state]
		i,state = func(s,i,n)

	return state</t>
<t tx="T550">def continueBlockComment (self,s,i,n):
	
	j = string.find(s,self.block_comment_end,i)

	if j == -1:
		# The entire line is part of the block comment.
		if self.language=="cweb":
			self.doLatexLine(s,i,len(s),n)
		else:
			self.body.tag_add("comment", index(n,i), index(n,"end"))
		return len(s),"blockComment" # skipt the rest of the line.
	else:
		# End the block comment.
		k = len(self.block_comment_end)
		if self.language=="cweb" and self.latex_cweb_comments:
			self.doLatexLine(s,i,j,n)
			self.body.tag_add("comment", index(n,j), index(n,j+k))
		else:
			self.body.tag_add("comment", index(n,i), index(n,j+k))
		i = j + k
		return i,"normal"</t>
<t tx="T551">def continueDoubleString (self,s,i,n):
	return self.continueString(s,i,n,'"',"doubleString")
	
def continueSingleString (self,s,i,n):
	return self.continueString(s,i,n,"'","singleString")

# Similar to skip_string.
def continueString (self,s,i,n,delim,continueState):

	continueFlag = false
	j = i
	while i &lt; len(s) and s[i] != delim:
		if s[i:] == "\\":
			i = len(s) ; continueFlag = true ; break
		elif s[i] == "\\":
			i += 2
		else:
			i += 1
	if i &gt;= len(s):
		i = len(s)
	elif s[i] == delim:
		i += 1
	self.body.tag_add("string", index(n,j), index(n,i))
	state = choose(continueFlag,continueState,"normal")
	return i,state</t>
<t tx="T552">def continueDocPart (self,s,i,n):
	
	state = "doc"
	if self.language == "cweb":
		&lt;&lt; handle cweb doc part &gt;&gt;
	else:
		&lt;&lt; handle noweb doc part &gt;&gt;
	return i,state</t>
<t tx="T553">word = self.getCwebWord(s,i)
if word and len(word) &gt; 0:
	j = i + len(word)
	if word in ("@&lt;","@(","@c","@d","@f","@p"):
		state = "normal" # end the doc part and rescan
	else:
		# The control code does not end the doc part.
		self.body.tag_add("keyword", index(n,i), index(n,j))
		i = j
		if word in ("@^","@.","@:","@="): # Ended by "@&gt;"
			j = string.find(s,"@&gt;",i)
			if j &gt; -1:
				self.body.tag_add("cwebName", index(n,i), index(n,j))
				self.body.tag_add("nameBrackets", index(n,j), index(n,j+2))
				i = j + 2
elif match(s,i,self.lb):
	j = self.doNowebSecRef(s,i,n)
	if j == i + 2: # not a section ref.
		self.body.tag_add("docPart", index(n,i), index(n,j))
	i = j
elif self.latex_cweb_docs:
	# Everything up to the next "@" is latex colored.
	j = string.find(s,"@",i+1)
	if j == -1: j = len(s)
	self.doLatexLine(s,i,j,n)
	i = j
else:
	# Everthing up to the next "@" is in the doc part.
	j = string.find(s,"@",i+1)
	if j == -1: j = len(s)
	self.body.tag_add("docPart", index(n,i), index(n,j))
	i = j</t>
<t tx="T554">if i == 0 and match(s,i,"&lt;&lt;"):
	# Possible section definition line.
	return i,"normal" # rescan the line.

if i == 0 and s[i] == '@':
	j = self.skip_id(s,i+1,chars='-')
	word = s[i:j]
	word = string.lower(word)
else:
	word = ""

if word in ["@c","@code","@unit","@root","@root-code","@root-doc","@color","@nocolor"]:
	# End of the doc part.
	self.body.tag_remove("docPart", index(n,i), index(n,j))
	self.body.tag_add("leoKeyword", index(n,i), index(n,j))
	i = j ; state = "normal"
else:
	# The entire line is in the doc part.
	self.body.tag_add("docPart", index(n,i), index(n,len(s)))
	i = len(s) # skipt the rest of the line.
</t>
<t tx="T555">def continueNocolor (self,s,i,n):

	if i == 0 and s[i] == '@':
		j = self.skip_id(s,i+1)
		word = s[i:j]
		word = string.lower(word)
	else:
		word = ""
	
	if word == "@color" and self.language != "plain":
		# End of the nocolor part.
		self.body.tag_add("leoKeyword", index(n,0), index(n,j))
		return i,"normal"
	else:
		# The entire line is in the nocolor part.
		# Add tags for blanks and tabs to make "Show Invisibles" work.
		for ch in s[i:]:
			if ch == ' ':
				self.body.tag_add("blank", index(n,i))
			elif ch == '\t':
				self.body.tag_add("tab", index(n,i))
			i += 1
		return i,"nocolor"</t>
<t tx="T556">def continueDoublePythonString (self,s,i,n):
	j = string.find(s,'"""',i)
	return self.continuePythonString(s,i,j,n,"string3d")

def continueSinglePythonString (self,s,i,j,n):
	j = string.find(s,"'''",i)
	return self.continuePythonString(s,i,j,n,"string3s")

def continuePythonString (self,s,i,j,n,continueState):

	if j == -1:
		# The entire line is part of the triple-quoted string.
		self.body.tag_add("string", index(n,i), index(n,"end"))
		return len(s),continueState # skip the rest of the line.
	else:
		# End the string
		self.body.tag_add("string", index(n,i), index(n,j+3))
		return j+3,"normal"</t>
<t tx="T557"># Handles non-cweb keyword.

def doAtKeyword (self,s,i,n):

	j = self.skip_id(s,i+1,chars="-") # to handle @root-code, @root-doc
	word = s[i:j]
	word = string.lower(word)
	if i != 0 and word != "@others":
		word = "" # can't be a Leo keyword, even if it looks like it.
	
	# 7/8/02: don't color doc parts in plain text.
	if self.language != "plain" and (word == "@" or word == "@doc"):
		# at-space is a Leo keyword.
		self.body.tag_add("leoKeyword", index(n,i), index(n,j))
		# Everything on the line is in the doc part.
		self.body.tag_add("docPart", index(n,j), index(n,len(s)))
		return len(s),"doc"
	elif word == "@nocolor":
		# Nothing on the line is colored.
		self.body.tag_add("leoKeyword", index(n,i), index(n,j))
		return j,"nocolor"
	elif word in leoKeywords:
		self.body.tag_add("leoKeyword", index(n,i), index(n,j))
		return j,"normal"
	else:
		return j,"normal"</t>
<t tx="T558"># Colorize the line from i to j.

def doLatexLine (self,s,i,j,n):

	while i &lt; j:
		if match(s,i,"\\"):
			k = self.skip_id(s,i+1)
			word = s[i:k]
			if word in latex_keywords:
				self.body.tag_add("latexModeKeyword",index(n,i),index(n,k))
			i = k
		else:
			self.body.tag_add("latexModeBackground",index(n,i),index(n,i+1))
			i += 1</t>
<t tx="T559">## To do: rewrite using dynamically generated tables.

def doNormalState (self,s,i,n):

	ch = s[i] ; state = "normal"

	if ch in string.letters or ch == '_' or (ch == '\\' and self.language=="latex"):
		&lt;&lt; handle possible keyword &gt;&gt;
	elif match(s,i,self.lb):
		i = self.doNowebSecRef(s,i,n)
	elif ch == '@':
		&lt;&lt; handle at keyword &gt;&gt;
	elif match(s,i,self.single_comment_start):
		&lt;&lt; handle single-line comment &gt;&gt;
	elif match(s,i,self.block_comment_start):
		&lt;&lt; start block comment &gt;&gt;
	elif ch == '%' and self.language=="cweb":
		&lt;&lt; handle latex line &gt;&gt;
	elif self.language=="latex":
		&lt;&lt; handle latex normal character &gt;&gt;
	# ---- From here on self.language != "latex" -----
	elif self.has_string and (ch == '"' or ch == "'"):
		&lt;&lt; handle string &gt;&gt;
	elif ch == '#' and self.has_pp_directives:
		&lt;&lt; handle C preprocessor line &gt;&gt;
	elif self.language == "php" and (match(s,i,"&lt;") or match(s,i,"?")):
		&lt;&lt; handle special php keywords &gt;&gt;
	elif ch == ' ':
		&lt;&lt; handle blank &gt;&gt;
	elif ch == '\t':
		&lt;&lt; handle tab &gt;&gt;
	else:
		&lt;&lt; handle normal character &gt;&gt;

	assert(self.progress &lt; i)
	return i,state</t>
<t tx="T560"></t>
<t tx="T561">if self.language == "latex":
	if match(s,i,"\\"):
		j = self.skip_id(s,i+1)
		word = s[i:j]
		if word in latex_keywords:
			self.body.tag_add("latexKeyword", index(n,i), index(n,j))
		else:
			self.body.tag_add("latexBackground", index(n,i), index(n,j))
	else:
		self.body.tag_add("latexBackground", index(n,i), index(n,i+1))
		j = i + 1 # skip the character.
else:
	j = self.skip_id(s,i)
	word = s[i:j]
	if word in self.keywords:
		self.body.tag_add("keyword", index(n,i), index(n,j))
	elif self.language == "php":
		if word in php_paren_keywords and match(s,j,"()"):
			self.body.tag_add("keyword", index(n,i), index(n,j+2))
			j += 2
i = j</t>
<t tx="T562">if self.language == "cweb":
	if match(s,i,"@(") or match(s,i,"@&lt;"):
		&lt;&lt; handle cweb ref or def &gt;&gt;
	else:
		word = self.getCwebWord(s,i)
		if word:
			&lt;&lt; Handle cweb control word &gt;&gt;
		else:
			i,state = self.doAtKeyword(s,i,n)
else:
	i,state = self.doAtKeyword(s,i,n)</t>
<t tx="T563"># Color and skip the word.
assert(self.language=="cweb")

j = i + len(word)
self.body.tag_add("keyword",index(n,i),index(n,j))
i = j

if word in ("@ ","@\t","@\n","@*","@**"):
	state = "doc"
elif word in ("@&lt;","@(","@c","@d","@f","@p"):
	state = "normal"
elif word in ("@^","@.","@:","@="): # Ended by "@&gt;"
	j = string.find(s,"@&gt;",i)
	if j &gt; -1:
		self.body.tag_add("cwebName", index(n,i), index(n,j))
		self.body.tag_add("nameBrackets", index(n,j), index(n,j+2))
		i = j + 2</t>
<t tx="T564">self.body.tag_add("nameBrackets", index(n,i), index(n,i+2))

# See if the line contains the right name bracket.
j = string.find(s,"@&gt;=",i+2)
k = choose(j==-1,2,3)
if j == -1:
	j = string.find(s,"@&gt;",i+2)

if j == -1:
	i += 2
else:
	self.body.tag_add("cwebName", index(n,i+2), index(n,j))
	self.body.tag_add("nameBrackets", index(n,j), index(n,j+k))
	i = j + k
</t>
<t tx="T565"># print "single-line comment n,i,s:",n,i,s

if self.language == "cweb" and self.latex_cweb_comments:
	j = i + len(self.single_comment_start)
	self.body.tag_add("comment", index(n,i), index(n,j))
	self.doLatexLine(s,j,len(s),n)
	i = len(s)
else:
	self.body.tag_add("comment", index(n,i), index(n,"end"))
i = len(s)</t>
<t tx="T566">k = len(self.block_comment_start)
self.body.tag_add("comment", index(n,i), index(n,i+k))
i += k ; state = "blockComment"</t>
<t tx="T567">self.body.tag_add("keyword", index(n,i), index(n,i+1))
i += 1 # Skip the %
self.doLatexLine(s,i,len(s),n)
i = len(s)</t>
<t tx="T568"></t>
<t tx="T569">if self.language=="cweb":
	self.body.tag_add("latexModeBackground", index(n,i), index(n,i+1))
else:
	self.body.tag_add("latexBackground", index(n,i), index(n,i+1))
i += 1</t>
<t tx="T570"></t>
<t tx="T571">if self.language == "python":
	j, state = self.skip_python_string(s,i)
	self.body.tag_add("string", index(n,i), index(n,j))
	i = j
else:
	j, state = self.skip_string(s,i)
	self.body.tag_add("string", index(n,i), index(n,j))
	i = j
</t>
<t tx="T572"># 10/17/02: recognize comments in preprocessor lines.
j = i
while i &lt; len(s):
	if match(s,i,self.single_comment_start) or match(s,i,self.block_comment_start):
		break
	else: i += 1

self.body.tag_add("pp", index(n,j), index(n,i))</t>
<t tx="T573">if match(s,i,"&lt;?php"):
	self.body.tag_add("keyword", index(n,i), index(n,i+5))
	i += 5
elif match(s,i,"?&gt;"):
	self.body.tag_add("keyword", index(n,i), index(n,i+2))
	i += 2
else:
	i += 1
</t>
<t tx="T574">if self.showInvisibles:
	self.body.tag_add("blank", index(n,i))
i += 1</t>
<t tx="T575">if self.showInvisibles:
	self.body.tag_add("tab", index(n,i))
i += 1</t>
<t tx="T576"># self.body.tag_add("normal", index(n,i))
i += 1</t>
<t tx="T577">def doNowebSecRef (self,s,i,n):

	self.body.tag_add("nameBrackets", index(n,i), index(n,i+2))
	
	# See if the line contains the right name bracket.
	j = string.find(s,self.rb+"=",i+2)
	k = choose(j==-1,2,3)
	if j == -1:
		j = string.find(s,self.rb,i+2)
	if j == -1:
		return i + 2
	else:
		searchName = self.body.get(index(n,i), index(n,j+k)) # includes brackets
		ref = findReference(searchName,self.v)
		if ref:
			self.body.tag_add("link", index(n,i+2), index(n,j))
			if self.use_hyperlinks:
				&lt;&lt; set the hyperlink &gt;&gt;
		elif k == 3: # a section definition
			self.body.tag_add("link", index(n,i+2), index(n,j))
		else:
			self.body.tag_add("name", index(n,i+2), index(n,j))
		self.body.tag_add("nameBrackets", index(n,j), index(n,j+k))
		return j + k</t>
<t tx="T578"># Set the bindings to vnode callbacks.
# Create the tag.
# Create the tag name.
tagName = "hyper" + `self.hyperCount`
self.hyperCount += 1
self.body.tag_delete(tagName)
self.body.tag_add(tagName, index(n,i+2), index(n,j))
ref.tagName = tagName
self.body.tag_bind(tagName,"&lt;Control-1&gt;",ref.OnHyperLinkControlClick)
self.body.tag_bind(tagName,"&lt;Any-Enter&gt;",ref.OnHyperLinkEnter)
self.body.tag_bind(tagName,"&lt;Any-Leave&gt;",ref.OnHyperLinkLeave)</t>
<t tx="T579">def removeAllTags (self):

	self.body.tag_delete(
		"blank","comment","cwebName","docPart","keyword","leoKeyword",
		"latexModeBackground","latexModeKeyword",
		"latexBackground","latexKeyword",
		"link","name","nameBrackets","pp","string","tab")
		
def removeTagsFromLine (self,n):
	
	for tag in self.tags:
		self.body.tag_remove(tag,index(n,0),index(n,"end"))</t>
<t tx="T580">def getPrefs (self):

	a = app() ; c = self.commands ; config = a.config
	
	if self.getOpenTag("&lt;preferences"):
		return

	while 1:
		if self.matchTag("allow_rich_text="):
			self.getDquote() ; self.getBool() ; self.getDquote() #ignored
		elif self.matchTag("tab_width="):
			self.getDquote() ; c.tab_width = self.getLong() ; self.getDquote()
		elif self.matchTag("page_width="):
			self.getDquote() ; c.page_width = self.getLong() ; self.getDquote()
		elif self.matchTag("tangle_bat="):
			self.getDquote() ; c.tangle_batch_flag = self.getBool() ; self.getDquote()
		elif self.matchTag("untangle_bat="):
			self.getDquote() ; c.untangle_batch_flag = self.getBool() ; self.getDquote()
		# New in version 0.10
		elif self.matchTag("output_doc_chunks="):
			self.getDquote() ; c.output_doc_flag = self.getBool() ; self.getDquote()
		elif self.matchTag("noweb_flag="):
			# New in version 0.19: Ignore this flag.
			self.getDquote() ; self.getBool() ; self.getDquote()
		elif self.matchTag("extended_noweb_flag="):
			# New in version 0.19: Ignore this flag.
			self.getDquote() ; self.getBool() ; self.getDquote()
		elif self.matchTag("defaultTargetLanguage="):
			# New in version 0.15
			self.getDquote()
			&lt;&lt; check for syntax coloring prefs &gt;&gt;
		elif self.matchTag("use_header_flag="):
			self.getDquote() ; c.use_header_flag = self.getBool() ; self.getDquote()
		else: break
	self.getTag("&gt;")
	while 1:
		if self.matchTag("&lt;defaultDirectory&gt;"):
			# New in version 0.16.
			c.tangle_directory = self.getEscapedString()
			self.getTag("&lt;/defaultDirectory&gt;")
			if not os.path.exists(c.tangle_directory):
				es("default tangle directory not found:" + c.tangle_directory)
		elif self.matchTag("&lt;TSyntaxMemo_options&gt;"):
			self.getEscapedString() # ignored
			self.getTag("&lt;/TSyntaxMemo_options&gt;")
		else: break
	self.getTag("&lt;/preferences&gt;")
	
	# Override .leo file's preferences if settings are in leoConfig.txt.
	if config.configsExist:
		config.setCommandsIvars(c)</t>
<t tx="T581">@ignore
@color
@language tcl/tk
@root "c:\prog\test\tcltktest.txt"

after # 'after' is a keyword
all # 'all' is not a keyword

&lt;&lt; stuff &gt;&gt;

# A comment
// Not a comment
"A string"
'A string'</t>
<t tx="T582">@ This is a tcl/tk doc part

This is code</t>
<t tx="T583">I would like to create a set of Tkinter callbacks that vary only in the bindings of a single argument. For example,  I would like to do:

for val in vals:
  b = Tk.Button(...,command=self.myCallback(val))

But this doesn't work: it executes callback, rather than returning the callback function with the second arg bound to val.

I also tried:

for val in vals:
 callback=lambda None:self.myCallback(x=val)
 b = Tk.Button(...,command=callback)

But that doesn't quite work either.  When the callback executes I get:
TypeError: &lt;lambda&gt;() takes exactly 1 argument (0 given)

Can someone explain how to do this?  Thanks.

-----

My suggestion:

    def makeCallback(self, val):
        def callback(self=self, val=val): return self.myCallback(val)
        return callback

and then:

    b = Tk.Button(..., command=self.makeCallback(val) )


You don't need the default-values trick in Python 2.2 -- so, if
that's what you're using, it would be better to use, instead:

    def makeCallback(self, val):
        def callback(): return self.myCallback(val)
        return callback

If you're insistent on using lambda (only sensible reason being that
you made a bet about lambda being used here), you _can_, e.g. in 2.2:

    def makeCallback(self, val):
        return lambda: self.myCallback(val)

but I think the nested-function approach is more readable.

&gt; This "extra" level of indirection is needed. The following does not
&gt; work:
&gt; 
&gt; for val in vals:
&gt;   callback=lambda: self.myCallback(val) # or (val=val)
&gt;    b = Tk.Button(..., command=callback)
&gt; 
&gt; All the callbacks get bound to a function with the last val in vals.  I
&gt; have no idea why.  Maybe you could explain?

Sure.  You need to "snapshot" the value of val at the moment you're
interested in it -- passing it as an argument is one way to do that.

In the for loop that you show, the use of val in:

for val in vals:
   callback=lambda: self.myCallback(val)

indicates the variable thus named in outer scope (or global scope),
and the relevant value is the one that said variable has _when
the lambda is later called_ -- by what time the loop has proceeded
to the end and val has stayed bound to the last value.

BTW, the for loop using:

   callback = lambda val=val: self.myCallback(val)

should work just fine -- now you're "snapshotting" again (passing
val as an argument, so the value that matters is here the one at
*function-definition* time, as in the "extra level of indirection"
case that I suggest, NOT the value at *function-call* time in the
outer or global scope).

I consider the use of makeCallback preferable for stylistic reasons,
although it does also have the desired snapshot effect -- the latter
could also be obtained in other ways.</t>
<t tx="T584">Martin Franklin &lt;mfranklin1@gatwick.westerngeco.slb.com&gt;

Create a callback class that uses the built in __call__ method

class Callback:
    def __init__(self, value):
        self.value=value

    def __call__(self):
        ## do somthing with self.value
        if callable(self.value):
            self.value()

## so the GUI build looks like
for val in vals:
    b = Tk.Button(...,command=self.Callback(val))
    b.pack...............

Example....

&gt;&gt;&gt; from Tkinter import *
&gt;&gt;&gt;
&gt;&gt;&gt; root=Tk()
&gt;&gt;&gt; class Callback:

...     def __init__(self, value):
...             self.value=value
...     def __call__(self):
...             try:
...                     self.value()
...             except:
...                     print 'Cannot call', self.value
...

&gt;&gt;&gt; b=Button(root, text='Press ME!', command=Callback(1))
&gt;&gt;&gt; b.pack()
&gt;&gt;&gt; Cannot call 1

Cannot call 1
Cannot call 1</t>
<t tx="T585">In general, everything you can do in Python is accessible through the C API.

	lines = block.split('\n');
 
&gt; That will be
 
	lines = PyObject_CallMethod(block, "split", "s", "\n");
</t>
<t tx="T586">What we want is a comment that is ignored by _both_ of cweb's tangle and weave commands.

The @q ... @&gt; code does just what you want. It is ignored by everything and is intended for comments that exist only in the .w file. So long as the whole sentinel comment fits on one line, we're golden. 

So using

@comment @q @&gt;

will work.</t>
<t tx="T587">To increase the size of environment space, add the following to config.sys:

shell=C:\windows\command\command.com /p:4096

Notes:

1. The path C:\windows\command\command.com may vary.  Check you system for the location of command.com.

2. This works for versions of Windows prior to Me.  On Me you set the registry somehow.  No information on XP.</t>
<t tx="T588">Bruce M. Bolden, bruceb@cs.uidaho.edu, is using Leo on MaxOS X.  Here is his description of how to get Leo working there:

I installed: 
- Latest OS X Developer tools
- latest (as of about two weeks ago) tk/tcl
         MacOSXTk8.4a4-2.tar.gz
- the machopython distribution
http://prdownloads.sourceforge.net/wxpython/MachoPython-2.2.1.dmg

For OS X 10.1, I followed the directions at:
    http://tony.lownds.com/macosx/tkinter.html

That worked fine for 10.1, but didn't work for 10.2.  It
took awhile to find a Python distribution that worked
correctly with tk/tcl.

I was just getting into Leo about a week before 10.2 was released and thought about---what if it breaks....  10.2 broke it, but I was able to find a solution as described above.

Thanks very much, Bruce, for this information.  I'll add it to the FAQ and the installation instructions.

Edward
</t>
<t tx="T589">By: ba-natureguy ( Tom Fetherston ) 
RE: How to run Leo with MacOS X   
2002-09-23 17:03 

I've been following Leo a while, but mostly as a lurker as my primary 
platform is Mac, with the relaese of Jaguar I thought I would give it 
another try.  I seemed to have meet good success, so I'm going to try and 
pass on the steps I took to get a working install of Leo under MacOs X 
10.2.1 .

First caveaut: this would be painful/impossible to do without a broadband 
connection!  I was lucky and got the major portion of this done at a Linux 
meeting where there was broadband access (and help for some of the unix 
stuff).

In broad strokes this is what we need to accomplish:

1)  install a working X11 window server
2)  install a window manager
3)  install python and tcltk

There are probablly several way to do this, I'm just going to give you the 
way that worked for me.

One and two are relatively easy to do, just go to these web pages and 
download the current binaries:

  xonx.sf.net
  oroboros.sf.net

You now have X Windows, the unix windowing system, available to run with a 
window manager that looks/acts well under OS X.  To start it up and try it 
out, just double click the oroboros app icon, it will start up the X11 
server for you (you can put this in the dock to make a handy shortcut).

Here is where it starts to get complicated.  We are going to use another 
project on sourceforge, "Fink", to download and install python and tcltk, 
plus a package that lets these apps know about, and run on the X11 stuff 
we have set-up.

"Fink" excels at making unix programs availabe and easily installable on a 
Mac, unfortunately, they are still catching up to the release of Jaguar and 
do not yet have a binary for download, so you have to have the developer 
tools installed and compile it yourself.  They have a link on how to do 
this on there front page:

  fink.sf.net

Some tips I found:

You are getting a lot of different source files from a lot of different 
places on the net, not all of which work/are good choices, you may have to 
play around with the offered download sites to get all the sources you need.

You have to use the terminal app to do a lot of the work, if you aren't a 
unix whiz, release that a lot of the stuff you are doing may require that 
you have superuser privledges, you can get these on a temporary basis by 
using the "sudo" command, just type:

  sudo &lt;command you want to execute as superuser&gt;

and you will be prompted for your password (at least the first time).

A simple editor to use to modify the config files is "pico"

Just cd your way to the right directory and type

  pico &lt;filename to edit&gt;

you may need to "sudo" that command to gain write access to the file.

Now that we have installed fink and updated its database of installable 
packages, we have to get the package that let's fink installed apps known 
about and use the the X11 and window manager that we installed manually.  
This has to be done from the latest CVS sources so it has to be gotten and 
compiled also.  Fortunately this is easy and short now that fink is 
installed.

The package we need is "system-xfree86", version 4.2-1 currently.  You 
need to type the following to download, compile and install the latest:

  fink install system-xfree86

Now all you need is install python and tcltk.  Having done enought compiling 
and and installing, I used the versions that are available pre-compiled.  
I used "sudo dselect", (dselect -- a fink command to start a menu driven 
front-end to getting, installing, removing packages), but the command line 
commands using apt-get might be easier:

  sudo apt-get update
  sudo apt-get install python
  sudo apt-get install tcltk

Now we should be done!


Now to try leo, start oroboros, type:
  python &lt;filepath to leo.py&gt;

The body font is way too small, but you can change that via the font dialog.

Tom
</t>
<t tx="T590">teknico ( Nicola Larosa ) 
 RE: Removing '\r' characters?   
2002-09-16 14:27  
&gt; I am plowing through old bug reports, and I found the following, from whom 
&gt; I don't know: 

That's from me, *again*. You are kindly advised to stop forgetting the attribution to all my bug reports. ;^) 

&gt;&gt; - Source files still have the dreaded \r in them. Why don't you switch 
&gt;&gt; to \n only, once and for all, and live happily ever after? ;^) 

&gt; I sure whould like to do that, and I'm not sure how to do this. All 
&gt; versions of the read code attempt to remove '\r' characters, and all 
&gt; versions of the write code write '\n' only for newlines. 

Sorry for being a bit vague, I was talking about the Leo source files themselves. I don't know what you use to edit them, ;^))) but in version 3.6 they still have \r\n as end-of-line. 

If Leo itself does not solve the problem, may I suggest the 
Tools/scripts/crlf.py script in the Python source distibution? It's nice and simple, and skips binary files, too. That's what I use every time I install a new version of Leo. :^) 
 
</t>
<t tx="T591">Under unix, python writes "\n" as "\n"; under windows, it writes it as "\r\n". The unix python interpreter ignores trailing "\r" in python source files. There are no such guarantees for other languages. Unix users should be able to get rid of the cosmetically detrimental "\r" either by running dos2unix on the offending files, or, if they're part of a .leo project, reading them into leo and writing them out again.  


By: edream ( Edward K. Ream ) 
 RE: Removing '\r' characters?   
2002-09-17 09:34  
Oh, I see. Thanks very much for this clarification. 

Just to make sure I understand you: the problem with '\r' characters is that: 

1. I am creating LeoPy.leo and LeoDocs.leo on Windows and 
2. People are then using these files on Linux. 

and the way to remove the '\r' characters: 

1. I could run dos2unix on all distributed files just before committing to CVS or making a final distribution or 
2. People could, say, do the following: 

Step 1: Read and Save the .leo files, thereby eliminating the '\r' in those files and 
Step 2: Use the Write @file nodes command on all derived files to clear the '\r' in those files. 

Do you agree so far? 

&gt; Under unix, python writes "\n" as "\n"; under windows, it writes it as "\r\n". 

I am going to see if there is any way to get Python to write a "raw" '\n' to a file. I think there must be. This would solve the problem once and for all. 

Thanks again for this most helpful comment. 

Edward</t>
<t tx="T592">In 2.3 you can open files with the "U" flag and get "universal newline"
support: 

% python
Python 2.3a0 (#86, Sep 4 2002, 21:13:00) 
[GCC 2.96 20000731 (Mandrake Linux 8.1 2.96-0.62mdk)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; f = open("crlf.txt")
&gt;&gt;&gt; line = f.readline()
&gt;&gt;&gt; line
'This is an example of what I have come to call the "cursed newline"
problem,\r\n'
&gt;&gt;&gt; f = open("crlf.txt", "rU")
&gt;&gt;&gt; line = f.readline()
&gt;&gt;&gt; line
'This is an example of what I have come to call the "cursed newline" problem,\n'

</t>
<t tx="T593">&gt; You can open the file in 'binary' mode (adding 'b' to the mode string) and
&gt; the file will contain '\r\n' on both platforms (and any other platforms.)

Nope. Exactly wrong. In 2.2 and those before, when files are opened in
*text* mode (no "b") then reading them will provide Unix-style line endings
(newline only). When you open files in binary mode then you see the bytes
stored in the file.

On Unix systems there's no difference in the contents of a file whether in
binary or text mode. On Windows a file is shorter by the number of carriage
returns. On the Mac I have no idea what they do. Probably just carriage
returns, to be different :-)

2.3 will be a bit more flexible about such mattrers.
</t>
<t tx="T594">import pychecker.checker from idle, then just import Leo.</t>
<t tx="T595">It is worth noting that NT, Win2K and XP all have an alternative which is
to add .PY to the PATHEXT environment variable. Then you can run any .PY
file directly just by typing the name of the script without the extension. 

e.g.
C:\&gt;set PATHEXT=.COM;.EXE;.BAT;.CMD

C:\&gt;set PATH=%PATH%;c:\python22\tools\Scripts

C:\&gt;google
'google' is not recognized as an internal or external command,
operable program or batch file.

C:\&gt;set PATHEXT=.COM;.EXE;.BAT;.CMD;.PY

C:\&gt;google
Usage: C:\python22\tools\Scripts\google.py querystring

C:\&gt;
</t>
<t tx="T596">&gt;&gt; It has a header of just one line. All the ugly stuff is at the end.
&gt;&gt;
&gt;&gt; -------------------------------------------------------------------
&gt;&gt; goto ="python"
&gt;&gt;
&gt;&gt; # Python code goes here
&gt;&gt;
&gt;&gt; ''' hybrid python/batch footer:
&gt;&gt; @:="python"
&gt;&gt; @python.exe %0 %1 %2 %3 %4 %5 %6 %7 %8 %9
&gt;&gt; @if errorlevel 9009 echo Python may be downloaded from
&gt;www.python.org/download
&gt;&gt; @rem '''
&gt;&gt; -------------------------------------------------------------------
&gt;&gt;
&gt;&gt;         Oren
&gt;&gt;
&gt;

It's for running python scripts on windows, without having to type:

[&lt;path to python&gt;\]python[.exe] &lt;scriptname&gt; [&lt;arguments&gt;*]

and almost takes the place of the "shabang" line at the top of *nix
scripts.

</t>
<t tx="T597">@ignore
@color

	# To get the current selection
	sel = c.body.tag_ranges("sel")
	if len(sel) == 2:
		start,end = sel # unpack tuple.

	def selection_clear(text):
		text.tag_remove(SEL, 1.0, END)

	def selection_from(text, index):
		text._anchor = index

	def selection_present(text):
		return len(text.tag_ranges(SEL)) != 0

	def selection_range(text, start, end):
		text.tag_remove(SEL, 1.0, start)
		text.tag_add(SEL, start, end)
		text.tag_remove(SEL, end, END)

	def selection_to(text, index):
		if text.compare(index, "&lt;", text._anchor):
			selection_range(text, index, text._anchor)
		else:
			selection_range(text, text._anchor, index)</t>
<t tx="T598">I'd like to start a thread to think more about what we can do to deal with LeoPy.leo
in CVS.

Motivation: after making my Unix EOL fixes, I though I'd get with the program
and create a new node under (Project Views)-&gt;Bugs, and collect under there clones
of all the nodes that I touched as part of the fix.  I managed to get my changes
to LeoPy.py into CVS by doing a cvs up immediately before starting the work,
and being lucky enough that noone made any updates before I finished.

But of course, Edward was working on something else at the time, and when he
went to check in, he got a conflict.  Because of the intractablility of resolving
LeoPy.leo conflicts, he had to blow away my changes to get his in - not the
changes to the .py files (all intact), but the additional "documentation" node
for the bug.

This points out clearly what the .leo file contains that the python files don't:
the structures outside the @file (and @root) nodes.  If we concede that the
LeoPy.leo file is intractable in the presence of conflicts, then to preserve
that information, there would have to be some external, more tractable source
for that structure.  I am not at all convinced that's feasible, but I'm going
to speculate in public to see where it leads me/us.

What would such a structure contain?  All of the headlines, certainly.  Used
in combination with the .py files to rebuild the .leo file, it will also have
to include all the bodies not incorporated into files.  Internally, it will
need a syntax to indicate the tree structure.  So far, we're just building the
entire .leo file over again.  But here's a difference that might make a
difference:

Currently nodes are named in the .leo file with numbers.  The nodes need names,
or else it would be impossible to refer to clones.  Those names are effectively
recreated on the fly when the .leo file gets written, so any addition of a new
node changes all the names of the nodes following it in the tree walk.  That's
the core problem, and indicates a possible solution: what if these names weren't
disposable?  Store this .leo node name along with the node.  New nodes would
be assigned new names (probably the next highest integer).  So, at the end of
this thought process, the proposal is not to add a file external to the .leo
file, but to preserve the node numbers contained in the .leo file.  My python
reference suggests that these integers take about 12 bytes to store; adding
them to each node in LeoPy.leo would add about 30k to the memory footprint

I haven't yet studied the code that reads the .leo file, so any insight or guidance
from those who have would be appreciated before I head further down this path.

    - Stephen</t>
<t tx="T599">leo.py reads and writes exactly like LeoCB</t>
<t tx="T600">Amazing.  I wrote some dummy code last night, read up on indices this morning, and got everything to work in a couple of hours. The result is very fast: no optimization is needed for Leo. I love Tkinter!

Added c.recolor and tree.recolor routines.  This hooks should be called whenever the body text changes.  Apparently there is no "OnTextChanged" event in Tk.</t>
<t tx="T601">This marked my complete frustration with wxLeo and wxPython, and the real beginning of the work on leo.py.</t>
<t tx="T602">I am totally in love with Python.  Everything is so much easier:  Automatic debugging, no declarations, no types, no compilation. Great data structures. Even without single stepping the debugging is easy.

All major aspects of c2py are now complete.</t>
<t tx="T603">I am not sure exactly when this happened.  The details apparently have been lost.  There was a time when I was experimenting with Python and wxPython, and a time when I was working on wxWindows version of Leo.</t>
<t tx="T604">Read and respond to this message at: 
http://sourceforge.net/forum/message.php?msg_id=1684478
By: ktenney

Promo idea;
Several people arguing about the correct answer to 'What is Leo'
A production coder talks about the efficiency advantages.

An academic talks about the increased understanding of the code via literate
concepts.

A documentation writer talks about the organizational benefits of outlines.

A hacker dood talks about how easy it is to write Python to make it do kewel
things.

A system administrator talks about a way to centralize access to config files,
and keep notes on them.

etc.
</t>
<t tx="T605">leoGlobals.py:879: No module attribute (clock) found
leoGlobals.py:882: No module attribute (clock) found
leoGlobals.py:883: No module attribute (clock) found
leoGlobals.py:1209: Local variable (start) not used
leoGlobals.py:1244: Local variable (start) not used
leoGlobals.py:1304: Local variable (i1) not used
leoGlobals.py:1466: Local variable (start_line) not used
leoGlobals.py:2199: Function (CheckVersion) has too many returns (16)
leoGlobals.py:2228: Raising string exceptions are deprecated (errMsg)
leoGlobals.py:2271: Raising string exceptions are deprecated
	(condition must be one of '&gt;=', '&gt;', '==', '!=', '&lt;', or '&lt;='.)
leoGlobals.py:2317: No module attribute (SyntaxError) found

leoConfig.py:97: No module attribute (leo_config_directory) found
leoConfig.py:489: No class attribute (languageNameDict) found
leoConfig.py:537: No class attribute (languageNameDict) found
leoConfig.py:538: No class attribute (languageNameDict) found
leoConfig.py:688: Catching string exceptions are deprecated (true)
leoConfig.py:688: No module attribute (IOError) found

leoFind.py:174: No global (box) found
leoFind.py:197: No class attribute (reverse_flag) found

leoApp.py:279: Object (d) has no attribute (testDialogs)

leoColor.py:1706: Local variable (config) not used

leoAtFile.py:907: Local variable (t1) not used
leoAtFile.py:1464: Local variable (config) not used
leoAtFile.py:1827: Local variable (nextline) not used
leoAtFile.py:2138: Local variable (k) not used
leoAtFile.py:2848: No module attribute (asctime) found
leoAtFile.py:2997: No module attribute (asctime) found
leoAtFile.py:3224: No global (implicitChildIndex) found

leoFileCommands.py:479: Catching a non-Exception object (BadLeoFile)
leoFileCommands.py:535: Catching a non-Exception object (BadLeoFile)
leoFileCommands.py:603: Local variable (s) not used

leoImport.py:378: Comparisons with false are not necessary and may not work as expected
leoImport.py:380: Comparisons with true are not necessary and may not work as expected
leoImport.py:1072: Local variable (c) not used
leoImport.py:2467: Comparisons with false are not necessary and may not work as expected
leoImport.py:2592: Local variable (i) not used

leoTangle.py:3035: Comparisons with true are not necessary and may not work as expected
leoTangle.py:3441: Function (is_sentinel_line_with_data) has too many returns (11)

leoCommands.py:338: Local variable (current) not used
leoCommands.py:338: Local variable (v) not used
leoCommands.py:633: Local variable (x) not used

leoCompare.py:76: Parameter (makeWhitespaceVisible) not used
leoCompare.py:429: No class attribute (makeWhitespaceVisible) found
leoCompare.py:734: Local variable (leoApp) not used
leoCompare.py:734: Local variable (leoCommands) not used
leoCompare.py:736: Local variable (cmp) not used

leoTree.py:907: Local variable (c) not used
leoTree.py:920: Local variable (id) not used

leoFrame.py:113: Comparisons with false are not necessary and may not work as expected
leoFrame.py:889: Comparisons with false are not necessary and may not work as expected
leoFrame.py:989: Local variable (frame) not used
leoFrame.py:1024: Comparisons with false are not necessary and may not work as expected
leoFrame.py:1139: Comparisons with false are not necessary and may not work as expected
leoFrame.py:1164: Local variable (v) not used
leoFrame.py:1293: Comparisons with false are not necessary and may not work as expected
leoFrame.py:1293: Comparisons with true are not necessary and may not work as expected
leoFrame.py:1449: Comparisons with false are not necessary and may not work as expected
leoFrame.py:1648: Comparisons with false are not necessary and may not work as expected
leoFrame.py:1648: Comparisons with true are not necessary and may not work as expected
leoFrame.py:2837: Local variable (c) not used
leoFrame.py:3357: Local variable (tree) not used</t>
<t tx="T606">@color</t>
<t tx="T607">c=leo.topCommand() # done, sort of

[c]=leo.getCommands() # done</t>
<t tx="T608"># Drawing utilities...
c.BeginUpdate() # also beginUpdate (done)
c.EndUpdate() # also endUpdate (done)
c.Repaint() # also repaint (done)
c.BringToFront() # also bringToFront (done)

# Getters...
v=c.currentVnode() # add (done)
v=c.rootVnode() # add (done)
b=c.isChanged()
s=c.fileName() # mFileName (done)

# Setters...
c.bringToFront()
c.clearAllVisited()
c.editVnode(v)
c.endEditing(v)
c.makeVisible(v)
c.selectVnode(v)
c.synchVnode()  # No longer used.</t>
<t tx="T609"># File menu commands
c.new(windowName)
b=c.open(fileName)
c.close()
b=c.save(fileName)
b=c.saveAs(fileName)
b=c.saveACopyAs(fileName)
c.revert(windowName)

c.tangle()
c.tangleAll()
c.tangleMarked()

c.untangle()
c.untangleAll()
c.untangleMarked()

c.flattenOutline( [fileNames] )
c.cwebToOutline( [fileNames] )
c.importFiles( [fileNames] )
c.importMoreText( [fileNames] )
c.exportMoreText()

# Edit menu commands
c.cut
c.copy
c.paste
c.delete
c.selectAll

c.editCurrentHeadline()
c.extract()
c.extractSection()
c.extractSectionNames()
c.convertBlanks()

# Outline menu commands
c.cutOutline()
c.copyOutline()
c.pasteOutline()
c.deleteHeadline()
c.insertHeadline()
c.clone()

c.contractSubheads()
c.contractAllSubheads()
c.contractAllHeadlines()

c.expandAllHeadlines()
c.expandAllSubheads()
c.expandSubheads()

c.expandLevel1()
c.expandLevel2()
c.expandLevel3()
c.expandLevel4()
c.expandLevel5()
c.expandLevel6()
c.expandLevel7()
c.expandLevel8()
c.expandLevel9()
c.expandNextLevel()

c.moveOutlineLeft()
c.moveOutlineRight()
c.moveOutlineUp()
c.moveOutlineDown()

c.promote()
c.demote()

c.selectThreadBack()
c.selectThreadNext()
c.selectVisBack()
c.selectVisNext()

c.markHeadline()
c.markSubheads()
c.markChangedHeadlines()
c.markChangedRoots()
c.unmarkAll()

c.goToNextDirtyHeadline()
c.goToNextMarkedHeadline()

# Window menu commands
c.equalSizedPanes()</t>
<t tx="T610"># Menu enablers
b=c.canContractAllHeadlines()
b=c.canContractAllSubheads()
b=c.canContractSubheads()
b=c.canCutOutline()
b=c.canDeleteHeadline()
b=c.canDemote()
b=c.canExpandAllHeadlines()
b=c.canExpandAllSubheads()
b=c.canExpandSubheads()
b=c.canExtractSection()
b=c.canExtractSectionNames()
b=c.canGoToNextDirtyHeadline ()
b=c.canGoToNextMarkedHeadline()
b=c.canMarkChangedHeadlines()
b=c.canMarkChangedRoots()
b=c.canMoveOutlineDown()
# Note: the docs do not indicate that these are commands methods (c. omitted)

b=c.canMoveOutlineLeft()
b=c.canMoveOutlineRight()
b=c.canMoveOutlineUp()
b=c.canPasteOutline()
b=c.canPromote()
b=c.canRevert()
b=c.canSelectVisBack()
b=c.canSelectVisNext()
b=c.canSelectThreadBack()
b=c.canSelectThreadNext()
b=c.canSelectToEnd()
b=c.canSelectToStart()
b=c.canShiftBodyLeft()
b=c.canShiftBodyRight()
b=c.canUndo()
b=c.canUnmarkAll()</t>
<t tx="T611"># Getters...
p = leo.getPrefs() # returns instance of the Prefs class
b=p.defaultTangleDirectory()
b=p.doLeoDoneBat()
b=p.doLeoUnBat()
s=p.logWindowString() # returns contents of log window
n=p.pageWidth()
b=p.tangleOutputsHeaderLine()
b=p.tangleOutputsDocChunks()

# Setters...
p.setDefaultTangleDirectory(s)
p.setDoLeoDoneBat(b)
p.setDoLeoUnBat(b)
p.setPageWidth(n)
p.setTangleOutputsHeaderLine(b)
p.setTangleOutputsDocChunks(b)
</t>
<t tx="T612"># Getters...

v=v.next() # mNext (done)
v=v.back() # mBack (done)
v=v.parent()  # mParent (done)
v=v.firstChild() # mFirstChild (done)
s=v.headString() # mHeadString (done)
v=v.findRoot() # (done)
s=v.bodyString() # add: return v.t.bodystring (done)

v=v.currentVnode()
v=v.lastChild()
v=v.lastNode()
v=v.nodeAfterTree()
v=v.nthChild(n)
v=v.threadBack()
v=v.threadNext()
v=v.visBack()
v=v.visNext()
n=v.childIndex()
n=v.numberOfChildren()
n=v.level()
b=v.hasChildren()
b=v.isAncestorOf(v2)
b=v.isCloned()
b=v.isDirty()
b=v.isExpanded()
b=v.isMarked()
b=v.isVisible()
b=v.isVisited()

s=v.convertTreeToString() # not ready yet
s=v.moreBody() # not ready yet
s=v.moreHead(n) # not ready yet

# Setters...
v.setBodyTextOrPane(s) # add (done)
v.setHeadStringOrHeadline(s)
v.setIcon() # add for compatibility (done)
v.trimTrailingLines() # not ready yet

v.moveAfter(v2)
v.moveToNthChildOf(v2,n)  
v.moveToRoot()

v.clearVisited()
v.setVisited()
</t>
<t tx="T613">More on the issues involved in munging PHP with Leo.

By its nature, PHP is a difficult language for toolsmiths to accommodate, especially
with its 'dual-mode' nature (ability to switch between 'HTML mode' and 'code
mode' with the '&lt;?php' and '?&gt;' construct.

I've succeeded in absorbing a PHP project into Leo, but only with the following
constraints:

* All PHP files start with '&lt;?php' and end with '?&gt;' - ie they are predominantly
in 'code mode'

* No '&lt;?php' or '?&gt;' statements occur at the start of a line, except at beginning
and end of file

* No '#' comments - only '//' and '/* ... */'

If all PHP files obey these constraints, they can be handled in Leo.

But there's another issue - when Leo generates the PHP files (as with any other
files), it places comments before the leading '&lt;?php' and after the trailing
one.

Since it's oblivious to PHP's 'dual modes', something has to be done.

So I took a really neanderthal step - I manipulate the code within Leo files
and, after tangling/saving, I run a Perl script which copies the entire PHP
tree, stripping all of Leo's comments from the PHP files along the way, and
guaranteeing that the PHP files start with '&lt;?php' (no blank leading lines),
and end with '?&gt;' (no blank trailing lines).

Headers are written to the converted PHP files, warning people not to edit these
files, but rather, edit them in Leo.

I offer the Perl script below. Convention used is that the 'original' code is
in a tree called 'leo', containing a file 'project.leo'.

The perl script creates a tree called 'html', identical to tree 'leo', except
that leo's markups are removed from the PHP files.

Above tree 'leo' is the perl script 'publish.pl', reproduced here (please excuse
my naive perl coding):

#!/usr/bin/perl

system("cp -rp leo/* html");
unlink("html/project.leo*");
@files = split /\n/, `cd leo &amp;&amp; find .|grep -v \.leo\$`;
foreach $f (@files)
  {
    $f =~ s/^\.\///;
    if (grep(/\.php/,$f))
      {
#print "File: $f\n";
open(FILEIN, "leo/$f") || die("Failed to open input file leo/$f\n");
open(FILEOUT, "&gt;html/$f") || die("Failed to open output file html/$f\n");
print FILEOUT "&lt;?php\n\n";
print FILEOUT "// DO NOT EDIT THIS FILE - IT HAS BEEN GENERATED BY publish.pl
FROM THE LEO PROJECT TREE\n";
print FILEOUT "//\n// EDIT THE SOURCE CODE WITH 'leo' instead\n\n";
@infile = &lt;FILEIN&gt;;
close(FILEIN);
foreach $line (@infile)
  {
    #print "File: $f: $line";
    if (!grep(/^\#\@/, $line) &amp;&amp; !grep(/^&lt;\?php/, $line) &amp;&amp; !grep(/^\?&gt;/,
$line))
      {
print FILEOUT $line;
      }
    else
      {
#print "$file: suppressed $line";
      }
  }
print FILEOUT "?&gt;\n";
close(FILEOUT);
      }
  }

</t>
<t tx="T614">We definitely need a @last directive to handle php.  I know this is in the TODO
list, but its at the end of the list and I'm hoping that it can be done sooner
rather than later.

I tried adding PHP support to the code (mainly preferences and keywords).  It
all works great, except for the trailing comments in the files output from
tangle.

As has been noted, in most PHP files the very first line must be 

&lt;?php

Good enough;  the @first directive manages this splendly.

However, the PHP files must also _end_ with

?&gt;

and nothing else must follow except whitespace.  Why? because everything after
the ?&gt; is appended to the HTTP response, which can end up screwing up a cookie
negotiation  and may show up in the displayed browser window.

It would be really really really nice to provide good PHP support;  PHP being
one of the most popular methods for generating dynamic web content.  I must
say, the keywording colorization looks great;  it would be nice to add it. 
But we really need a @last directive in order to provide integrated support
for PHP.

Unfortunately, I don't think I have enough of an understainding of the Leo internals
to add the @last directive..  But I will work at it if noone else is going to
do this over the next couple weeks.  If you are going to work on this, or already
are, please let me know.

If someone can tackle "@last", I might be able to tackle some explicit import
functionality for PHP files.

</t>
<t tx="T615">Read and respond to this message at: 
http://sourceforge.net/forum/message.php?msg_id=1673863
By: dthein

Code is posted ... all the .py files anyway.  If you want test examples for
importing, try the code posted on the website I gave  (wiki.php is the simplest
and resonse.php is the most complex).  And you can add some extraneous text
before the &lt;?php or after the closing ?&gt; to see what happens when importing
mixed HTML/PHP.

Note that I tried to see what would happen if I had the LeoPy.leo file that
is in CVS (version 1.95) and the 7 (count 'em :-) updated .py files.

When I opened the v1.95 LeoPy.leo, I got a lot of log messages complaining about
unreferenced nodes and not being able to properly establish clones and so forth
.. from leoImport.py and leoUtils.py.  It made me want to also checkin my local
copy of LeoPy.py that I used to make the code changes -- but I didn't.  All
the nodes I created seemed to be there, despite the warnings.   Even so, let
me know if you want the LeoPy.leo file checked in as well.

PS: By the way, some of the keyword strings are not getting highlighted -- because
they don't use standard variable naming characters (e.g. "array()" is considered
a keyword, not a function call).  We might think about what to do about that.
</t>
<t tx="T616">@ignore</t>
<t tx="T617">@silent</t>
<t tx="T618">@root c:\prog\test\newlineTest.txt

&lt;&lt; section &gt;&gt;

&lt;&lt; section &gt;&gt;=
abc
&lt;&lt; section &gt;&gt;=
xyz</t>
<t tx="T619">By: btheado ( Brian Theado ) 

Text widget undo   
2002-11-02 13:38

&gt;At present, Leo simply stores _all_ present text in the next undo "bead", so there is a huge amount of redundant text in the collection of beads. Another way... 

If you do decide to change your undo approach, there are two text widget undo alternatives already available. First, the text widget in Tcl/Tk 8.4 comes with undo capabilities builtin.

If you are unable to upgrade to 8.4, then there is a pure Tcl solution that has been around for a while called supertext. Links to more information about both of these can be found at http://wiki.tcl.tk/supertext.</t>
<t tx="T620">@ignore
@language python
@color</t>
<t tx="T621"># Apparently the value returned from this routine is ignored.

def onKillLeoEvent (event=None):
	
	print "onKillLeoEvent"
	import leoDialog
	d = leoDialog.leoDialog()
	answer = d.askYesNo("Save Before Shutdown?", "Save files before shutting down")
	if answer == "yes":
		print "0"
		return 0
	else:
		print "1"
		return 1</t>
<t tx="T622">@ignore
@nocolor
</t>
<t tx="T623">@nocolor</t>
<t tx="T624">Correction of my last statement: plain Python does NOT give an error message, only Idle does. Plain Python does print characters like these, although what I end up seeing on the Windows2000 command line has little to do with the symbols in the original string - which probably means that Windows uses a different code page, than UTF-8 

This raises the question if this UnicodeError is perhaps a Tcl/Tk bug? 

--

Many thanks for this report. I'm pretty sure this means that the bug is in Leo--a communication problem between Leo and Tk. Very unlikely to be a Tk bug. 

There is code in the Python cookbook to determine the likely encoding of a unicode string. It may be that this will allow Leo to do a better job of handling what it gets from Tk.</t>
<t tx="T625">By: korakot ( Korakot Chaovavanich ) 
 RE: Control-drag now clones dragged node   
2002-11-27 11:04  
After I try it for some time. I modify the behavior to be more like 
windows explorer. That is, it determine wether to move or copy 
at the time of 'mouseup' if the Ctrl is press or not. The current 
implementation is doing it at 'mousedown' event. 

So, in tree.OnEndDrag 
I change from if self.controlDrag: 
to if c.frame.controlKeyIsDown: 
I guess that self.cloneDrag may even not be necessary since 
we don't need to keep the state.  
</t>
<t tx="T626">What I'd like to be able to do is right-click on the header, then select a command from the menu that adds a prefix "&lt;&lt; " and suffix " &gt;&gt;" to the header, and a command that removes the "&lt;&lt; " and " &gt;&gt;" if they exist. 

However, it seems silly to have two commands: make-named-section, make-unamed-section (or whatever you'd call them). 

It seems easier to have a single command that "toggles" the angle brackets so that: 

..a) if the headline already is bracketed (named) then the &lt;&lt; &gt;&gt; are removed, or 

..b) if the headline is not bracketed (unnamed) then the &lt;&lt; &gt;&gt; are inserted. 

PS: Besides automating a frequent excercise, it would also help make a consistent style (that is always use "&lt;&lt; " (with whitespace) rather than just "&lt;&lt;" (without whitespace).  

</t>
<t tx="T627">Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1766903
By: jmgilligan

It would be nice to be able to set the colors used in "show invisibles" (blanks
and tabs) from the color dialog and leoConfig.txt.
</t>
<t tx="T628">import leoImport 
dir = "directory from which you want to import" 
leoImport.importFiles(dir, ".java") 


Damn that's nice :-)

Yes it should be a menu item.

It might be very useful to have the option to include files from a list. For
example one could point it at an external text file called 'leolist.txt'

c:\rebol\view\downloads\
e:\leo\newideas.txt
d:\outlines\latestnotes\

and it would just pass all those in as if they were part of dir in the above
script.

Other options I though would be really handy: 
1. Use an existing node as a source also
2. Use an node from another Leo file.. I am not sure what the syntax for that
would be exactly
3. From a URL.. this would be really cool
People could post outlines not oinly as existing Leo xml files, but as text
files or even dynamic scripts. The code to handle these would presumably need
to deal with http:// intelligently. But that's easy in Python. Rebol is great
at that too.

4. Other XML file with valid filepaths in them.
That's probably a much bigger project like Leo 3.10  

thanks
/Jason
</t>
<t tx="T629">Create temp root.
Demote.
Sort siblings.
Promote.</t>
<t tx="T630">topCommand -&gt; top</t>
<t tx="T631">Say somewhere the colorizer will colorize directives even if they are invalid in a particular context.
</t>
<t tx="T632">@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1772276
By: korakot

Dear all Leo users,

I have just try modifying leo with 'customizeLeo.py' to add a feature
that I want. It is about 'annotation'.

Since I met leo, I started to store all my text data in a single leo file.
This include diary, work-log, articles that I read, interesting websites
and addressbook. So far, everything work fine. The problem is that
sometimes I get word files, excel files, powerpoint files, graphics, etc.
I could not directly handle them now easily with leo, so everything
would be assessible easily from a single place.

My first try is to create a folder. And say in my diary/work-log that
I got a new file like 'courses.doc' and I put everything I got in that
folder. When they accumulate, it become difficult to handle them
just from that folder. I would prefer to handle them through leo.

Last week, after Edward release the code that allow 'hook' and
'customizeLeo.py'. I know I could have my second try to solve it.
So this is it, '@folder' node.  If a node is named '@folder path_to_folder',
the content (filenames) of the folder and the children of that node
will be sync. Whenever a new file is put there, a new node will appear
on top of the children list (with mark). So that I can put my description
(ie. annotation) as the content of that node. In this way, I can find
any files much easier from leo.

Moreover, I add another feature to allow you to group files(in leo) into
children of another group. This will help when there are many files in
that folder. You can logically group it in leo (or even clone it to many
groups), while keep every files in a flat/single directory on your computer.

To use the code. You must enable 'customizeLeo.py' as instructed in
http://sourceforge.net/forum/forum.php?thread_id=770866&amp;forum_id=10226
and then add the following lines to 'customizeLeo.py'. I assume you
know how customizeLeo.py work and how defining a function in python work.

@color

# add this to def customizeLeo(tag,keywords):
if tag == 'select1':
	v = keywords.get("new_v")
	h = v.headString()
	if match_word(h,0,"@folder"):
		sync_node_to_folder(v, h[8:])

def sync_node_to_folder(parent,d):

	oldlist = {}
	newlist = []
	#get children info
	v = parent
	after_v = parent.nodeAfterTree()
	while v != after_v:
		if not v.hasChildren():
			oldlist[v.headString()] = v.bodyString()
		v = v.threadNext()
	#compare folder content to children
	for name in os.listdir(d):
		if name in oldlist:
			del oldlist[name]
		else:
			newlist.append(name)
	#insert newlist
	newlist.sort()
	newlist.reverse()
	for name in newlist:
		v = parent.insertAsNthChild(0)
		v.setHeadStringOrHeadline(name)
		v.setMarked()
	#warn for orphan oldlist
	if len(oldlist)&gt;0:
		es('missing: '+','.join(oldlist.keys()))
</t>
<t tx="T633">@ 

- trace2 for explicit tags.
- use *args for unlimited args in trace and es.
- convert non-string args to strings in trace, trace2 and es.
</t>
<t tx="T634">replace string.x(s...) by s.x(...)</t>
<t tx="T635">- replace atFile constants with strings.</t>
<t tx="T636">By: derwisch ( Johannes HÃ¼sing ) 
 Cloning somewhere else   
2002-11-22 12:41  
Hi there, 

is there any method to have a clone somewhere very distant from the original node, other than having to hold the Ctrl+U(D) keys after cloning and wait till it is at the desired position? 

Similar to Copy&amp;Paste but with the recognition of the clone's cloneness? 


Johannes  </t>
<t tx="T637">Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1759009
By: davidmcnab

Hi,

I know I've put this one before, but as I use Leo more and more, the lack of
this is really pressing.

I tried your previous suggestion - opening another editor to have a view of
the file, but this is really painful, especially when I'm wanting to work on
two or more files simultaneously.

I've tried having files open in Emacs and writing them out, then doing a 'read
@file nodes', but this doesn't always work - the changes made in Emacs aren't
getting incorporated into the Leo tree (unless I quit/restart Leo).

(BTW - I'm using latest CVS of Leo).

What would make for Total Hacking Heaven is the ability to split a body pane
vertically or horizontally, and to be able to split the sub-panes
vertically/horizontally.

What that, hotkeys would move the cursor between panes (ie make different panes
'active'). Also, clicking on a node would display that node in the *currently
active* body pane.

This in place, as well as an accurage 'goto line number' feature would make
Leo even more of a killer app.

Cheers
David

</t>
<t tx="T638">Add unicode utility routines

Add charrefs to Unicode handling</t>
<t tx="T639">Specifies encoding of particular derived files.

Is this kind of mixed encoding possible in XML?
Would it be wise?</t>
<t tx="T640">By: riotnrrrd

My setup: Linux, Python 2.2, Leo 3.6

The problem: All the accented characters that I enter via keyboard to the body
text, are saved in the .leo file and derived files as weird combinations (a
umlaut for example appears as a combination of A tilde and currency symbol)

However, when the accented characters are entered some other way, like importing,
untangling, or cutting and pasting from other application, or editing the .leo
file directly, they appear in the body text window normally and are saved in
leo file and derived files as themselves.

The workaround is to always edit everything that has accented caracters in external
editor (which is often since my native language has lots of umlauts), and then
import or untangle it, but this is often a nuicance since Leo's own editing
functionality usually would be sufficient.

The encoding setting in leoConfig.txt doesn't seem to affect this behaviour.</t>
<t tx="T641">By: dmitryazh

I created a section with a name in Russian and a reference to it. As a result
Leo gives me an error (traceback) and crashes sometimes while trying to select
referencing node.

I discovered that it may be concerned with the vnode.mHeadString, which is not
a unicode string (not always, at least), but utf-8-encoded (in my case).

WBR,
Dmitry
</t>
<t tx="T642">LeoDocs.leo file contain characters that are not in the UTF-8 encoding. 

The real encoding output by this program is ISO-Latin-1, I changed the encoding in the file manually and it works just fine. So, a real full fledged xml parser can't process the leo files until this is changed. 
</t>
<t tx="T643">Do the following: 

1. Set the file encoding in the config file to ISO-8859-1. 

2. Create a new document. 

3. Enter a single Ã¤ into the body pane, save and close the document. 

3b. If we open the leo file now, we see the Ã¤ ISO-8859-1 encoded, all well and good. 

4. Open the document again, enter a new Ã¤ next to the previous one. 

5. Save the leo document again. 

If we noww open the leo file with a text editor we see that the first Ã¤ is still ISO-8859-1 encoded, while the second one is UTF-8 encoded. The file has become a strange mix of ISO-8859-1 and UTF-8. 

I ran into this problem while using leo to create ISO-8859-1 encoded html files with international characters. </t>
<t tx="T644">By: riotnrrrd ( Timo Honkasalo ) 
 RE: internationalization   
2002-10-03 17:25  
I just tried the latest CVS version (on my Linux box) and the problem doesn't seem to have gone anywhere, but as earlier [1], non-ascii characters work fine when cut and pasted from another application. 

There's another glitch though: when opening files created with 3.6, and clicking to a node that includes non-ascii characters, the body text window appears empty and I get the following traceback: 

Traceback (most recent call last): 
File "./leoTree.py", line 1368, in select 
d = s.decode("utf-8") # result is unicode. 
UnicodeError: UTF-8 decoding error: invalid data 

 
</t>
<t tx="T645">@ignore

@ to do:

- add new @cwebmode directives??</t>
<t tx="T646">@nocolor

Your tests confirm the bug: 

Roundtripping to/from leo seems to work fine, but the sentinels are illegal cweb control sequences. Cweb fails with errors: "Control codes are forbidden in control text." when I try to cweave/ctangle the .w file. 

When CWeave and CTangle parse the sentinel, they read (putting tokens in curly braces): 

{@q} {@@} {@c} olor {@&gt;} 

@c looks to cweb like a control code, and hence produces an error when weaving or tangling. 

To make the sentinel legal for cweave or ctangle, there can only be sequences of even numbers of @ signs in the @q ... @&gt; control sequence: 

Legal: 
@qcolor@&gt; 
@q@@color@&gt; 
@q@@@@color@&gt; 
etc. 

Illegal: 
@q@color@&gt; 
@q@@@color@&gt; 
etc. 
</t>
<t tx="T647">@ In cweb mode must double all @ signs in all directives, so putSentinel is the place to do this.</t>
<t tx="T648"># This method outputs s, a directive or reference, in a sentinel.

def putDirective(self,s,i):

	tag = "@delims"
	assert(i &lt; len(s) and s[i] == '@')
	k = i
	j = skip_to_end_of_line(s,i)
	directive = s[i:j]

	if match_word(s,k,tag):
		&lt;&lt; handle @delims &gt;&gt;
	else:
		self.putSentinel("@" + directive)

	i = skip_line(s,k)
	return i</t>
<t tx="T649"># Put a space to protect the last delim.
self.putSentinel(directive + " ") # 10/23/02: put @delims, not @@delims

# Skip the keyword and whitespace.
j = i = skip_ws(s,k+len(tag))

# Get the first delim.
while i &lt; len(s) and not is_ws(s[i]) and not is_nl(s,i):
	i += 1
if j &lt; i:
	self.startSentinelComment = s[j:i]
	# Get the optional second delim.
	j = i = skip_ws(s,i)
	while i &lt; len(s) and not is_ws(s[i]) and not is_nl(s,i):
		i += 1
	self.endSentinelComment = choose(j&lt;i, s[j:i], "")
else:
	self.writeError("Bad @delims directive")</t>
<t tx="T650">@ All sentinels are eventually output by this method.

Sentinels include both the preceding and following newlines. This rule greatly simplies the code and has several important benefits:

1. Callers never have to generate newlines before or after sentinels.  Similarly, routines that expand code and doc parts never have to add "extra" newlines.
2. There is no need for a "no-newline" directive.  If text follows a section reference, it will appear just after the newline that ends sentinel at the end of the expansion of the reference.  If no significant text follows a reference, there will be two newlines following the ending sentinel.

The only exception is that no newline is required before the opening "leo" sentinel. The putLeoSentinel and isLeoSentinel routines handle this minor exception.
@c
def putSentinel(self,s):
	
	if not self.sentinels: return # Handle @nosentinelsfile.

	self.newline_pending = false # discard any pending newline.
	self.onl() ; self.putIndent(self.indent) # Start of sentinel.
	self.os(self.startSentinelComment)

	# 11/1/02: The cweb hack: if the opening comment delim ends in '@',
	# double all '@' signs except the first, which is "doubled" by the
	# trailing '@' in the opening comment delimiter.
	start = self.startSentinelComment
	if start and len(start) &gt; 0 and start[-1] == '@':
		assert(s and len(s)&gt;0 and s[0]=='@')
		s = string.replace(s,'@','@@')[1:]

	self.os(s)
	self.os(self.endSentinelComment)
	if self.suppress_newlines:
		self.newline_pending = true # Schedule a newline.
	else:
		self.onl() # End of sentinel.</t>
<t tx="T651">def skipSentinelStart(self,s,i):

	start = self.startSentinelComment
	assert(start and len(start)&gt;0)

	if is_nl(s,i): i = skip_nl(s,i)
	i = skip_ws(s,i)
	assert(match(s,i,start))
	i += len(start)
	# 7/8/02: Support for REM hack
	i = skip_ws(s,i)
	assert(i &lt; len(s) and s[i] == '@')
	return i + 1
</t>
<t tx="T652">@ This method tells what kind of sentinel appears in line s.  Typically s will be an empty line before the actual sentinel, but it is also valid for s to be an actual sentinel line.

Returns (kind, s, emptyFlag), where emptyFlag is true if kind == noSentinel and s was an empty line on entry.
@c

sentinelDict = {
	"@comment" : startComment, # 10/16/02
	"@delims" : startDelims, # 10/26/02
	"@newline" : startNewline,
	"@nonewline" : startNoNewline,
	"@verbatim": startVerbatim,
	"@verbatimAfterRef": startVerbatimAfterRef,
	"@+at": startAt, "@-at": endAt,
	"@+body": startBody, "@-body": endBody,
	"@+doc": startDoc, "@-doc": endDoc,
	"@+leo": startLeo, "@-leo": endLeo,
	"@+node": startNode, "@-node": endNode,
	"@+others": startOthers, "@-others": endOthers }

def sentinelKind(self,s):

	i = skip_ws(s,0)
	if match(s,i,self.startSentinelComment): 
		i += len(self.startSentinelComment)
	else:
		return atFile.noSentinel

	# 10/30/02: locally undo cweb hack here
	start = self.startSentinelComment
	if start and len(start) &gt; 0 and start[-1] == '@':
		s = s[:i] + string.replace(s[i:],'@@','@')

	# Do not skip whitespace here!
	if match(s,i,"@&lt;&lt;"): return atFile.startRef
	if match(s,i,"@@"): return atFile.startDirective
	if not match(s,i,'@'): return atFile.noSentinel
	j = i # start of lookup
	i += 1 # skip the at sign.
	if match(s,i,'+') or match(s,i,'-'):
		i += 1
	i = skip_c_id(s,i)
	# trace(`s[j:i]`)
	key = s[j:i]
	if len(key) &gt; 0 and atFile.sentinelDict.has_key(key):
		return atFile.sentinelDict[key]
	else:
		return atFile.noSentinel</t>
<t tx="T653">def nodeSentinelText(self,v):

	config = app().config

	if config.write_clone_indices:
		cloneIndex = v.t.cloneIndex
		clone_s = choose(cloneIndex &gt; 0, "C=" + `cloneIndex`, "")
	else: clone_s = ""
	
	if v == self.root or not v.parent():
		node_s = '0'
	else:
		index = v.childIndex() + 1
		if 0: # config.use_relative_node_indices and self.defaultIndex == index:
			node_s = ""
		else:
			# Use absolute node indices.
			node_s = str(index)

	return node_s + ':' + clone_s + ':' +  v.headString()</t>
<t tx="T654"># Set headline to the rest of the line.
if len(self.endSentinelComment) == 0:
	headline = string.strip(s[i:-1])
else:
	# 10/24/02: search from the right, not the left.
	k = string.rfind(s,self.endSentinelComment,i)
	headline = string.strip(s[i:k]) # works if k == -1
	
# 10/23/02: The cweb hack: undouble @ signs if the opening comment delim ends in '@'.
if self.startSentinelComment[-1:] == '@':
	headline = string.replace(headline,'@@','@')

# Set reference if it exists.
i = skip_ws(s,i)

if 0: # no longer used
	if match(s,i,"&lt;&lt;"):
		k = string.find(s,"&gt;&gt;",i)
		if k != -1: ref = s[i:k+2]</t>
<t tx="T655">@ The sentinel contains an @ followed by a section name in angle brackets.  This code is different from the code for the @@ sentinel: the expansion of the reference does not include a trailing newline.
@c

assert(match(s,i,"&lt;&lt;"))

if len(self.endSentinelComment) == 0:
	line = s[i:-1] # No trailing newline
else:
	k = string.find(s,self.endSentinelComment,i)
	line = s[i:k] # No trailing newline, whatever k is.
		
# 10/30/02: undo cweb hack here
start = self.startSentinelComment
if start and len(start) &gt; 0 and start[-1] == '@':
	line = string.replace(line,'@@','@')

out.append(line)</t>
<t tx="T656"># The first '@' has already been eaten.
assert(match(s,i,"@"))

if match_word(s,i,"@raw"):
	self.raw = true
elif match_word(s,i,"@end_raw"):
	self.raw = false

e = self.endSentinelComment
s2 = s[i:]
if len(e) &gt; 0:
	k = string.rfind(s,e,i)
	if k != -1:
		s2 = s[i:k] + '\n'
	
start = self.startSentinelComment
if start and len(start) &gt; 0 and start[-1] == '@':
	s2 = string.replace(s2,'@@','@')
out.append(s2)
# trace(`s2`)</t>
<t tx="T657"># Returns the kind of at-directive or noDirective.

def directiveKind(self,s,i):

	n = len(s)
	if i &gt;= n or s[i] != '@':
		return atFile.noDirective

	table = (
		("@c",atFile.cDirective),
		("@code",atFile.codeDirective),
		("@doc",atFile.docDirective),
		("@end_raw",atFile.endRawDirective),
		("@others",atFile.othersDirective),
		("@raw",atFile.rawDirective))

	# This code rarely gets executed, so simple code suffices.
	if i+1 &gt;= n or match(s,i,"@ ") or match(s,i,"@\t") or match(s,i,"@\n"):
		# 10/25/02: @space is not recognized in cweb mode.
		# 11/15/02: Noweb doc parts are _never_ scanned in cweb mode.
		return choose(self.language=="cweb",
			atFile.noDirective,atFile.atDirective)

	# 10/28/02: @c and @(nonalpha) are not recognized in cweb mode.
	# We treat @(nonalpha) separately because @ is in the colorizer table.
	if self.language=="cweb" and (
		match_word(s,i,"@c") or
		i+1&gt;= n or s[i+1] not in string.letters):
		return atFile.noDirective

	for name,directive in table:
		if match_word(s,i,name):
			return directive
	# 10/14/02: return miscDirective only for real directives.
	for name in leoColor.leoKeywords:
		if match_word(s,i,name):
			return atFile.miscDirective

	return atFile.noDirective</t>
<t tx="T658">@ 10/30/02: Rather than messing with the code, I have just set use_noweb_flag = true, use_cweb_flag = false.  This has the effect of allowing the user to use noweb sections to organize cweb code.

However, we must disable @c and @ when cweb mode is in effect, so we use the raw_cweb_mode ivar for this.
@c
</t>
<t tx="T659">@ignore

@language cweb
</t>
<t tx="T660">@root c:/prog/test/rawCwebRootTest.txt

root first line

&lt;&lt; noweb sec1 &gt;&gt;
&lt;&lt; noweb sec2 &gt;&gt;

&lt;@ cweb sec ref1 @&gt;
&lt;@ cweb sec ref2 @&gt;

root last line

</t>
<t tx="T661">@code

@c
cweb c section

@&lt; cweb sec def @&gt;=
cweb section</t>
<t tx="T662">&lt;&lt; noweb sec2 &gt;&gt;=

@&lt; cweb sec2 @&gt;
sec 2</t>
<t tx="T663"># Synonyms for multiple_parts_flag.
allow_multiple_parts = 1
disallow_multiple_parts = 2
unused_parts_flag = 3

# Synonyms for is_root_flag to st_enter.
is_root_name = 1 ; not_root_name = 0

# Synonyms for scanAllDirectives
report_errors = 1 ; dont_report_errors = 0
require_path = 1 ; done_require_path = 0

# Constants...
max_errors = 20

@ All these must be defined together, because they form a single enumeration.  Some of these are used by utility functions.
@c

if 1: # A single enum...

	# Used by token_type().
	plain_line = 1 # all other lines
	at_at	     = 2 # double-at sign.
	at_chapter = 3 # @chapter
	# at_c       = 4 # @c in noweb mode
	at_code	   = 5 # @code, or @c or @p in CWEB mode.
	at_doc	    = 6 # @doc
	at_other   = 7 # all other @directives
	at_root	   = 8 # @root or noweb * sections
	at_section = 9 # @section
	# at_space   = 10 # @space
	at_web	    = 11 # any CWEB control code, except at_at.
	
	# Returned by self.skip_section_name() and allies and used by token_type.
	bad_section_name = 12  # &lt; &lt; with no matching &gt; &gt;
	section_ref	 = 13  # &lt; &lt; name &gt; &gt;
	section_def	 = 14  # &lt; &lt; name &gt; &gt; =
	
	# Returned by is_sentinal_line.
	non_sentinel_line   = 15
	start_sentinel_line = 16
	end_sentinel_line   = 17
	
	# Stephen P. Schaefer 9/13/2002
	# add support for @first
	at_last    = 18
</t>
<t tx="T664">if 0: # not used in this version of Leo
	self.allow_rich_text = default_allow_rich_text
	self.extended_noweb_flag = default_extended_noweb_flag
	self.target_language = default_target_language # uses c.target_lanuage instead
	
# Global options
self.page_width = c.page_width
self.tab_width = c.tab_width
self.tangle_batch_flag = c.tangle_batch_flag
self.untangle_batch_flag = c.untangle_batch_flag

# Default tangle options.
self.tangle_directory = None # Initialized by scanAllDirectives
self.output_doc_flag = c.output_doc_flag
self.use_header_flag = c.use_header_flag

# Default tangle language
self.language = c.target_language
delim1,delim2,delim3 = set_delims_from_language(self.language)
# print `delim1`,`delim2`,`delim3`

# 8/1/02: this now works as expected.
self.single_comment_string = delim1
self.start_comment_string = delim2
self.end_comment_string = delim3

# Abbreviations for self.language.
# Warning: these must also be initialized in tangle.scanAllDirectives.
if 1: # 10/30/02: Don't change the code, just ignore @language cweb.
	self.use_cweb_flag = false
	self.raw_cweb_flag = self.language == "cweb" # A new ivar.
else:
	self.use_cweb_flag = self.language == "cweb"
	self.raw_cweb_flag = false # was never used before.

self.use_noweb_flag = not self.use_cweb_flag

# Set only from directives.
self.print_mode = "verbose"

# Stephen P. Schaefer 9/13/2002
# support @first directive
self.first_lines = ""</t>
<t tx="T665">@ This method returns a code indicating the apparent kind of token at the position i. The caller must determine whether section definiton tokens are valid.

returns (kind, end) and sets global root_name using setRootFromText().
@c

def token_type(self,s,i,err_flag):

	kind = plain_line ; end = -1
	if self.use_noweb_flag:
		&lt;&lt; set token_type in noweb mode &gt;&gt;
	else:
		&lt;&lt; set token_type for CWEB mode &gt;&gt;
	if kind == at_other :
		&lt;&lt; set kind for directive &gt;&gt;
	# trace(`kind` + ":" + `get_line(s,i)`)
	return kind, end</t>
<t tx="T666">if match(s,i,"&lt;&lt;"):
	i, kind, end = self.skip_section_name(s,i)
	if kind == bad_section_name:
		kind = plain_line # not an error.
	elif kind == at_root:
		if self.head_root:
			self.setRootFromText(self.head_root,err_flag)
		else:
			kind = bad_section_name # The warning has been given.
elif match(s,i,"@ ") or match(s,i,"@\t") or match(s,i,"@\n"):
	# 10/30/02: Only @doc starts a noweb doc part in raw cweb mode.
	kind = choose(self.raw_cweb_flag,plain_line,at_doc)
elif match(s,i,"@@"): kind = at_at
elif i &lt; len(s) and s[i] == '@': kind = at_other
else: kind = plain_line</t>
<t tx="T667">i = skip_ws(s,i)
if match(s,i,"@*") or match(s,i,"@ "): kind = at_doc
elif match(s,i,"@&lt;"): i, kind, end = self.skip_section_name(s,i)
elif match(s,i,"@@"): kind = at_at
elif match_word(s,i,"@c") or match_word(s,i,"@p"): kind = at_code
elif i &lt; len(s) and s[i] == '@':
	if   i + 1 &gt;= len(s): kind = at_doc
	elif i + 1 &lt; len(s) and s[i+1] not in string.letters:
		kind = at_web
	else: kind = at_other # Set kind later
else: kind = plain_line</t>
<t tx="T668"># This code will return at_other for any directive other than those listed.

if match_word(s,i,"@c"):
	# 10/30/02: Only @code starts a code section in raw cweb mode.
	kind = choose(self.raw_cweb_flag,plain_line,at_code)
else:
	for name, type in [
		("@chapter", at_chapter),
		("@code", at_code),
		("@doc", at_doc),
		("@root", at_root),
		("@section", at_section) ]:
		if match_word(s,i,name):
			kind = type ; break
		
if self.raw_cweb_flag and kind == at_other:
	# 10/30/02: Everything else is plain text in raw cweb mode.
	kind = plain_line

if kind == at_root:
	i = self.setRootFromText(s[i:],err_flag)</t>
<t tx="T669">@ No changes have been made to this code.</t>
<t tx="T670">@ This method handles newline processing while skipping a code section. It sets 'done' if the line contains an @directive or section definition that terminates the present code section. On entry: i should point to the first character of a line.  This routine scans past a line only if it could not contain a section reference.

Returns (i, done)
@c

def handle_newline(self,s,i):

	j = i ; done = false
	kind, end = self.token_type(s,i,dont_report_errors)
	# token_type will not skip whitespace in noweb mode.
	i = skip_ws(s,i)
	# trace(`kind` + "," + `get_line(s,i)`)

	if kind == plain_line:
		pass
	elif (kind == at_code or kind == at_doc or
		kind == at_root or kind == section_def):
		i = j ; done = true # Terminate this code section and rescan.
	elif kind == section_ref:
		# Enter the reference.
		ref = s[i:end]
		self.st_enter_section_name(ref,None,None,unused_parts_flag)
	# DTHEIN 13-OCT-2002: @first directives are OK in code sections
	elif (kind == at_other) and match_word(s,j,"@first"):
		pass
	elif kind == at_other or kind == at_chapter or kind == at_section:
		# We expect to see only @doc,@c or @root directives
		# while scanning a code section.
		i = skip_to_end_of_line(s,i)
		if 0: # 12/03/02: no longer needed
			self.error("directive not valid here: " + s[j:i])
	elif kind == bad_section_name:
		if self.use_cweb_flag:
			i = skip_to_end_of_line(s,i)
	elif kind == at_web or kind == at_at:
		i += 2 # Skip a CWEB control code.
	else: assert(false)

	return i, done</t>
<t tx="T671"># This method handles all the body text.

def skip_body (self,v):

	# trace(`v`)
	s = v.bodyString()
	code_seen = false ; code = doc = None ; i = 0
	anyChanged = false
	
	if self.start_mode == "code":
		j = skip_blank_lines(s,i)
		i,code = self.skip_code(s,j)
		if code:
			&lt;&lt; Define a section for a leading code part &gt;&gt;

	if not code:
		i,doc = self.skip_doc(s,i) # Start in doc section by default.
		if i &gt;= len(s) and doc:
			&lt;&lt; Define a section containing only an @doc part &gt;&gt;

	while i &lt; len(s):
		progress = i # progress indicator
		# line = get_line(s,i) ; trace(`line`)
		kind, end = self.token_type(s,i,report_errors)
		# if is_nl(s,i): i = skip_nl(s,i)
		i = skip_ws(s,i)
		if kind == section_def:
			&lt;&lt; Scan and define a section definition &gt;&gt;
		elif kind == at_code:
			if self.use_cweb_flag:
				i += 2 # Skip the at-c or at-p
			else:
				i = skip_line(s,i)
			&lt;&lt; Scan and define an @code defininition &gt;&gt;
		elif kind == at_root:
			i = skip_line(s,i)
			&lt;&lt; Scan and define a root section &gt;&gt;
		elif kind == at_doc:
			if self.use_cweb_flag:
				i += 2 # Skip the at-space
			else:
				i = skip_line(s,i)
			i, doc = self.skip_doc(s,i)
		elif kind == at_chapter or kind == at_section:
			i = skip_line(s,i)
			i, doc = self.skip_doc(s,i)
		else:
			i = skip_line(s,i)
		assert(progress &lt; i) # we must make progress!
	# 3/4/02: Only call v.trimTrailingLines if we have changed its body.
	if anyChanged:
		v.trimTrailingLines()</t>
<t tx="T672">@ The following subsections contain the interface between the Tangle and Untangle commands.  This interface is an important hack, and allows Untangle to avoid duplicating the logic in skip_tree and its allies.

The aha is this: just at the time the Tangle command enters a definition into the symbol table, all the information is present that Untangle needs to update that definition.

To get whitespace exactly right we retain the outline's leading whitespace and remove leading whitespace from the updated definition.
</t>
<t tx="T673">@ It's valid for an @doc directive to appear under a headline that does not contain a section name.  In that case, no section is defined.
@c

if self.header_name:
	# Tangle code.
	flag = choose(code_seen,allow_multiple_parts,disallow_multiple_parts)
	part = self.st_enter_section_name(self.header_name,code,doc,flag)
	# Untangle code.
	if not self.tangling: 
		# Untangle no longer updates doc parts.
		# 12/03/02: Mark the part as having been updated to suppress warning.
		junk,junk = self.ust_lookup(self.header_name,
			part,not_root_name,true) # set update flag

doc = None</t>
<t tx="T674">if self.header_name:
	# Tangle code.
	flag = choose(code_seen,allow_multiple_parts,disallow_multiple_parts)
	part = self.st_enter_section_name(self.header_name,code,doc,flag)
	# Untangle code.
	if not self.tangling: 
		head = s[:j] ; tail = s[i:]
		s,i,changed = self.update_def(self.header,part,head,code,tail,not_root_name)
		if changed: anyChanged = true
	code_seen = true
	code = doc = None</t>
<t tx="T675"># We enter the code part and any preceding doc part into the symbol table.

# Skip the section definition line.
k = i ; i, kind, junk = self.skip_section_name(s,i)
section_name = s[k:i]
# trace(`section_name`)
assert(kind == section_def)
i = skip_to_end_of_line(s,i)

# Tangle code: enter the section name even if the code part is empty.
j = skip_blank_lines(s,i)
i, code = self.skip_code(s,j)
flag = choose(kind==section_def,allow_multiple_parts,disallow_multiple_parts)
part = self.st_enter_section_name(section_name,code,doc,flag)
		
if not self.tangling: # Untangle code.
	head = s[:j] ; tail = s[i:]
	s,i,changed = self.update_def(section_name,part,head,code,tail,not_root_name)
	if changed: anyChanged = true
	
code = doc = None</t>
<t tx="T676"># All @c or @code directives denote &lt; &lt; headline_name &gt; &gt; =
if self.header_name:

	# Tangle code.
	j = skip_blank_lines(s,i)
	i, code = self.skip_code(s,j)
	flag = choose(code_seen,allow_multiple_parts,disallow_multiple_parts)
	part = self.st_enter_section_name(self.header_name,code,doc,flag)
	if not self.tangling: # Untangle code.
		head = s[:j] ; tail = s[i:]
		s,i,changed = self.update_def(self.header,part,head,code,tail,not_root_name)
		if changed: anyChanged = true
else:
	self.error("@c expects the headline: " + self.header + " to contain a section name")

code_seen = true
code = doc = None</t>
<t tx="T677"># We save the file name in case another @root ends the code section.
old_root_name = self.root_name

# Tangle code.
j = skip_blank_lines(s,i)
k, code = self.skip_code(s,j)

# Stephen Schaefer, 9/2/02, later
# st_enter_root_name relies on scanAllDirectives to have set
# the root attributes, such as language, *_comment_string,
# use_header_flag, etc.
self.st_enter_root_name(old_root_name,code,doc)

if not self.tangling: # Untangle code.
	part = 1 # Use 1 for root part.
	head = s[:j] ; tail = s[k:]
	s,i,changed = self.update_def(old_root_name,part,head,code,tail,is_root_name)
	if changed: anyChanged = true
	
code = doc = None</t>
<t tx="T678">@ This method skips an entire code section. The caller is responsible for entering the completed section into the symbol table. On entry, i points at the line following the @directive or section definition that starts a code section. We skip code until we see the end of the body text or the next @ directive or section defintion that starts a code or doc part.
@c

def skip_code(self,s,i):

	# trace(`get_line(s,i)`)
	code1 = i
	nl_i = i # For error messages
	done = false # true when end of code part seen.
	if self.use_noweb_flag:
		&lt;&lt; skip a noweb code section &gt;&gt;
	else:
		&lt;&lt; skip a CWEB code section &gt;&gt;
	code = s[code1:i]
	# trace(returns: + `code`)
	return i,code</t>
<t tx="T679">@ This code handles the following escape conventions: double at-sign at the start of a line and at-&lt;&lt; and at.&gt;.
@c

i, done = self.handle_newline(s,i)
while not done and i &lt; len(s):
	ch = s[i]
	if is_nl(s,i):
		nl_i = i = skip_nl(s,i)
		i, done = self.handle_newline(s,i)
	elif ch == '@' and (match(s,i+1,"&lt;&lt;") or # must be on different lines
		match(s,i+1,"&gt;&gt;")):
		i += 3 # skip the noweb escape sequence.
	elif ch == '&lt;':
		&lt;&lt; handle possible noweb section reference &gt;&gt;
	else: i += 1</t>
<t tx="T680">j, kind, end = self.is_section_name(s,i)
if kind == section_def:
	k = skip_to_end_of_line(s,i)
	# We are in the middle of a line.
	i += 1
	self.error("chunk definition not valid here\n" + s[nl_i:k])
elif kind == bad_section_name:
	i += 1 # This is not an error.  Just skip the '&lt;'.
else:
	assert(kind == section_ref)
	# Enter the reference into the symbol table.
	name = s[i:end]
	self.st_enter_section_name(name,None,None,unused_parts_flag)
	i = end</t>
<t tx="T681"># This code is simple because CWEB control codes are valid anywhere.

while not done and i &lt; len(s):
	if s[i] == '@':
		&lt;&lt; handle CWEB control code &gt;&gt;
	else: i += 1</t>
<t tx="T682">j, kind, end = self.is_section_name(s,i)

if kind == section_def:
	done = true
elif kind == bad_section_name:
	i += 2 # Any other control code.
else:
	assert(kind == section_ref)
	# Enter the reference into the symbol table.
	name = s[i:j]
	self.st_enter_section_name(name,None,None,unused_parts_flag)
	i = j</t>
<t tx="T683">@ This method outputs a code section, expanding section references by their definition. We should see no @directives or section definitions that would end the code section.

Most of the differences bewteen noweb mode and CWEB mode are handled by token_type(called from put_newline). Here, the only difference is that noweb handles double-@ signs only at the start of a line.
@c

def put_code(self,s,no_first_lws_flag):

	# trace(`get_line(s,0)`)
	i = 0
	if i &lt; len(s):
		i = self.put_newline(s,i,no_first_lws_flag)
		# Double @ is valid in both noweb and CWEB modes here.
		if match(s,i,"@@"):
			self.os('@') ; i += 2
	while i &lt; len(s):
		progress = i
		ch = s[i]
		if (match(s,i,"&lt;&lt;") and self.use_noweb_flag or
			match(s,i,"@&lt;") and self.use_cweb_flag):
			&lt;&lt; put possible section reference &gt;&gt;
		elif ch == '@': # We are in the middle of a line.
			if self.use_cweb_flag:
				&lt;&lt; handle 2-character CWEB control codes &gt;&gt;
			else:
				&lt;&lt; handle noweb @ &lt; &lt; convention &gt;&gt;
		elif ch == body_ignored_newline:
			i += 1
		elif ch == body_newline:
			i += 1 ; self.onl()
			i = self.put_newline(s,i,false) # Put full lws
			if self.use_cweb_flag and match(s,i,"@@"):
				self.os('@') ; i += 2
		else: self.os(s[i]) ; i += 1
		assert(progress &lt; i)</t>
<t tx="T684">j, kind, name_end = self.is_section_name(s,i)
if kind == section_def:
	# We are in the middle of a code section
	self.error(
		"Should never happen:\n" +
		"section definition while putting a section reference: " +
		s[i:j])
	i += 1
elif kind == bad_section_name:
	self.os(s[i]) ; i += 1 # This is not an error.
else:
	assert(kind == section_ref)
	name = s[i:name_end]
	self.put_section(s,i,name,name_end)
	i = j</t>
<t tx="T685">if match(s,i,"@@"):
	# Handle double @ sign.
	self.os('@') ; i += 2
else:
	i += 1 # skip the @.
	if i+1 &gt;= len(s) or is_ws_or_nl(s,i):
		# A control code: at-backslash is not a valid CWEB control code.
		# We are in CWEB mode, so we can output C block comments.
		self.os("/*@" + s[i] + "*/") ; i += 1
	else:
		self.os("@") # The at sign is not part of a control code.</t>
<t tx="T686">@ The user must ensure that neither @ &lt; &lt; nor @ &gt; &gt; occurs in comments or strings. However, it is valid for @ &lt; &lt; or @ &gt; &gt; to appear in the doc chunk or in a single-line comment.
@c

if match(s,i,"@&lt;&lt;"):
	self.os("/*@*/&lt;&lt;") ; i += 3

elif match(s,i,"@&gt;&gt;"):
	self.os("/*@*/&gt;&gt;") ; i += 3
	
else: self.os("@") ; i += 1</t>
<t tx="T687">@ This method handles scanning when putting the start of a new line. Unlike the corresponding method in pass one, this method doesn't need to set a done flag in the caller because the caller already knows where the code section ends.
@c

def put_newline(self,s,i,no_first_lws_flag):

	kind, end = self.token_type(s,i,dont_report_errors)
	&lt;&lt; Output leading white space except for blank lines &gt;&gt;
	if i &gt;= len(s):
		return i
	elif kind == at_web or kind == at_at:
		i += 2 # Allow the line to be scanned.
	elif kind == at_doc or kind == at_code:
		if self.use_cweb_flag:
			i += 2
	else:
		# These should have set limit in pass 1.
		assert(kind != section_def and kind != at_chapter and kind != at_section)
	return i</t>
<t tx="T688">j = i ; i = skip_ws(s,i)
if i &lt; len(s) and not is_nl(s,i):
	# Conditionally output the leading previous leading whitespace.
	if not no_first_lws_flag:
		self.put_leading_ws(self.tangle_indent)
	# Always output the leading whitespace of _this_ line.
	k, width = skip_leading_ws_with_indent(s,j,self.tab_width)
	self.put_leading_ws(width)</t>
<t tx="T689">@ This method outputs the definition of a section and all sections referenced from the section. name is the section's name. This code checks for recursive definitions by calling section_check(). We can not allow section x to expand to code containing another call to section x, either directly or indirectly.
@c

def put_section(self,s,i,name,name_end):

	j = skip_line(s,i)
	# trace("indent:" + `self.tangle_indent`  + ", " + `s[i:j]`)
	outer_old_indent = self.tangle_indent
	trailing_ws_indent = 0 # Set below.
	inner_old_indent = 0 # Set below.
	newline_flag = false  # True if the line ends with the reference.
	assert(match(name,0,"&lt;&lt;") or match(name,0,"@&lt;"))
	&lt;&lt; Calculate the new value of tangle_indent &gt;&gt;
	&lt;&lt; Set 'newline_flag' if the line ends with the reference &gt;&gt;
	section = self.st_lookup(name,not_root_name)
	if section and section.parts:
		# Expand the section only if we are not already expanding it.
		if self.section_check(name):
			self.section_stack.append(name)
			&lt;&lt; put all parts of the section definition &gt;&gt;
			self.section_stack.pop()
	else:
		&lt;&lt; Put a comment about the undefined section &gt;&gt;
	if not newline_flag:
		self.put_leading_ws(trailing_ws_indent)
	self.tangle_indent = outer_old_indent
	return i, name_end</t>
<t tx="T690"># Find the start of the line containing the reference.
j = i
while j &gt; 0 and not is_nl(s,j):
	j -= 1
if is_nl(s,j):
	j = skip_nl(s,j)

# Bump the indentation
j, width = skip_leading_ws_with_indent(s,j,self.tab_width)
self.tangle_indent += width
# trace("leading ws:" + `width` + " + new indent:" + `self.tangle_indent`)

# 4/27/01: Force no trailing whitespace in @silent mode.
if self.print_mode == "silent":
	trailing_ws_indent = 0
else:
	trailing_ws_indent = self.tangle_indent

# Increase the indentation if the section reference does not immediately follow
# the leading white space.  4/3/01: Make no adjustment in @silent mode.
if (j &lt; len(s) and self.print_mode != "silent" and
		((self.use_noweb_flag and s[j] != '&lt;') or
		(self.use_cweb_flag and s[j] != '@'))):
	self.tangle_indent += abs(self.tab_width)</t>
<t tx="T691">if self.print_mode != "silent":
	i = name_end
	i = skip_ws(s,i)
	newline_flag = (i &gt;= len(s) or is_nl(s,i))</t>
<t tx="T692">@ This section outputs each part of a section definition. We first count how many parts there are so that the code can output a comment saying 'part x of y'.
@c

# Output each part of the section.
sections = len(section.parts)
count = 0
for part in section.parts:
	count += 1
	# In @silent mode, there is no sentinel line to "use up" the previously output
	# leading whitespace.  We set the flag to tell put_part_node and put_code
	# not to call put_newline at the start of the first code part of the definition.
	no_first_leading_ws_flag = (count == 1 and self.print_mode == "silent")
	inner_old_indent = self.tangle_indent
	# 4/3/01: @silent inhibits newlines after section expansion.
	if self.print_mode != "silent":
		&lt;&lt; Put the section name in a comment &gt;&gt;
	self.put_part_node(part,no_first_leading_ws_flag)
	# 4/3/01: @silent inhibits newlines after section expansion.
	if count == sections and (self.print_mode != "silent" and self.print_mode != "quiet"):
		&lt;&lt; Put the ending comment &gt;&gt;
	# Restore the old indent.
	self.tangle_indent = inner_old_indent</t>
<t tx="T693">if count &gt; 1:
	self.onl()
	self.put_leading_ws(self.tangle_indent)
	
# Don't print trailing whitespace
name = string.rstrip(name)
if self.single_comment_string:
	self.os(self.single_comment_string) ; self.oblank() ; self.os(name)
	&lt;&lt; put (n of m) &gt;&gt;
else:
	assert(
		self.start_comment_string and len(self.start_comment_string) &gt; 0 and
		self.end_comment_string and len(self.end_comment_string)&gt; 0)
	self.os(self.start_comment_string) ; self.oblank() ; self.os(name)
	&lt;&lt; put (n of m) &gt;&gt;
	self.oblank() ; self.os(self.end_comment_string)

self.onl() # Always output a newline.</t>
<t tx="T694">if sections &gt; 1:
	self.oblank()
	self.os("(" + `count` + " of " + `sections` + ")")</t>
<t tx="T695">@ We do not produce an ending comment unless we are ending the last part of the section,and the comment is clearer if we don't say(n of m).
@c

self.onl() ; self.put_leading_ws(self.tangle_indent)
#  Don't print trailing whitespace
while name_end &gt; 0 and is_ws(s[name_end-1]):
	name_end -= 1

if self.single_comment_string:
	self.os(self.single_comment_string) ; self.oblank()
	self.os("-- end -- ") ; self.os(name)
else:
	self.os(self.start_comment_string) ; self.oblank()
	self.os("-- end -- ") ; self.os(name)
	self.oblank() ; self.os(self.end_comment_string)
	
@ The following code sets a flag for untangle.

If something follows the section reference we must add a newline, otherwise the "something" would become part of the comment.  Any whitespace following the (!newline) should follow the section defintion when Untangled.
@c

if not newline_flag:
	self.os(" (!newline)") # LeoCB puts the leading blank, so we must do so too.
	# Put the whitespace following the reference.
	while name_end &lt; len(s) and is_ws(s[name_end]):
		self.os(s[name_end])
		name_end += 1
	self.onl() # We must supply the newline!</t>
<t tx="T696">self.onl() ; self.put_leading_ws(self.tangle_indent)

if self.print_mode != "silent":
	if self.single_comment_string:
		self.os(self.single_comment_string)
		self.os(" undefined section: ") ; self.os(name) ; self.onl()
	else:
		self.os(self.start_comment_string)
		self.os(" undefined section: ") ; self.os(name)
		self.oblank() ; self.os(self.end_comment_string) ; self.onl()

self.error("Undefined section: " + name)</t>
<t tx="T697"># Compares section names or root names.
# Arbitrary text may follow the section name on the same line.

def compare_section_names (self,s1,s2):

	# trace(`get_line(s1,0)` + ":" + `get_line(s2,0)`)
	if match(s1,0,"&lt;&lt;") or match(s1,0,"@&lt;"):
		# Use a forgiving compare of the two section names.
		delim = choose(self.use_cweb_flag,"@&gt;","&gt;&gt;")
		i1 = i2 = 0
		while i1 &lt; len(s1) and i2 &lt; len(s2):
			ch1 = s1[i1] ; ch2 = s2[i2]
			if is_ws(ch1) and is_ws(ch2):
				i1 = skip_ws(s1,i1)
				i2 = skip_ws(s2,i2)
			elif match(s1,i1,delim) and match(s2,i2,delim):
				return true
			elif string.lower(ch1) == string.lower(ch2):
				i1 += 1 ; i2 += 1
			else: return false
		return false
	else: # A root name.
		return s1 == s2</t>
<t tx="T698">def is_section_name(self,s,i):

	kind = bad_section_name ; end = -1

	if self.use_cweb_flag :
		if match(s,i,"@&lt;"):
			i, kind, end = self.skip_cweb_section_name(s,i)
	elif match(s,i,"&lt;&lt;"):
		i, kind, end = self.skip_noweb_section_name(s,i)

	# trace(`kind` + ":" + `get_line(s,end)`)
	return i, kind, end</t>
<t tx="T699">@ This function returns true if i points to a line a sentinel line of one of the following forms:

start_sentinel &lt;&lt;section name&gt;&gt; end_sentinel
start_sentinel &lt;&lt;section name&gt;&gt; (n of m) end_sentinel
start_sentinel -- end -- &lt;&lt;section name&gt;&gt; end_sentinel
start_sentinel -- end -- &lt;&lt;section name&gt;&gt; (n of m) end_sentinel

start_sentinel: the string that signals the start of sentinel lines\
end_sentinel:   the string that signals the endof sentinel lines.

end_sentinel may be None,indicating that sentinel lines end with a newline.

Any of these forms may end with (!newline), indicating that the section reference was not followed by a newline in the orignal text.  We set nl_flag to false if such a string is seen. The name argument contains the section name.

The valid values of kind param are:

non_sentinel_line,   # not a sentinel line.
start_sentinel_line, #   /// &lt;section name&gt; or /// &lt;section name&gt;(n of m)
end_sentinel_line  //  /// -- end -- &lt;section name&gt; or /// -- end -- &lt;section name&gt;(n of m).
@c
def is_sentinel_line (self,s,i):

	result,i,kind,name,part,of,end,nl_flag = self.is_sentinel_line_with_data(s,i)
	return result

def is_sentinel_line_with_data (self,s,i):

	start_sentinel = self.sentinel
	end_sentinel = self.sentinel_end
	&lt;&lt; Initialize the return values &gt;&gt;
	&lt;&lt; Make sure the line starts with start_sentinel &gt;&gt;
	&lt;&lt; Set end_flag if we have -- end -- &gt;&gt;
	&lt;&lt; Make sure we have a section reference &gt;&gt;
	&lt;&lt; Set part and of if they exist &gt;&gt;
	&lt;&lt; Set nl_flag to false if !newline exists &gt;&gt;
	&lt;&lt; Make sure the line ends with end_sentinel &gt;&gt;
	kind = choose(end_flag,end_sentinel_line,start_sentinel_line)
	return true,i,kind,name,part,of,end,nl_flag</t>
<t tx="T700">name = end = None
part = of = 1
kind = non_sentinel_line
nl_flag = true
false_data = (false,i,kind,name,part,of,end,nl_flag)
</t>
<t tx="T701">if is_nl(s,i): i = skip_nl(s,i)
i = skip_ws(s,i)

# 4/18/00: We now require an exact match of the sentinel.
if match(s,i,start_sentinel):
	i += len(start_sentinel)
else:
	return false_data</t>
<t tx="T702"># If i points to "-- end --", this code skips it and sets end_flag.

end_flag = false
i = skip_ws(s,i)
if match(s,i,"--"):
	while i &lt; len(s) and s[i] == '-':
		i += 1
	i = skip_ws(s,i)
	if not match(s,i,"end"):
		return false_data # Not a valid sentinel line.
	i += 3 ; i = skip_ws(s,i)
	if not match(s,i,"--"):
		return false_data # Not a valid sentinel line.
	while i &lt; len(s) and s[i] == '-':
		i += 1
	end_flag = true</t>
<t tx="T703">i = skip_ws(s,i)

if (self.use_noweb_flag and match(s,i,"&lt;&lt;") or
	self.use_cweb_flag  and match(s,i,"@&lt;") ):

	j = i ; i, kind, end = self.skip_section_name(s,i)
	if kind != section_ref:
		return false_data
	name = s[j:i]
else:
	return false_data</t>
<t tx="T704"># This code handles (m of n), if it exists.
i = skip_ws(s,i)
if match(s,i,'('):
	j = i
	i += 1 ; i = skip_ws(s,i)
	i, part = self.scan_short_val(s,i)
	if part == -1:
		i = j # back out of the scanning for the number.
		part = 1
	else:
		i = skip_ws(s,i)
		if not match(s,i,"of"):
			return false_data
		i += 2 ; i = skip_ws(s,i)
		i, of = self.scan_short_val(s,i)
		if of == -1:
			return false_data
		i = skip_ws(s,i)
		if match(s,i,')'):
			i += 1 # Skip the paren and do _not_ return.
		else:
			return false_data</t>
<t tx="T705">line = "(!newline)"
i = skip_ws(s,i)
if match(s,i,line):
	i += len(line)
	nl_flag = false
</t>
<t tx="T706">i = skip_ws(s,i)
if end_sentinel:
	# Make sure the line ends with the end sentinel.
	if match(s,i,end_sentinel):
		i += len(end_sentinel)
	else:
		return false_data

end = i # Show the start of the whitespace.
i = skip_ws(s,i)
if i &lt; len(s) and not is_nl(s,i):
	return false_data</t>
<t tx="T707"># Returns a tuple (i, kind, end)

def skip_section_name(self,s,i):

	if self.use_noweb_flag:
		return self.skip_noweb_section_name(s,i)
	else:
		return self.skip_cweb_section_name(s,i)</t>
<t tx="T708">@ This is the "forgiving compare" function.  It compares two texts and returns true if they are identical except for comments or non-critical whitespace.  Whitespace inside strings or preprocessor directives must match exactly.
@c

def forgiving_compare (self,name,part,s1,s2):

	if 0:
		trace(`name`+":"+`part`+
		      "\n1:"+`get_line(s1,0)`+
		      "\n2:"+ `get_line(s2,0)`)
	&lt;&lt; Define forgiving_compare vars &gt;&gt;
	p1 = skip_ws_and_nl(s1,0) 
	p2 = skip_ws_and_nl(s2,0)
	result = true
	while result and p1 &lt; len(s1) and p2 &lt; len(s2):
		first1 = p1 ; first2 = p2
		if self.comment and self.comment_end:
			&lt;&lt; Check both parts for @ comment conventions &gt;&gt;
		ch1 = s1[p1]
		if ch1 == '\r' or ch1 == '\n':
			&lt;&lt; Compare non-critical newlines &gt;&gt;
		elif ch1 ==  ' ' or ch1 == '\t':
			&lt;&lt; Compare non-critical whitespace &gt;&gt;
		elif ch1 == '\'' or ch1 == '"':
			&lt;&lt; Compare possible strings &gt;&gt;
		elif ch1 == '#':
			&lt;&lt; Compare possible preprocessor directives &gt;&gt;
		elif ch1 == '&lt;' or ch1 == '@':
			&lt;&lt; Compare possible section references &gt;&gt;
		else:
			&lt;&lt; Compare comments or single characters &gt;&gt;
	&lt;&lt; Make sure both parts have ended &gt;&gt;
	if not result:
		&lt;&lt; trace the mismatch &gt;&gt;
	return result</t>
<t tx="T709"># scan_derived_file has set the ivars describing comment delims.
first1 = first2 = 0

tot_len = 0
if self.comment: tot_len += len(self.comment)
if self.comment_end: tot_len += len(self.comment_end)

CWEB_flag = (self.language == "c" and not self.use_noweb_flag)</t>
<t tx="T710">@ This code is used in forgiving_compare()and in compare_comments().

In noweb mode we allow / * @ * /  (without the spaces)to be equal to @.
In CWEB mode we allow / * @ ? * / (without the spaces)to be equal to @?.
at-backslash is not a valid CWEB control code, so we don't have to equate
/ * @ \\ * / with at-backslash.

We must be careful not to run afoul of this very convention here!
@c

if p1 &lt; len(s1) and s1[p1] == '@':
	if match(s2,p2,self.comment + '@' + self.comment_end):
		p1 += 1
		p2 += tot_len + 1
		continue
	elif (CWEB_flag and s1[p1] == '@' and p1 + 1 &lt; len(s1) and
		match(s2,p2,self.comment + '@' + s1[p1+1])):
		p1 += 2
		p2 += tot_len + 2
		continue
elif p2 &lt; len(s2) and s2[p2] == '@':
	if match(s1,p1,self.comment + '@' + self.comment_end):
		p2 += 1
		p1 += tot_len + 1
		continue
	elif (CWEB_flag and s1[p1] == '@' and p1 + 1 &lt; len(s1) and
		match(s1,p1,self.comment + '@' + s2[p2+1])):
		p2 += 2
		p1 += tot_len + 2
		continue
</t>
<t tx="T711">p1 = skip_ws_and_nl(s1,p1)
p2 = skip_ws_and_nl(s2,p2)
</t>
<t tx="T712">p1 = skip_ws(s1,p1)
p2 = skip_ws(s2,p2)</t>
<t tx="T713">if self.language == "c":
	&lt;&lt; compare preprocessor directives &gt;&gt;
else:
	&lt;&lt; compare single characters &gt;&gt;
</t>
<t tx="T714">assert(p1 &lt; len(s1) and p2 &lt; len(s2))
result = s1[p1] == s2[p2]
p1 += 1 ; p2 += 1
if not result: self.mismatch("Mismatched single characters")</t>
<t tx="T715"># We cannot assume that newlines are single characters.

result = s1[p1] == s2[p2]
p1 += 1 ; p2 += 1
while result and p1 &lt; len(s1) and p2 &lt; len(s2):
	if is_nl(s1,p1):
		result = is_nl(s2,p2)
		if not result or self.is_end_of_directive(s1,p1):
			break
		p1 = skip_nl(s1,p1)
		p2 = skip_nl(s2,p2)
	else:
		result = s1[p1] == s2[p2]
		p1 += 1 ; p2 += 1
if not result:
	self.mismatch("Mismatched preprocessor directives")</t>
<t tx="T716"># This code implicitly assumes that string1_len == string2_len == 1.
# The match test ensures that the language actually supports strings.

if (match(s1,p1,self.string1) or match(s1,p1,self.string2)) and s1[p1] == s2[p2]:

	if self.language == "pascal":
		&lt;&lt; Compare Pascal strings &gt;&gt;
	else:
		&lt;&lt; Compare C strings &gt;&gt;
	if not result:
		self.mismatch("Mismatched strings")
else:
	&lt;&lt; Compare single characters &gt;&gt;</t>
<t tx="T717">delim = s1[p1]
result = s1[p1] == s2[p2]
p1 += 1 ; p2 += 1

while result and p1 &lt; len(s1) and p2 &lt; len(s2):
	if s1[p1] == delim and self.is_end_of_string(s1,p1,delim):
		result =(s2[p2] == delim and self.is_end_of_string(s2,p2,delim))
		p1 += 1 ; p2 += 1
		break
	elif is_nl(s1,p1) and is_nl(s2,p2):
		p1 = skip_nl(s1,p1)
		p2 = skip_nl(s2,p2)
	else:
		result = s1[p1] == s2[p2]
		p1 += 1 ; p2 += 1
</t>
<t tx="T718">@ We assume the Pascal string is on a single line so the problems with cr/lf do not concern us.
@c

first1 = p1 ; first2 = p2
p1 = skip_pascal_string(s1,p1)
p2 = skip_pascal_string(s2,p2)
result = s1[first1,p1] == s2[first2,p2]
</t>
<t tx="T719">if s1[p1] == '@' and CWEB_flag:  start_ref = "@&lt;"
elif s1[p1] == '&lt;' and not CWEB_flag:  start_ref = "&lt;&lt;"
else: start_ref = None

# Tangling may insert newlines.
p2 = skip_ws_and_nl(s2,p2)

junk, kind1, junk2 = self.is_section_name(s1,p1)
junk, kind2, junk2 = self.is_section_name(s2,p2)

if start_ref and (kind1 != bad_section_name or kind2 != bad_section_name):
	result = self.compare_section_names(s1[p1:],s2[p2:])
	if result:
		p1, junk1, junk2 = self.skip_section_name(s1,p1)
		p2, junk1, junk2 = self.skip_section_name(s2,p2)
	else: self.mismatch("Mismatched section names")
else:
	# Neither p1 nor p2 points at a section name.
	result = s1[p1] == s2[p2]
	p1 += 1 ; p2 += 1
	if not result:
		self.mismatch("Mismatch at '@' or '&lt;'")</t>
<t tx="T720">if match(s1,p1,self.sentinel) and match(s2,p2,self.sentinel):
	first1 = p1 ; first2 = p2
	p1 = skip_to_end_of_line(s1,p1)
	p2 = skip_to_end_of_line(s2,p2)
	result = self.compare_comments(s1[first1:p1],s2[first2:p2])
	if not result:
		self.mismatch("Mismatched sentinel comments")
elif match(s1,p1,self.line_comment) and match(s2,p2,self.line_comment):
	first1 = p1 ; first2 = p2
	p1 = skip_to_end_of_line(s1,p1)
	p2 = skip_to_end_of_line(s2,p2)
	result = self.compare_comments(s1[first1:p1],s2[first2:p2])
	if not result:
		self.mismatch("Mismatched single-line comments")
elif match(s1,p1,self.comment) and match(s2,p2,self.comment):
	while (p1 &lt; len(s1) and p2 &lt; len(s2) and
		not match(s1,p1,self.comment_end) and not match(s2,p2,self.comment_end)):
		# ws doesn't have to match exactly either!
		if is_nl(s1,p1)or is_ws(s1[p1]):
			p1 = skip_ws_and_nl(s1,p1)
		else: p1 += 1
		if is_nl(s2,p2)or is_ws(s2[p2]):
			p2 = skip_ws_and_nl(s2,p2)
		else: p2 += 1
	p1 = skip_ws_and_nl(s1,p1)
	p2 = skip_ws_and_nl(s2,p2)
	if match(s1,p1,self.comment_end) and match(s2,p2,self.comment_end):
		first1 = p1 ; first2 = p2
		p1 += len(self.comment_end)
		p2 += len(self.comment_end)
		result = self.compare_comments(s1[first1:p1],s2[first2:p2])
	else: result = false
	if not result:
		self.mismatch("Mismatched block comments")
elif match(s1,p1,self.comment2) and match(s2,p2,self.comment2):
	while (p1 &lt; len(s1) and p2 &lt; len(s2) and
		not match(s1,p1,self.comment2_end) and not match(s2,p2,self.comment2_end)):
		# ws doesn't have to match exactly either!
		if  is_nl(s1,p1)or is_ws(s1[p1]):
			p1 = skip_ws_and_nl(s1,p1)
		else: p1 += 1
		if is_nl(s2,p2)or is_ws(s2[p2]):
			p2 = skip_ws_and_nl(s2,p2)
		else: p2 += 1
	p1 = skip_ws_and_nl(s1,p1)
	p2 = skip_ws_and_nl(s2,p2)
	if match(s1,p1,self.comment2_end) and match(s2,p2,self.comment2_end):
		first1 = p1 ; first2 = p2
		p1 += len(self.comment2_end)
		p2 += len(self.comment2_end)
		result = self.compare_comments(s1[first1:p1],s2[first2:p2])
	else: result = false
	if not result:
		self.mismatch("Mismatched alternalte block comments")
else:
	&lt;&lt; Compare single characters &gt;&gt;</t>
<t tx="T721">if result:
	p1 = skip_ws_and_nl(s1,p1)
	p2 = skip_ws_and_nl(s2,p2)
	result = p1 &gt;= len(s1) and p2 &gt;= len(s2)
	if not result:
		# Show the ends of both parts.
		p1 = len(s1)
		p2 = len(s2)
		self.mismatch("One part ends before the other.")</t>
<t tx="T722">if 0:
	trace(self.message +
		"\nPart " + `part` + ", section " + name +
		"\n1:" + get_line(s1,p1) +
		"\n2:" + get_line(s2,p2) )</t>
<t tx="T723">@ This function compares the interior of comments and returns true if they are identical except for whitespace or newlines. It is up to the caller to eliminate the opening and closing delimiters from the text to be compared.
@c

def compare_comments (self,s1,s2):

	tot_len = 0
	if self.comment: tot_len += len(self.comment)
	if self.comment_end: tot_len += len(self.comment_end)
	CWEB_flag = (self.language == "c" and not self.use_noweb_flag)
	
	p1, p2 = 0, 0
	while p1 &lt; len(s1) and p2 &lt; len(s2):
		p1 = skip_ws_and_nl(s1,p1)
		p2 = skip_ws_and_nl(s2,p2)
		if self.comment and self.comment_end:
			&lt;&lt; Check both parts for @ comment conventions &gt;&gt;
		if p1 &gt;= len(s1) or p2 &gt;= len(s2):
			break
		if s1[p1] != s2[p2]:
			return false
		p1 += 1 ; p2 += 1
	p1 = skip_ws_and_nl(s1,p1)
	p2 = skip_ws_and_nl(s2,p2)
	return p1 == len(s1) and p2 == len(s2)
</t>
<t tx="T724">@ This function issues a warning about any sections in the derived file for which no corresponding section has been seen in the outline.
@c

def ust_warn_about_orphans (self):

	for section in self.ust.values():
		# trace(`section`)
		for part in section.parts.values():
			assert(part.of == section.of)
			if not part.update_flag:
				es("Warning: " +
					choose(self.use_noweb_flag,"&lt;&lt; ","@&lt; ") +
					part.name +
					choose(self.use_noweb_flag," &gt;&gt;"," @&gt;") +
					" is not in the outline")
				break # One warning per section is enough.</t>
<t tx="T725">@ This function checks the given symbol table for defined but never referenced sections.
@c

def st_check(self):

	keys = self.tst.keys()
	keys.sort()
	# trace(`keys`)
	for name in keys:
		section = self.tst[name]
		if not section.referenced:
			es(	' ' * 4 + "Warning: " +
				choose(self.use_noweb_flag,"&lt;&lt; ","@&lt; ") +
				section.name +
				choose(self.use_noweb_flag," &gt;&gt;"," @&gt;") +
				" has been defined but not used.")</t>
<t tx="T726">Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1745015
By: jmgilligan

For the most part, I can get cweb mode to color both the tex and the c code
appropriately by using @language.

I have run into a small problem, though:

@language latex
blah blah blah

works fine, but

@language latex
@!@^memory allocation@&gt;
blah blah blah

does not. This causes leo to color all subsequent latex text as leo doc parts.

The control sequence @! means underline the following term in the index. @^foo
bar@&gt; means put the term "foo bar" in the index with a reference to the current
location.
</t>
<t tx="T727">@language latex

% This is a \LaTeX mode comment.

This is a test of \LaTeX mode.

@ blah blah blah
@c

\c and \LaTeX are latex keywords.</t>
<t tx="T728">@language cweb

% This is limbo in cweb mode... It should be in \LaTeX mode, not \c mode.
% The following should not be colorized: class,if,else.

@* this is a _cweb_ comment.  Code is written in \c.
"strings" should not be colorized.
It should be colored in \LaTeX mode.
The following are not keywords in latex mode: if, else, etc.
Noweb section referencs are _valid_ in cweb comments!
&lt;&lt; section ref &gt;&gt;
&lt;&lt; missing ref &gt;&gt;
@c

and this is C code. // It is colored in \LaTeX mode by default.
/* This is a C block comment.  It may also be colored in restricted \LaTeX mode. */

// Section refs are valid in code too, of course.
&lt;&lt; section ref &gt;&gt;
&lt;&lt; missing ref &gt;&gt;

\LaTeX and \c should not be colored.
if else, while, do // C keywords.</t>
<t tx="T729">&lt;&lt; section def &gt;&gt;=

	my \c code goes here // This is \LaTeX text
	/* This is also \LaTeX text */</t>
<t tx="T730">@ To do:

This does not take into account the following line number issues:
	
1. Source lines in doc parts may be broken into shorter lines.
   The trailing newline convention determines whether trailing newlines are real or not.
2. All sentinels begin and end with a newline, some of which must be ignored.
3. There are presently problems with trailing newlines in body text.
4. Lines may have been inserted or deleted from the derived file.
5. Line "n" may be a sentinel line, not corresponding directly to any line in the outline.

A better way to find a given line would be as follows:
	
- Scan backward from line "n", looking for a "suitable" line for comparisons.
  This line should have a minimum number of non-whitespace characters.
- Remember the offset of this line from line "n".
- Given a "candidate" offset into a vnode, scan forward and backward
  until a matching line in the outline is found.
  (A match is not guaranteed if the derived file has been changed).
	</t>
<t tx="T731">@language c</t>
<t tx="T732">@first line 5
line6
line7
&lt;&lt; ref &gt;&gt;
line 17
line 18</t>
<t tx="T733">ref line 12
ref line 13</t>
<t tx="T734">@first line 1
line6
line7
&lt;&lt; ref &gt;&gt;
line 9
line 10</t>
<t tx="T735">ref line 15
ref line 16
</t>
<t tx="T736">def OnGoToLineNumber (self,event=None):

	c = self.commands
	&lt;&lt; set root to the nearest @file, @silentfile or @rawfile ancestor node &gt;&gt;
	&lt;&lt; read the file into lines &gt;&gt;
	&lt;&lt; get n, the line number, from a dialog &gt;&gt;
	# trace("n:"+`n`)
	if n==1:
		v = root ; n2 = 1 ; found = true
	elif n &gt;= len(lines):
		v = root.lastNode()
		n2 = v.bodyString().count('\n')
		found = false
	elif root.isAtSilentFileNode():
		&lt;&lt; count outline lines, setting v,n2,found &gt;&gt;
	else:
		# To do: choose a "suitable line" for searching.
		vnodeName,n2 = self.convertLineToVnodeAndLine(lines,n,root)
		found = true
		if not vnodeName:
			es("invalid derived file: " + fileName)
			return
		&lt;&lt; set v to the node whose headline is vnodeName &gt;&gt;
	# To do: search for the "suitable line".
	&lt;&lt; select v and make it visible &gt;&gt;
	&lt;&lt; put the cursor on line n2 of the body text &gt;&gt;</t>
<t tx="T737">v = c.currentVnode()
fileName = None
while v and not fileName:
	if v.isAtFileNode():
		fileName = v.atFileNodeName()
	elif v.isAtSilentFileNode():
		fileName = v.atSilentFileNodeName()
	elif v.isAtRawFileNode():
		fileName = v.atRawFileNodeName()
	else:
		v = v.parent()

root = v
if not root:
	es("no @file node found") ; return</t>
<t tx="T738">try:
	file=open(fileName)
	lines = file.readlines()
	file.close()
except:
	es("not found: " + fileName)
	return
	
</t>
<t tx="T739">import leoDialog

d = leoDialog.leoDialog()
n = d.askOkCancelNumber("Enter Line Number","Line number:")
if n == -1:
	return
n0 = n = max(n,1)</t>
<t tx="T740">v = lastv = root ; after = root.nodeAfterTree()
prev = 0 ; found = false
while v and v != after:
	lastv = v
	s = v.bodyString()
	lines = s.count('\n')
	if len(s) &gt; 0 and s[-1] != '\n':
		lines += 1
	# print lines,prev,v
	if prev + lines &gt;= n:
		found = true ; break
	prev += lines
	v = v.threadNext()

v = lastv
n2 = max(1,n-prev)</t>
<t tx="T741">after = root.nodeAfterTree()
while v and v != after and not v.matchHeadline(vnodeName):
	v = v.threadNext()

if not v or v == after:
	es("vnode not found in outline: " + vnodeName)
	return</t>
<t tx="T742">c.beginUpdate()
c.tree.expandAllAncestors(v)
c.selectVnode(v)
c.endUpdate()</t>
<t tx="T743">if found:
	c.frame.body.mark_set("insert",str(n2)+".0 linestart")
else:
	c.frame.body.mark_set("insert","end-1line")
	es(root.headString() + " has " + `len(lines)` + " lines.")</t>
<t tx="T744">@ This routine converts a line number, n, in a derived file to a vnode and offset within the vnode

We count "real" lines in the derived files, ignoring all sentinels that do not arise from source lines.  When the indicated line is found, we scan backwards for an @+body line, get the vnode's name from that line and set v to the indicated vnode.  This will fail if vnode names have been changed, and that can't be helped.

Returns vnodeName,n2,found
vnodeName: the name found in the previous @+body sentinel.
offset: the offset within v of the desired line.
@c

def convertLineToVnodeAndLine (self,lines,n,root):
	
	&lt;&lt; set delim, leoLine from the @+leo line &gt;&gt;
	if not delim:
		es("bad @+leo sentinel")
		return None,None
	&lt;&lt; scan back to @+node, setting offset,nodeSentinelLine &gt;&gt;
	if nodeSentinelLine == -1:
		# The line precedes the first @+node sentinel
		return root.headString(),1
	s = lines[nodeSentinelLine]
	&lt;&lt; set vnodeName from s &gt;&gt;
	return vnodeName,offset</t>
<t tx="T745"># Find the @+leo line.
tag = "@+leo"
i = 0 
while i &lt; len(lines) and lines[i].find(tag)==-1:
	i += 1
leoLine = i # Index of the line containing the leo sentinel
# trace("leoLine:"+`leoLine`)

delim = None # All sentinels start with this.
if leoLine &lt; len(lines):
	# The opening comment delim is the initial non-whitespace.
	s = lines[leoLine]
	i = skip_ws(s,0)
	j = s.find(tag)
	delim = s[i:j]
	if len(delim)==0:
		delim=None
	else:
		delim += '@'</t>
<t tx="T746">offset = 0 # This is essentially the tk line number.
nodeSentinelLine = -1
line = n - 1
while line &gt;= 0:
	s = lines[line]
	# trace(`s`)
	i = skip_ws(s,0)
	if match(s,i,delim):
		&lt;&lt; handle delim while scanning backward &gt;&gt;
	else:
		offset += 1 # Assume the line is real.  A dubious assumption.
	line -= 1</t>
<t tx="T747">if line == n:
	es("line "+str(n)+" is a sentinel line")
i += len(delim)

if match(s,i,"-node"):
	# The end of a nested section.
	line = self.skipToMatchingNodeSentinel(lines,line,delim)
elif match(s,i,"+node"):
	nodeSentinelLine = line
	break
elif match(s,i,"&lt;&lt;") or match(s,i,"@first"):
	offset += 1 # Count these as a "real" lines.</t>
<t tx="T748"># vnode name is everything following the third ':'

# trace("last body:"+`s`)
vnodeName = None
i = 0 ; colons = 0
while i &lt; len(s) and colons &lt; 3:
	if s[i] == ':': colons += 1
	i += 1
vnodeName = s[i:].strip()
# trace("vnodeName:"+`vnodeName`)

if len(vnodeName) == 0:
	vnodeName = None
if not vnodeName:
	es("bad @+node sentinel")</t>
<t tx="T749">def skipToMatchingNodeSentinel (self,lines,n,delim):
	
	s = lines[n]
	i = skip_ws(s,0)
	assert(match(s,i,delim))
	i += len(delim)
	if match(s,i,"+node"):
		start="+node" ; end="-node" ; delta=1
	else:
		assert(match(s,i,"-node"))
		start="-node" ; end="+node" ; delta=-1
	# Scan to matching @+-node delim.
	n += delta ; level = 0
	while 0 &lt;= n &lt; len(lines):
		s = lines[n] ; i = skip_ws(s,0)
		if match(s,i,delim):
			i += len(delim)
			if match(s,i,start):
				level += 1
			elif match(s,i,end):
				if level == 0: return n
				else: level -= 1
		n += 1
	return n</t>
<t tx="T750">Things to check:

** How much memory do memory moves use for undo???

- undo
- move checking.
- Look at vnode routines: they may be using n*n algorithms...</t>
<t tx="T751">By: travers ( Travers A. Hough ) 
 Outline Navigation   
2002-11-23 16:40  
I've been writing new code (as opposed to changing existing code) and have wished for a few more outline navigation commands, if they wouldn't take too much time to implement. 

My Outline Navigation Wish List: 
1. Go to first (or last) node. 
2. Go to parent node (but don't close the parent's tree). 
3. Close the tree underneath the current node. 
4. Go to next (or previous) node at the same level as the current node. 
 
</t>
<t tx="T752">Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1773516
By: travers

How about:
1.  Page up (down) outline pane.
2.  Scroll up (down) outline pane.

?
Travers
</t>
<t tx="T753">By: travers ( Travers A. Hough ) 
 RE: Outline Navigation   
2002-12-03 17:06  
After many more hours using Leo to write a sizeable program from scratch, I think the page-up/down and scroll-up/down commands would be nice, but not important. 

These same hours have made me think that outline navigation is very (underlined) important when writing new code. I think the following would be very very very helpful: 

1. Have the "ExpandToLevelx" commands (including "ExpandNextLevel") retain focus on the highlighted node, or (if the current node will no longer be visible) move focus to the first parent which will still be visible after the Expand. 

Currently, these commands shift focus to the first node in the outline. Staying in the same place would save a lot of time. 

2. Have the outline pane scroll by one line when focus moves to the first (or last) node in the pane. 

Currently, moving focus up from the first node scrolls by one, but the first node on the screen may be partially off-screen, depending on the outline font. 

Moving focus down from the last node causes a page-down, after which the first node on the screen has focus, but this node may be partially off-screen. 

3. Create "ExpandSuboutlineToLevelx" commands. 

Leo users could achieve a similar effect by using the "ExpandToLevelx" commands if #1 above is implemented, however, traversing nodes (with "GoNext" and "GoBack", or "GoNextVisible" and "GoPrevVisible") seems to slow greatly as more nodes are expanded. Having "Expand" commands that work only on a suboutline would avoid the performance hit and would most likely be what the programmer really wanted.</t>
<t tx="T754">There may be a bug in Tkinter, or a really weird bug in Leo.

Single-stepping through the code, I see that the icon is initially drawn correctly in the body pane, and then it is messed up after return "break".  The code that messes it up apparently doesn't happen when Leo takes an uncaught exception.</t>
<t tx="T755">See also: http://zvon.org/

By: jasonic

Leo has really got me into XSLT. I was afraid and confused before. Suddenly
I see why one would wan to go through all that. Leo makes it much more possible
and advisable.

So I bought an excellent book by Michael Kay the author of the 'Saxon' XSLT
processor. No hype.Very honest well written, clear.

"XSLT 2nd edition" by Michael Kay published by Wrox. 

I looked on the web and found a lot of good sites, tools,  and tutorals. The
one I like best so far is

"TopXML - never stop learning"
- good reference chart:
http://www.topxml.com/xsl/xsltref.asp?
- clear tutorials:
http://www.topxml.com/xsl/tutorials/intro/

I download a time-limited demo of 'MarrowSoft Xselerator 2.5'
http://www.topxml.com/xselerator/

It is an excellent tool. Armed with good book, online tutorials and sample files
it gives one confidence to precessed quickly. As I started experimenting with
XSLT in Leo, I found it invaluable to check my  code, Leo's own XML. It is very
enlightening to view the the same code in different display modes and apply
then small XSL functions in another window. Especially working with a .leo files
loaded into the left-hand XML frame, and XSL in the right one can appreciate
teh poopwerful scope of Leo and XSLT. The toolsaves tmie becuae it validates
and gives helpful messages. The processor is there so no installation confusions
either. Good interface. Working with Xselerator interface also helped me think
more broadly about Leo's, and where this creative creature belongs!

I did not appreciate until now that XSL really is a language. There's an more
advanced article abuot that some of you may like:

The Functional Programming Language XSLT - A proof through examples
http://www.topxml.com/xsl/articles/fp/default.asp
</t>
<t tx="T756">It would be great to have script-oriented searching, like icon or snobol.

We could have 3 radio buttons:

plain text
pattern match
script</t>
<t tx="T757">I will wait. Here's clarification, when you're ready for it:

All of my projects are stored on remote computers, and accessed via FTP. 
What I want is basically the ability to open up these projects directly 
through leo, instead of transferring the files manually between my computer 
and the computers that hold my projects, preferably through FTP.

My solution: A new menu item called 'FTP' or 'Remote'. Click on this, and an 
FTP dialog opens up, with an empty list of FTP sites, and the ability to add 
more. You select a site, and it brings up a list of files. You select a 
file, and it is added to your project. When you hit 'save', it automatically 
does an FTP send.

Python makes this a lot easier with the builtin module 'ftplib'. I'm sure 
there are similar things for C++. I hope you take this idea into 
consideration.

Scott Powell
CEO, Dev Designs
</t>
<t tx="T758">This is done automatically now!  I may have to use configure events.

&gt; When I have the 'split mode' set to display tree and log on left, and viewpane
on right, I sometimes need to increase the width of the window.

When I do the resize, the tree/log panes grow in proportion. I don't know about
others, but I'd much prefer if the tree/log panes stayed at the same width,
and only the view pane grew.
</t>
<t tx="T759">I'm using Leo.py on Win98 to generate @root files. I've noticed that if I have a node that is empty except for &lt;&lt;Section Name&gt;&gt;=, I get "Undefined section: &lt;&lt;Section Name&gt;&gt;" error messages. I added a comment to each of the empty sections, and the error messages went away. 

Is there some way to avoid this? In this case, the empty sections are there for possible future growth, or just to keep appearances consistent between models. 
</t>
<t tx="T760">@ This code contributed by Fred Gansevles. 

@color</t>
<t tx="T761">@first #!/usr/bin/env python2.2
@ignore
@language python

import tokenize, pprint

""" Parse python-style programs
The main 'program' is a tree with sub-programs as nodes.
Every sub-program is introduced by either 'class' or 'def'
"""

@others

if __name__ == '__main__':
	import sys
	if len(sys.argv) &gt; 1: scanPythonText(open(sys.argv[1]).read())
	else: scanPythonText(sys.stdin.read())
</t>
<t tx="T762">class Parser:
	@others
</t>
<t tx="T763">class StringBuffer:
	""" StringBuffer -- simplified StringIO
	This StringBuffer is used to deliver the lines for tokenize.
	a slice returns the lines from StringBuffer, i.e.
		stringBufferInstance[0:1]
	returns the first line"""
	
	@others</t>
<t tx="T764">def __init__(self, s):
	self.buf = s
	self.indices = [0]
	self.pos = 0
	self.len = len(s)
</t>
<t tx="T765">def __call__(self):
	pos = self.pos
	self.pos = self.buf.find('\n', self.pos) + 1
	# fill the inices on-the-fly
	self.indices.append(self.pos)
	return self.buf[pos:self.pos]
</t>
<t tx="T766">def __getslice__(self, start_i, end_i):
	start = self.indices[start_i]
	end = self.indices[end_i]
	return self.buf[start:end]
</t>
<t tx="T767">class Body:

	@others</t>
<t tx="T768"># --- Leo ---
# ---
# --- a vnode parameter should be passed to __init__ here
# ---
# --- Leo ---

def __init__(self, parser, start):
	self.parser = parser
	self.start = start
	# start holds the starting sbuf-index from tokenize to remember
	# the start position in the input-string that belongs to the
	# current body
	if self.start == 0:
		# we start at the beginning of the input-string, so
		# this is the top-level Body-instance.
		# in a module-context, the last DEDENT doesn't leave the
		# context, so set it to 1 to avoid 'pop'-ing the eater to soon
		self.level = 1
	else:
		# in a def- or class-context, the last DEDENT leaves the
		# context, so if it reaches 0 again, pop the current eater
		self.level = 0
	self.lines = []
	# make sure that an empty line is not interpreted as a one-liner
	self.last = (tokenize.OP, ':')
	# give the parser a token-eater for the current context
	parser.eater.append(self)</t>
<t tx="T769">def __call__(self, type, token, (srow, scol), (erow, ecol), line):
	if type in (tokenize.NEWLINE, tokenize.NL):
		# when a NL or NEWLINE token is encountered, start is set
		# to the next line because all the lines from start upto
		# end belong to this body
		# since StringBuffer-slicing counts from 0 and the tokenize
		# start- and end-tuples count from 1, the erow value points to
		# the beginning of the next line
		start = self.start
		self.start = erow
		if not self.lines:
			# this is the line containing 'def' or 'class'
			if self.last &lt;&gt; (tokenize.OP, ':'):
				# one-liner, so 'inject' a DEDENT
				self.level += 1
				type = tokenize.DEDENT
		# --- Leo ---
		# --- 
		# --- this is where 'parent.appendStringToBody(s[start:])
		# --- from leoImport.py must be placed, instead of
		# --- self.lines.append(...)
		# --- 
		# --- Leo ---
		self.lines.append(self.parser.sbuf[start:self.start])
	if type == tokenize.NAME and token in ('def', 'class'):
		# --- Leo ---
		# --- 
		# --- this is where 'self.createHeadline(parent, ...)
		# --- from leoImport.py must be placed, instead of
		# --- self.lines.append(...)
		# --- 
		# --- Leo ---
		decl = line.split()[1]
		name = decl.split('(')[0].strip()
		if token == 'class':
			self.lines.append("&lt;&lt; class %s &gt;&gt;\n" % name)
		else:
			self.lines.append("&lt;&lt; %s &gt;&gt;\n" % name)
		# recurse into the class, method or function context
		# --- Leo ---
		# ---
		# --- a vnode parameter should be passed to Parser.Body() here
		# ---
		# --- Leo ---
		Parser.Body(self.parser, self.start)
	elif type == tokenize.INDENT:
		self.level += 1
	elif type == tokenize.DEDENT:
		self.level -= 1
		# if the level is 0 we leave the current context
		if self.level == 0:
			# --- Leo ---
			# ---
			# --- replace the next line with
			# ---	self.parser.eater.pop()
			# --- when using this code in leoImport.py
			# ---
			# --- Leo ---
			self.parser.parsed.append(self.parser.eater.pop())
			# the rest of the input-string belongs in the previous
			# context
			if self.parser.eater:
				self.parser.eater[-1].start = self.start
	elif type == tokenize.ENDMARKER:
		# we're done
		# --- Leo ---
		# ---
		# --- replace the next line with
		# ---	self.parser.eater.pop()
		# --- when using this code in leoImport.py
		# ---
		# --- Leo ---
		self.parser.parsed.append(self.parser.eater.pop())
	self.last = (type, token)
</t>
<t tx="T770">def __repr__(self):
	return ''.join(self.lines)
</t>
<t tx="T771"># --- Leo ---
# ---
# --- a vnode parameter should be passed to __init__ here
# ---
# --- Leo ---
def __init__(self, s):
	self.sbuf = Parser.StringBuffer(s)
	# every Body instance appends itself to this list and removes
	# itself if the body-context is completely parsed.
	self.eater = []
	# after parsing a body-context, the body instance appends itself to
	# this list so scanPythonText() can print the result.
	# If this is used in leoImport.py this list is no longer needed.
	self.parsed = []
	# --- Leo ---
	# ---
	# --- a vnode parameter should be passed to Parser.Body() here
	# ---
	# --- Leo ---
	Parser.Body(self, 0)
</t>
<t tx="T772">def readline(self):
	return self.sbuf()
</t>
<t tx="T773">def tokeneater(self, *args):
	# defer the call to the current context
	self.eater[-1](*args)
</t>
<t tx="T774">def scanPythonText (s,parent = None):
	# --- Leo ---
	# ---
	# --- a vnode parameter should be passed to Paser() here
	# ---
	# --- Leo ---
	parser = Parser(s)
	tokenize.tokenize(parser.readline, parser.tokeneater)
	print pprint.pformat(parser.parsed)[1:-1],
</t>
<t tx="T775">Just like to make a note here, about mind-maps. 

There is a wxpython application to 
manage structured data. It's "gimini"; and it's on sourceforge as well. 

see 
http://sourceforge.net/projects/gimini 

I falled in love with it once, and hope it will grow into an even 
easier tool to manage structure. But it has stop the development 
for some time. Now I fall in love with leo, which is even easier 
to use. 

Still, one thing I miss in mind-map is the spartial connection that 
let me access the data even quicker. I remember the position of 
each idea on the map, and just look around there. 

Thank you very much for leo. I think my way of working with 
data will change forever. </t>
<t tx="T776">@nocolor

These would be minor projects.  There is no rush...</t>
<t tx="T777">How about a Emacs style meta-key(Esc?) followed by up or down? or F1/F2 ? anything to escape having to hold down three keys at the same time -- which seems to be common to other shortcut combinations too. so if you could put this in as an option in the preferences -- to turn on or off meta-key binding, that would let people choose what they prefer...

EKR:  This would require Leo to remember state in the event handlers.  It could be done, and having user-configurable shortcuts should reduce the need for this considerably.</t>
<t tx="T778">I'd like to see leo's @file can be extended to cover more protocols, like REBOL's "read" does. 

in short, it would be very sweet if the following work: 

@file http://www.somedomain.org/python/foo.py 

@file pass@ftp.sd.org/python/foo.py" target="_blank" target="_new"&gt;ftp://user:pass@ftp.sd.org/python/foo.py&gt; 

while we are at it, what about xmlrpc/soap? 

should there be new directive, like @source ?</t>
<t tx="T779">I want to share a large Leo outline. New ideas come up aso people wnat ot keep adding fresh node headings and content. Often that content is clones from of toher distant parts of the tree. So one has to go off and search them, then create clone and drag it back to the new context wher yuo want to use it. I found quickly this is quite diffiucult to navigate. A lot of searching back an and forth and scrolling. Hard to keep a sequence. 

I tried using the 'mark' functions [ctrl+ m, alt+m] 
They are good,I cannot see how one can control them very well. ALT+m just keeps jumping one around the tree unitl it has visited all the marks. 

In many cases I imagine one simply needs to open a node, mark it and then jamp bacc to the last/previous node. Else do the same thing with marks. 

But what I am really looking for is a way to create a list of marks, and then be able to step through them sequentially. 

I think there is great uses for this. Your How-to for example lists a sequence of steps programmers need to follow. 

Imagine if one had an efficient 'Leo way' to help that How-to creation process. Or to preparare a review sequence to co-authors, colleagues, managers etc.. Or for tutorials and other Leo applications. 

Yes this is largely what Screenbook Maker XSLT does. But why not keep the functionality right within Leo. 

It could work along the lines of macro/history used in prgorams like photoshop. 

1. start sequence recorder, naming a sequence 
2. perform action, in this case navigate to the node you want. 
3. mark it to be added to the sequence 
4. go on to the next one 
5.repeat until done 
6. end sequence 

Using it 
7. Select "go to sequence" from menu or click on a Leo 'sequence' node. 
8. alt+something lets you jump through the list 
9. at the end you return to the beginning 

Editing 
10. It is important to be able to edit these on fly 
11. add delete reorder 
12. renaming shoudl also be allowed 

TreeSeqs 
13. Since this is Leo, people may naturally want to join sequences and thus add branches to existing sequences. This gets a little tricky becuase a sequence is by default a linear progression. 
So how best to enable the switch/troute action when it meets a branch? 

Status feedback 
14. Dedicated Leo sequence nodes should perhaps be a separate category with a graphic icon/fill color to help see them. Irefer to nodes which are a full set of sequences. 

15. likewise we should perhaps add an @seq symbol 

16. But also one may want to just embed seqs within other ergular Leo nodes, content. When we add a node to part of sequence how best to indicate. marked nodes geta little red vertical line. Sequenced marks should indicate, pehaps via its index number within the seqquence.The Leo log window coudl give more info. 

17. A sequence syntax might be: 
@seq seqname seqindex seqtitle 

seqname - unique name of leo sequence local to this .leo file 
examples: "howto33" or "gettingstarted" 

seqindex - unique integer controlling where this netry appears in the named Leo sequence 

seqtitle - text string which is more human readable than seqname' For the sequence itself this would be its disaplyed title. Wihtin a sequence for an entry, it woudl be the huam readbale idplasy title to ct as a metadata alais to its Leo node name. This improtant because the use context may change but we donlt want to fuck up the existing base Leo outline in any way. 

Conversions 
18. Sometimes you may want to take an exisiting bnode and sub-nodes and be able to do a "print-to-seq" on them. For example you already have 'diary' entries which have a clear historical order. But it might be useful to generate a Leo sequence of those. Then perhaps edit he sequence so it just highlights key events in the diary. Likewise any set of changes and extensions to a project. 

Implementation 
19. I imagine 90% of what I propose already exists in Leo. For many situation sequences are not suitable. People wil want ot be freeer. But for others, especially in project planning, management, presentation, training and fast review, I think they are invaluable. I see sequences as a full complent to Leo existing modes. 

20. I would be delighted to work on this, but need tmie as I am a complete Leo beginner. It is topic I spend a lot time with. Among possible tools to help prgram this there are sequential dictionaries. The module I like and have used in the past is by 'seqdict' by Wolfgang Grafen: 

http://home.germany.net/100-366919/Python/Modules/Modules.html 

I used it in conjucntion with the wonderful mxDateTime package for a Zope project about 2 years ago. 
http://www.egenix.com/files/python/mxDateTime.html 

./Jason 
</t>
<t tx="T780">http://zope.org/

Yeah, it's a 'big' one.

I'm probably trolling for a Zopista (Zope developer), not asking you to do anything,
I expect the work would require more Zope experience than Leo.

The vision is something like this:

I install the ZLeo product on my Zope site.
Configuring it involves filling in a form with the location of a .leo file in
my filesystem.

Now there exists a URL (http://mysite/zope/leo) which consists of an HTML version
of my Leo file. (The ZLeo product has used an XSLT file to transform the Leo
XML into HTML)

The structure of the Leo file has been translated to list elements and
hyperlinks.

My Leo file is viewable in it's last saved state by anyone who points their
browser at the URL.

</t>
<t tx="T781">Requires platform-independent time-stamp in file format.</t>
<t tx="T782">The following items might be nice, and they just don't seem very important to me.</t>
<t tx="T783">This may not be possible in Python.

A "Recent Files" menu is sufficient.</t>
<t tx="T784">It might be nice to view versions/branches as leo outlines and nodes. If Leo could check in/out files from CVS ... cool. 

Also, could 'synthetic' outlines be made which have (almost) dynamic data in them such as an outline view of /var/log/messages with nodes by year month day or by severity etc? Since Leo is extensible this might be a doable &amp; worthwhile project. </t>
<t tx="T785">Basically, javadoc in the following form: 

/** 
* Returns a JNDI context that can be used to lookup 
references 
* to EJB's. 
*/ 

appears like this after a save: 

/* 
* * Returns a JNDI context that can be 
used to lookup references * to EJB's. 
*/ </t>
<t tx="T786">Contract All keeps current text pane 

Leo/PC 1.13 Windows 98SE/J 

Category: Editor/Display 

Clicking on [-] of the root node in the LEO file displays the text pane of the root node. 
Contract All should probably do the same. It keeps open the text pane that was open before. 
</t>
<t tx="T787">Leo/PC 1.13 Windows 98SE/J 

Category: Editor/Clipboard

Make a node with empty header and empty body. 
With that header selected. 
Shift-Ctrl-C 
Shift-Ctrl-V 
Errors: 
1. The clipboard is not a valid Leo outline. 
2. The clipboard is not a valid LEO file. 

Type this in the header: head 
With that header selected. 
Shift-Ctrl-C 
Shift-Ctrl-V 
The same errors persists. 

Type this in the text: 
--- Top --- 
text 
--- End --- 
The same errors persists. 

Type this in the text: 
--- Top --- 
&lt;&lt; chunk &gt;&gt;= 
--- End --- 
The same errors persists. 

Type this in the text: 
--- Top --- 
&lt;&lt; chunk &gt;&gt;= 

--- End --- 
The same errors persists. 

Type this in the text: 
--- Top --- 
&lt;&lt; chunk &gt;&gt;= 
@ 
--- End --- 
The node is now copied. 

Sometimes it is not possible to get out of this state when no node can be copied to the clipboard. 
I have to close the file and load it again to clear the problem. </t>
<t tx="T788">@ignore

Leo/PC 1.13 Windows 98SE/J 

Category: Tangle/Error handling

I copied a @root directive and forgot to change the file name. 
I had something like this: 

@root ./a.txt 
@ 

@root ./a.txt 
some text 
@ 

Ctrl-Shift-A resulted in a never ending Tangle run, 
with repeated line in the log window: 
Unchanged: ./a.txt 

I did not find a way to stop this. I had to shut down Windows. 
I am afraid to repeat this. If you cannot reproduce this problem, I will try again. </t>
<t tx="T789">This isn't really useful.  There are plenty of ways to do this as it is.</t>
<t tx="T790">This might be cute, but it really isn't useful.  And it might cause problems with clones.</t>
<t tx="T791">Possible option: ignore all comments.
Possible option: recurse into subdirectories.
			
I had originally thought that the following options would be good to have. (leoComparePanel.browser would have brought up a panel with these options on it.)  I have my doubts now: it's easy enough for the user to create derived files in some directory.  It's probably best to separate file creation from file comparison.

radio box: Select file
radio box: Select all files in directory
radio box: Select all files in directory with extension: box
radio box: Use nodes from outline (give name)
	radio box: Use nodes in selected outline
	radio box: Use nodes in entire outline
	
	radio box: Use only @file nodes
	radio box: Use only @file nodes
	radio box: Use both @file and @root nodes</t>
<t tx="T792">The pain of making the switch from Windows to GNU/Linux is notorious throughout the community. The effort involved is not so much learning, but unlearning, since Windows creates what many feel to be an inaccurate over-simplified user interface. 

If you want a GNU/Linux variant that's as easy, or easier than, Windows, you need not look any further than Mandrake 8.2+. Mandrake is an excellent attempt at creating a truly 'desktop-friendly' Linux that doesn't seek to drag its users into the technical entrails. Nearly all of its configuration is done via GUI programs. 

However, I personally find dual-booting to be a right royal pain. It trashes the flow of thought, and makes for frustrating time delays. 

So your best options are either 
* Dedicated Linux box, running headless, using your existing WinXP box as an X server (using Cygwin X server, or a shareware X server), or 
* Install VMware onto your WinXP desktop. It runs an accurate emulation of a PC, in a window - BIOS and all. You can simply install GNU/Linux into this 'simulated' VMware box. - no need to reboot your PC in order to run Linux. 

One of the most startling things about GNU/Linux is the fact that nearly all of the 6000+ available programs are free of charge, contain no spyware, and don't impose any sneaky restrictions (for example, it's illegal to develop a Word Processor or Spreadsheet with ActivePython, due to its use of MFC). 

I was a totally committed Windows user 18 months ago. Today, I'm almost at the point of asking 'what's Windows?'. </t>
<t tx="T793">Fortunately, Linux can be installed even on cheap machines. For as little as $80 you could get yourself a P133 box or similar, and run it as a headless system - ssh in and use your Windows box as an X server. 

That, a couple of cheap NICs and a crossover cable, and that's all the hardware you need. 

The Cygwin environment gives you everything you need to run X in your Windows environment. 
</t>
<t tx="T794">There have been a couple different suggestions on how to obtain a .leo file
that presents the conflicts for resolution.  My initial thought was to have
some sort of external file containing only the structure information of interest.
Edward has suggested that we could process the CVS created .leo file with all
its conflict indicators.

I'd like to offer another alternative: based on the ad-hoc procedure that Edward
is currently using, i.e.,

* Save your work to foo.leo file.
* copy your foo.leo file to fooCvsTmp.leo
* cvs ci
* if there are no conflicts (hurray)
*    remove fooCvsTmp.leo; finished
* otherwise
*    remove foo.leo
*    cvs up foo.leo
*    read foo.leo into an internal directed acyclic graph (DAG)
*    generate the conflict resolution DAG from the proposed new leo internal
DAG (which Leo already has as a matter of course) and the CVS derived DAG
*    present for editting
*    when you are satisfied and want to try to check in again, repeat.

From the user's point of view, a CVS check in either succeeds or requires that
the conflicts be resolved, after which another check in may be attempted.  If
we're somehow interrupted in the middle of the process, the fooCvsTmp.leo file
preserves the users work.
</t>
<t tx="T795">These may indicate problems with Tk on Linux.  I can not reproduce them on XP.</t>
<t tx="T796">(In Linux) The home page and online tutorial options in the menu only work properly if Mozilla window is already open. If not, a Mozilla window opens, but with empty page and url field. </t>
<t tx="T797">When in 'vertical split' mode (with viewpane on right, and tree pane over log pane on left), the horixontal scrollbar at bottom of screen is at full width, despite the fact that not all of the tree pane area is displayed. 

Another way of saying this - I narrow the tree and log panes, to the extent that the display of tree node headings is truncated. But the horizontal scrollbar at the bottom doesn't contract, and doesn't allow me to horizontally scroll the tree pane to expose the rest of the node headings. 
</t>
<t tx="T798">This has been and continues to be a known issue with Tk. Has been logged as a bug; no response from the Tk folks. 

Here is a link to the Tk bug report: 

http://sourceforge.net/tracker/?func=detail&amp;aid=605277&amp;group_id=12997&amp;atid=112997 

Note the work-around/patch in the followup post at the bottom of that page. Commenting out some statements in text.tcl removes the problem. 
</t>
<t tx="T799">The following bugs can not be fixed because they are Tk bugs.</t>
<t tx="T800">Using leo under Windows, the keyboard shortcuts seem to use the "Caps Lock" state in determining the shift state when executing a shortcut.   For example, if the caps-lock key is on, then Ctrl-X is interpreted as Shift-Ctrl-X and cuts a node rather than selected text, and Shift-Ctrl-X is interpreted as Ctrl-X and cuts text.
</t>
<t tx="T801">1. The border of the tree control is gray, and it is overwritten with large headlines.  This may be a Tk or Tkinter bug.

2. Adding trailing whitespace to a line in body text does not set the file-dirty mark.  This can never cause a derived file to become "out-of-synch" because the read code does not compare body text.

Apparently there is no way to fix this glitch because of holes in Tk's event mechanism.  Specifically, tree.idle_body_key has no way to tell directly what keystroke caused it to be entered.</t>
<t tx="T802">Create a Tk demo for each bug.</t>
<t tx="T803">Using leo under Windows, the keyboard shortcuts seem to use the "Caps Lock" state in determining the shift state when executing a shortcut. 

If my caps-lock key is on, then Ctrl-X is interpreted as Shift-Ctrl-X and cuts a node rather than selected text, and Shift-Ctrl-X is interpreted as Ctrl-X and cuts text.</t>
<t tx="T804">@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1765069
By: dalcolmo

I use the bindings that come with Leo:

[keyboard shortcuts]
pastenode = Shift+Ctrl+V
gonextvisible = Alt+DnArrow
importtofile = Shift+Ctrl+F
writefilenodes = Shift+Ctrl+W
editheadline = Ctrl+H
markchangeditems = Alt+C
replace = Ctrl+=
goprevvisible = Alt+UpArrow
gotonextmarked = Alt+M
readoutlineonly = Shift+Ctrl+R
extractnames = Shift+Ctrl+N
gonext = Alt+Shift+DnArrow
findpanel = Ctrl+F
close = Ctrl+W
demote = Ctrl+}
tangle = Shift+Ctrl+T
extract = Shift+Ctrl+D
openpythonwindow = Alt+P
marksubheads = Alt+S
saveas = Shift+Ctrl+S
cut = Ctrl+X
preferences = Ctrl+Y
equalsizedpanes = Ctrl+E
cantundo = Ctrl+Z
open = Ctrl+O
promote = Ctrl+{
sortsiblings = Alt-A
unmarkall = Alt+U
mark = Ctrl+M
showinvisibles = Alt+V
exit = Ctrl-Q
insertnode = Ctrl+I
findprevious = F4
converttabs = Shift+Ctrl+J
save = Ctrl+S
tanglemarked = Shift+Ctrl+M
moveup = Ctrl+U
copynode = Shift+Ctrl+C
contractparent = Alt+0
selectall = Ctrl+A
setfont = Alt+Shift+T
aborteditheadline = Shift+Esc
goback = Alt+Shift+UpArrow
toggleactivepane = Ctrl+T
findnext = F3
tangleall = Shift+Ctrl+A
endeditheadline = Esc
deletenode = Shift+Ctrl+BkSp
cantredo = Shift+Ctrl+Z
new = Ctrl+N
contractall = Alt+1
moveleft = Ctrl+L
copy = Ctrl+C
paste = Ctrl+V
convertblanks = Shift+Ctrl+B
expandall = Alt+9
markchangedroots = Alt+R
cutnode = Shift+Ctrl+X
indent = Ctrl+]
gotonextchanged = Alt+D
expandnextlevel = Alt+=
setcolors = Alt+Shift+S
matchbrackets = Ctrl+K
movedown = Ctrl+D
clonenode = Ctrl+`
untangle = Shift+Ctrl+U
expandtolevel7 = Alt+7
expandtolevel6 = Alt+6
expandtolevel5 = Alt+5
expandtolevel4 = Alt+4
expandtolevel3 = Alt+3
expandtolevel2 = Alt+2
moveright = Ctrl+R
unindent = Ctrl+[
replacethenfind = Ctrl+-
extractsection = Shift+Ctrl+E
expandtolevel8 = Alt+8


However, I use a utility called AllChars (Free as in beer :-(  ) to be able
to type all kinds of chars on my US keyboard, and "Handything" to place the
windows on the screen (Win2000). Perhaps this makes a difference, although disabling
them did not seem to make it go away. Still, on pressing alt+ctrl+uparrow I
end up at the next upper node etc...

- Josef

</t>
<t tx="T805">@color</t>
<t tx="T806"># This file creates tk test code for prototyping.
@language tcltk
@others

go</t>
<t tx="T807">proc go {} {
	# createLeo 1
	# createLeo 2
	# createFindPanel
	# createPrefsPanel
	# createColorPanel
	# toplevel .font
	# createFontPanel .font
	# createComparePanel
	# createWindowWithIcon
	# createWindowWithCursor
}
</t>
<t tx="T808">proc createLeo { n } {

	toplevel .leo$n

	# Create two splitters
	createSplitter .leo$n.s 1
	createSplitter .leo$n.s.pane1.s 0 ;# contains tree and log
	
	text      .leo$n.s.pane2.body -bd 2 -yscrollcommand ".leo$n.s.pane2.scroll set" -setgrid 1
	scrollbar .leo$n.s.pane2.scroll -command ".leo$n.s.pane2.body yview"

	pack .leo$n.s.pane2.scroll -side right -fill y
	pack .leo$n.s.pane2.body -expand yes -fill both

	text .leo$n.s.pane1.s.pane1.tree -bd 2 -yscrollcommand ".leo$n.s.pane1.s.pane1.scroll set" -setgrid 1
	scrollbar .leo$n.s.pane1.s.pane1.scroll -command ".leo$n.s.pane1.s.pane1.tree yview"
	
	pack .leo$n.s.pane1.s.pane1.scroll -side right -fill y
	pack .leo$n.s.pane1.s.pane1.tree   -expand yes -fill both

	# -padx is needed to handle overlap of splitter bar
	text      .leo$n.s.pane1.s.pane2.log    -yscrollcommand ".leo$n.s.pane1.s.pane2.scroll set" -setgrid 1 -padx 4
	scrollbar .leo$n.s.pane1.s.pane2.scroll -command ".leo$n.s.pane1.s.pane2.log yview"
	pack .leo$n.s.pane1.s.pane2.scroll -side right -fill y
	pack .leo$n.s.pane1.s.pane2.log -expand yes -fill both
	
	createMenus $n
}</t>
<t tx="T809">proc createMenus { n } {

	# Create the menu bar
	menu .leo$n.menu -tearoff 0

    set m .leo$n.menu.file
    menu $m -tearoff 0

    .leo$n.menu add cascade -label "File" -menu $m -underline 0
	# to do: fill in the commands...
    $m add command -label "Open..." -command {""}
    $m add command -label "New" -command {""}
    $m add command -label "Save" -command {""}
    $m add command -label "Save As..." -command {""}
    $m add separator
    $m add command -label "Print Setup..." -command {""}
    $m add command -label "Print..." -command {""}
    $m add separator
    $m add command -label "Quit" -command "destroy ."
	
	.leo$n configure -menu .leo$n.menu
}</t>
<t tx="T810"># Create a splitter window into which the caller packs widgets.

proc createSplitter {w verticalFlag} {
	# verticalFlag, height, width could be params
	frame $w -width 4i -height 3i
	frame $w.pane1
	frame $w.pane2
	if { $verticalFlag } {
		# Panes arranged vertically; horizontal splitter bar
		frame $w.bar -height 7
		place $w.pane1 -relx 0.5 -rely   0 -anchor n -relwidth 1.0 -relheight 0.5
		place $w.pane2 -relx 0.5 -rely 1.0 -anchor s -relwidth 1.0 -relheight 0.5
		place $w.bar   -relx 0.5 -rely 0.5 -anchor c -relwidth 1.0
		bind $w.bar &lt;ButtonPress-1&gt;		"onGrabSplitterBar $w 1"
		bind $w.bar &lt;B1-Motion&gt;			"onDragSplitterBar $w 1 %y"
		bind $w.bar &lt;ButtonRelease-1&gt;	"onDropSplitterBar $w 1 %y"
	} else {
		# Panes arranged horizontally; vertical splitter bar
		frame $w.bar -width 7
		place $w.pane1 -rely 0.5 -relx   0 -anchor w -relheight 1.0 -relwidth 0.5
		place $w.pane2 -rely 0.5 -relx 1.0 -anchor e -relheight 1.0 -relwidth 0.5
		place $w.bar   -rely 0.5 -relx 0.5 -anchor c -relheight 1.0
		bind $w.bar &lt;ButtonPress-1&gt;		"onGrabSplitterBar $w 0"
		bind $w.bar &lt;B1-Motion&gt;			"onDragSplitterBar $w 0 %x"
		bind $w.bar &lt;ButtonRelease-1&gt;	"onDropSplitterBar $w 0 %x"
	}
	# Borderwidth required
	$w.bar configure -borderwidth 2 -relief raised -background LightSteelBlue2 
	pack $w -expand yes -fill both
}
</t>
<t tx="T811">proc onGrabSplitterBar {w verticalFlag} {

	# We should change the cursor here.
	
	# Changing the relief is pointless.
		# $w.bar configure -relief sunken
	
	# Changing colors is really bad
		# $w.bar configure -relief sunken -background LightSteelBlue4
		# $w.bar configure -background LightSteelBlue4
}</t>
<t tx="T812">proc onDropSplitterBar {w verticalFlag xy} {

	# We should reset the cursor here.
	$w.bar configure -relief raised -background LightSteelBlue2
}
</t>
<t tx="T813"># xy is the coordinate of the cursor relative to the bar, not the main window.

proc onDragSplitterBar {w verticalFlag xy} {

	if { $verticalFlag } {
		# Panes arranged vertically; horizontal splitter bar
		set wRoot	[winfo rooty $w]
		set barRoot [winfo rooty $w.bar]
		set wMax	[winfo height $w]
	} else {
		# Panes arranged horizontally; vertical splitter bar
		set wRoot	[winfo rootx $w]
		set barRoot [winfo rootx $w.bar]
		set wMax	[winfo width $w]
	}
	set offset [expr double($barRoot) + $xy - $wRoot ]
	# Adjust the pixels, not the frac.
	if { $offset &lt; 3 } { set offset 3 }
	if { $offset &gt; [expr $wMax - 2] } { set offset [expr $wMax - 2] }
	set frac [ expr double($offset) / $wMax ]
	# This redraws the splitter as the drag is occuring.
	# We could also redraw in onDropSplitterBar for non-dynamic updates.
	divideSplitter $w $verticalFlag $frac
	return $frac ;# No longer used
}</t>
<t tx="T814">proc divideSplitter {w verticalFlag frac} {

	if { $verticalFlag } {
		# Panes arranged vertically; horizontal splitter bar
		place $w.bar -rely $frac
		place $w.pane1 -relheight $frac
		place $w.pane2 -relheight [expr 1 - $frac]
	} else {
		# Panes arranged horizontally; vertical splitter bar
		place $w.bar -relx $frac
		place $w.pane1 -relwidth $frac
		place $w.pane2 -relwidth [expr 1 - $frac]
	}
}</t>
<t tx="T815">proc createFindPanel {} {

	toplevel .find
	&lt;&lt; Create the Find and Change panes &gt;&gt;
	&lt;&lt; Create two columns of checkboxes &gt;&gt;
	&lt;&lt; Create two rows of buttons &gt;&gt;
}
</t>
<t tx="T816">frame .find.fc -bd 1m
pack  .find.fc -anchor n -expand yes -fill x

frame .find.fc.fpane -bd 1 -height 0.95i -width 1.5i
frame .find.fc.cpane -bd 1 -height 0.95i -width 1.5i

pack  .find.fc.fpane -anchor n -expand yes -fill x
pack  .find.fc.cpane -anchor s -expand yes -fill x

# Create the labels and text fields.
label .find.fc.fpane.lab -width 8 -text "Find:"
label .find.fc.cpane.lab -width 8 -text "Change:"
text  .find.fc.fpane.t -height 2 -width 20 ; # 2 lines, 20 characters
text  .find.fc.cpane.t -height 2 -width 20

pack  .find.fc.fpane.lab -side left 
pack  .find.fc.cpane.lab -side left
pack  .find.fc.cpane.t -side right -expand yes -fill both
pack  .find.fc.fpane.t -side right -expand yes -fill both
</t>
<t tx="T817">frame .find.boxes -bd 1m
pack  .find.boxes -anchor n -expand yes -fill x

frame .find.boxes.lt -bd 1
frame .find.boxes.rt -bd 1
pack  .find.boxes.lt -side left  -padx 5m
pack  .find.boxes.rt -side right -ipadx 2m

# Create the left column
checkbutton .find.boxes.lt.batch -anchor w -text "Batch"
checkbutton .find.boxes.lt.wrap  -anchor w -text "Wrap around"
checkbutton .find.boxes.lt.word  -anchor w -text "Whole word"
checkbutton .find.boxes.lt.case  -anchor w -text "Ignore case"
checkbutton .find.boxes.lt.pat   -anchor w -text "Pattern match"
pack .find.boxes.lt.batch -fill x
pack .find.boxes.lt.wrap  -fill x
pack .find.boxes.lt.word  -fill x
pack .find.boxes.lt.case  -fill x
pack .find.boxes.lt.pat    -fill x

# Create the right column
checkbutton .find.boxes.rt.headline -anchor w -text "Search Headline Text"
checkbutton .find.boxes.rt.body     -anchor w -text "Search Body Text"
checkbutton .find.boxes.rt.outline  -anchor w -text "Suboutline Only"
checkbutton .find.boxes.rt.mark     -anchor w -text "Mark Changes"
checkbutton .find.boxes.rt.markch   -anchor w -text "Mark Finds"
pack .find.boxes.rt.headline -side top -fill x
pack .find.boxes.rt.body     -side top -fill x
pack .find.boxes.rt.outline  -side top -fill x
pack .find.boxes.rt.mark     -side top -fill x
pack .find.boxes.rt.markch   -side top -fill x
</t>
<t tx="T818"># Create the button panes
frame .find.buttons -bd 1
pack  .find.buttons -anchor n -expand yes -fill x

frame .find.buttons2 -bd 1
pack  .find.buttons2 -anchor n -expand yes -fill x

# Create the first row of buttons
button      .find.buttons.find    -width 8 -text "Find"
checkbutton .find.buttons.reverse -width 8 -text "Reverse"
button      .find.buttons.findAll -width 8 -text "Find All"

pack .find.buttons.find    -pady 1m -padx 1m -side left
pack .find.buttons.reverse -pady 1m          -side left -expand 1
pack .find.buttons.findAll -pady 1m -padx 1m -side right

# Create the second row of buttons
button .find.buttons2.change     -width 8 -text "Change"
button .find.buttons2.changeFind           -text "Change, Then Find"
button .find.buttons2.changeAll  -width 8 -text "Change All"

pack .find.buttons2.change       -pady 1m -padx 1m -side left
pack .find.buttons2.changeFind   -pady 1m          -side left -expand 1
pack .find.buttons2.changeAll    -pady 1m -padx 1m -side right
</t>
<t tx="T819">proc createPrefsPanel {} {

	toplevel .prefs
	&lt;&lt; Create the Global Options frame &gt;&gt;
	&lt;&lt; Create the Tangle Options frame &gt;&gt;
	&lt;&lt; Create the Target Language frame &gt;&gt;
}</t>
<t tx="T820">frame .prefs.glob -bd 1m -relief groove
pack  .prefs.glob -anchor n -pady 1m -ipadx 1m -expand 1 -fill x

label .prefs.glob.title -text "Global Options..."
pack  .prefs.glob.title -pady 1m

# Page width &amp; page width
frame .prefs.glob.f
pack  .prefs.glob.f -anchor w -pady 1m -expand 1 -fill x

label .prefs.glob.f.lab -anchor w -padx 1m -text "Page width:"
text  .prefs.glob.f.txt -height 1 -width 4 ;# lines, characters
pack  .prefs.glob.f.lab .prefs.glob.f.txt -side left

label .prefs.glob.f.lab2 -padx 1m -text "Tab width:"
text  .prefs.glob.f.txt2 -height 1 -width 4 ;# lines, characters
pack  .prefs.glob.f.lab2 .prefs.glob.f.txt2 -side left

# Checkbuttons
checkbutton .prefs.glob.done -anchor w -text "Execute Leo_done.bat after Tangle"
checkbutton .prefs.glob.un   -anchor w -text "Execute Leo_un.bat after Tangle"
pack .prefs.glob.done .prefs.glob.un -fill x
</t>
<t tx="T821"># Frame and title
frame .prefs.tangle -bd 1m -relief groove
pack  .prefs.tangle -anchor n -ipadx 1m -expand 1 -fill x

label .prefs.tangle.title -text "Default Options..."
pack  .prefs.tangle.title -pady 1m

# Label and text
label .prefs.tangle.lab -anchor w -text "Default tangle directory"
text  .prefs.tangle.txt -height 1 -width 30 ;# width significant

pack  .prefs.tangle.lab           -padx 1m -pady 1m -fill x
pack  .prefs.tangle.txt -anchor w -padx 1m -pady 1m -fill x

# Checkbuttons
checkbutton .prefs.tangle.header -anchor w -text "Tangle outputs header line"
checkbutton .prefs.tangle.doc    -anchor w -text "Tangle outputs document chunks"
pack .prefs.tangle.header .prefs.tangle.doc -fill x
</t>
<t tx="T822"># Frame and title
frame .prefs.target -bd 1m -relief groove
pack  .prefs.target -anchor n -pady 1m -ipadx 1m -expand 1 -fill x

label .prefs.target.title -text "Default Target Language..."
pack  .prefs.target.title -pady 1m

# Frames for two columns of radio buttons
frame .prefs.target.lt 
frame .prefs.target.rt
pack  .prefs.target.lt -side left
pack  .prefs.target.rt -side right

## To do: make radio buttons functional.

# Left column of radio buttons
radiobutton .prefs.target.lt.c      -anchor w -text "C/C++"
radiobutton .prefs.target.lt.cweb   -anchor w -text "CWEB"
radiobutton .prefs.target.lt.html   -anchor w -text "HTML"
radiobutton .prefs.target.lt.java   -anchor w -text "Java"
radiobutton .prefs.target.lt.pascal -anchor w -text "Pascal"

pack .prefs.target.lt.c      -fill x
pack .prefs.target.lt.cweb   -fill x
pack .prefs.target.lt.html   -fill x
pack .prefs.target.lt.java   -fill x
pack .prefs.target.lt.pascal -fill x

# Right column of radio buttons
radiobutton .prefs.target.rt.perl   -width 12 -anchor w -text "Perl"
radiobutton .prefs.target.rt.pod              -anchor w -text "Perl + POD"
radiobutton .prefs.target.rt.plain            -anchor w -text "Plain Text"
radiobutton .prefs.target.rt.python           -anchor w -text "Python"

pack .prefs.target.rt.perl   -fill x
pack .prefs.target.rt.pod    -fill x
pack .prefs.target.rt.plain  -fill x
pack .prefs.target.rt.python -fill x
</t>
<t tx="T823">proc showColorPicker {} {
	tk_chooseColor
}

proc createColorPanel {} {

	toplevel .color
	wm title .color "Syntax Coloring"

	frame .color.f -bd 2 -relief groove
	pack  .color.f -anchor n -pady 2 -ipady 1 -ipadx 0 -expand 1 -fill x
	
	# label .color.f.lab -text "Choose syntax colors..."
	# pack  .color.f.lab -side top -fill x
	
	frame .color.f.docF -bd 2
	pack  .color.f.docF
	label .color.f.docF.lab -text "Doc parts:" -width 14 -anchor e
	button .color.f.docF.show -text "" -bg "red" -width 4
	button .color.f.docF.set -text "Set..." -command showColorPicker
	pack  .color.f.docF.lab .color.f.docF.show .color.f.docF.set -side left -padx 3
	
	frame .color.f.cF -bd 2
	pack  .color.f.cF
	label .color.f.cF.lab -text "Comments:" -width 14 -anchor e
	button .color.f.cF.show -text "" -bg "red" -width 4
	button .color.f.cF.set -text "Set..." -command showColorPicker
	pack  .color.f.cF.lab .color.f.cF.show .color.f.cF.set -side left -padx 3

	frame .color.f.sF -bd 2
	pack  .color.f.sF
	label .color.f.sF.lab  -text "Strings:" -width 14 -anchor e
	button .color.f.sF.show -bg "green" -width 4
	button .color.f.sF.set -text "Set..." -command showColorPicker
	pack  .color.f.sF.lab .color.f.sF.show .color.f.sF.set -side left -padx 3
	
	frame .color.f.kF -bd 2
	pack  .color.f.kF
	label .color.f.kF.lab  -text "Keywords:" -width 14 -anchor e
	button .color.f.kF.show -bg "blue" -width 4
	button .color.f.kF.set -text "Set..." -command showColorPicker
	pack  .color.f.kF.lab .color.f.kF.show .color.f.kF.set -side left -padx 3
	
	frame .color.f.dF -bd 2
	pack  .color.f.dF
	label .color.f.dF.lab  -text "Directives:" -width 14 -anchor e
	button .color.f.dF.show -bg "blue" -width 4
	button .color.f.dF.set -text "Set..." -command showColorPicker
	pack  .color.f.dF.lab .color.f.dF.show .color.f.dF.set -side left -padx 3

	frame .color.f.snF -bd 2
	pack  .color.f.snF
	label .color.f.snF.lab  -text "Section names:" -width 14 -anchor e
	button .color.f.snF.show -bg "red" -width 4
	button .color.f.snF.set -text "Set..." -command showColorPicker
	pack  .color.f.snF.lab .color.f.snF.show .color.f.snF.set -side left -padx 3

	frame .color.f.unF -bd 2
	pack  .color.f.unF
	label .color.f.unF.lab  -text "Undefined names:" -width 14 -anchor e
	button .color.f.unF.show -bg "orange" -width 4 
	button .color.f.unF.set -text "Set..." -command showColorPicker
	pack  .color.f.unF.lab .color.f.unF.show .color.f.unF.set -side left -padx 3
}</t>
<t tx="T824">proc createFontPanel {w} {

	frame $w.top
	frame $w.size -bd 2 -relief "ridge"
	frame $w.sample -bd 2 -relief "ridge"
	pack $w.top $w.size $w.sample -pady 2 -ipadx 5 -anchor w -fill both
	
	&lt;&lt; create family pane &gt;&gt;
	&lt;&lt; create style pane &gt;&gt;
	&lt;&lt; create buttons &gt;&gt;
	&lt;&lt; create size pane &gt;&gt;
	&lt;&lt; create sample pane &gt;&gt;
}</t>
<t tx="T825">frame $w.top.family -bd 2 -relief "ridge"
label $w.top.family.lab -text "family"
listbox $w.top.family.box
pack $w.top.family.lab $w.top.family.box -anchor w

frame $w.top.style -bd 2 -relief "ridge"
frame $w.top.right -bd 2 -relief "flat"
pack $w.top.family $w.top.style $w.top.right -side left -fill y -padx 2 -pady 2 ; # -ipadx 5 -ipady 5</t>
<t tx="T826">label $w.top.style.lab -text "Style"
pack  $w.top.style.lab -anchor w
foreach {name text} {
	b Bold
	i Italic
	u Underline
	o Overstrike
} {
	checkbutton $w.top.style.$name -text $text
	pack $w.top.style.$name -side top -anchor w -expand 1
}</t>
<t tx="T827">foreach {name text} {
	ok OK
	cancel Cancel
	apply Apply
} {
	button $w.top.right.$name -text $text -width 6
	pack   $w.top.right.$name -side top -anchor w -pady 2m ; # -expand 1
}</t>
<t tx="T828">frame $w.size.left
label $w.size.lab -text "Size"

text  $w.size.text -height 1 -width 4
pack  $w.size.lab -anchor w
pack  $w.size.left -side left
pack  $w.size.text -side left -fill x -expand 1

frame $w.size.left.row1
frame $w.size.left.row2
pack $w.size.left.row1 $w.size.left.row2 -side top

foreach {size} {
	8 12 18
} {
	radiobutton $w.size.left.row1.radio$size -text $size -variable size
	pack $w.size.left.row1.radio$size -side left
}
foreach {size} {
	10 14 24
} {
	radiobutton $w.size.left.row2.radio$size -text $size -variable size
	pack $w.size.left.row2.radio$size -side left
}</t>
<t tx="T829">label $w.sample.lab -text "Sample"
pack  $w.sample.lab -side top -anchor w

label $w.sample.text -text "ABCabcXYZxyz123(may be changed)"

# entry $w.sample.text -background [$w.sample cget -background]
# $w.sample.text insert 0 "ABCabcXYZxyz123(may be changed)"

pack $w.sample.text -side top -anchor c -expand 1 -fill none

# $w.sample.text insert 0 "ABCabcXYZxyz123(may be changed)"
# $w.sample.text configure -state disabled</t>
<t tx="T830">@ Build the font panel (except for the apply button, which is handled by the 'configure_apply procedure...
@c

proc origCreateFontPanel {w} {
	# Framed regions.  Do this with grid and labels, as that seems
	# to be the most effective technique in practise!
	frame $w.border1 -class DKFChooseFontFrame
	frame $w.border2 -class DKFChooseFontFrame
	frame $w.border3 -class DKFChooseFontFrame
	frame $w.border4 -class DKFChooseFontFrame
	set gap [get_gap $w]
	grid $w.border1 -row 0 -column 0 -rowspan 4 -columnspan 4 \
		-padx $gap -pady $gap -sticky nsew
	grid $w.border2 -row 0 -column 4 -rowspan 4 -columnspan 3 \
		-padx $gap -pady $gap -sticky nsew
	grid $w.border3 -row 4 -column 0 -rowspan 3 -columnspan 9 \
		-padx $gap -pady $gap -sticky nsew
	grid $w.border4 -row 7 -column 0 -rowspan 3 -columnspan 9 \
		-padx $gap -pady $gap -sticky nsew
	incr gap $gap
	foreach col {0 3 4 6 8} {
		grid columnconfigure $w $col -minsize $gap
	}
	foreach row {0 3 4 6 7 9} {
		grid rowconfigure    $w $row -minsize $gap
	}
	grid columnconfigure $w 1 -weight 1
	grid rowconfigure    $w 1 -weight 1
	grid rowconfigure    $w 8 -weight 1

	# Labels for the framed boxes &amp; focus accelerators for their contents
	foreach {subname row col focusWin} {
		Family 0 1 .family     
		Style  0 5 .style.sBold
		Size   4 1 .size.b8    
		Sample 7 1 .sample.text
	} {
		set l [label $w.lbl$subname]
		grid $l -row $row -column $col -sticky w
		## set accel [get_accel $l]
		## if {[string length $accel]} {
			## bind $w &lt;$accel&gt; [list focus $w$focusWin]
		##}
	}

	# Font families
	frame $w.familyBox
	listbox $w.family -exportsel 0 -selectmode browse \
		-xscrollcommand [list $w.familyX set] \
		-yscrollcommand [list $w.familyY set]
	scrollbar $w.familyX -command [list $w.family xview]
	scrollbar $w.familyY -command [list $w.family yview]
	##foreach family [list_families] {
	##	$w.family insert end ['map 'capitalise $family]
	##}
	grid $w.familyBox -row 1 -column 1 -rowspan 1 -columnspan 2 -sticky nsew
	grid columnconfigure $w.familyBox 0 -weight 1
	grid rowconfigure    $w.familyBox 0 -weight 1
	grid $w.family  $w.familyY -sticky nsew -in $w.familyBox
	grid $w.familyX            -sticky nsew -in $w.familyBox
	## bind $w.family &lt;1&gt; [namespace code {'change_family %W [%W nearest %y]}]
	## bindtags $w.family [concat [bindtags $w.family] key$w.family]
	## bind key$w.family &lt;Key&gt; [namespace code {'change_family %W active %A}]

	# Font styles.
	frame $w.style
	grid $w.style -row 1 -column 5 -sticky news
	grid columnconfigure $w.style 0 -weight 1
	foreach {fontstyle lcstyle row next prev} {
		Bold      bold       0 Italic    {}
		Italic    italic     1 Underline Bold
		Underline underline  2 Strikeout Italic
		Strikeout overstrike 3 {}        Underline
	} {
		set b $w.style.s$fontstyle
		checkbutton $b -variable [namespace current]::Style($lcstyle) \
			-command [namespace code 'set_font]
		grid $b -sticky nsew -row $row
		grid rowconfigure $w.style $row -weight 1
		if {[string length $next]} {
			## bind $b &lt;Down&gt; [list focus $w.style.s$next]
		}
		if {[string length $prev]} {
			## bind $b &lt;Up&gt; [list focus $w.style.s$prev]
		}
		## bind $b &lt;Tab&gt;       "[list focus $w.size.b8];break"
		## bind $b &lt;Shift-Tab&gt; "[list focus $w.family ];break"
		## set accel ['get_accel $b]
		## if {[string length $accel]} {
			## bind $w &lt;$accel&gt; "focus $b; $b invoke"
		## }
		## bind $b &lt;Return&gt; "$b invoke; break"
	}
	
	# Size adjustment.  Common sizes with radio buttons, and an
	# entry for everything else.
	frame $w.size
	grid $w.size -row 5 -column 1 -rowspan 1 -columnspan 7 -sticky nsew
	foreach {size row col u d l r} {
		8  0 0  {} 10 {} 12
		10 1 0   8 {} {} 14
		12 0 1  {} 14  8 18
		14 1 1  12 {} 10 24
		18 0 2  {} 24 12 {}
		24 1 2  18 {} 14 {}
	} {
		set b $w.size.b$size
		radiobutton $b -variable [namespace current]::Size -value $size \
			-command [namespace code 'set_font]
		grid $b -row $row -column $col -sticky ew
		#grid columnconfigure $w.size $col -weight 1
		## bif {[string length $u]} {bind $b &lt;Up&gt;    [list focus $w.size.b$u]}
		## bif {[string length $d]} {bind $b &lt;Down&gt;  [list focus $w.size.b$d]}
		## bif {[string length $l]} {bind $b &lt;Left&gt;  [list focus $w.size.b$l]}
		## bif {[string length $r]} {bind $b &lt;Right&gt; [list focus $w.size.b$r]}
		## bind $b &lt;Tab&gt;       "[list focus $w.size.entry ];break"
		## bind $b &lt;Shift-Tab&gt; "[list focus $w.style.sBold];break"
		## set accel ['get_accel $b]
		## if {[string length $accel]} {
			## bind $w &lt;$accel&gt; "focus $b; $b invoke"
		## }
		## bind $b &lt;Return&gt; "$b invoke; break"
	}
	entry $w.size.entry -textvariable [namespace current]::Size
	grid $w.size.entry -row 0 -column 3 -rowspan 2 -sticky ew
	grid columnconfigure $w.size 3 -weight 1
	## bind $w.size.entry &lt;Return&gt; [namespace code {'set_font;break}]
	
	# Sample text.  Note that this is editable
	frame $w.sample
	grid $w.sample -row 8 -column 1 -columnspan 7 -sticky nsew
	grid propagate $w.sample 0
	entry $w.sample.text -background [$w.sample cget -background]
	$w.sample.text insert 0 [option get $w.sample.text text Text]
	grid $w.sample.text
	
	# OK, Cancel and (partially) Apply.  See also 'configure_apply
	frame $w.butnframe
	grid $w.butnframe -row 0 -column 7 -rowspan 4 -columnspan 2 -sticky nsew -pady $gap
	foreach {but code} {
		ok  0
		can 1
	} {
		button $w.butnframe.$but -command [namespace code [list set Done $code]]
		pack   $w.butnframe.$but -side top -fill x -padx [expr {$gap/2}] -pady [expr {$gap/2}]
	}
	button $w.butnframe.apl
	## bind $w.butnframe.ok &lt;Down&gt; [list focus $w.butnframe.can]
	## bind $w.butnframe.can &lt;Up&gt; [list focus $w.butnframe.ok]
}</t>
<t tx="T831"># Convenience proc to get the accelerator for a particular window
# if the user has given one.  Makes it simpler to get this right
# everywhere it is needed...

proc get_accel {w} {
	option get $w accelerator Accelerator
}</t>
<t tx="T832"># Get the gap spacing for the frameboxes.  Use a user-specified
# default if there is one (that is a valid integer) and fall back
# to measuring/guessing otherwise.
proc get_gap {w} {
	set gap [option get $w lineGap LineGap]
	if {[catch {incr gap 0}]} {
		# Some cunning font measuring!
		label $w._testing
		set font [$w._testing cget -font]
		set gap [expr {[font metrics $font -linespace]/2+1}]
		destroy $w._testing
	}
	return $gap
}</t>
<t tx="T833"># Get a sorted lower-case list of all the font families defined on
# the system.  A canonicalisation of [font families]
proc list_families {} {
	lsort [string tolower [font families]]
}
</t>
<t tx="T834"># Path 1: text box
# Path 2: text box

# check: File extension: text box

# Radio buttons:
# 	* print all lines
# 	* print mismatches
# 	* print matches
	
# check: stop after first mismatch
# check: send result to file: text box
# check: generate diffs
# check: ignore whitespace
# check: ignore blank lines

proc createComparePanel {} {

	toplevel .comparePanel
}</t>
<t tx="T835"># apparantly this is a Tk bug on XP.
proc createWindowWithCursor {} {

	toplevel .panel
	text     .panel.text
	.panel.text configure -cursor {gumby red green}
	pack .panel.text
}</t>
<t tx="T836">proc createWindowWithIcon {} {

	global tk_library
	global tcl_patchLevel

	toplevel .panel
	
	# ***** Bitmaps apparently must be only 2 colors.  Photos are everything else!

	# wm iconbitmap .panel [image create photo -file c:/prog/leoCVS/leo/Icons/box00.GIF]
	#wm iconbitmap .panel [image create bitmap -file c:/prog/leoCVS/leo/Icons/box00.bmp]
	
	# no errors, no icon
	#wm iconbitmap .panel [image create bitmap @[file join c:/ Tcl lib tk8.3 demos images face.bmp]]
	# wm iconbitmap .panel @[file join c:/ Tcl lib tk8.3 demos images face.bmp]
	
	wm iconbitmap .panel info
	
	# Bitmap image1 not defined
	#wm iconbitmap .panel [image create photo -file [file join c:/ prog leoCVS leo Icons Leoapp.GIF]]
	
	# works
	#label .panel.bitmap -borderwidth 2 -relief sunken -bitmap @[file join $tk_library demos images face.bmp]
	#label .panel.lab -text $tk_library
	# label .panel.lab -borderwidth 2 -relief sunken -bitmap @[file join c:/ Tcl lib tk8.3 demos images face.bmp]
	# label .panel.lab -borderwidth 2 -relief sunken -bitmap @[file join c:/ prog leoCVS leo Icons face.bmp]
	
	# works!! (Only GIF allowed?)
	label .panel.lab -borderwidth 2 -relief sunken -image \
		[image create photo -file [file join c:/ prog leoCVS leo Icons Leoapp.GIF]]
	pack  .panel.lab

	label .panel.lab2 -text $tcl_patchLevel
	pack  .panel.lab2
}</t>
<t tx="T837"># w is the frame to be created.
# This configures w.f to be the content.
# Typically, the user will pack more content into w.f.

proc myFrame {w args} {

	# Args must come in pairs.
    if {([llength $args] % 2) != 0} {
        error {wrong # args: should be "myFrame pathName ?options?"}
    }
	# Initialize the local vars.
    set allopts {} # options that apply everywhere.
    set fopts {} # border options.
    set lopts {} # label options (only for labels that are Tk label widgets)
    set labelanchor nw # The usual default.
    set padx 0
    set pady 0
    set bd 2
    set relief groove
    set labelwindow "" # Can be any Tk widget!
    set text "" # The user usually just sets this.
	# Set vars based on args.
    foreach {opt val} $args {
        switch -- $opt {
            -bd - -borderwidth {
                set bd $val
            }
            -relief {
                set relief $val
            }
            -text {
                lappend lopts $opt $val
                set text $val
            }
            -font - -fg - -foreground {
                lappend lopts $opt $val
            }
            -labelanchor {
                set labelanchor $val
            }
            -labelwindow {
                set labelwindow $val
            }
            -padx {
                set padx $val
            }
            -pady {
                set pady $val
            }
            -bg - -background - -cursor {
                lappend allopts $opt $val
            }
            default {
                error "Unknown or unsupported option: $opt"
            }
        }
    }
	# relief and border options are frame options.
    lappend fopts -relief $relief -bd $bd 
	# Create the frame and its border, w.bd.
    eval frame $w $allopts
    eval frame $w.bd $fopts $allopts
	# Create lw depending on args.
    if {$labelwindow != ""} {
		# Used the window the user passed in.
        set lw $labelwindow
        raise $labelwindow $w
    } elseif {$text != ""} {
        set lw $w.l
		# This is typical.
        eval label $lw $lopts $allopts -highlightthickness 0 -bd 0
    } else {
        set lw ""
    }
	# Create the frame's grid.
    eval frame $w.f $allopts
	# Configure w as a grid with 5 rows and columns:
	# 1 border, 2 pad, 3 w.f, 4 pad, 5 border.
    grid columnconfigure $w {2 4} -minsize $padx
    grid rowconfigure    $w {2 4} -minsize $pady
    grid columnconfigure $w 3     -weight 1
    grid rowconfigure    $w 3     -weight 1
    grid columnconfigure $w {1 5} -minsize $bd
    grid rowconfigure    $w {1 5} -minsize $bd
	# Create the border, w.bd.
    grid $w.bd -row 1 -col 1 -rowspan 5 -columnspan 5 -sticky news
	# Create the content, w.f in the center.
    grid $w.f -row 3 -col 3 -sticky news
	# Optional: configure lw, the label window in the frame.
    if {$lw != ""} {
		# n*, s*, w* and e* are patterns to -glob.
        switch -glob $labelanchor {
            n* {
                grid $lw -in $w -row 0 -col 2 -rowspan 2 -columnspan 3 -padx 4
            }
            s* {
                grid $lw -in $w -row 5 -col 2 -rowspan 2 -columnspan 3 -padx 4
            }
            w* {
                grid $lw -in $w -row 2 -col 0 -rowspan 3 -columnspan 2 -pady 4
            }
            e* {
                grid $lw -in $w -row 2 -col 5 -rowspan 3 -columnspan 2 -pady 4
            }
        }
		# set the sticky param to the first character of the labelanchor, i.e., n,s,e or w.
        grid $lw -sticky [string index $labelanchor 1]
    }
}</t>
<t tx="T838">proc makeLeoFrame {} {

	# Create the outer labeld frame (doesn't actually have a label).
	myFrame .f -relief ridge -padx 5 -pady 5
	pack .f -fill both -expand 1 -padx 5 -pady 5
	
	# Initialize the grid positioin.
	set row 0
	set col 0
	# lp is the labelanchor value: 1 or two characters, the first character indicates side.
	foreach lp {nw n ne en e es se s sw ws w wn} {
		set w .f.f.f$lp
		# Create a myFrame: everything after %w are args.
		myFrame $w -text "Hej" -padx 2 -pady 2 -labelanchor $lp
		# Place the frame in the grid.
		grid $w -row $row -col $col -sticky news -padx 5 -pady 5
		# Create two buttons and pack them in the labeled frame.
		button $w.f.b1 -text Hoppsan
		button $w.f.b2 -text Quit -command exit
		pack $w.f.b1 $w.f.b2 -side top -fill x -padx 2 -pady 2
		# Bump the grid position.
		incr col
		if {$col == 3} {
			incr row
			set col 0
		}
	}
	
	# Create the last row.
	foreach wl {l1 l2 l3} {
		# Create the "special" label w.
		switch $wl {
			l1 {
				label .$wl -text Hej -bd 2 -relief groove
			} 
			l2 {
				checkbutton .$wl -text Hej
			} 
			l3 {
				radiobutton .$wl -text Hej
			}
		} 
		set w .f.f.f$wl
	
		# Create the labled frame using the -labelwindow option.
		myFrame $w -labelwindow .$wl -padx 2 -pady 2 -labelanchor nw
		# Place the labeled frame in the grid
		grid $w -row $row -col $col -sticky news -padx 5 -pady 5
		# Create two buttons and pack them in the labeled frame.
		button $w.f.b1 -text Hoppsan
		button $w.f.b2 -text Quit -command exit
		pack $w.f.b1 $w.f.b2 -side top -fill x -padx 2 -pady 2
		# Bump the grid position.
		incr col
		if {$col == 3} {
			incr row
			set col 0
		}
	}
}</t>
<t tx="T839"># This file creates tk test code for prototyping.
@language tcltk
@others

bindBug
</t>
<t tx="T840">proc canvasBug {} {
	toplevel .test -bg "blue"
	canvas .test.c -bd 20 -bg "white" -relief "raised"
	pack .test.c -expand 1 -fill "both"
	text .test.c.t -height 1 -background "red"
	pack .test.c.t
	menu .test 
}
</t>
<t tx="T841">proc bindBug {} {

	toplevel .top
	
	text .top.t
	pack .top.t
	
	menu .top.m   -tearoff 0
	menu .top.m.f -tearoff 0
	menu .top.m.e -tearoff 0
	
	.top.m.f add separator
	.top.m.f add command -label "A" -command {""}
	.top.m.f add command -label "B" -command {""}

	.top.m add cascade -label "File" -menu top.m.f -underline 0
	.top.m add cascade -label "Edit" -menu top.m.e -underline 0
	
	.top configure -menu .top.m
}
</t>
<t tx="T842">@ignore
@nocolor</t>
<t tx="T843">By: travers ( Travers A. Hough ) 
 RE: @nosentinelsfile on CVS, was: could Leo...   
2002-11-29 06:33
 
It looks like @nsf may be injecting additional tabs at the beginning or end of body text. 

Here are a few lines of an @file output file: 
-------- 
for Pool_Account in self.Pool_Accounts: 

# Create allocation accounts 


#@+others 
#@+node:1::Zero total allocation accumulator 
#@+body 
# Zero total allocation amount accumulator 
Total_Alloc_Amount = 0 



#@-body 
#@-node:1::Zero total allocation accumulator 
#@+node:2::For each program: Create allocation account 
#@+body 
# For each program: 
# Create allocation accounts 
# Track amount allocated 
for Program in self.Programs: 
Alloc_Amount = Program.Create_Alloc_Accounts(Cost_Pool_Account) 
Total_Alloc_Amount += Alloc_Amount 
-------- 

Here are the same lines after changing to @nosentinelsfile: 

-------- 
for Pool_Account in self.Pool_Accounts: 

# Create allocation accounts 

# Zero total allocation amount accumulator 
Total_Alloc_Amount = 0 


# For each program: 
# Create allocation accounts 
# Track amount allocated 
for Program in self.Programs: 
Alloc_Amount = Program.Create_Alloc_Accounts(Cost_Pool_Account) 
Total_Alloc_Amount += Alloc_Amount 

-------- 

The "# For each program" line has 3 extra tabs in the @nsf version. It seems to occur where there is the parent node containing an "@others" directive followed by child nodes. The first child is processed as expected, the second and subsequent children have the extra tabs. 
 
</t>
<t tx="T844">Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1782437
By: nobody

From: Rich
I just auto-tangled a .C file, with @language C and @comment /* */. Looking
into the .C file, I saw that Leo is again commenting with //.

I looked at "def set_delims_from_string(s)", and the fix (tagged 'rr) is there.
I tested previous versions of Leo, and the bug re-appeared in Leo 3.8, between
builds 1.207 &amp; 1.245.

--Rich

</t>
<t tx="T845">@ This part of the tree shows views of the outline related to specific projects or tasks.  I put such headlines in parentheses, and that is just my convention.

I create a new view by cloning headlines that relate to its task, and moving the cloned headlines under the task headline.  This greatly increases my focus.  Any changes made in a task view to clone headlines affect the other clones scattered throughout the outline.  In particular, all @file nodes containing changed clones become marked as dirty, so they will be written when the entire outline is saved.
@c

@ignore
@language python

</t>
<t tx="T846">@ignore
@ doc
@c
@language latex
	@others

abc
for # comment
# pp
@q comment @&gt; after
// comment
&lt;!-- comment --&gt; after
/* java comment */
{ pascal comment }
% latex comment
xor php keyword
fblocked tcl keyword
synchronized java keyword
\acute latex keyword
alarm perl keyword

# Python single-line comment
// C single-line comment
xx /* C block comment */ yy
xxx """ triple string """ zzz
a 'string' b
c "string" d
// C keywords
switch, case
</t>
<t tx="T847">@ignore

@ Calling tree.recolor_now in tree.select eliminates almost all flashing!</t>
<t tx="T848">@ Warning: do not try to "optimize" this be returning if v==tree.currentVnode.
@c

def select (self,v):
	
	# trace(`v`)
	c = self.commands ; frame = c.frame ; body = frame.body
	old_v = c.currentVnode()
	doSelectHook = v != old_v
	# Call the pre-select hook.
	if doSelectHook:
		handleLeoHook("select1",c=c,new_v=v)
	# Remember the position of the scrollbar before making any changes.
	yview=body.yview()
	insertSpot = c.body.index("insert") # 9/21/02
	# Remember the old body text
	old_body = body.get("1.0","end")

	xml_encoding = app().config.xml_version_string
	s = v.t.bodyString
	if type(s) != types.UnicodeType:
		try: # Tk expects utf-8 encoding, and converting to unicode is safe.
			s2 = unicode(s,xml_encoding)
			s = s2 # don't destroy s until we know that all is well.
		except:
			s = v.t.bodyString
			es("can't convert to " + xml_encoding)
			es_exception()
			es_nonEncodingChars(s,xml_encoding)
			s = replaceNonEncodingChars(s,"?",xml_encoding)
			v.setBodyStringOrPane(s)

	# Delete only if necessary: this may reduce flicker slightly.
	if old_body != s:
		body.delete("1.0","end")
		body.insert("1.0",s)
		if 0: # This is too drastic.
			# Make sure what we get is what we expect.
			s2 = body.get("1.0","end")
			if s == s2[:-1]:
				body.delete("end-1c")

	# We must do a full recoloring: we may be changing context!
	self.recolor_now(v)

	# Unselect any previous selected but unedited label.
	self.endEditLabel()
	old = self.currentVnode
	if old and old != v and old.edit_text:
		self.setUnselectedLabelState(old)
		old.t.scrollBarSpot = yview
		old.t.insertSpot = insertSpot # 9/21/02
		# print yview,old
	if v and v.t.scrollBarSpot != None:
		first,last = v.t.scrollBarSpot
		body.yview("moveto",first)
		# print first,last,v
	if v.t.insertSpot != None: # 9/21/02: moved from c.selectVnode
		# print v.t.insertSpot,v
		c.body.mark_set("insert",v.t.insertSpot)
		c.body.see(v.t.insertSpot)
	else:
		c.body.mark_set("insert","1.0")
	self.currentVnode = v
	self.setSelectedLabelState(v)
	self.scanForTabWidth(v) # 9/13/02
	# Set focus.
	self.commands.body.focus_set()
	# Call the post-select hook.
	if doSelectHook:
		handleLeoHook("select2",c=c,old_v=old_v)</t>
<t tx="T849">def recolor(self,v,incremental=0):

	body = self.commands.frame.body
	
	if 0: # Do immediately
		self.colorizer.colorize(v,body,incremental)
	else: # Do at idle time
		self.colorizer.schedule(v,body,incremental)

def recolor_now(self,v,incremental=0):

	body = self.commands.frame.body
	self.colorizer.colorize(v,body,incremental)
	
def recolor_range(self,v,leading,trailing):

	body = self.commands.frame.body
	self.colorizer.recolor_range(v,body,leading,trailing)</t>
<t tx="T850">@language php

and or
array
array()
__CLASS__
&lt;?php and or array() ?&gt;
</t>
<t tx="T851">Read and respond to this message at: 
http://sourceforge.net/forum/message.php?msg_id=1719215
By: nobody

Ok, it seems to be in the code I copied in. I tried it with a second Node, and
don't have the trouble.

Console Mode gives the following:

Traceback (most recent call last):
File "d:\language\literate programming\Leo\leoColor.py", line 830,
in colorizeAnyLanguage
    i,state = func(s,i,n)

File "d:\language\literate programming\Leo\leoColor.py", line 934,
in continueBlockComment
    j = string.find(s,self.block_comment_end,i)

File "D:\LANGUAGE\PYTHON\lib\string.py", line 174, in find
    return s.find(*args)

TypeError: expected a character buffer object

The line, "#define WIPEOUT 0 /* " seems to be the problem child -- if I move
the start-of-comment marker to the next line, the error message goes away; however,
the lines between the '/*' and '*/' are NOT comment-colored...

--Rich
</t>
<t tx="T852">@language c
@comment /* */
@path .

&lt;&lt; Defines &gt;&gt;
&lt;&lt; Head &gt;&gt;</t>
<t tx="T853">#define WIPEOUT 0 /* 
                   * Causes database card number &amp; flags to be set to zero. 
                   * This is so I don't need an infinite supply of cards!
                   */
// Not colored.
#include "equ.h"
#include "cmn.h"
#include "ramdef.h"
#include "eeprom.h"
#include &lt;hpc_ram.h&gt;
#include &lt;rlydef.h&gt;
</t>
<t tx="T854">@ignore

@

We need both incremental and full syntax coloring...

We must do a _full_ recoloring when selecting any node, even for two cloned nodes, because the nodes may have different contexts.

Furthermore, at present undo must always do a full recoloring because setBodyStringOrPane just replaces the old text with the new, and that destroys all the coloring tags.  The only possible solution would be to do an "incremental update" in setBodyStringOrPane.  It would also be good to do that in tree.select.

The present code _is_ faster than the old code because it avoids redundant drawing.</t>
<t tx="T855"># This creates a free-floating copy of v's tree for undo.
# The copied trees must use different tnodes than the original.

def copyTree(self,root):

    c = self
    # Create the root vnode.
    result = v = leoNodes.vnode(c,root.t)
        # Copy the headline and icon values v.copyNode(root,v)
        # Copy the rest of tree.
        v.copyTree(root,v)
    # Replace all tnodes in v by copies.
    assert(v.nodeAfterTree() == None)
    while v:
        v.t = leoNodes.tnode(0, v.t.bodyString)
        v = v.threadNext()
    return result
    
# This creates a free-floating copy of v's tree for undo.
# The copied trees must use different tnodes than the original.

def copyTree(self,root):

    c = self
    # Create the root vnode.
    result = v = leoNodes.vnode(c,root.t)

	# Copy the headline and icon values
    v.copyNode(root,v)
    # Copy the rest of tree.
        v.copyTree(root,v)
    # Replace all tnodes in v by copies.
    assert(v.nodeAfterTree() == None)
    while v:
        v.t = leoNodes.tnode(0, v.t.bodyString)
        v = v.threadNext()
    return result</t>
<t tx="T856">@language c</t>
<t tx="T857">@
This is just a test
@c
aprocedure(
	a,
	b )
	{
	printf( "Hello, world\n" );
	return 0;
}

"/* testing */"
@#
bprocedure(
	a,
	b )
	{
	printf( "Hello, world\n" );
	return 0;
}

@#
cprocedure(
	a,
	b )
	{
	printf( "Hello, world\n" );
	return 0;
}

@#
dprocedure(
	a,
	b )
	{
	printf( "Hello, world\n" );
	return 0;
}

@#
int main()
{
  return 0
}</t>
<t tx="T858">Here's another issue

Create a @file node[snip]

You should see the &lt;!-- test --&gt; in 'red' (comment color).

Now backspace over 'html' in the language directive and type 'xml'.  

The bug is that XML is not a valid Leo language but the comment is still 'red'.
If you go to another node and come back it changes back to black type.  Now
change the language back to 'html'.  It doesn't recolorize and the comment remains
black.

This is a nit, really.
</t>
<t tx="T859">@language html
&lt;? xml version="1.0"&gt;
&lt;!-- test --&gt;
&lt;project name="Converter" default="dist"&gt;
&lt;/project&gt;</t>
<t tx="T860">def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:		
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()


</t>
<t tx="T861">"""python
string"""d

'this\
is</t>
<t tx="T862">@nocolor</t>
<t tx="T863">@ The problem is this: clicking in a window's title area or the menu area does _not_ generate an activate for the window.

To solve this problem, we set app().log in two places:
	
- frame.OnMenuClick
- frame.doCommaned
</t>
<t tx="T864">@ Executes the given command, invoking hooks and catching exceptions.
Command handlers no longer need to return "break".  Yippee!

The code assumes that customizeLeo("command1") has completely handled the command if customizeLeo("command1") returns false.  This provides a very simple mechanism for overriding commands.
@c

def doCommand (self,command,label,event=None):
	
	# A horrible kludge: set app().log to cover for a possibly missing activate event.
	app().log = self

	app().commandName = label
	flag = handleLeoHook("command1",label=label)
	if flag == None: # Anything other than None overrides.
		try:
			command(event)
		except:
			es("exception executing command")
			print "exception executing command"
			es_exception()
	
		handleLeoHook("command2",label=label)
		# collectGarbage()
			
	return "break" # Inhibit all other handlers.</t>
<t tx="T865"># This is the Tk "postcommand" callback.  It should update all menu items.

def OnMenuClick (self):
	
	# A horrible kludge: set app().log to cover for a possibly missing activate event.
	app().log = self
	
	# Allow the user first crack at updating menus.
	flag = handleLeoHook("menu2")
	if flag == None:  # Anything other than None overrides.
		self.updateFileMenu()
		self.updateEditMenu()
		self.updateOutlineMenu()</t>
<t tx="T866">@ignore</t>
<t tx="T867">a = app()
# Add the Open With entries if they exist.
if a.openWithTable:
	frame.createMenuEntries(menu,a.openWithTable,openWith=1)
	table = (("-",None,None),)
	frame.createMenuEntries(menu,table)
# Create the rest of the popup menu.
table = (
	("Read @file Nodes",None,frame.OnReadAtFileNodes),
	("Write @file Nodes",None,frame.OnWriteAtFileNodes),
	("-",None,None),
	("Tangle","Shift+Ctrl+T",frame.OnTangle),
	("Untangle","Shift+Ctrl+U",frame.OnUntangle),
	("-",None,None),
	("Cut Node","Shift+Ctrl+X",frame.OnCutNode),
	("Copy Node","Shift+Ctrl+C",frame.OnCopyNode),
	("Paste Node","Shift+Ctrl+V",frame.OnPasteNode),
	("Delete Node","Shift+Ctrl+BkSp",frame.OnDeleteNode),
	("-",None,None),
	("Insert Node","Ctrl+I",frame.OnInsertNode),
	("Clone Node","Ctrl+`",frame.OnCloneNode),
	("Sort Children",None,frame.OnSortChildren),
	("Sort Siblings","Alt-A",frame.OnSortSiblings),
	("-",None,None),
	("Contract Parent","Alt+0",frame.OnContractParent))

frame.createMenuEntries(menu,table)

# Enable and disable.
&lt;&lt; set isAtRoot and isAtFile if v's tree contains @root or @file nodes &gt;&gt;
isAtFile = choose(isAtFile,1,0)
isAtRoot = choose(isAtRoot,1,0)
canContract = v.parent() != None
canContract = choose(canContract,1,0)

for name in ("Read @file Nodes", "Write @file Nodes"):
	enableMenu(menu,name,isAtFile)
for name in ("Tangle", "Untangle"):
	enableMenu(menu,name,isAtRoot)

enableMenu(menu,"Cut Node",c.canCutOutline())
enableMenu(menu,"Delete Node",c.canDeleteHeadline())
enableMenu(menu,"Paste Node",c.canPasteOutline())
enableMenu(menu,"Sort Children",c.canSortChildren())
enableMenu(menu,"Sort Siblings",c.canSortSiblings())
enableMenu(menu,"Contract Parent",c.canContractParent())</t>
<t tx="T868">isAtFile = false ; isAtRoot = false
next = v.nodeAfterTree()
v2 = v
while (not isAtFile or not isAtRoot) and v2 != None and v2 != next:
	if v2.isAtFileNode() or v.isAtRawFileNode() or v.isAtSilentFileNode() or v.isAtNoSentinelsFileNode():
		isAtFile = true
	isRoot, junk = is_special(v2.bodyString(),0,"@root")
	if isRoot:
		isAtRoot = true
	v2 = v2.threadNext()</t>
<t tx="T869">def __init__(self, root):

	# These ivars are the global vars of this program.
	self.commandName = None # The name of the command being executed.
	self.config = None # The leoConfig instance.
	self.configDir = None # The directory containing configuration info.
	self.deleteOnClose = true # true: delete frame objects when a frame closes.
	self.hookError = false # true: suppress further calls to hooks.
	self.hookFunction = None # Application wide hook function.
	self.idle_imported = false # true: we have done an import idle
	self.idleTimeDelay = 100 # Delay in msec between calls to "idle time" hook.
	self.idleTimeHook = false # true: the global idleTimeHookHandler will reshedule itself.
	self.loadDir = None # The directory from which Leo was loaded.
	self.log = None # The LeoFrame containing the present log.
	self.menuWarningsGiven = false # true: supress warnings in menu code.
	self.numberOfWindows = 0 # Number of opened windows.
	self.openWithFiles = [] # List of data used by Open With command.
	self.openWithFileNum = 0 # Used to generate temp file names for Open With command.
	self.openWithTable = None # The table passed to createOpenWithMenuFromTable.
	self.quitting = false # True if quitting.  Locks out some events.
	self.realMenuNameDict = {} # Contains translations of menu names and menu item names.
	self.root = root # The hidden main window
	self.trace_list = [] # "Sherlock" argument list for tracing().
	self.unicodeErrorGiven = false # true: suppres unicode tracebacks.
	self.windowList = [] # Global list of all frames.  Does not include hidden root window.

	if 0: # app() is not accessible during shutdown!
		self.printDel = false # true: enable prints in __del__ routines

	# Global panels.  Destroyed when Leo ends.
	self.findFrame = None
	self.pythonFrame = None
	
	&lt;&lt; Define global constants &gt;&gt;
	&lt;&lt; Define global data structures &gt;&gt;</t>
<t tx="T870"># Internally, lower case is used for all language names.
self.language_delims_dict = {
	"c" : "// /* */", # C, C++ or objective C.
	"cweb" : "@q@ @&gt;", # Use the "cweb hack"
	"forth" : "_\\_ _(_ _)_", # Use the "REM hack"
	"fortran" : "C",
	"fortran90" : "!",
	"html" : "&lt;!-- --&gt;",
	"java" : "// /* */",
	"latex" : "%",
	"pascal" : "// { }",
	"perl" : "#",
	"perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
	"php" : "//",
	"plain" : "#", # We must pick something.
	"python" : "#",
	"shell" : "#",  # shell scripts
	"tcltk" : "#",
	"unknown" : "#" } # Set when @comment is seen.
	
self.language_extension_dict = {
	"c" : "c", 
	"cweb" : "w",
	"forth" : "forth",
	"fortran" : "f",
	"fortran90" : "f",
	"html" : "html",
	"java" : "java",
	"latex" : "latex",
	"noweb" : "nw",
	"pascal" : "p",
	"perl" : "perl",
	"perlpod" : "perl", 
	"php" : "php",
	"plain" : "txt",
	"python" : "py",
	"shell" : "txt",
	"tex" : "tex",
	"tcltk" : "tcl",
	"unknown" : "txt" } # Set when @comment is seen.
</t>
<t tx="T871">@ Try to remove temp files created with the Open With command.  This may fail if the files are still open.

We can't use es here because the log stream no longer exists.
@c 

def handleOpenTempFiles (self):
	
	for dict in self.openWithFiles:
		path = dict.get("path")
		if path and os.path.exists(path):
			try:
				os.remove(path)
				print "deleting temp file:", path
			except:
				print "can not delete temp file:", path</t>
<t tx="T872">@ The old, non-user-configurable code bound shortcuts in createMenuBar.  The new user-configurable code binds shortcuts here.

Centralized tables of shortscuts no longer exist as they did in createAccelerators.  To check for duplicates, (possibly arising from leoConfig.txt) we add entries to a central dictionary here, and report duplicates if an entry for a canonicalized shortcut already exists.
@c

def createMenuEntries (self,menu,table,openWith=0):
	
	for label,accel,command in table:
		if label == None or command == None or label == "-":
			menu.add_separator()
		else:
			&lt;&lt; get menu and bind shortcuts &gt;&gt;
			if openWith:
				callback=lambda self=self,path=command:self.OnOpenWith(path)
			else:
				callback=lambda self=self,cmd=command,label=name:self.doCommand(cmd,label)
			realLabel = app().getRealMenuName(label)
			amp_index = realLabel.find("&amp;")
			realLabel = realLabel.replace("&amp;","")
			if not menu_shortcut: menu_shortcut = ""
			menu.add_command(label=realLabel,accelerator=menu_shortcut,
				command=callback,underline=amp_index)
				
			if bind_shortcut:
				if bind_shortcut in self.menuShortcuts:
					if not app().menuWarningsGiven:
						print "duplicate shortcut:", accel, bind_shortcut, label
				else:
					self.menuShortcuts.append(bind_shortcut)
					try:
						# The self and event params must be unbound.
						if openWith:
							f = self.OnOpenWith
							callback=lambda event,f=f,path=command:f(path)
						else:
							f = self.doCommand
							callback=lambda event,f=f,cmd=command,label=name:f(cmd,label,event)
						self.body.bind(bind_shortcut,callback) # To override defaults in body.
						self.top.bind (bind_shortcut,callback)
					except: # could be a user error
						if not app().menuWarningsGiven:
							print "exception binding menu shortcut..."
							print bind_shortcut
							es_exception()
							app().menuWarningsGive = true</t>
<t tx="T873">name = string.strip(label)
name = string.lower(name)
# Remove special characters from command names.
name2 = ""
for ch in name:
	if ch in string.letters or ch in string.digits:
		name2 = name2 + ch
name = name2

config = app().config
accel2 = config.getShortcut(name)
if accel2 and len(accel2) &gt; 0:
	accel = accel2
	# print name,accel
else:
	pass
	# print "no default:",name

bind_shortcut,menu_shortcut = self.canonicalizeShortcut(accel)

# Kludge: disable the shortcuts for cut, copy, paste.
# This has already been bound in leoFrame.__init__
if bind_shortcut in ("&lt;Control-c&gt;","&lt;Control-v&gt;","&lt;Control-x&gt;"):
	bind_shortcut = None</t>
<t tx="T874">def createMenuItemsFromTable (self,menuName,table,openWith=0):
	
	try:
		menu = self.getMenu(menuName)
		if menu == None:
			print "menu does not exist: ", menuName
			es("menu does not exist: " + `menuName`)
			return
		self.createMenuEntries(menu,table,openWith)
	except:
		print "exception creating items for ", menuName," menu"
		es("exception creating items for " + `menuName` + " menu")
		es_exception()</t>
<t tx="T875">@ Entries in the table passed to createOpenWithMenuFromTable are
tuples of the form (commandName,shortcut,data).

- command is one of "os.system", "os.startfile", "os.spawnl", "os.spawnv" or "exec".
- shortcut is a string describing a shortcut, just as for createMenuItemsFromTable.
- data is a tuple of the form (command,arg,ext).

Leo executes command(arg+path) where path is the full path to the temp file.
If ext is not None, the temp file has the given extension.
Otherwise, Leo computes an extension based on the @language directive in effect.
@c

def createOpenWithMenuFromTable (self,table):

	a = app()
	a.openWithTable = table # Override any previous table.
	# Delete the previous entry.
	parent = self.getMenu("File")
	label=a.getRealMenuName("Open &amp;With...")
	amp_index = label.find("&amp;")
	label = label.replace("&amp;","")
	try:
		index = parent.index(label)
		parent.delete(index)
	except:
		try:
			index = parent.index("Open With...")
			parent.delete(index)
		except: return
	# Create the "Open With..." menu.
	openWithMenu = Tkinter.Menu(parent,tearoff=0)
	self.setMenu("Open With...",openWithMenu)
	parent.insert_cascade(index,label=label,menu=openWithMenu,underline=amp_index)
	# Populate the "Open With..." menu.
	shortcut_table = []
	for name,shortcut,data in table:
		data2 = (name,shortcut,data)
		shortcut_table.append(data2)
	# for i in shortcut_table: print i
	self.createMenuItemsFromTable("Open &amp;With...",shortcut_table,openWith=1)
</t>
<t tx="T876">@ This prepares string s to be a valid file name:

- substitute '_' for forbidden characters.
- strip leading and trailing whitespace.
- return at most 128 characters.
@c

def sanitize_filename(s):
	
	import re
	s = s.strip()
	ws = re.compile('[ \t]')
	bad_chars = re.compile('[\\/&amp;&lt;&gt;\'"`@|?*]')
	s = bad_chars.sub('',s)
	s = s.strip()
	s = ws.sub('_',s)
	return s[:128]</t>
<t tx="T877">@ This routine handles the items in the Open With... menu.
These items can only be created by createOpenWithMenuFromTable().
Typically this would be done from the "open2" hook.
@c

def OnOpenWith(self,data=None,event=None):
	
	a = app() ; c = self.commands ; v = c.currentVnode()
	if not data: return
	
	openType,arg,ext=data
	flag = handleLeoHook("openwith1",c=c,v=v,openType=openType,arg=arg,ext=ext)
	if flag == None:  # Anything other than None overrides.
		&lt;&lt; set ext based on the present language &gt;&gt;
		&lt;&lt; set path to the full pathname of a temp file using ext &gt;&gt;
		&lt;&lt; execute a command to open path &gt;&gt;
		handleLeoHook("openwith2",c=c,v=v,openType=openType,arg=arg,ext=ext)
	return "break"</t>
<t tx="T878">if ext == None or len(ext) == 0:
	dict = scanDirectives(c)
	language = dict.get("language")
	ext = a.language_extension_dict.get(language)
	if ext == None:
		ext = "txt"
	
if ext[0] != ".":
	ext = "."+ext</t>
<t tx="T879">file = None
while file == None:
	a.openWithFileNum += 1
	# name = "LeoTemp" + str(a.openWithFileNum) + ext
	name = "LeoTemp_" + sanitize_filename(v.headString()) + ext
	path = os.path.join(a.loadDir,name)
	if not os.path.exists(path):
		try:
			file = open(path,"w")
			file.write(v.bodyString())
			file.flush()
			file.close()
			try:
				time=os.path.getmtime(path)
			except:
				time=None
			es("creating: " + path)
			es("time: " + str(time))
			dict = {"c":c, "v":v, "f":file, "path":path, "time":time}
			a.openWithFiles.append(dict)
		except:
			file = None
			es("exception opening temp file")
			es_exception()
if not file: return</t>
<t tx="T880">try:
	if arg == None: arg = ""
	if openType == "os.system":
		command  = "os.system("+arg+path+")"
		os.system(arg+path)
	elif openType == "os.startfile":
		command    = "os.startfile("+arg+path+")"
		os.startfile(arg+path)
	elif openType == "exec":
		command    = "exec("+arg+path+")"
		exec(arg+path)
	elif openType == "os.spawnl":
		filename = os.path.basename(arg)
		command = "os.spawnl("+arg+","+filename+','+ path+")"
		apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
	elif openType == "os.spawnv":
		filename = os.path.basename(arg)
		command = "os.spawnv("+arg+",("+filename+','+ path+"))"
		apply(os.spawnl,(os.P_NOWAIT,arg,(filename,path)))
	else:
		command="bad command:"+str(openType)
	es(command)
except:
	es("exception executing: "+command)
	es_exception()</t>
<t tx="T881">def destroy (self):

	if not app().deleteOnClose:
		return
		
	# Can't trace while destroying.
	# print "tree.destroy"

	for v in self.vnode_alloc_list:
		v.destroy()
	del self.vnode_alloc_list # del all vnodes

	self.iconimages = None
	del self.colorizer
	self.colorizer = None

	# Remove links to objects destroyed by frame.
	self.commands = None
	self.canvas = None

	# Remove all links to nodes
	self.currentVnode = None # The presently selected vnode.
	self.editVnode = None # The vnode being edited.
	self.rootVnode = None
	self.topVnode = None</t>
<t tx="T882">@ This routine immediately removes all links from this node to other objects.  We expect this routine to be called only from tree.destroy when a window is being closed.
@c

def destroy (self):

	# Can't trace while destroying.
	# print "v.destroy"
	self.commands = None
	self.joinList = None
	self.t.destroy()
	self.t = None
	self.mParent = self.mFirstChild = self.mNext = self.mBack = None
	self.edit_text = None
	if 0: # These no longer exist
		self.box_id = self.icon_id = self.edit_text_id = None</t>
<t tx="T883">def destroy (self):

	# Can't trace while destroying.
	# print "c.destroy:", self.frame

	# Remove all links from this object to other objects.
	self.frame = None
	self.fileCommands = None
	self.atFileCommands = None
	self.importCommands = None
	self.tangleCommands = None</t>
<t tx="T884">def destroy (self):

	# don't trace during shutdown logic.
	# print "frame.destroy:", self, self.top
	self.tree.destroy()
	self.tree = None
	self.commands.destroy()
	self.commands = None
	self.top.destroy() # Actually close the window.
	self.top = None</t>
<t tx="T885"># Called from quit logic and when user closes the window.
# Returns true if the close happened.

def OnCloseLeoEvent(self):

	# trace(`self in app().windowList` + ":" + `self`)
	veto=false
	c = self.commands ; frame = c.frame
	if c.changed:
		&lt;&lt; Prompt for change.  Set veto if the user cancels &gt;&gt;
	if veto: return false
	app().log = None # no log until we reactive a window.
	# Destroy all windows attached to this windows.
	# This code will be executed if we haven't explicitly closed the windows.
	if self.comparePanel:
		self.comparePanel.top.destroy()
	if self.colorPanel:
		self.colorPanel.top.destroy()
	if self.fontPanel:
		self.fontPanel.top.destroy()
	if self.prefsPanel:
		self.prefsPanel.top.destroy()

	if self in app().windowList:
		app().windowList.remove(self)
		self.destroy() # force the window to go away now.
	if app().windowList:
		# Pick a window to activate so we can set the log.
		w = app().windowList[0]
		w.top.deiconify()
		w.top.lift()
		app().log = w
	else:
		app().quit()
	return true</t>
<t tx="T886">name = choose(self.mFileName, self.mFileName, self.title)
type = choose(app().quitting, "quitting?", "closing?")

d = leoDialog.leoDialog()
answer = d.askYesNoCancel("Confirm",
	'Save changes to "' + name + '" before ' + type)

if answer=="yes":
	if not self.mFileName or self.mFileName == "":
		&lt;&lt; Put up a file save dialog; set veto if the user cancels &gt;&gt;
	if veto==false and self.mFileName and self.mFileName != "":
		self.commands.fileCommands.save( self.mFileName )

elif answer=="cancel":
	veto = true #The user wants to cancel the close.

else: veto = false # The user wants to close without saving.</t>
<t tx="T887"># Make sure we never pass None to the ctor.
if not self.title:
	self.title = ""
	
self.mFileName = tkFileDialog.asksaveasfilename(
	initialfile = self.mFileName,
	title="Save",
	filetypes=[("Leo files", "*.leo")],
	defaultextension=".leo")
	
if not self.mFileName:
	veto = true
</t>
<t tx="T888">def OnQuit(self,event=None):

	app().quitting += 1
	
	while app().windowList:
		w = app().windowList[0]
		if not w.OnCloseLeoEvent():
			break
			
	app().quitting -= 1 # If we get here the quit has been disabled.

</t>
<t tx="T889">def quit(self):

	# Wait until everything is quiet before really quitting.
	handleLeoHook("end1")

	self.destroyAllGlobalWindows()
	self.handleOpenTempFiles()

	if 1: # leaves Python window open.
		self.root.destroy()
	else: # closes Python window.
		self.root.quit()</t>
<t tx="T890"># All output to the log stream eventually comes here.

def put (self,s):
	if app().quitting &gt; 0: return
	if self.log:
			self.log.insert("end",s)
			self.log.see("end")
			self.log.update_idletasks()
	else:
		print "Null log"
		print s

def putnl (self):
	if app().quitting &gt; 0: return
	if self.log:
		self.log.insert("end",'\n')
		self.log.see("end")
		self.log.update_idletasks()
	else:
		print "Null log"
		print</t>
<t tx="T891">@ignore
</t>
<t tx="T892">@ignore
@language java

@ Reported by Chris P. Jobling, University of Wales Swansea, UK. C.P.Jobling@Swansea.ac.uk.
</t>
<t tx="T893">//: c08:Adventure.java
// From 'Thinking in Java, 2nd ed.' by Bruce Eckel
// www.BruceEckel.com. See copyright notice in CopyRight.txt.
// Multiple interfaces.
import java.util.*;

interface CanFight {
  void fight();
}

interface CanSwim {
  void swim();
}

interface CanFly {
  void fly();
}

class ActionCharacter {
  public void fight() {}
}

class Hero extends ActionCharacter 
    implements CanFight, CanSwim, CanFly {
  public void swim() {}
  public void fly() {}
}

public class Adventure {
  static void t(CanFight x) { x.fight(); }
  static void u(CanSwim x) { x.swim(); }
  static void v(CanFly x) { x.fly(); }
  static void w(ActionCharacter x) { x.fight(); }
  public static void main(String[] args) {
    Hero h = new Hero();
    t(h); // Treat it as a CanFight
    u(h); // Treat it as a CanSwim
    v(h); // Treat it as a CanFly
    w(h); // Treat it as an ActionCharacter
  }
} ///:~</t>
<t tx="T894">//: c06:Bath.java
// From 'Thinking in Java, 2nd ed.' by Bruce Eckel
// www.BruceEckel.com. See copyright notice in CopyRight.txt.
// Constructor initialization with composition.

class Soap {
  private String s;
  Soap() {
    System.out.println("Soap()");
    s = new String("Constructed");
  }
  public String toString() { return s; }
}

public class Bath {
  private String 
    // Initializing at point of definition:
    s1 = new String("Happy"), 
    s2 = "Happy", 
    s3, s4;
  Soap castille;
  int i;
  float toy;
  Bath() {
    System.out.println("Inside Bath()");
    s3 = new String("Joy");
    i = 47;
    toy = 3.14f;
    castille = new Soap();
  }
  void print() {
    // Delayed initialization:
    if(s4 == null)
      s4 = new String("Joy");
    System.out.println("s1 = " + s1);
    System.out.println("s2 = " + s2);
    System.out.println("s3 = " + s3);
    System.out.println("s4 = " + s4);
    System.out.println("i = " + i);
    System.out.println("toy = " + toy);
    System.out.println("castille = " + castille);
  }
  public static void main(String[] args) {
    Bath b = new Bath();
    b.print();
  }
} ///:~</t>
<t tx="T895">//: c02:HelloDate.java
// From 'Thinking in Java, 2nd ed.' by Bruce Eckel
// www.BruceEckel.com. See copyright notice in CopyRight.txt.
import java.util.*;

/** The first Thinking in Java example program.
 * Displays a string and today's date.
 * @author Bruce Eckel
 * @author www.BruceEckel.com
 * @version 2.0 
*/
public class HelloDate {
  /** Sole entry point to class &amp; application
   * @param args array of string arguments
   * @return No return value
   * @exception exceptions No exceptions thrown
  */
  public static void main(String[] args) {
    System.out.println("Hello, it's: ");
    System.out.println(new Date());
  }
} ///:~</t>
<t tx="T896">@ignore
</t>
<t tx="T897">@ignore
@language java
&lt;&lt; Adventure declarations &gt;&gt;

@others
 ///:~</t>
<t tx="T898">//: c08:Adventure.java
// From 'Thinking in Java, 2nd ed.' by Bruce Eckel
// www.BruceEckel.com. See copyright notice in CopyRight.txt.
// Multiple interfaces.
import java.util.*;
</t>
<t tx="T899">interface CanFight {
  void fight();
}</t>
<t tx="T900">
interface CanSwim {
  void swim();
}</t>
<t tx="T901">
interface CanFly {
  void fly();
}</t>
<t tx="T902">
class ActionCharacter {
	@others
}</t>
<t tx="T903">public void fight() {}
</t>
<t tx="T904">
class Hero extends ActionCharacter 
    implements CanFight, CanSwim, CanFly {
	@others
}</t>
<t tx="T905">public void swim() {}
</t>
<t tx="T906">public void fly() {}
</t>
<t tx="T907">
public class Adventure {
	@others
}</t>
<t tx="T908">static void t(CanFight x) { x.fight(); }
</t>
<t tx="T909">static void u(CanSwim x) { x.swim(); }
</t>
<t tx="T910">static void v(CanFly x) { x.fly(); }
</t>
<t tx="T911">static void w(ActionCharacter x) { x.fight(); }
</t>
<t tx="T912">public static void main(String[] args) {
  Hero h = new Hero();
  t(h); // Treat it as a CanFight
  u(h); // Treat it as a CanSwim
  v(h); // Treat it as a CanFly
  w(h); // Treat it as an ActionCharacter
}
</t>
<t tx="T913">@ignore
@language java

@others
 ///:~</t>
<t tx="T914">//: c06:Bath.java
// From 'Thinking in Java, 2nd ed.' by Bruce Eckel
// www.BruceEckel.com. See copyright notice in CopyRight.txt.
// Constructor initialization with composition.

class Soap {
	&lt;&lt; class Soap declarations &gt;&gt;

	@others
}</t>
<t tx="T915">private String s;
</t>
<t tx="T916">Soap() {
  System.out.println("Soap()");
  s = new String("Constructed");
}
</t>
<t tx="T917">public String toString() { return s; }
</t>
<t tx="T918">
public class Bath {
	&lt;&lt; class Bath declarations &gt;&gt;

	@others
}</t>
<t tx="T919">private String 
  // Initializing at point of definition:
  s1 = new String("Happy"), 
  s2 = "Happy", 
  s3, s4;
Soap castille;
int i;
float toy;
</t>
<t tx="T920">Bath() {
  System.out.println("Inside Bath()");
  s3 = new String("Joy");
  i = 47;
  toy = 3.14f;
  castille = new Soap();
}
</t>
<t tx="T921">void print() {
  // Delayed initialization:
  if(s4 == null)
    s4 = new String("Joy");
  System.out.println("s1 = " + s1);
  System.out.println("s2 = " + s2);
  System.out.println("s3 = " + s3);
  System.out.println("s4 = " + s4);
  System.out.println("i = " + i);
  System.out.println("toy = " + toy);
  System.out.println("castille = " + castille);
}
</t>
<t tx="T922">public static void main(String[] args) {
  Bath b = new Bath();
  b.print();
}
</t>
<t tx="T923">@ignore
@language java
&lt;&lt; HelloDate declarations &gt;&gt;

@others
 ///:~</t>
<t tx="T924">//: c02:HelloDate.java
// From 'Thinking in Java, 2nd ed.' by Bruce Eckel
// www.BruceEckel.com. See copyright notice in CopyRight.txt.
import java.util.*;
</t>
<t tx="T925">/** The first Thinking in Java example program.
 * Displays a string and today's date.
 * @author Bruce Eckel
 * @author www.BruceEckel.com
 * @version 2.0 
*/
public class HelloDate {
	@others
}</t>
<t tx="T926">/** Sole entry point to class &amp; application
 * @param args array of string arguments
 * @return No return value
 * @exception exceptions No exceptions thrown
*/
public static void main(String[] args) {
  System.out.println("Hello, it's: ");
  System.out.println(new Date());
}
</t>
<t tx="T927">@ Skips from the opening to the matching . If no matching is found i is set to len(s).

This code is called only from the import logic, so we are allowed to try some tricks.  In particular, we assume all braces are matched in #if blocks.
@c

def skip_braces(s,i):

	start = get_line(s,i)
	assert(match(s,i,'{'))
	level = 0 ; n = len(s)
	while i &lt; n:
		c = s[i]
		if c == '{':
			level += 1 ; i += 1
		elif c == '}':
			level -= 1
			if level &lt;= 0: return i
			i += 1
		elif c == '\'' or c == '"': i = skip_string(s,i)
		elif match(s,i,'//'): i = skip_to_end_of_line(s,i)
		elif match(s,i,'/*'): i = skip_block_comment(s,i)
		# 7/29/02: be more careful handling conditional code.
		elif match_word(s,i,"#if") or match_word(s,i,"#ifdef") or match_word(s,i,"#ifndef"):
			i,delta = skip_pp_if(s,i)
			level += delta
		else: i += 1
	return i</t>
<t tx="T928">def find_line_start(s,i):

	# bug fix: 11/2/02: change i to i+1 in rfind
	i = string.rfind(s,'\n',0,i+1) # Finds the highest index in the range.
	if i == -1: return 0
	else: return i + 1</t>
<t tx="T929">@ignore</t>
<t tx="T930">def updateBodyPane (self,head,middle,tail,undoType,oldSel,oldYview):
	
	c = self ; v = c.currentVnode()
	# Update the text and set start, end.
	c.body.delete("1.0","end")
	# The caller must do rstrip.head if appropriate.
	if head and len(head) &gt; 0:
		c.body.insert("end",head)
		start = c.body.index("end-1c")
	else: start = "1.0"
	if 0: # 9/12/02: Do not gratuitously remove newlines!
		if middle and len(middle) &gt; 0:
			middle = string.rstrip(middle)
	if middle and len(middle) &gt; 0:
		c.body.insert("end",middle)
		end = c.body.index("end-1c")
	else: end = start
	if tail and len(tail) &gt; 0:
		tail = string.rstrip(tail)
	if tail and len(tail) &gt; 0:
		c.body.insert("end",tail)
	# Activate the body key handler by hand.
	c.tree.onBodyChanged(v,undoType,oldSel=oldSel,oldYview=oldYview)
	# Update the changed mark.
	if not c.isChanged():
		c.setChanged(true)
	# Update the icon.
	c.beginUpdate()
	if not v.isDirty():
		v.setDirty()
	c.endUpdate()
	# Update the selection.
	# trace(`start` + "," + `end`)
	setTextSelection(c.body,start,end)
	if oldYview:
		first,last=oldYview
		c.body.yview("moveto",first)
	else:
		c.body.see("insert")
	c.body.focus_force()
	c.recolor() # 7/5/02</t>
<t tx="T931"></t>
<t tx="T932"># Returns optimized whitespace corresponding to width with the indicated tab_width.

def computeLeadingWhitespace (width, tab_width):

	if width &lt;= 0:
		return ""
	if tab_width &gt; 1:
		tabs   = width / tab_width
		blanks = width % tab_width
		return ('\t' * tabs) + (' ' * blanks)
	else: # 7/3/02: negative tab width always gets converted to blanks.
		return (' ' * width)</t>
<t tx="T933"># Returns the width of s, assuming s starts a line, with indicated tab_width.

def computeWidth (s, tab_width):
		
	w = 0
	for ch in s:
		if ch == '\t':
			w += (abs(tab_width) - (w % abs(tab_width)))
		else:
			w += 1
	return w</t>
<t tx="T934">def get_leading_ws(s):
	
	"""Returns the leading whitespace of 's'."""

	i = 0 ; n = len(s)
	while i &lt; n and s[i] in (' ','\t'):
		i += 1
	return s[0:i]
</t>
<t tx="T935"># Optimize leading whitespace in s with the given tab_width.

def optimizeLeadingWhitespace (line,tab_width):

	i, width = skip_leading_ws_with_indent(line,0,tab_width)
	s = computeLeadingWhitespace(width,tab_width) + line[i:]
	return s</t>
<t tx="T936"># Remove whitespace up to first_ws wide in s, given tab_width, the width of a tab.

def removeLeadingWhitespace (s,first_ws,tab_width):

	j = 0 ; ws = 0
	for ch in s:
		if ws &gt;= first_ws:
			break
		elif ch == ' ':
			j += 1 ; ws += 1
		elif ch == '\t':
			j += 1 ; ws += (abs(tab_width) - (ws % abs(tab_width)))
		else: break
	if j &gt; 0:
		s = s[j:]
	return s</t>
<t tx="T937"># Warning: string.rstrip also removes newlines!

def removeTrailingWs(s):

	j = len(s)-1
	while j &gt;= 0 and (s[j] == ' ' or s[j] == '\t'):
		j -= 1
	return s[:j+1]
</t>
<t tx="T938"># Skips leading up to width leading whitespace.

def skip_leading_ws(s,i,ws,tab_width):

	count = 0
	while count &lt; ws and i &lt; len(s):
		ch = s[i]
		if ch == ' ':
			count += 1
			i += 1
		elif ch == '\t':
			count += (abs(tab_width) - (count % abs(tab_width)))
			i += 1
		else: break

	return i</t>
<t tx="T939">@ Skips leading whitespace and returns (i, indent), where i points after the whitespace and indent is the width of the whitespace, assuming tab_width wide tabs.
@c

def skip_leading_ws_with_indent(s,i,tab_width):

	count = 0 ; n = len(s)
	while i &lt; n:
		ch = s[i]
		if ch == ' ':
			count += 1
			i += 1
		elif ch == '\t':
			count += (abs(tab_width) - (count % abs(tab_width)))
			i += 1
		else: break

	return i, count</t>
<t tx="T940">def convertAllBlanks (self):
	
	c = self ; v = current = c.currentVnode()
	next = v.nodeAfterTree()
	dict = scanDirectives(c)
	tabWidth  = dict.get("tabwidth")
	# Create copy for undo.
	v_copy = c.copyTree(v)
	anyChanged = false
	while v and v != next:
		if v == current:
			c.convertBlanks()
		else:
			result = [] ; changed = false
			text = v.t.bodyString
			lines = string.split(text, '\n')
			for line in lines:
				s = optimizeLeadingWhitespace(line,tabWidth)
				if s != line:
					changed = true ; anyChanged = true
				result.append(s)
			if changed:
				result = string.join(result,'\n')
				v.t.setTnodeText(result)
		v.setDirty()
		v = v.threadNext()
	if anyChanged:
		c.undoer.setUndoParams("Convert All Blanks",current,select=current,oldTree=v_copy)
	else:
		es("nothing changed")</t>
<t tx="T941">def convertAllTabs (self):

	c = self ; v = current = c.currentVnode()
	next = v.nodeAfterTree()
	dict = scanDirectives(c)
	tabWidth  = dict.get("tabwidth")
	# Create copy for undo.
	v_copy = c.copyTree(v)
	anyChanged = false
	while v and v != next:
		if v == current:
			self.convertTabs()
		else:
			result = [] ; changed = false
			text = v.t.bodyString
			lines = string.split(text, '\n')
			for line in lines:
				i,w = skip_leading_ws_with_indent(line,0,tabWidth)
				s = computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
				if s != line:
					changed = true ; anyChanged = true
				result.append(s)
			if changed:
				result = string.join(result,'\n')
				v.t.setTnodeText(result)
		v.setDirty()
		v = v.threadNext()
	if anyChanged:
		c.undoer.setUndoParams("Convert All Tabs",current,select=current,oldTree=v_copy)
	else:
		es("nothing changed")

</t>
<t tx="T942">def convertTabs (self):

	c = self
	head,lines,tail,oldSel,oldYview = self.getBodyLines()
	result = [] ; changed = false
	
	# DTHEIN 3-NOV-2002: use the relative @tabwidth, not the global one
	dict = scanDirectives(c)
	tabWidth  = dict.get("tabwidth")

	if 0: # DTHEIN 3-NOV-2002: don't use the global @tabwidth
		for line in lines:
			i,w = skip_leading_ws_with_indent(line,0,c.tab_width)
			s = computeLeadingWhitespace(w,-abs(c.tab_width)) + line[i:] # use negative width.
			if s != line: changed = true
			result.append(s)
	else: # DTHEIN 3-NOV-2002: use the relative @tabwidth (tabWidth)
		for line in lines:
			i,w = skip_leading_ws_with_indent(line,0,tabWidth)
			s = computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
			if s != line: changed = true
			result.append(s)

	if changed:
		result = string.join(result,'\n')
		c.updateBodyPane(head,result,tail,"Convert Tabs",oldSel,oldYview) # Handles undo
		setTextSelection(c.body,"1.0","1.0")</t>
<t tx="T943">def convertBlanks (self):

	c = self ; v = current = c.currentVnode()
	head,lines,tail,oldSel,oldYview = c.getBodyLines()
	result = [] ; changed = false

	# DTHEIN 3-NOV-2002: use the relative @tabwidth, not the global one
	dict = scanDirectives(c)
	tabWidth  = dict.get("tabwidth")

	if 0: # DTHEIN 3-NOV-2002: don't use the global @tabwidth
		for line in lines:
			s = optimizeLeadingWhitespace(line,c.tab_width)
			if s != line: changed = true
			result.append(s)
	else: # DTHEIN 3-NOV-2002: use relative @tabwidth (tabWidth)
		for line in lines:
			s = optimizeLeadingWhitespace(line,tabWidth)
			if s != line: changed = true
			result.append(s)

	if changed:
		result = string.join(result,'\n')
		c.updateBodyPane(head,result,tail,"Convert Blanks",oldSel,oldYview) # Handles undo
		setTextSelection(c.body,"1.0","1.0")
</t>
<t tx="T944">@nocolor

By: riotnrrrd ( Timo Honkasalo ) 
 Pasted text doesn't stick   
2002-11-01 13:38  
System: Linux 

Under X Window system, when text is selected, it is automatically entered into a buffer and can be pasted with the middle button of the mouse. 

In Leo, when this is done, the text is rendered in right place, but it doesn't stick unless some key is pressed after pasting. That is, if I leave the node in question without pressing any key after pressing the middle button, the pasted text is gone when I come back to that node. 

Doing copy and paste works normally when done through the edit menu. 

-------------------

I also found out that if you do an extra "click" on the control key, it will
stick from then on.

If your text should have color in it, you can see that right before you "click",
the text has no color and the color back on right after you click the control.

It maybe a clue to someone, but seems strange to me. 
</t>
<t tx="T945">abc bbb bbbxyz bbb</t>
<t tx="T946">def canPasteOutline (self,s=None):

	a = app() ; c = self

	if s == None:
		try:
			s = a.root.selection_get(selection="CLIPBOARD")
		except:
			return false
		
	if match(s,0,a.prolog_prefix_string):
		return true
	elif len(s) &gt; 0:
		return c.importCommands.stringIsValidMoreFile(s)
	else:
		return false</t>
<t tx="T947"></t>
<t tx="T948">def cutOutline(self):

	c = self
	if c.canDeleteHeadline():
		c.copyOutline()
		c.deleteHeadline("Cut Node")
		c.recolor()</t>
<t tx="T949">def copyOutline(self):

	c = self
	c.endEditing()
	c.fileCommands.assignFileIndices()
	s = c.fileCommands.putLeoOutline()
	# trace(`s`)
	app().root.clipboard_clear()
	app().root.clipboard_append(s)
	# Copying an outline has no undo consequences.
</t>
<t tx="T950">@ To cut and paste between apps, just copy into an empty body first, then copy to Leo's clipboard.
@c

def pasteOutline(self):

	a = app() ; c = self ; current = c.currentVnode()
	
	try:
		s = a.root.selection_get(selection="CLIPBOARD")
	except:
		s = None # This should never happen.

	if not s or not c.canPasteOutline(s):
		return # This should never happen.

	isLeo = match(s,0,a.prolog_prefix_string)

	# trace(`s`)
	if isLeo:
		v = c.fileCommands.getLeoOutline(s)
	else:
		v = c.importCommands.convertMoreStringToOutlineAfter(s,current)
	if v:
		c.endEditing()
		c.beginUpdate()
		if 1: # inside update...
			v.createDependents()# To handle effects of clones.
			c.validateOutline()
			c.selectVnode(v)
			v.setDirty()
			c.setChanged(true)
			# paste as first child if back is expanded.
			back = v.back()
			if back and back.isExpanded():
				v.moveToNthChildOf(back,0)
			c.undoer.setUndoParams("Paste Node",v)
		c.endUpdate()
		c.recolor()
	else:
		es("The clipboard is not a valid " + choose(isLeo,"Leo","MORE") + " file")</t>
<t tx="T951">def OnPaste (self,event=None):

	# Activate the body key handler by hand.
	c = self.commands ; v = c.currentVnode()
	self.commands.tree.onBodyWillChange(v,"Paste")
	
def OnPasteNode (self,event=None):

	# trace(`event`)
	pass
	
def OnPasteFromMenu (self,event=None):

	w = self.getFocus()
	w.event_generate(virtual_event_name("Paste"))
	
	# 10/23/02: Make sure the event sticks.
	c = self.commands ; v = c.currentVnode()
	c.tree.onHeadChanged(v) # Works even if it wasn't the headline that changed.
</t>
<t tx="T952">def OnCopy (self,event=None):

	# Copy never changes dirty bits or syntax coloring.
	pass
	
def OnCopyFromMenu (self,event=None):

	# trace()
	w = self.getFocus()
	w.event_generate(virtual_event_name("Copy"))
</t>
<t tx="T953">def OnCut (self,event=None):

	# Activate the body key handler by hand.
	c = self.commands ; v = c.currentVnode()
	self.commands.tree.onBodyWillChange(v,"Cut")

def OnCutFromMenu (self,event=None):

	w = self.getFocus()
	w.event_generate(virtual_event_name("Cut"))
	
	# 11/2/02: Make sure the event sticks.
	c = self.commands ; v = c.currentVnode()
	c.tree.onHeadChanged(v) # Works even if it wasn't the headline that changed.
</t>
<t tx="T954">def __init__(self, title = None):

	Tk = Tkinter
	&lt;&lt; set the LeoFrame ivars &gt;&gt;
	self.top = top = Tk.Toplevel()
	top.withdraw() # 7/15/02
	attachLeoIcon(top)
	# print top
	
	if sys.platform=="win32":
		self.hwnd = top.frame()
		# trace("__init__", "frame.__init__: self.hwnd:" + `self.hwnd`)
	top.title(title)
	
	top.minsize(30,10) # In grid units. This doesn't work as I expect.
	
	c = None # Make sure we don't mess with c yet.
	self.createBothLeoSplitters(top)
	self.commands = c = leoCommands.Commands(self)
	self.tree = leoTree.leoTree(self.commands, self.canvas)
	c.tree = self.tree
	self.setTabWidth(c.tab_width)
	&lt;&lt; create the first tree node &gt;&gt;
	flag = handleLeoHook("menu1")
	if flag == None: # Anything other than None overrides.
		self.createMenuBar(top)
	app().log = self # the LeoFrame containing the log
	app().windowList.append(self)
	# Sign on.
	es("Leo Log Window...")
	n1,n2,n3,junk,junk=sys.version_info
	ver1 = "Python %d.%d.%d" % (n1,n2,n3)
	ver2 = ", Tk " + self.top.getvar("tk_patchLevel")
	es(ver1 + ver2) ; enl()

	self.top.protocol("WM_DELETE_WINDOW", self.OnCloseLeoEvent)
	self.top.bind("&lt;Button-1&gt;", self.OnActivateLeoEvent)
	self.top.bind("&lt;Activate&gt;", self.OnActivateLeoEvent) # Doesn't work on windows.
	self.top.bind("&lt;Deactivate&gt;", self.OnDeactivateLeoEvent) # Doesn't work on windows.
	self.top.bind("&lt;Control-KeyPress&gt;",self.OnControlKeyDown)
	self.top.bind("&lt;Control-KeyRelease&gt;",self.OnControlKeyUp)
	self.tree.canvas.bind("&lt;Button-1&gt;", self.OnActivateTree)
	self.body.bind("&lt;Button-1&gt;", self.OnActivateBody)
	self.body.bind("&lt;Double-Button-1&gt;", self.OnBodyDoubleClick)
	self.log.bind("&lt;Button-1&gt;", self.OnActivateLog)
	self.body.bind("&lt;Key&gt;", self.tree.OnBodyKey)
	self.body.bind(virtual_event_name("Cut"), self.OnCut)
	self.body.bind(virtual_event_name("Copy"), self.OnCopy)
	self.body.bind(virtual_event_name("Paste"), self.OnPaste)
	
	# Handle mouse wheel in the outline pane.
	if sys.platform == "linux2": # This crashes tcl83.dll
		self.tree.canvas.bind("&lt;MouseWheel&gt;", self.OnMouseWheel)</t>
<t tx="T955"># Set title and fileName
if title:
	self.mFileName = title
else:
	title = "untitled"
	n = app().numberOfWindows
	if n &gt; 0: title += `n`
	app().numberOfWindows = n+1
	self.mFileName = ""
	
self.stylesheet = None # The contents of &lt;?xml-stylesheet...?&gt; line.

# These are set the first time a panel is opened.
# The panel remains open (perhaps hidden) until this frame is closed.
self.colorPanel = None 
self.fontPanel = None 
self.prefsPanel = None
self.comparePanel = None
	
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.title=title # Title of window, not including dirty mark
self.saved=false # True if ever saved
self.startupWindow=false # True if initially opened window
self.openDirectory = ""
self.es_newlines = 0 # newline count for this log stream

self.splitVerticalFlag,self.ratio,self.secondary_ratio = self.initialRatios()

# Created below
self.commands = None
self.tree = None
self.f1 = self.f2 = None
self.log = None  ; self.logBar = None
self.body = None ; self.bodyBar = None
self.canvas = None ; self.treeBar = None
self.splitter1 = self.splitter2 = None
self.icon = None

self.menus = {} # Menu dictionary.
self.menuShortcuts = None # List of menu shortcuts for warnings.

# Used by event handlers...
self.redrawCount = 0
self.activeFrame = None
self.draggedItem = None
self.recentFiles = [] # List of recent files
self.controlKeyIsDown = false # For control-drags</t>
<t tx="T956">t = leoNodes.tnode()
v = leoNodes.vnode(c,t)
v.initHeadString("NewHeadline")
v.moveToRoot()

c.beginUpdate()
c.tree.redraw()
c.tree.canvas.focus_get()
c.editVnode(v)
c.endUpdate(false)</t>
<t tx="T957"></t>
<t tx="T958">def bound_paragraph(t=None):
	"""Find the bounds of the text paragraph that contains the current cursor position.
	
t: a Tk.Text widget

Returns:
	None if the cursor is on a whitespace line or a delimeter line.
	Otherwise: (start,end,endsWithNL,wsFirst,wsSecond)

start: the paragraph starting position,
end: the paragraph ending position,
endsWithNL: true if the paragraph ends with a newline"""

	if not t: return None
	x=t.index("insert")
	
	# Return if the selected line is all whitespace or a Leo directive.
	s = t.get(x+"linestart",x+"lineend")
	if len(s)==0 or s.isspace() or s[0] == '@':
		return None	

	# Point start and end at the start and end of the selected line.
	start = t.index(x+"linestart")
	tmpLine = int(float(start))
	end = str(tmpLine + 1) + ".0"
	
	# EKR: This is needlessly complex.
	# It would be much easier to use a list of lines,
	# rather than asking TK to do so much work.

	# Set start to the start of the paragraph.
	while (tmpLine &gt; 1):
		tmpLine -= 1
		tmp = str(tmpLine) + ".0"
		s = t.get(tmp,tmp+"lineend")
		if len(s)==0 or s.isspace() or s[0] == '@':
			break
		start = tmp

	# Set end to the end of the paragraph.
	tmpLine = int(float(end))
	bodyEnd = t.index("end")

	while end != bodyEnd:
		end = str(tmpLine) + ".0"
		s = t.get(end,end+"lineend")
		if len(s)==0 or s.isspace() or s[0] == '@':
			break
		tmpLine += 1

	# do we insert a trailing NL?
	endsWithNL = len(t.get(end))

	return start, end, endsWithNL</t>
<t tx="T959"># t is a Tk.Text widget.  Returns the selected range of t.

def getTextSelection (t):

	# To get the current selection
	sel = t.tag_ranges("sel")
	if len(sel) == 2:
		start, end = sel # unpack tuple.
		return start, end
	else: return None, None</t>
<t tx="T960"># t is a Tk.Text widget.  Returns the text of the selected range of t.

def getSelectedText (t):

	start, end = getTextSelection(t)
	if start and end:
		return t.get(start,end)
	else:
		return None</t>
<t tx="T961">@ t is a Tk.Text widget.  start and end are positions.  Selects from start to end.
@c

def setTextSelection (t,start,end): 

	if not start or not end:
		return
	if t.compare(start, "&gt;", end):
		start,end = end,start
		
	t.tag_remove("sel","1.0",start)
	t.tag_add("sel",start,end)
	t.tag_remove("sel",end,"end")
	t.mark_set("insert",end)
</t>
<t tx="T962">@ I used SciTE to open a .htm file I made with MS Word and Front Page.  I
selected a buncha text, copied and pasted into the Leo text window in a doc
chunk.  The star came on in the (Leo) title bar indicating the file had been
altered.  I pulled down File | Save and the * didn't go away.  The command
window shows:

Exception in Tkinter callback
Traceback (most recent call last):
  File "C:\Python22\lib\lib-tk\Tkinter.py", line 1292, in __call__
    return apply(self.func, args)
  File "C:\downloads\Leo\Leo-2.7beta\leo-2.7beta\leoFrame.py", line 1175, in OnSave
    c.fileCommands.save(self.mFileName)
  File "C:\downloads\Leo\Leo-2.7beta\leo-2.7beta\leoFileCommands.py", line 1346, in save
    if self.write_LEO_file(fileName,false): # outlineOnlyFlag
  File "C:\downloads\Leo\Leo-2.7beta\leo-2.7beta\leoFileCommands.py", line 1423, in write_LEO_file
    at.writeAll(c.rootVnode(), false) # forceFlag
  File "C:\downloads\Leo\Leo-2.7beta\leo-2.7beta\leoAtFile.py", line 2203, in writeAll
    self.write(v)
  File "C:\downloads\Leo\Leo-2.7beta\leo-2.7beta\leoAtFile.py", line 2108, in write
    self.putBodyPart(root)
  File "C:\downloads\Leo\Leo-2.7beta\leo-2.7beta\leoAtFile.py", line 1663, in putBodyPart
    i = self.putCodePart(s,i,v)
  File "C:\downloads\Leo\Leo-2.7beta\leo-2.7beta\leoAtFile.py", line 1755, in putCodePart
    self.putRef(name,v,s,j,delta)
  File "C:\downloads\Leo\Leo-2.7beta\leo-2.7beta\leoAtFile.py", line 1859, in putRef
    self.putBody(v, ref)
  File "C:\downloads\Leo\Leo-2.7beta\leo-2.7beta\leoAtFile.py", line 1627, in putBody
    self.putBodyPart(v)
  File "C:\downloads\Leo\Leo-2.7beta\leo-2.7beta\leoAtFile.py", line 1663, in putBodyPart
    i = self.putCodePart(s,i,v)
  File "C:\downloads\Leo\Leo-2.7beta\leo-2.7beta\leoAtFile.py", line 1755, in putCodePart
    self.putRef(name,v,s,j,delta)
  File "C:\downloads\Leo\Leo-2.7beta\leo-2.7beta\leoAtFile.py", line 1859, in putRef
    self.putBody(v, ref)
  File "C:\downloads\Leo\Leo-2.7beta\leo-2.7beta\leoAtFile.py", line 1627, in putBody
    self.putBodyPart(v)
  File "C:\downloads\Leo\Leo-2.7beta\leo-2.7beta\leoAtFile.py", line 1656, in putBodyPart
    i = self.putDoc(s,i,kind)
  File "C:\downloads\Leo\Leo-2.7beta\leo-2.7beta\leoAtFile.py", line 1938, in putDoc
    self.putDocPart(s[i:j])
  File "C:\downloads\Leo\Leo-2.7beta\leo-2.7beta\leoAtFile.py", line 1998, in putDocPart
    self.os(theLine)
  File "C:\downloads\Leo\Leo-2.7beta\leo-2.7beta\leoAtFile.py", line 1610, in os

    self.outputFile.write(s)
UnicodeError: ASCII encoding error: ordinal not in range(128)</t>
<t tx="T963">def oblank(self):
	self.os(' ')

def oblanks(self,n):
	self.os(' ' * abs(n))

def onl(self):
	self.os(self.output_newline)

def os(self,s):
	if s is None or len(s) == 0: return
	if self.suppress_newlines and self.newline_pending:
		self.newline_pending = false
		s = self.output_newline + s
	if self.outputFile:
		try:
			try:
				self.outputFile.write(s)
			except UnicodeError: # This might never happen.
				xml_encoding = app().config.xml_version_string
				s = s.encode(xml_encoding)
				self.outputFile.write(s)
		except:
			es("exception writing:" + `s`)
			es_exception()

def otabs(self,n):
	self.os('\t' * abs(n))</t>
<t tx="T964"># Puts a comment part in comments.
# Note: this routine is _never_ called in cweb mode,
# so noweb section references are _valid_ in cweb doc parts!

def putDocPart(self,s):

	# j = skip_line(s,0) ; trace(`s[:j]`)
	c = self.commands
	single = len(self.endSentinelComment) == 0
	if not single:
		self.putIndent(self.indent)
		self.os(self.startSentinelComment) ; self.onl()
	# Put all lines.
	i = 0 ; n = len(s)
	while i &lt; n:
		self.putIndent(self.indent)
		leading = self.indent
		if single:
			self.os(self.startSentinelComment) ; self.oblank()
			leading += len(self.startSentinelComment) + 1
		&lt;&lt; copy words, splitting the line if needed &gt;&gt;
	if not single:
		# This comment is like a sentinel.
		self.onl() ; self.putIndent(self.indent)
		self.os(self.endSentinelComment)
		self.onl() # Note: no trailing whitespace.</t>
<t tx="T965">@ We remove trailing whitespace from lines that have _not_ been split so that a newline has been inserted by this routine if and only if it is preceded by whitespace.
@c

line = i # Start of the current line.
while i &lt; n:
	word = i # Start of the current word.
	# Skip the next word and trailing whitespace.
	i = skip_ws(s, i)
	while i &lt; n and not is_nl(s,i) and not is_ws(s[i]):
		i += 1
	i = skip_ws(s,i)
	# Output the line if no more is left.
	if i &lt; n and is_nl(s,i):
		break
	# Split the line before the current word if needed.
	lineLen = i - line
	if line == word or leading + lineLen &lt; self.page_width:
		word = i # Advance to the next word.
	else:
		# Write the line before the current word and insert a newline.
		theLine = s[line:word]
		self.os(theLine)
		self.onl() # This line must contain trailing whitespace.
		line = i = word  # Put word on the next line.
		break
# Remove trailing whitespace and output the remainder of the line.
theLine = string.rstrip(s[line:i]) # from right.
self.os(theLine)
if i &lt; n and is_nl(s,i):
	i = skip_nl(s,i)
	self.onl() # No inserted newline and no trailing whitespace.</t>
<t tx="T966">def canRevert (self):

	# c.mFileName will be "untitled" for unsaved files.
	c = self
	return (c.frame and c.frame.mFileName and
		len(c.frame.mFileName) &gt; 0 and c.isChanged())</t>
<t tx="T967">def OnRevert(self,event=None):

	# Make sure the user wants to Revert.
	if not self.mFileName:
		self.mFileName = ""
	if len(self.mFileName)==0:
		return
	
	d = leoDialog.leoDialog()
	reply = d.askYesNo("Revert",
		"Revert to previous version of " + self.mFileName + "?")

	if reply=="no":
		return

	# Kludge: rename this frame so OpenWithFileName won't think it is open.
	fileName = self.mFileName ; self.mFileName = ""

	# Create a new frame before deleting this frame.
	ok, frame = self.OpenWithFileName(fileName)
	if ok:
		frame.top.deiconify()
		app().windowList.remove(self)
		self.destroy() # Destroy this frame.
	else:
		self.mFileName = fileName
</t>
<t tx="T968">def OnDelete(self,event=None):

	c = self.commands ; v = c.currentVnode()
	first, last = getTextSelection(self.body)
	if first and last:
		self.body.delete(first,last)
		c.tree.onBodyChanged(v,"Delete")
</t>
<t tx="T969">@ignore</t>
<t tx="T970">@ This executes body text as a Python script.  We execute the selected text, or the entire body text if no text is selected.
@c

def OnExecuteScript(self,event=None,v=None):
	
	c = self.commands ; body = self.body ; s = None
	if v == None:
		v = c.currentVnode() 

	# Assume any selected body text is a script.
	start,end = getTextSelection(body)
	if start and end:
		s = body.get(start,end)
	else:
		s = body.get("1.0","end")
	if s == None:
		s = ""
		
	s = s.strip()
	
	# Neither of these helps with the unicode problems.
	# s,u = convertUnicodeToString(s)
	# s,u = convertStringToUnicode(s)

	# trace(`s`)
	if s and len(s) &gt; 0:
		s += '\n' # Make sure we end the script properly.
		try:
			# 11/18/02: don't pollute the exec environment with Leo globals.
			exec(s,__builtins__,__builtins__)
		except:
			es("exception executing script")
			es_exception(full=false)
	else:
		es("no script selected")</t>
<t tx="T971"># Calling redraw inside c.beginUpdate()/c.endUpdate() does nothing.
# This _is_ useful when a flag is passed to c.endUpdate.
def redraw (self):
	if self.updateCount == 0 and not self.redrawScheduled:
		# print "tree.redraw"
		self.redrawScheduled = true
		self.canvas.after_idle(self.idle_redraw)
		
# Schedules a redraw even if inside beginUpdate/endUpdate
def force_redraw (self):
	# print "tree.force_redraw"
	if not self.redrawScheduled:
		self.redrawScheduled = true
		self.canvas.after_idle(self.idle_redraw)
		
# Redraws immediately: used by Find so a redraw doesn't mess up selections.
# It is up to the caller to ensure that no other redraws are pending.
def redraw_now (self):

	# print "tree.redraw_now: ", self.redrawScheduled
	self.idle_redraw()

def idle_redraw (self):

	# trace()
	self.redrawScheduled = false
	frame = self.commands.frame
	if frame in app().windowList and app().quitting == 0:
		# self.redrawCount += 1 ; trace(`self.redrawCount`)
		self.expandAllAncestors(self.currentVnode)
		# Erase and redraw the entire tree.
		oldcursor = self.canvas['cursor']
		self.canvas['cursor'] = "watch"
		self.deleteBindings()
		self.canvas.delete("all")
		self.drawTree(self.rootVnode,root_left,root_top,0,0)
		self.canvas['cursor'] = oldcursor
		# Set up the scroll region.
		x0, y0, x1, y1 = self.canvas.bbox("all")
		self.canvas.configure(scrollregion=(0, 0, x1, y1))
		# Schedule a scrolling operation after the scrollbar is redrawn
		self.canvas.after_idle(self.idle_scrollTo)
		if self.recycleBindings:
			collectGarbage()</t>
<t tx="T972">def setNormalLabelState (self,v): # selected, editing
	if v and v.edit_text:
		&lt;&lt; set editing headline colors &gt;&gt;

def setDisabledLabelState (self,v): # selected, disabled
	if v and v.edit_text:
		&lt;&lt; set selected, disabled headline colors &gt;&gt;

def setSelectedLabelState (self,v): # selected, not editing
	self.setDisabledLabelState(v)

def setUnselectedLabelState (self,v): # not selected.
	if v and v.edit_text:
		&lt;&lt; set unselected headline colors &gt;&gt;</t>
<t tx="T973">config = app().config
fg   = config.getWindowPref("headline_text_editing_foreground_color")
bg   = config.getWindowPref("headline_text_editing_background_color")
selfg = config.getWindowPref("headline_text_editing_selection_foreground_color")
selbg = config.getWindowPref("headline_text_editing_selection_background_color")
if fg and bg and selfg and selbg:
	try:
		v.edit_text.configure(state="normal",highlightthickness=1,
			selectforeground=selfg,selectbackground=selbg,fg=fg, bg=bg)
		return
	except:
		es_exception()
elif selfg and selbg:
	try:
		v.edit_text.configure(state="normal",highlightthickness=1,
			selectforeground=selfg,selectbackground=selbg,fg="black",bg="white")
		return
	except:
		es_exception()
elif fg and bg:
	try:
		v.edit_text.configure(state="normal",highlightthickness=1,fg=fg,bg=bg)
		return
	except:
		es_exception()
		
v.edit_text.configure(state="normal",highlightthickness=1,fg="black",bg="white")</t>
<t tx="T974">config = app().config
fg = config.getWindowPref("headline_text_selected_foreground_color")
bg = config.getWindowPref("headline_text_selected_background_color")
if fg and bg:
	try:
		v.edit_text.configure(state="disabled",highlightthickness=0,fg=fg, bg=bg)
		return
	except:
		es_exception()

v.edit_text.configure(state="disabled",highlightthickness=0,fg="black",bg="gray80")</t>
<t tx="T975">config = app().config
fg = config.getWindowPref("headline_text_unselected_foreground_color")
bg = config.getWindowPref("headline_text_unselected_background_color")
if fg and bg:
	try:
		v.edit_text.configure(state="disabled",highlightthickness=0,fg=fg, bg=bg)
		return
	except:
		es_exception()
		
v.edit_text.configure(state="disabled",highlightthickness=0,fg="black", bg="white")</t>
<t tx="T976">@ The find and change commands are tricky; there are many details that must be handled properly. This documentation describes the leo.py code. Previous versions of Leo used an inferior scheme.  The following principles govern the LeoFind class:

1.	Find and Change commands initialize themselves using only the state of the present Leo window. In particular, the Find class must not save internal state information from one invocation to the next. This means that when the user changes the nodes, or selects new text in headline or body text, those changes will affect the next invocation of any Find or Change command. Failure to follow this principle caused all kinds of problems in the Borland and Macintosh codes. There is one exception to this rule: we must remember where interactive wrapped searches start. This principle simplifies the code because most ivars do not persist. However, each command must ensure that the Leo window is left in a state suitable for restarting the incremental (interactive) Find and Change commands. Details of initialization are discussed below.

2. The Find and Change commands must not change the state of the outline or body pane during execution. That would cause severe flashing and slow down the commands a great deal. In particular, c.selectVnode and c.editVnode methods must not be called while looking for matches.

3. When incremental Find or Change commands succeed they must leave the Leo window in the proper state to execute another incremental command. We restore the Leo window as it was on entry whenever an incremental search fails and after any Find All and Change All command.

Initialization involves setting the self.c, self.v, self.in_headline, self.wrapping and self.s_text ivars. Setting self.in_headline is tricky; we must be sure to retain the state of the outline pane until initialization is complete. Initializing the Find All and Change All commands is much easier because such initialization does not depend on the state of the Leo window.

Using Tk.Text widgets for both headlines and body text results in a huge simplification of the code. Indeed, the searching code does not know whether it is searching headline or body text. The search code knows only that self.s_text is a Tk.Text widget that contains the text to be searched or changed and the insert and sel Tk attributes of self.search_text indicate the range of text to be searched. Searching headline and body text simultaneously is complicated. The selectNextVnode() method handles the many details involved by setting self.s_text and its insert and sel attributes.
</t>
<t tx="T977">def __init__(self):

	Tk=Tkinter
	&lt;&lt; Initialize the leoFind ivars &gt;&gt;
	self.top = top = Tk.Toplevel()
	top.title("Leo Find/Change")
	top.resizable(0,0) # neither height or width is resizable.
	# self.top.SetIcon("LeoIcon")

	# Create the find panel...
	outer = Tk.Frame(top,relief="groove",bd=2)
	outer.pack(padx=2,pady=2)
	&lt;&lt; Create the Find and Change panes &gt;&gt;
	&lt;&lt; Create two columns of checkboxes &gt;&gt;
	&lt;&lt; Create two rows of buttons &gt;&gt;
	self.top.protocol("WM_DELETE_WINDOW", self.OnCloseFindEvent)
	self.find_text.bind  ("&lt;1&gt;", self.resetWrap)
	self.change_text.bind("&lt;1&gt;", self.resetWrap)
	self.find_text.bind  ("&lt;Key&gt;", self.resetWrap)
	self.change_text.bind("&lt;Key&gt;", self.resetWrap)</t>
<t tx="T978"># Initialize the ivars for the find panel.
for var in ivars:
	exec ("self.%s_flag = Tk.IntVar()" % var)
	
# The c.x_flag ivars contain the user preferences.
# These are updated just before executing any find/change command.

# Ivars containing internal state...
self.commands = None # The commander for this search.
self.v = None # The vnode being searched.  Never saved between searches!
self.in_headline = false # true: searching headline text.
self.wrapping = false # true: wrapping is enabled. _not_ the same as c.wrap_flag for batch searches.
self.s_text = Tk.Text() # Used by find.search()

@ Initializing a wrapped search is tricky.  The search() method will fail if v==wrapVnode and pos &gt;= wrapPos.  selectNextVnode() will fail if v == wrapVnode.  We set wrapPos on entry, before the first search.  We set wrapVnode in selectNextVnode after the first search fails.  We also set wrapVnode on exit if the first search suceeds.
@c
self.wrapVnode = None # The start of wrapped searches: persists between calls.
self.onlyVnode = None # The starting node for suboutline-only searches.
self.wrapPos = None # The starting position of the wrapped search: persists between calls.</t>
<t tx="T979">fc = Tk.Frame(outer, bd="1m")
fc.pack(anchor="n", fill="x", expand=1)

fpane = Tk.Frame(fc, borderwidth=1, height="0.95i", width="1.5i")
cpane = Tk.Frame(fc, borderwidth=1, height="0.95i", width="1.5i")

fpane.pack(anchor="n", expand=1, fill="x")
cpane.pack(anchor="s", expand=1, fill="x")

# Create the labels and text fields...
flab = Tk.Label(fpane, width=8, text="Find:")
clab = Tk.Label(cpane, width=8, text="Change:")
self.find_text   = ftxt = Tk.Text(fpane, height=2, width=20)
self.change_text = ctxt = Tk.Text(cpane, height=2, width=20)

flab.pack(side="left")
clab.pack(side="left")
ctxt.pack(side="right", expand=1, fill="both")
ftxt.pack(side="right", expand=1, fill="both")</t>
<t tx="T980">boxes = Tk.Frame(outer, bd="1m")
boxes.pack(anchor="n", expand=1, fill="x")

lt = Tk.Frame(boxes, bd=1)
rt = Tk.Frame(boxes, bd=1)
lt.pack(side="left", padx="5m")
rt.pack(side="right", ipadx="2m")

lt_list = [
	("Show Context", "batch"), # batch flag now records Show context.
	("Wrap Around", "wrap"),
	("Whole Word", "whole_word"),
	("Ignore Case", "ignore_case"),
	("Pattern Match", "pattern_match"),
	("Reverse", "reverse")]

rt_list = [
	("Search Headline Text", "search_headline"),
	("Search Body Text", "search_body"),
	("Suboutline Only", "suboutline_only"),
	("Node Only", "node_only"),
	("Mark Changes", "mark_changes"),
	("Mark Finds", "mark_finds") ]

for name, var in lt_list:
	exec ( 'box = Tk.Checkbutton(lt, anchor="w", text="' + name +
		'", variable=self.' + var + "_flag)" )
	box.pack(fill="x")
	box.bind("&lt;1&gt;", self.resetWrap)
	
for name, var in rt_list:
	exec ( 'box = Tk.Checkbutton(rt, anchor="w", text="' + name +
		'", variable=self.' + var + "_flag)" )
	box.pack(fill="x")
	box.bind("&lt;1&gt;", self.resetWrap)
</t>
<t tx="T981"># Create the button panes
buttons  = Tk.Frame(outer, bd=1)
buttons2 = Tk.Frame(outer, bd=1)
buttons.pack (anchor="n", expand=1, fill="x")
buttons2.pack(anchor="n", expand=1, fill="x")

# Create the first row of buttons
findButton   =Tk.Button     (buttons,width=8,text="Find",command=self.findButton)
findAllButton=Tk.Button     (buttons,width=8,text="Find All",command=self.findAllButton)

if 0: # Now in left column.
	reverseBox   =Tk.Checkbutton(buttons,width=8,text="Reverse",variable=self.reverse_flag)
	reverseBox.bind("&lt;1&gt;", self.resetWrap)


findButton.pack   (pady="1m",padx="1m",side="left")
# reverseBox.pack   (pady="1m",          side="left",expand=1)
findAllButton.pack(pady="1m",padx="1m",fill="x",side="right")

# Create the second row of buttons
changeButton    =Tk.Button(buttons2,width=8,text="Change",command=self.changeButton)
changeFindButton=Tk.Button(buttons2,        text="Change, Then Find",command=self.changeThenFindButton)
changeAllButton =Tk.Button(buttons2,width=8,text="Change All",command=self.changeAllButton)

changeButton.pack    (pady="1m",padx="1m",side="left")
changeFindButton.pack(pady="1m",          side="left",expand=1)
changeAllButton.pack (pady="1m",padx="1m",side="right")</t>
<t tx="T982">def init (self,c):

	for var in ivars:
		exec("self.%s_flag.set(c.%s_flag)" % (var,var))

	&lt;&lt; set widgets &gt;&gt;
	
	# trace("__init__", "find.init")</t>
<t tx="T983">self.find_text.delete("1.0","end")
self.find_text.insert("end",c.find_text)

self.change_text.delete("1.0","end")
self.change_text.insert("end",c.change_text)</t>
<t tx="T984">def resetWrap (self,event=None):

	self.wrapVnode = None
	self.onlyVnode = None</t>
<t tx="T985"></t>
<t tx="T986">
# The user has pushed the "Change" button from the find panel.

def changeButton(self):

	self.setup_button()
	self.change()</t>
<t tx="T987"># The user has pushed the "Change All" button from the find panel.

def changeAllButton(self):

	c = self.setup_button()
	c.clearAllVisited() # Clear visited for context reporting.
	self.changeAll()</t>
<t tx="T988"># The user has pushed the "Change Then Find" button from the find panel.

def changeThenFindButton(self):

	self.setup_button()
	self.changeThenFind()</t>
<t tx="T989"># The user has pushed the "Find" button from the find panel.

def findButton(self):

	self.setup_button()
	self.findNext()</t>
<t tx="T990"># The user has pushed the "Find All" button from the find panel.

def findAllButton(self):

	c = self.setup_button()
	c.clearAllVisited() # Clear visited for context reporting.
	self.findAll()</t>
<t tx="T991"># The user has selected the "Replace" menu item.

def changeCommand(self,c):

	self.setup_command(c)
	self.change()</t>
<t tx="T992"># The user has pushed the "Change Then Find" button from the Find menu.

def changeThenFindCommand(self,c):

	self.setup_command(c)
	self.changeThenFind()</t>
<t tx="T993"># The user has selected the "Find Next" menu item.

def findNextCommand(self,c):

	self.setup_command(c)
	self.findNext()</t>
<t tx="T994"># The user has selected the "Find Previous" menu item.

def findPreviousCommand(self,c):

	self.setup_command(c)
	c.reverse_flag = not c.reverse_flag
	self.findNext()
	c.reverse_flag = not c.reverse_flag</t>
<t tx="T995"># Initializes a search when a button is pressed in the Find panel.

def setup_button(self):

	self.commands = c = app().log.commands
	self.v = c.currentVnode()
	assert(c)
	c.bringToFront()
	if 0: # We _must_ retain the editing status for incremental searches!
		c.endEditing()
	c.setIvarsFromFind()
	return c</t>
<t tx="T996"># Initializes a search when a command is invoked from the menu.

def setup_command(self,c):

	self.commands = c
	self.v = c.currentVnode()
	if 0: # We _must_ retain the editing status for incremental searches!
		c.endEditing()
	c.setIvarsFromFind()</t>
<t tx="T997"></t>
<t tx="T998">@ This routine performs a single batch change operation, updating the head or body string of v and leaving the result in s_text.  We update the c.body if we are changing the body text of c.currentVnode().

s_text contains the found text on entry and contains the changed text on exit.  pos and pos2 indicate the selection.  The selection will never be empty. NB: we can not assume that self.v is visible.
@c

def batchChange (self,pos1,pos2,count):

	c = self.commands ; v = self.v ; st = self.s_text
	# Replace the selection with c.change_text
	# s = st.get("1.0","end") ; trace("entry:" + `s`)
	if st.compare(pos1, "&gt;", pos2):
		pos1,pos2=pos2,pos1
	st.delete(pos1,pos2)
	st.insert(pos1,c.change_text)
	s = st.get("1.0","end")
	# Update the selection.
	insert=choose(c.reverse_flag,pos1,pos1+'+'+`len(c.change_text)`+'c')
	st.tag_remove("sel","1.0","end")
	st.mark_set("insert",insert)
	# trace("result:" + `insert` + ", " + `s`)
	# Update the node
	if self.in_headline:
		&lt;&lt; set the undo head params &gt;&gt;
		v.initHeadString(s)
	else:
		&lt;&lt; set the undo body typing params &gt;&gt;
		v.setBodyStringOrPane(s)
	# Set mark, changed and dirty bits.
	if c.mark_changes_flag:
		v.setMarked()
	if not c.isChanged():
		c.setChanged(true)
	v.setDirty()</t>
<t tx="T999">sel = None
if len(s) &gt; 0 and s[-1]=='\n': s = s[:-1]
if s != v.headString():
	if count == 1:
		c.undoer.setUndoParams("Change All",v) # Tag the start of the Change all.
	c.undoer.setUndoTypingParams(v,"Change Headline",v.bodyString(),s,sel,sel)</t>
<t tx="T1000">sel = c.body.index("insert")
if len(s) &gt; 0 and s[-1]=='\n': s = s[:-1]
if s != v.bodyString():
	if count == 1:
		c.undoer.setUndoParams("Change All",v) # Tag the start of the Change all.
	c.undoer.setUndoTypingParams(v,"Change",v.bodyString(),s,sel,sel)</t>
<t tx="T1001">def change(self):

	if self.checkArgs():
		self.initInHeadline()
		self.changeSelection()</t>
<t tx="T1002">def changeAll(self):

	c = self.commands ; st = self.s_text
	if not self.checkArgs():
		return
	self.initInHeadline()
	data = self.save()
	self.initBatchCommands()
	count = 0
	c.beginUpdate()
	while 1:
		pos1, pos2 = self.findNextMatch()
		if pos1:
			count += 1
			self.batchChange(pos1,pos2,count)
			line = st.get(pos1 + " linestart", pos1 + " lineend")
			self.printLine(line,all)
		else: break
	c.endUpdate() # self.restore
	# Make sure the headline and body text are updated.
	v = c.currentVnode()
	c.tree.onHeadChanged(v)
	c.tree.onBodyChanged(v,"Can't Undo")
	if count &gt; 0:
		# A change was made.  Tag the end of the Change All command.
		c.undoer.setUndoParams("Change All",v)
	## c.undoer.clearUndoState()
	es("changed: " + `count`)
	self.restore(data)</t>
<t tx="T1003"># Replace selection with c.change_text.
# If no selection, insert c.change_text at the cursor.

def changeSelection(self):
	
	c = self.commands ; v = self.v
	# trace(`self.in_headline`)
	t = choose(self.in_headline,v.edit_text,c.body)
	# Not yet: set undo params.
	sel = t.tag_ranges("sel")
	if len(sel) != 2:
		es("No text selected")
		return false
	# trace(`sel` + ", " + `c.change_text`)
	# Replace the selection
	start,end = sel
	t.delete(start,end)
	t.insert(start,c.change_text)
	# 2/7/02: Also update s_text in case we find another match on the same line.
	self.s_text.delete(start,end)
	self.s_text.insert(start,c.change_text)
	# Update the selection for the next match.
	setTextSelection(t,start,start + "+" + `len(c.change_text)` + "c")
	t.focus_force()

	c.beginUpdate()
	if c.mark_changes_flag:
		v.setMarked()
		c.tree.drawIcon(v,v.iconx,v.icony) # redraw only the icon.
	# update node, undo status, dirty flag, changed mark &amp; recolor
	if self.in_headline:
		c.tree.idle_head_key(v)
	else:
		c.tree.onBodyChanged(v,"Change")
	c.endUpdate(false) # No redraws here: they would destroy the headline selection.
	# trace(c.body.index("insert")+":"+c.body.get("insert linestart","insert lineend"))
	return true</t>
<t tx="T1004">def changeThenFind(self):

	if not self.checkArgs():
		return

	self.initInHeadline()
	if self.changeSelection():
		self.findNext(false) # don't reinitialize</t>
<t tx="T1005">def findAll(self):

	c = self.commands ; st = self.s_text
	if not self.checkArgs():
		return
	self.initInHeadline()
	data = self.save()
	self.initBatchCommands()
	count = 0
	c.beginUpdate()
	while 1:
		pos, newpos = self.findNextMatch()
		if pos:
			count += 1
			line = st.get(pos + " linestart", pos + " lineend")
			self.printLine(line,all)
		else: break
	c.endUpdate()
	es("found: " + `count`)
	self.restore(data)</t>
<t tx="T1006">def findNext(self,initFlag = true):

	c = self.commands
	if not self.checkArgs():
		return
		
	if initFlag:
		self.initInHeadline()
		data = self.save()
		self.initInteractiveCommands()
	else:
		data = self.save()
	
	c.beginUpdate()
	pos, newpos = self.findNextMatch()
	c.endUpdate(false) # Inhibit redraws so that headline remains selected.
	
	if pos:
		self.showSuccess(pos,newpos)
	else:
		if self.wrapping:
			es("end of wrapped search")
		else:
			# 8/3/02: don't put c.find_text in backquotes: that shows Unicode escape sequences.
			es("not found: " + "'" + c.find_text + "'")
		self.restore(data)</t>
<t tx="T1007"># Resumes the search where it left off.
# The caller must call set_first_incremental_search or set_first_batch_search.

def findNextMatch(self):

	c = self.commands

	if not c.search_headline_flag and not c.search_body_flag:
		return None, None

	if len(c.find_text) == 0:
		return None, None
		
	v = self.v
	while v:
		pos, newpos = self.search()
		if pos:
			if c.mark_finds_flag:
				v.setMarked()
				c.tree.drawIcon(v,v.iconx,v.icony) # redraw only the icon.
			return pos, newpos
		elif c.node_only_flag:
			# We are only searching one node.
			return None,None
		else:
			v = self.v = self.selectNextVnode()
	return None, None</t>
<t tx="T1008"># Selects the next node to be searched.

def selectNextVnode(self):

	c = self.commands ; v = self.v
	# trace(`v`)
	
	# Start suboutline only searches.
	if c.suboutline_only_flag and not self.onlyVnode:
		self.onlyVnode = v

	# Start wrapped searches.
	if self.wrapping and not self.wrapVnode:
		assert(self.wrapPos != None)
		self.wrapVnode = v

	if self.in_headline and c.search_body_flag:
		# just switch to body pane.
		self.in_headline = false
		self.initNextText()
		# trace(`v`)
		return v

	if c.reverse_flag:
		v = v.threadBack()
	else:
		v = v.threadNext()

	# Wrap if needed.
	if not v and self.wrapping and not c.suboutline_only_flag:
		v = c.rootVnode()
		if c.reverse_flag:
			# Set search_v to the last node of the tree.
			while v and v.next():
				v = v.next()
			if v: v = v.lastNode()

	# End wrapped searches.
	if self.wrapping and v and v == self.wrapVnode:
		# trace("ending wrapped search")
		v = None ; self.resetWrap()
		
	# End suboutline only searches.
	if (c.suboutline_only_flag and self.onlyVnode and v and
		(v == self.onlyVnode or not self.onlyVnode.isAncestorOf(v))):
		# trace("end outline-only")
		v = None ; self.onlyVnode = None

	self.v = v # used in initNextText().
	if v: # select v and set the search point within v.
		self.in_headline = c.search_headline_flag
		self.initNextText()
	return v</t>
<t tx="T1009">@ Searches the present headline or body text for c.find_text and returns true if found.
c.whole_word_flag, c.ignore_case_flag, and c.pattern_match_flag control the search.
@c

def search (self):

	c = self.commands ; v = self.v ; t = self.s_text
	assert(c and t and v)
	index = t.index("insert")
	stopindex = choose(c.reverse_flag,"1.0","end")
	while 1:
		# trace(`index`+":"+`stopindex`+":"+t.get(index+" linestart",index+" lineend"))
		pos = t.search(c.find_text,index,
			stopindex=stopindex,backwards=c.reverse_flag,
			regexp=c.pattern_match_flag,nocase=c.ignore_case_flag)
		if not pos:
			return None, None
		newpos = pos + "+" + `len(c.find_text)` + "c"
		if c.reverse_flag and t.compare(newpos,"==",index): # 10/3/02
			&lt;&lt; search again after getting stuck going backward &gt;&gt;
		# trace(`pos`+":"+`newpos`)
		&lt;&lt; return if we are passed the wrap point &gt;&gt;
		if c.whole_word_flag:
			index = t.index(choose(c.reverse_flag,pos,newpos))
			&lt;&lt; test for whole word match &gt;&gt;
			if not pos: continue
		# trace("found:" + `pos` + ":" + `newpos` + ":" + `v`)
		# set the insertion point.
		setTextSelection(t,pos,newpos)
		t.mark_set("insert",choose(c.reverse_flag,pos,newpos))
		return pos, newpos</t>
<t tx="T1010"># print "stuck"
index = newpos + "-" + `len(c.find_text)` + "c"
pos = t.search(c.find_text,index,
	stopindex=stopindex,backwards=c.reverse_flag,
	regexp=c.pattern_match_flag,nocase=c.ignore_case_flag)

if not pos:
	return None, None
newpos = pos + "+" + `len(c.find_text)` + "c"</t>
<t tx="T1011">if self.wrapping and self.wrapPos and self.wrapVnode and self.v == self.wrapVnode:
	if c.reverse_flag and t.compare(pos, "&lt;", self.wrapPos):
		# trace("wrap done")
		return None, None
	if not c.reverse_flag and t.compare(newpos, "&gt;", self.wrapPos):
		return None, None</t>
<t tx="T1012"># Set pos to None if word characters preceed or follow the selection.

before = t.get(pos + "-1c", pos)
first  = t.get(pos)
last   = t.get(newpos)
after  = t.get(newpos, newpos + "+1c")
# print before, first, last, after

if before and is_c_id(before) and first and is_c_id(first):
	pos = None
if after  and is_c_id(after)  and last  and is_c_id(last):
	pos = None</t>
<t tx="T1013"></t>
<t tx="T1014">def checkArgs (self):

	c = self.commands 
	val = true
	if not c.search_headline_flag and not c.search_body_flag:
		es("not searching headline or body")
		val = false
	if len(c.find_text) == 0:
		es("empty find patttern")
		val = false
	return val</t>
<t tx="T1015"># Initializes for the Find All and Change All commands.

def initBatchCommands (self):

	c = self.commands
	self.in_headline = c.search_headline_flag # Search headlines first.

	# Select the first node.
	if c.suboutline_only_flag:
		self.v = c.currentVnode()
	else:
		v = c.rootVnode()
		if c.reverse_flag:
			while v and v.next():
				v = v.next()
			v = v.lastNode()
		self.v = v
	
	# Set the insert point.
	self.initBatchText()</t>
<t tx="T1016">@ Returns s_text with "insert" point set properly for batch searches.
@c

def initBatchText(self):
	c = self.commands ; v = self.v ; st = self.s_text	
	s = choose(self.in_headline,v.headString(), v.bodyString())
	st.delete("1.0","end")
	st.insert("end",s)
	st.mark_set("insert",choose(c.reverse_flag,"end","1.0"))
	self.wrapping = false # Only interactive commands allow wrapping.
	return st

# Call this routine when moving to the next node when a search fails.
# Same as above except we don't reset wrapping flag.
def initNextText(self):
	c = self.commands ; v = self.v ; st = self.s_text	
	s = choose(self.in_headline,v.headString(), v.bodyString())
	st.delete("1.0","end")
	st.insert("end",s)
	st.mark_set("insert",choose(c.reverse_flag,"end","1.0"))
	return st</t>
<t tx="T1017"># Guesses which pane to start in for incremental searches and changes.
# This must not alter the current "insert" or "sel" marks.

def initInHeadline (self):

	c = self.commands ; v = self.v
	
	if c.search_headline_flag and c.search_body_flag:
		# Do not change this line without careful thought and extensive testing!
		self.in_headline = (v == c.tree.editVnode)
	else:
		self.in_headline = c.search_headline_flag</t>
<t tx="T1018"># For incremental searches

def initInteractiveCommands(self):

	c = self.commands ; v = self.v
	
	if self.in_headline:
		t = v.edit_text
		c.tree.editVnode = v
		pos = t.index("insert")
		# trace(`pos` + ":" + `self.in_headline` + ":" + `v==c.tree.editVnode` + ":" + `v`)
	else:
		t = c.body
		pos = t.index("insert")

	st = self.initNextText()
	t.focus_force()
	st.mark_set("insert",pos)
	self.wrapping = c.wrap_flag
	if c.wrap_flag and self.wrapVnode == None:
		self.wrapPos = pos
		# Do not set self.wrapVnode here: that must be done after the first search.</t>
<t tx="T1019">def printLine (self,line,allFlag=false):

	c = self.commands
	both = c.search_body_flag and c.search_headline_flag
	context = c.batch_flag # "batch" now indicates context

	if allFlag and both and context:
		es(`self.v`)
		type = choose(self.in_headline,"head: ","body: ")
		es(type + line)
	elif allFlag and context and not self.v.isVisited():
		# We only need to print the context once.
		es(`self.v`)
		es(line)
		self.v.setVisited()
	else:
		es(line)</t>
<t tx="T1020"># Restores the screen after a search fails

def restore (self,data):

	c = self.commands
	in_headline,v,t,insert,start,end = data
	# trace(`insert` + ":" + `start` + ":" + `end`)
	# Don't try to reedit headline.
	c.selectVnode(v) 
	if not in_headline:
		if 0: # Looks bad.
			if start and end:
				setTextSelection(t,start,end)
		else: # Looks good and provides clear indication of failure or termination.
			t.tag_remove("sel","1.0","end")
		t.mark_set("insert",insert)
		t.see("insert")
		t.focus_force()</t>
<t tx="T1021">def save (self):

	c = self.commands ; v = self.v
	t = choose(self.in_headline,v.edit_text,c.body)
	insert = t.index("insert")
	sel = t.tag_ranges("sel")
	if len(sel) == 2:
		start,end = sel
	else:
		start,end = None,None
	return (self.in_headline,v,t,insert,start,end)</t>
<t tx="T1022">@ This is used for displaying the final result.  It returns self.dummy_vnode, v.edit_text or c.body with "insert" and "sel" points set properly.
@c

def showSuccess(self,pos,newpos):

	c = self.commands ; v = self.v
	
	c.beginUpdate() # Prevent all redraws except c.tree.redraw_now()
	if 1: # range of update...
		c.selectVnode(v)
		c.tree.redraw_now() # Redraw now so selections are not destroyed.
		# Select the found vnode again after redraw.
		if self.in_headline:
			c.editVnode(v)
			c.tree.setNormalLabelState(v)
			assert(v.edit_text)
		else:
			c.selectVnode(v)
	c.endUpdate(false) # Do not draw again!

	t = choose(self.in_headline,v.edit_text,c.body)
	# trace(`self.in_headline` + "," + `t`)
	insert = choose(c.reverse_flag,pos,newpos)
	t.mark_set("insert",insert)
	setTextSelection(t,pos,newpos)
	if not self.in_headline:
		t.see(insert)
	t.focus_force()
	if c.wrap_flag and not self.wrapVnode:
		self.wrapVnode = self.v</t>
<t tx="T1023">@ignore</t>
<t tx="T1024">@nocolor
@pagewidth 40

A one-line paragraph one two three four five six seven eight nine ten...

An @rawfile tree is a tree whose root headline starts with
@rawfile &lt;filename&gt;. Similarly, an @silentfile tree is a
tree whose root headline starts with an @silentfile
&lt;filename&gt; directive.

    Leo creates derived files from @rawfile and @silentfile trees by writing the body text of all nodes of the tree in outline order.  Leo writes the body text _as is_, without recognizing section definitions, without expanding section references, and without treating directives specially in any way.  In particular, Leo copies all directives, including @space or @c directives, to the derived file as text. Exception: Leo recognizes the @ignore directive in @rawfile or @silentfile nodes, so you may use the @ignore directive as usual to prevent Leo from writing @rawfile and @silentfile trees.

There are several difference between @rawfile and @silentfile trees:
	
  This
  is
  a
  test.

  1. This is the first line and it is really really really long. And it has
	 a hanging indentation.
     and another line.

  2. This is a lllllllllllllllllllllllllllllllllllloooooooooooooooooong
     next item.
     And it too has a hanging indentation.

  3. This is an exxxxxxxxxxxxxxxxxxxxxxxxtrrrrrrrrrrrrrrreeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeemlylong
     word.
And it too has a hanging indentation.</t>
<t tx="T1025">def skip_non_ws (s,i):

	n = len(s)
	while i &lt; n and not is_ws(s[i]):
		i += 1
	return i</t>
<t tx="T1026">@ Returns a list of lines, consisting of the input lines wrapped to the given pageWidth.

Important note: this routine need not deal with leading whitespace.  Instead, the caller should simply reduce pageWidth by the width of leading whitespace wanted, then add that whitespace to the lines returned here.

The key to this code is the invarient that line never ends in whitespace.
@c
# DTHEIN 3-NOV-2002: handle indented first line (normal or hanging indent)

def wrap_lines (lines,pageWidth,firstLineWidth=None):
	
	if pageWidth &lt; 10:
		pageWidth = 10
		
	# DTHEIN 3-NOV-2002: First line is special
	if not firstLineWidth:
		firstLineWidth = pageWidth
	if firstLineWidth &lt; 10:
		firstLineWidth = 10
	outputLineWidth = firstLineWidth

	# trace(`lines`)
	result = [] # The lines of the result.
	line = "" # The line being formed.  It never ends in whitespace.
	for s in lines:
		i = 0
		while i &lt; len(s):
			assert(len(line) &lt; outputLineWidth)
			j = skip_ws(s,i)   # ;   ws = s[i:j]
			k = skip_non_ws(s,j) ; word = s[j:k]
			assert(k&gt;i)
			i = k
			if 1 + len(word) + len(line) &lt; outputLineWidth:
				if len(word) &gt; 0:
					&lt;&lt; place blank and word on the present line &gt;&gt;
				else: pass # discard the trailing whitespace.
			else:
				&lt;&lt; place word on a new line &gt;&gt;
	if len(line) &gt; 0:
		result.append(line)
	# trace(`result`)
	return result</t>
<t tx="T1027">if len(line) == 0:
	# Just add the word to the start of the line.
	line = word
else:
	# Add the word, preceeded by a blank.
	line = string.join((line,' ',word),'')</t>
<t tx="T1028"># End the previous line.
if len(line) &gt; 0:
	result.append(line)
	outputLineWidth = pageWidth # DTHEIN 3-NOV-2002: width for remaining lines
	
# Discard the whitespace and put the word on a new line.
line = word

# Careful: the word may be longer than pageWidth.
if len(line) &gt;= pageWidth:
	result.append(line)
	outputLineWidth = pageWidth # DTHEIN 3-NOV-2002: width for remaining lines
	line = ""
</t>
<t tx="T1029">def getBodyLines (self):
	
	c = self
	oldYview = c.frame.body.yview()
	i, j = getTextSelection(c.body)
	oldSel = (i,j) # 11/21/02: for undo.
		# 12-SEP-2002 DTHEIN
		# i is index to first character in the selection
	# j is index to first character following the selection
	# if selection was made from back to front, then i and j are reversed
	if i and j: # Convert all lines containing any part of the selection.
		if c.body.compare(i,"&gt;",j): i,j = j,i
		i = c.body.index(i + "linestart")
		# 12-SEP-2002 DTHEIN: don't include following line in selection
		endSel = j # position of last character of selection
		trailingNewline = ""
		line,col = j.split(".")
		if col == "0":  # DTHEIN: selection ends at start of next line
			endSel = c.body.index(j + "- 1 chars")
			trailingNewline = '\n'
		else: # DTHEIN: selection ends in the midst of a line
			endSel = c.body.index(j + "lineend")
			j = endSel
		head = c.body.get("1.0",i)
		tail = c.body.get(j,"end")
	else: # Convert the entire text.
		i = "1.0" ; j = "end" ; head = tail = ""
		endSel = c.body.index(j + "- 1 chars") # 14-SEP-2002 DTHEIN
		trailingNewline = ""
	if i == endSel:
		head = tail = None ; lines = []
	else:
		lines = c.body.get(i,endSel)
		lines = string.split(lines, '\n')
		lines[-1] += trailingNewline # DTHEIN: add newline if needed
	return head,lines,tail,oldSel,oldYview</t>
<t tx="T1030">def reformatParagraph(self):
	"""Reformat a text paragraph in a Tk.Text widget

Wraps the concatenated text to present page width setting.
Leading tabs are sized to present tab width setting.
First and second line of original text is used to determine leading whitespace
in reformatted text.  Hanging indentation is honored.

Paragraph is bound by start of body, end of body, blank lines, and lines
starting with "@".  Paragraph is selected by position of current insertion
cursor."""

	c = self ; body = c.frame.body
	x = body.index("current")
	head,lines,tail,oldSel,oldYview = self.getBodyLines()
	result = []

	dict = scanDirectives(c)
	pageWidth = dict.get("pagewidth")
	tabWidth  = dict.get("tabwidth")
	# trace(`tabWidth`+","+`pageWidth`)

	# If active selection, then don't attempt a reformat.
	selStart, selEnd = getTextSelection(body)
	if selStart != selEnd: return

	# Find the paragraph range.
	data = bound_paragraph(body)
	if data:
		start, end, endsWithNL = data
		firstLine = int(float(start)) - 1 # subtract 1 to get on zero basis
		lastLine = int(float(end)) - 1
	else: return
	
	# Compute the leading whitespace.
	indents = [0,0] ; leading_ws = ["",""] # Bug fix: 11/16/02
	for i in (0,1):
		if firstLine + i &lt; len(lines):
			# Use the original, non-optimized leading whitespace.
			leading_ws[i] = ws = get_leading_ws(lines[firstLine+i])
			indents[i] = computeWidth(ws,tabWidth)
	indents[1] = max(indents)
	# 11/17/02: Bug fix suggested by D.T.Hein.
	if 1 == (lastLine - firstLine):
		leading_ws[1] = leading_ws[0]

    # Put the leading unchanged lines.
	for i in range(0,firstLine):
		result.append(lines[i])
		
	# Wrap the lines, decreasing the page width by indent.
	wrapped_lines = \
	    wrap_lines(lines[firstLine:lastLine],pageWidth-indents[1],pageWidth-indents[0])
	lineCount = len(wrapped_lines)
		
	i = 0
	for line in wrapped_lines:
		result.append(leading_ws[i] + line)
		if i &lt; 1: i += 1

	# Put the trailing unchanged lines.
	for i in range(lastLine,len(lines)):
		result.append(lines[i])

	# Replace the text if it changed.
	for i in range(firstLine,lineCount+firstLine):
		if i &gt;= lastLine or lines[i] != result[i]:
			result = string.join(result,'\n')
			c.updateBodyPane(head,result,tail,"Reformat Paragraph",oldSel,oldYview) # Handles undo
			break

	&lt;&lt; Set the new insert at the start of the next paragraph &gt;&gt;

	# Make sure we can see the new cursor.
	body.see("insert-5l")</t>
<t tx="T1031">lastLine = firstLine + lineCount
if not endsWithNL:
	insPos = str(lastLine) + ".0lineend"
else:
	endPos = body.index("end")
	endLine = int(float(endPos))
	lastLine += 1
	insPos = str(lastLine) + ".0"
	while lastLine &lt; endLine:
		s = body.get(insPos,insPos + "lineend")
		if s and (0 &lt; len(s)) and not s.isspace():
			break;
		lastLine += 1
		insPos = str(lastLine) + ".0"
setTextSelection(body,insPos,insPos)</t>
<t tx="T1032">@ignore</t>
<t tx="T1033">Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1762671
By: dalcolmo

When typing Ã¤, Ã¶, Ã¼, Ã¸, Ã³ ... I get the following message in the Python window:Ã¶Ã¶

Exception in Tkinter callback
Traceback (most recent call last):
  File "C:\programs\python\lib\lib-tk\Tkinter.py", line 1300, in __call__
    return apply(self.func, args)
  File "C:\programs\python\lib\lib-tk\Tkinter.py", line 436, in callit
    apply(func, args)
  File "C:\Program Files\Leo\leoTree.py", line 785, in idle_body_key
    if s == body:
UnicodeError: ASCII decoding error: ordinal not in range(128)

- Josef</t>
<t tx="T1034">a
b
c
d
</t>
<t tx="T1035">node 2
</t>
<t tx="T1036"># Handle text undo and redo.
# The terminology is for undo: converts _new_ text into _old_ text.
# Some more tests of statistics.
# And some more.

def ----- Testing----- (self, v,
	leading,trailing, # Number of matching leading &amp; trailing lines.
	oldMidLines,newMidLines, # Lists of unmatched lines.
	oldNewlines,newNewlines, # Number of trailing newlines.
	tag="undo", # "undo" or "redo".):
		# For debugging. The expected starting &amp; result text.
	
	c = self.commands
	assert(v == c.currentVnode())

	if self.new_undo:
		&lt;&lt; Incrementally update the Tk.Text widget &gt;&gt;
		&lt;&lt; Compute the result using v's body text &gt;&gt;
		&lt;&lt; Compare the result with the expected result &gt;&gt;
		v.t.setTnodeText(result)
		if 1: # A bit of protection in case the trailing newline doesn't match.
			c.tree.recolor_range(v,leading,trailing)
		else:
			c.tree.recolor(v,incremental=true)

	else: # Rewrite the body pane and do a full recolor.
		v.setBodyStringOrPane(expectedResult)</t>
<t tx="T1037">def __init__ (self,commands):
	
	u = self ; u.commands = commands
	
	# Ivars to transition to new undo scheme...
	
	u.debug = false # true: enable debugging code in new undo scheme.
	u.debug_print = false # true: enable print statements in debug code.
	u.new_undo = true # true: enable new debug code.
	
	# Statistics comparing old and new ways (only if u.debug is on).
	u.new_mem = 0
	u.old_mem = 0
	
	# State ivars...
	u.undoType = "Can't Undo"
	u.undoing = false # True if executing an Undo command.
	u.redoing = false # True if executing a Redo command.

	u.clearUndoState()</t>
<t tx="T1038">@ This method clears then entire Undo state.  All non-undoable commands should call this method.
@c

def clearUndoState (self):
	
	u = self
	
	u.redoMenuLabel = "Can't Redo" # Set here to indicate initial menu entry.
	u.undoMenuLabel = "Can't Undo" # Set here to indicate initial menu entry.

	realLabel = app().getRealMenuName("Can't Redo")
	u.realRedoMenuLabel = realLabel.replace("&amp;","")

	realLabel = app().getRealMenuName("Can't Undo")
	u.realUndoMenuLabel = realLabel.replace("&amp;","")
	
	u.setRedoType("Can't Redo")
	u.setUndoType("Can't Undo")
	u.beads = [] # List of undo nodes.
	u.bead = -1 # Index of the present bead: -1:len(beads)
	u.clearIvars()
	
def clearIvars (self):
	
	self.v = None # The node being operated upon for undo and redo.
	for ivar in optionalIvars:
		exec('self.%s = None' % ivar)
</t>
<t tx="T1039">elif redoType in ( "Typing",
	"Change","Convert Blanks","Convert Tabs","Cut",
	"Delete","Indent","Paste","Reformat Paragraph","Undent"):

	# trace(`redoType` + ":" + `u.v`)
	# selectVnode causes recoloring, so avoid if possible.
	if current != u.v:
		c.selectVnode(u.v) ## Optimize this away??
	self.undoRedoText(
		u.v,u.leading,u.trailing,
		u.newMiddleLines,u.oldMiddleLines,
		u.newNewlines,u.oldNewlines,
		tag="redo")
	if u.newSel:
		start,end=u.newSel
		setTextSelection (c.frame.body,start,end)
	if u.yview:
		first,last=u.yview
		c.body.yview("moveto",first)
	redrawFlag = (current != u.v)
		
elif redoType == "Change All":

	while 1:
		u.bead += 1
		d = u.getBead(u.bead+1)
		assert(d)
		redoType = u.undoType
		# trace(`redoType`)
		if redoType == "Change All":
			c.selectVnode(u.v)
			break
		elif redoType == "Change":
			u.v.t.setTnodeText(u.newText)
			u.v.setDirty()
		elif redoType == "Change Headline":
			u.v.initHeadString(u.newText)
		else: assert(false)

elif redoType == "Change Headline":
	
	# trace(`u.newText`)
	u.v.setHeadStringOrHeadline(u.newText)
	# 9/24/02: update all joined headlines.
	v2 = u.v.joinList
	while v2 and v2 != u.v:
		v2.setHeadString(u.newText)
		v2 = v2.joinList
	c.selectVnode(u.v)</t>
<t tx="T1040">@ When making "large" changes to text, we simply save the old and new text for undo and redo.  This happens rarely, so the expense is minor.

But for typical typing situations, where we are typing a single character, saving both the old and new text wastes a huge amount of space and puts extreme stress on the garbage collector.  This in turn can cause big performance problems.
@c
	
elif undoType in ( "Typing",
	"Change","Convert Blanks","Convert Tabs","Cut",
	"Delete","Indent","Paste","Reformat Paragraph","Undent"):

	# trace(`undoType` + ":" + `u.v`)
	# selectVnode causes recoloring, so don't do this unless needed.
	if current != u.v:
		c.selectVnode(u.v) ## Optimize this away??
	self.undoRedoText(
		u.v,u.leading,u.trailing,
		u.oldMiddleLines,u.newMiddleLines,
		u.oldNewlines,u.newNewlines,
		tag="undo")
	if u.oldSel:
		start,end=u.oldSel
		setTextSelection (c.frame.body,start,end)
	if u.yview:
		first,last=u.yview
		c.body.yview("moveto",first)
	redrawFlag = (current != u.v)
		
elif undoType == "Change All":

	while 1:
		u.bead -= 1
		d = u.getBead(u.bead)
		assert(d)
		undoType = u.undoType
		# trace(`undoType`)
		if undoType == "Change All":
			c.selectVnode(u.v)
			break
		elif undoType == "Change":
			u.v.t.setTnodeText(u.oldText)
			u.v.setDirty()
		elif undoType == "Change Headline":
			u.v.initHeadString(u.oldText)
		else: assert(false)
		
elif undoType == "Change Headline":
	
	# trace(`u.oldText`)
	u.v.setHeadStringOrHeadline(u.oldText)
	# 9/24/02: update all joined headlines.
	v2 = u.v.joinList
	while v2 and v2 != u.v:
		v2.setHeadString(u.oldText)
		v2 = v2.joinList
	c.selectVnode(u.v)</t>
<t tx="T1041">def setUndoTypes (self):
	
	u = self
	# trace(`u.bead` + ":" + `len(u.beads)`)

	# Set the undo type and undo menu label.
	d = u.peekBead(u.bead)
	if d:
		u.setUndoType(d["undoType"])
	else:
		u.setUndoType("Can't Undo")

	# Set only the redo menu label.
	d = u.peekBead(u.bead+1)
	if d:
		u.setRedoType(d["undoType"])
	else:
		u.setRedoType("Can't Redo")



</t>
<t tx="T1042">@ This routine saves enough information so a typing operation can be undone and redone.

We do nothing when called from the undo/redo logic because the Undo and Redo commands merely reset the bead pointer.
@c

def setUndoTypingParams (self,v,undo_type,oldText,newText,oldSel,newSel,oldYview=None):

	u = self ; c = self.commands
	if u.redoing or u.undoing: return None
	if undo_type == "Can't Undo":
		u.clearUndoState()
		return None
	if oldText == newText:
		# trace("no change")
		return None
	# Clear all optional params.
	for ivar in optionalIvars:
		exec('u.%s = None' % ivar)
	# Set the params.
	u.undoType = undo_type
	u.v = v
	&lt;&lt; compute leading, middle &amp; trailing  lines &gt;&gt;
	&lt;&lt; save undo text info &gt;&gt;
	u.oldSel = oldSel ; u.newSel = newSel
	# 11/13/02: Remember the scrolling position.
	if oldYview:
		u.yview = oldYview
	else:
		u.yview = c.frame.body.yview()
	# Push params on undo stack, clearing all forward entries.
	u.bead += 1
	d = u.setBead(u.bead)
	u.beads[u.bead:] = [d]
	# trace(`u.bead` + ":" + `len(u.beads)`)
	u.setUndoTypes() # Recalculate the menu labels.
	return d
</t>
<t tx="T1043">@ Incremental undo typing is similar to incremental syntax coloring.  We compute the number of leading and trailing lines that match, and save both the old and new middle lines.

NB: the number of old and new middle lines may be different.
@c

old_lines = string.split(oldText,'\n')
new_lines = string.split(newText,'\n')
new_len = len(new_lines)
old_len = len(old_lines)
min_len = min(old_len,new_len)

i = 0
while i &lt; min_len:
	if old_lines[i] != new_lines[i]:
		break
	i += 1
leading = i

if leading == new_len:
	# This happens when we remove lines from the end.
	# The new text is simply the leading lines from the old text.
	trailing = 0
else:
	i = 0
	while i &lt; min_len - leading:
		if old_lines[old_len-i-1] != new_lines[new_len-i-1]:
			break
		i += 1
	trailing = i
	
# NB: the number of old and new middle lines may be different.
if trailing == 0:
	old_middle_lines = old_lines[leading:]
	new_middle_lines = new_lines[leading:]
else:
	old_middle_lines = old_lines[leading:-trailing]
	new_middle_lines = new_lines[leading:-trailing]
	
# Remember how many trailing newlines in the old and new text.
i = len(oldText) - 1 ; old_newlines = 0
while i &gt;= 0 and oldText[i] == '\n':
	old_newlines += 1
	i -= 1

i = len(newText) - 1 ; new_newlines = 0
while i &gt;= 0 and newText[i] == '\n':
	new_newlines += 1
	i -= 1

if self.debug_print:
	trace()
	print "lead,trail",leading,trailing
	print "old mid,nls:",len(old_middle_lines),old_newlines,oldText
	print "new mid,nls:",len(new_middle_lines),new_newlines,newText
	#print "lead,trail:",leading,trailing
	#print "old mid:",old_middle_lines
	#print "new mid:",new_middle_lines
	print "---------------------"</t>
<t tx="T1044">@ This is the start of the incremental undo algorithm.

We must save enough info to do _both_ of the following:

Undo: Given newText, recreate oldText.
Redo: Given oldText, recreate oldText.

The "given" texts for the undo and redo routines are simply v.bodyString().
@c

if self.new_undo:
	if self.debug:
		# Remember the complete text for comparisons...
		u.oldText = oldText
		u.newText = newText
		# Compute statistics comparing old and new ways...
		# The old doesn't often store the old text, so don't count it here.
		self.old_mem += len(newText)
		s1 = string.join(old_middle_lines,'\n')
		s2 = string.join(new_middle_lines,'\n')
		self.new_mem += len(s1) + len(s2)
	else:
		u.oldText = None
		u.newText = None
else:
	u.oldText = oldText
	u.newText = newText

self.leading = leading
self.trailing = trailing
self.oldMiddleLines = old_middle_lines
self.newMiddleLines = new_middle_lines
self.oldNewlines = old_newlines
self.newNewlines = new_newlines</t>
<t tx="T1045"># Handle text undo and redo.
# The terminology is for undo: converts _new_ text into _old_ text.

def undoRedoText (self,v,
	leading,trailing, # Number of matching leading &amp; trailing lines.
	oldMidLines,newMidLines, # Lists of unmatched lines.
	oldNewlines,newNewlines, # Number of trailing newlines.
	tag="undo"): # "undo" or "redo"

	c = self.commands
	assert(v == c.currentVnode())

	&lt;&lt; Incrementally update the Tk.Text widget &gt;&gt;
	&lt;&lt; Compute the result using v's body text &gt;&gt;
	v.t.setTnodeText(result)
	&lt;&lt; Get textResult from the Tk.Text widget &gt;&gt;
	if textResult == result:
		# print "incremental undo:",leading,trailing
		c.tree.recolor_range(v,leading,trailing)
	else: # 11/19/02: # Rewrite the pane and do a full recolor.
		if self.debug_print:
			&lt;&lt; print mismatch trace &gt;&gt;
		# print "non-incremental undo"
		v.setBodyStringOrPane(result)</t>
<t tx="T1046"># Only update the changed lines.
mid_text = string.join(oldMidLines,'\n')
new_mid_len = len(newMidLines)
# Maybe this could be simplified, and it is good to treat the "end" with care.
if trailing == 0:
	c.frame.body.delete(str(1+leading)+".0","end")
	if leading &gt; 0:
		c.frame.body.insert("end",'\n')
	c.frame.body.insert("end",mid_text)
else:
	if new_mid_len &gt; 0:
		c.frame.body.delete(str(1+leading)+".0",
			str(leading+new_mid_len)+".0 lineend")
	elif leading &gt; 0:
		c.frame.body.insert(str(1+leading)+".0",'\n')
	c.frame.body.insert(str(1+leading)+".0",mid_text)
# Try to end the Tk.Text widget with oldNewlines newlines.
# This may be off by one, and we don't care because
# we never use body text to compute undo results!
s = c.frame.body.get("1.0","end")
newlines = 0 ; i = len(s) - 1
while i &gt;= 0 and s[i] == '\n':
	newlines += 1 ; i -= 1
while newlines &gt; oldNewlines:
	c.frame.body.delete("end-1c")
	newlines -= 1
if oldNewlines &gt; newlines:
	c.frame.body.insert("end",'\n'*(oldNewlines-newlines))
</t>
<t tx="T1047"># Recreate the text using the present body text.
body = v.bodyString()
body_lines = body.split('\n')
s = []
if leading &gt; 0:
	s.extend(body_lines[:leading])
if len(oldMidLines) &gt; 0:
	s.extend(oldMidLines)
if trailing &gt; 0:
	s.extend(body_lines[-trailing:])
s = string.join(s,'\n')
# Remove trailing newlines in s.
while len(s) &gt; 0 and s[-1] == '\n':
	s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines &gt; 0:
	s = s + '\n' * oldNewlines

result,junk = convertUnicodeToString(s)

if self.debug_print:
	print "body:  ",`body`
	print "result:",`result`</t>
<t tx="T1048">textResult = c.frame.body.get("1.0","end")
textResult,junk = convertUnicodeToString(textResult)

if textResult != result:
	# Remove the newline from textResult if that is the only difference.
	if len(textResult) &gt; 0 and textResult[:-1] == result:
		textResult = result</t>
<t tx="T1049">print "undo mismatch"
print "expected:",`result`
print "actual  :",`textResult`
</t>
<t tx="T1050"># Called when File-Close command is chosen.

def OnClose(self,event=None):
	
	u = self.commands.undoer
	if 0:
		if u and u.new_undo and u.debug:
			print "old undo mem:",u.old_mem
			print "new undo mem:",u.new_mem
			print "ratio new/old:",float(u.new_mem)/float(u.old_mem)
	
	self.OnCloseLeoEvent() # Destroy the frame unless the user cancels.</t>
<t tx="T1051">@ Trailing newlines must be handled with _extreme_ care.</t>
<t tx="T1052">def setBodyStringOrPane (self,s):

	v = self ; c = v.commands
	if not c or not v: return

	if v == c.currentVnode():
		# This code destoys all tags, so we must recolor.
		c.frame.body.delete("1.0","end")
		c.frame.body.insert("1.0", s) # Replace the body text with s.
		c.recolor()
		
	if type(s) == types.UnicodeType: # 10/9/02
		xml_encoding = app().config.xml_version_string
		s = s.encode(xml_encoding) # result is a string.
	assert(type(s)==types.StringType)

	# Keep the body text in the tnode up-to-date.
	if v.t.bodyString != s: # 3/4/02
		v.t.setTnodeText(s)
		v.t.setSelection(0,0)
		v.setDirty()
		if not c.isChanged():
			c.setChanged(true)

setBodyTextOrPane = setBodyStringOrPane # Compatibility with old scripts</t>
<t tx="T1053"># This sets the text in the tnode from the given string.

def setTnodeText (self,s):

	s,junk = convertUnicodeToString(s)
	self.bodyString = s</t>
<t tx="T1054">@ignore</t>
<t tx="T1055"># Deletes the current vnode and dependent nodes. Does nothing if the outline would become empty.

def deleteHeadline (self,op_name="Delete Outline"):

	c = self ; v = c.currentVnode()
	if not v: return
	vBack = v.visBack()
	# Bug fix: 1/18/00: if vBack is NULL we are at the top level,
	# the next node should be v.next(), _not_ v.visNext();
	if vBack: newNode = vBack
	else: newNode = v.next()
	if not newNode: return
	c.endEditing()# Make sure we capture the headline for Undo.
	c.beginUpdate()
	v.setDirtyDeleted() # 8/3/02: Mark @file nodes dirty for all clones in subtree.
	# Reinsert v after back, or as the first child of parent, or as the root.
	c.undoer.setUndoParams(op_name,v,select=newNode)
	v.doDelete(newNode) # doDelete destroys dependents.
	c.setChanged(true)
	c.endUpdate()
	c.validateOutline()</t>
<t tx="T1056"># Inserts a vnode after the current vnode.  All details are handled by the vnode class.

def insertHeadline (self,op_name="Insert Outline"):

	c = self ; current = c.currentVnode()
	if not current: return
	c.beginUpdate()
	if 1: # inside update...
		if current.hasChildren() and current.isExpanded():
			v = current.insertAsNthChild(0)
		else:
			v = current.insertAfter()
		c.undoer.setUndoParams(op_name,v,select=current)
		v.createDependents() # To handle effects of clones.
		c.selectVnode(v)
		v.setDirty() # Essential in Leo2.
		c.setChanged(true)
	c.endUpdate(false)
	c.tree.redraw_now()
	c.editVnode(v)</t>
<t tx="T1057"></t>
<t tx="T1058">def dragAfter(self,v,after):

	# es("dragAfter")
	c = self
	if not c.checkMoveWithParentWithWarning(v,after.parent(),true): return
	# Remember both the before state and the after state for undo/redo
	oldBack = v.back()
	oldParent = v.parent()
	oldN = v.childIndex()
	c.beginUpdate()
	if 1: # inside update...
		c.endEditing()
		v.setDirty()
		v.moveAfter(after)
		c.undoer.setUndoParams("Drag",v,
			oldBack=oldBack,oldParent=oldParent,oldN=oldN)
		v.setDirty()
		c.selectVnode(v)
		c.setChanged(true)
	c.endUpdate()
	c.updateSyntaxColorer(v) # Dragging can change syntax coloring.</t>
<t tx="T1059">def dragToNthChildOf(self,v,parent,n):

	# es("dragToNthChildOf")
	c = self
	if not c.checkMoveWithParentWithWarning(v,parent,true): return
	# Remember both the before state and the after state for undo/redo
	oldBack = v.back()
	oldParent = v.parent()
	oldN = v.childIndex()
	c.beginUpdate()
	if 1: # inside update...
		c.endEditing()
		v.setDirty()
		v.moveToNthChildOf(parent,n)
		c.undoer.setUndoParams("Drag",v,
			oldBack=oldBack,oldParent=oldParent,oldN=oldN)
		v.setDirty()
		c.selectVnode(v)
		c.setChanged(true)
	c.endUpdate()
	c.updateSyntaxColorer(v) # Dragging can change syntax coloring.</t>
<t tx="T1060">def dragCloneAfter (self,v,after):

	c = self
	c.beginUpdate()
	clone = v.clone(v) # Creates clone &amp; dependents, does not set undo.
	if not c.checkMoveWithParentWithWarning(clone,after.parent(),true):
		clone.doDelete(v) # Destroys clone &amp; dependents. Makes v the current node.
		c.endUpdate(false) # Nothing has changed.
		return
	# Remember both the before state and the after state for undo/redo
	oldBack = v.back()
	oldParent = v.parent()
	oldN = v.childIndex()
	c.endEditing()
	clone.setDirty()
	clone.moveAfter(after)
	c.undoer.setUndoParams("Drag &amp; Clone",clone,
		oldBack=oldBack,oldParent=oldParent,oldN=oldN,oldV=v)
	clone.setDirty()
	c.selectVnode(clone)
	c.setChanged(true)
	c.endUpdate()
	c.updateSyntaxColorer(clone) # Dragging can change syntax coloring.</t>
<t tx="T1061">def dragCloneToNthChildOf (self,v,parent,n):

	c = self
	c.beginUpdate()
	clone = v.clone(v) # Creates clone &amp; dependents, does not set undo.
	if not c.checkMoveWithParentWithWarning(clone,parent,true):
		clone.doDelete(v) # Destroys clone &amp; dependents. Makes v the current node.
		c.endUpdate(false) # Nothing has changed.
		return
	# Remember both the before state and the after state for undo/redo
	oldBack = v.back()
	oldParent = v.parent()
	oldN = v.childIndex()
	c.endEditing()
	clone.setDirty()
	clone.moveToNthChildOf(parent,n)
	c.undoer.setUndoParams("Drag &amp; Clone",clone,
		oldBack=oldBack,oldParent=oldParent,oldN=oldN,oldV=v)
	clone.setDirty()
	c.selectVnode(clone)
	c.setChanged(true)
	c.endUpdate()
	c.updateSyntaxColorer(clone) # Dragging can change syntax coloring.</t>
<t tx="T1062">def sortChildren(self):

	c = self ; v = c.currentVnode()
	if not v or not v.hasChildren(): return
	&lt;&lt; Set the undo info for sortChildren &gt;&gt;
	c.beginUpdate()
	if 1: # inside update...
		c.endEditing()
		v.sortChildren()
		v.setDirty()
		c.setChanged(true)
	c.endUpdate()
	
def sortSiblings (self):
	
	c = self ; v = c.currentVnode()
	if not v: return
	parent = v.parent()
	if not parent: return # can't sort the top level this way.
	&lt;&lt; Set the undo info for sortSiblings &gt;&gt;
	c.beginUpdate()
	if 1: # inside update...
		c.endEditing()
		parent.sortChildren()
		parent.setDirty()
		c.setChanged(true)
	c.endUpdate()</t>
<t tx="T1063"># Get the present list of children.
children = []
child = v.firstChild()
while child:
	children.append(child)
	child = child.next()
c.undoer.setUndoParams("Sort Children",v,sort=children)</t>
<t tx="T1064"># Get the present list of siblings.
sibs = []
sib = parent.firstChild()
while sib:
	sibs.append(sib)
	sib = sib.next()
c.undoer.setUndoParams("Sort Siblings",v,sort=sibs)</t>
<t tx="T1065">def demote(self):

	c = self ; v = c.currentVnode()
	if not v or not v.next(): return
	# Make sure all the moves will be valid.
	child = v.next()
	while child:
		if not c.checkMoveWithParentWithWarning(child,v,true):
			return
		child = child.next()
	c.beginUpdate()
	if 1: # update range...
		c.mInhibitOnTreeChanged = true
		c.endEditing()
		last = None
		while v.next():
			child = v.next()
			child.moveToNthChildOf(v,v.numberOfChildren())
			last = child # For undo.
		c.expandVnode(v)
		c.selectVnode(v)
		v.setDirty()
		c.setChanged(true)
		c.mInhibitOnTreeChanged = false
		c.initAllCloneBits() # 7/6/02
	c.endUpdate()
	c.undoer.setUndoParams("Demote",v,lastChild=last)
	c.updateSyntaxColorer(v) # Moving can change syntax coloring.</t>
<t tx="T1066">@ Moving down is more tricky than moving up; we can't move v to be a child of itself.  An important optimization:  we don't have to call checkMoveWithParentWithWarning() if the parent of the moved node remains the same.
@c

def moveOutlineDown(self):

	c = self
	v = c.currentVnode()
	if not v: return
	# Set next to the node after which v will be moved.
	next = v.visNext()
	while next and v.isAncestorOf(next):
		next = next.visNext()
	if not next: return
	c.beginUpdate()
	if 1: # inside update...
		c.endEditing()
		v.setDirty()
		&lt;&lt; Move v down &gt;&gt;
		v.setDirty() # This second call is essential.
		c.selectVnode(v)# 4/23/01
		c.setChanged(true)
	c.endUpdate()
	c.updateSyntaxColorer(v) # Moving can change syntax coloring.</t>
<t tx="T1067"># Remember both the before state and the after state for undo/redo
oldBack = v.back()
oldParent = v.parent()
oldN = v.childIndex()

if next.hasChildren() and next.isExpanded():
	# Attempt to move v to the first child of next.
	if c.checkMoveWithParentWithWarning(v,next,true):
		v.moveToNthChildOf(next,0)
		c.undoer.setUndoParams("Move Down",v,
			oldBack=oldBack,oldParent=oldParent,oldN=oldN)
else:
	# Attempt to move v after next.
	if c.checkMoveWithParentWithWarning(v,next.parent(),true):
		v.moveAfter(next)
		c.undoer.setUndoParams("Move Down",v,
			oldBack=oldBack,oldParent=oldParent,oldN=oldN)</t>
<t tx="T1068">def moveOutlineLeft(self):

	c = self
	v = c.currentVnode()
	if not v: return
	parent = v.parent()
	if not parent: return
	# Remember both the before state and the after state for undo/redo
	oldBack = v.back()
	oldParent = v.parent()
	oldN = v.childIndex()
	c.beginUpdate()
	if 1: # inside update...
		c.endEditing()
		v.setDirty()
		v.moveAfter(parent)
		c.undoer.setUndoParams("Move Left",v,
			oldBack=oldBack,oldParent=oldParent,oldN=oldN)
		v.setDirty()
		c.selectVnode(v)
		c.setChanged(true)
	c.endUpdate()
	c.updateSyntaxColorer(v) # Moving can change syntax coloring.</t>
<t tx="T1069">def moveOutlineRight(self):

	c = self
	v = c.currentVnode()
	if not v: return
	back = v.back()
	if not back: return
	if not c.checkMoveWithParentWithWarning(v,back,true): return
	# Remember both the before state and the after state for undo/redo
	oldBack = v.back()
	oldParent = v.parent()
	oldN = v.childIndex()
	c.beginUpdate()
	if 1: # inside update...
		c.endEditing()
		v.setDirty()
		n = back.numberOfChildren()
		v.moveToNthChildOf(back,n)
		c.undoer.setUndoParams("Move Right",v,
			oldBack=oldBack,oldParent=oldParent,oldN=oldN)
		v.setDirty()
		c.selectVnode(v)
		c.setChanged(true)
		c.initJoinedCloneBits(v) # 7/6/02
	c.endUpdate()
	c.updateSyntaxColorer(v) # Moving can change syntax coloring.</t>
<t tx="T1070">def moveOutlineUp(self):

	c = self
	v = c.currentVnode()
	if not v: return
	back = v.visBack()
	if not back: return
	back2 = back.visBack()
	c = self
	c.beginUpdate()
	if 1: # inside update...
		c.endEditing()
		v.setDirty()
		&lt;&lt; Move v up &gt;&gt;
		v.setDirty()
		c.selectVnode(v)
		c.setChanged(true)
	c.endUpdate()
	c.updateSyntaxColorer(v) # Moving can change syntax coloring.</t>
<t tx="T1071"># Remember both the before state and the after state for undo/redo
oldBack = v.back()
oldParent = v.parent()
oldN = v.childIndex()

if not back2:
	# v will be the new root node
	v.moveToRoot(c.tree.rootVnode) # 3/16/02, 5/17/02
	c.undoer.setUndoParams("Move Up",v,
		oldBack=oldBack,oldParent=oldParent,oldN=oldN)
elif back2.hasChildren() and back2.isExpanded():
	if c.checkMoveWithParentWithWarning(v,back2,true):
		v.moveToNthChildOf(back2,0)
		c.undoer.setUndoParams("Move Up",v,
			oldBack=oldBack,oldParent=oldParent,oldN=oldN)
elif c.checkMoveWithParentWithWarning(v,back2.parent(),true):
	# Insert after back2.
	v.moveAfter(back2)
	c.undoer.setUndoParams("Move Up",v,
		oldBack=oldBack,oldParent=oldParent,oldN=oldN)</t>
<t tx="T1072">def promote(self):

	c = self
	v = c.currentVnode()
	if not v or not v.hasChildren(): return
	c.beginUpdate()
	if 1: # inside update...
		c.endEditing()
		after = v ; last = None
		while v.hasChildren():
			child = v.firstChild()
			child.moveAfter(after)
			after = child
			last = child # for undo.
		v.setDirty()
		c.setChanged(true)
		c.selectVnode(v)
	c.endUpdate()
	c.undoer.setUndoParams("Promote",v,lastChild=last)
	c.updateSyntaxColorer(v) # Moving can change syntax coloring.</t>
<t tx="T1073">def redo (self):
	
	u = self ; c = u.commands
	if not u.canRedo(): return
	if not u.getBead(u.bead+1): return
	current = c.currentVnode()
	if not current: return
	# trace(`u.bead+1` + ":" + `len(u.beads)` + ":" + `u.peekBead(u.bead+1)`)
	u.redoing = true
	redrawFlag = true
	c.beginUpdate()
	redoType = u.undoType # Use the type of the next bead.
	if 1: # range...
		&lt;&lt; redo clone cases &gt;&gt;
		&lt;&lt; redo insert cases &gt;&gt;
		&lt;&lt; redo delete cases &gt;&gt;
		&lt;&lt; redo move &amp; drag cases &gt;&gt;
		&lt;&lt; redo promote and demote cases &gt;&gt;
		&lt;&lt; redo replace cases &gt;&gt;
		&lt;&lt; redo sort cases &gt;&gt;
		&lt;&lt; redo typing cases &gt;&gt;
		else: trace("Unknown case: " + `redoType`)
		c.setChanged(true)
		if u.v: u.v.setDirty()
	c.endUpdate(redrawFlag) # 11/08/02
	u.redoing = false
	u.bead += 1
	u.setUndoTypes()</t>
<t tx="T1074">if redoType in ("Clone","Drag &amp; Clone"):

	if u.back:
		u.v.linkAfter(u.back)
	elif u.parent:
		u.v.linkAsNthChild(u.parent,0)
	else:
		u.v.linkAsRoot()

	shared = u.findSharedVnode(u.v)
	if shared: u.v.joinTreeTo(shared)
	u.v.createDependents()
	if u.v.shouldBeClone():
		u.v.setClonedBit()
	c.initAllCloneBits()
	c.selectVnode(u.v)
</t>
<t tx="T1075">elif redoType == "Delete Outline" or redoType == "Cut Node":

	c.selectVnode(u.v)
	c.deleteHeadline()</t>
<t tx="T1076">elif redoType in ["Import", "Insert Outline", "Paste Node"]:

	if u.back:
		u.v.linkAfter(u.back)
	elif u.parent:
		u.v.linkAsNthChild(u.parent,0)
	else:
		u.v.linkAsRoot()

	shared = u.findSharedVnode(u.v)
	if shared: u.v.joinTreeTo(shared)
	u.v.createDependents()
	if u.v.shouldBeClone():
		u.v.setClonedBit()
	c.initAllCloneBits()
	c.selectVnode(u.v)</t>
<t tx="T1077">elif redoType in ["Drag","Move Down","Move Left","Move Right","Move Up"]:

	if u.parent:
		u.v.moveToNthChildOf(u.parent,u.n)
	elif u.back:
		u.v.moveAfter(u.back)
	else:
		# 3/16/02: Moving up is the only case that can do this.
		parent = u.v.parent()
		u.v.moveToRoot(c.tree.rootVnode) # 5/27/02
		if parent: # We could assert(parent)
			parent.moveAfter(u.v)
	c.initJoinedCloneBits(u.v) # 7/6/02
	c.selectVnode(u.v)
	
elif redoType == "Drag":

	u.v.moveToNthChildOf(u.parent,u.n)
	c.initJoinedCloneBits(u.v) # 7/6/02
	c.selectVnode(u.v)</t>
<t tx="T1078">elif redoType == "Demote":

	c.selectVnode(u.v)
	c.demote()
	
elif redoType == "Promote":

	c.selectVnode(u.v)
	c.promote()</t>
<t tx="T1079">elif redoType in [
	"Convert All Blanks",
	"Convert All Tabs",
	"Extract",
	"Extract Names",
	"Extract Section"]:
	
	# Same as undo except we interchange u.oldTree and u.v in the call to undoReplace.
	self.undoReplace(u.oldTree,u.v)
	u.v,u.oldTree = u.oldTree,u.v
	
	v = u.oldTree
	# selectVnode causes recoloring, so don't do this unless needed.
	if current != u.v:
		c.selectVnode(v)
	# This rewrites the body pane, so we must do a full recolor.
	v.setBodyStringOrPane(v.bodyString())
	c.tree.recolor(u.v)
	redrawFlag = (current != u.v)
</t>
<t tx="T1080">elif redoType == "Sort Children":

	c.selectVnode(u.v)
	c.sortChildren()

elif redoType == "Sort Siblings":

	c.selectVnode(u.v)
	c.sortSiblings()</t>
<t tx="T1081"></t>
<t tx="T1082"># Translation does not affect these routines.

def canRedo (self):

	return self.redoMenuLabel != "Can't Redo"

def canUndo (self):

	return self.undoMenuLabel != "Can't Undo"
</t>
<t tx="T1083">def enableMenuItems (self):

	u = self ; c = u.commands
	menu = c.frame.getMenu("Edit")
	enableMenu(menu,u.redoMenuLabel,u.canRedo())
	enableMenu(menu,u.undoMenuLabel,u.canUndo())
</t>
<t tx="T1084">def getBead (self,n):
	
	u = self
	if n &lt; 0 or n &gt;= len(u.beads): return false
	d = u.beads[n]
	# trace(`n` + ":" + `len(u.beads)` + ":" + `d`)
	self.clearIvars()
	u.v = d["v"]
	u.undoType = d["undoType"]

	for ivar in optionalIvars:
		if d.has_key(ivar):
			exec('u.%s = d["%s"]' % (ivar,ivar))
		else:
			exec('u.%s = None' % ivar)

	if not u.new_undo: # Recreate an "oldText" entry if necessary.
		if u.undoType == "Typing" and u.oldText == None:
			assert(n &gt; 0)
			old_d = u.beads[n-1]
			# The user will lose data if these asserts fail.
			assert(old_d["undoType"] == "Typing")
			assert(old_d["v"] == u.v)
			u.oldText = old_d["newText"]
			# trace(`u.oldText`)
	return d
	
def peekBead (self,n):
	
	u = self
	if n &lt; 0 or n &gt;= len(u.beads): return false
	d = u.beads[n]
	# trace(`n` + ":" + `len(u.beads)` + ":" + `d`)
	return d

def setBead (self,n,keywords=None):

	u = self ; d = {}
	d["undoType"]=u.undoType
	d["v"]=u.v
	# Only enter significant entries into the dictionary.
	# This is an important space optimization for typing.
	for ivar in optionalIvars:
		exec('if u.%s != None: d["%s"] = u.%s' % (ivar,ivar,ivar))
	# copy all significant keywords to d.
	if keywords:
		for key in keywords.keys():
			if keywords[key] != None:
				d[key] = keywords[key]
	# Clear the "oldText" entry if the previous entry was a "Typing" entry.
	# This optimization halves the space needed for Undo/Redo Typing.
	if not u.new_undo:
		if u.undoType == "Typing" and n &gt; 0:
			old_d = u.beads[n-1]
			if old_d["undoType"] == "Typing" and old_d["v"] == u.v:
				del d["oldText"] # We can recreate this entry from old_d["newText"]
				# trace(`u.oldText`)
	# trace(`d`)
	return d</t>
<t tx="T1085">def redoMenuName (self,name):

	if name=="Can't Redo":
		return name
	else:
		return "Redo " + name

def undoMenuName (self,name):

	if name=="Can't Undo":
		return name
	else:
		return "Undo " + name</t>
<t tx="T1086"># These routines update both the ivar and the menu label.
def setRedoType (self,type):
	u = self ; c = u.commands
	menu = c.frame.getMenu("Edit")
	name = u.redoMenuName(type)
	if name != u.redoMenuLabel:
		# Update menu using old name.
		realLabel = app().getRealMenuName(name)
		if realLabel == name:
			underline=choose(match(name,0,"Can't"),-1,0)
		else:
			underline = realLabel.find("&amp;")
		realLabel = realLabel.replace("&amp;","")
		setMenuLabel(menu,u.realRedoMenuLabel,realLabel,underline=underline)
		u.redoMenuLabel = name
		u.realRedoMenuLabel = realLabel

def setUndoType (self,type):
	u = self ; c = u.commands
	menu = c.frame.getMenu("Edit")
	name = u.undoMenuName(type)
	if name != u.undoMenuLabel:
		# Update menu using old name.
		realLabel = app().getRealMenuName(name)
		if realLabel == name:
			underline=choose(match(name,0,"Can't"),-1,0)
		else:
			underline = realLabel.find("&amp;")
		realLabel = realLabel.replace("&amp;","")
		setMenuLabel(menu,u.realUndoMenuLabel,realLabel,underline=underline)
		u.undoType = type
		u.undoMenuLabel = name
		u.realUndoMenuLabel = realLabel</t>
<t tx="T1087">@ This routine saves enough information so an operation can be undone and redone.  We do nothing when called from the undo/redo logic because the Undo and Redo commands merely reset the bead pointer.
@c

def setUndoParams (self,undo_type,v,**keywords):

	# trace(`undo_type`)
	u = self
	if u.redoing or u.undoing: return None
	if undo_type == "Can't Undo":
		u.clearUndoState()
		return None
	# Set the type: set the menu labels later.
	u.undoType = undo_type
	# Calculate the standard derived information.
	u.v = v
	u.parent = v.parent()
	u.back = v.back()
	u.n = v.childIndex()
	# Push params on undo stack, clearing all forward entries.
	u.bead += 1
	d = u.setBead(u.bead,keywords)
	u.beads[u.bead:] = [d]
	# trace(`u.bead` + ":" + `len(u.beads)` + ":" + `keywords`)
	# Recalculate the menu labels.
	u.setUndoTypes()
	return d</t>
<t tx="T1088">@ This function and its allies undo the operation described by the undo parmaters.
@c

def undo (self):

	u = self ; c = u.commands
	if not u.canUndo(): return
	if not u.getBead(u.bead): return
	current = c.currentVnode()
	if not current: return
	# trace(`u.bead` + ":" + `len(u.beads)` + ":" + `u.peekBead(u.bead)`)
	c.endEditing()# Make sure we capture the headline for a redo.
	u.undoing = true
	c.beginUpdate()
	undoType = u.undoType
	redrawFlag = true
	if 1: # range...
		&lt;&lt; undo clone cases &gt;&gt;
		&lt;&lt; undo delete cases &gt;&gt;
		&lt;&lt; undo insert cases &gt;&gt;
		&lt;&lt; undo move &amp; drag cases &gt;&gt;
		&lt;&lt; undo promote and demote cases &gt;&gt;
		&lt;&lt; undo replace cases &gt;&gt;
		&lt;&lt; undo sort cases &gt;&gt;
		&lt;&lt; undo typing cases &gt;&gt;
		else: trace("Unknown case: " + `u.undoType`)
		c.setChanged(true)
		if u.v: u.v.setDirty()
	c.endUpdate(redrawFlag) # 11/9/02
	u.undoing = false
	u.bead -= 1
	u.setUndoTypes()</t>
<t tx="T1089"># We can immediately delete the clone because clone() can recreate it using only v.

if undoType == "Clone":
	
	c.selectVnode(u.v)
	c.deleteHeadline()
	c.selectVnode(u.back)
	
elif undoType == "Drag &amp; Clone":
	
	c.selectVnode(u.v)
	c.deleteHeadline()
	c.selectVnode(u.oldV)</t>
<t tx="T1090">@ Deleting a clone is _not_ the same as undoing a clone: the clone may have been moved, so there is no necessary relationship between the two nodes.
@c

elif undoType == "Delete Outline" or undoType == "Cut Node":
	
	if u.back:
		u.v.linkAfter(u.back)
	elif u.parent:
		u.v.linkAsNthChild(u.parent,0)
	else:
		u.v.linkAsRoot()
	shared = u.findSharedVnode(u.v)
	if shared: u.v.joinTreeTo(shared)
	u.v.createDependents()
	if u.v.shouldBeClone():
		u.v.setClonedBit()
	c.initAllCloneBits()
	c.selectVnode(u.v)</t>
<t tx="T1091">elif undoType in ["Import", "Insert Outline", "Paste Node"]:
	
	c.selectVnode(u.v)
	c.deleteHeadline()
	if u.select:
		# trace("Insert/Paste:" + `u.select`)
		c.selectVnode(u.select)</t>
<t tx="T1092">elif undoType in ["Drag", "Move Down","Move Left","Move Right","Move Up"]:

	if u.oldParent:
		u.v.moveToNthChildOf(u.oldParent,u.oldN)
	elif u.oldBack:
		u.v.moveAfter(u.oldBack)
	else:
		# 3/16/02: Moving up is the only case that can do this.
		parent = u.v.parent()
		u.v.moveToRoot(c.tree.rootVnode) # 5/27/02
		if parent: # We could assert(parent)
			parent.moveAfter(u.v)
	
	c.initJoinedCloneBits(u.v) # 7/6/02
	c.selectVnode(u.v)
</t>
<t tx="T1093">@ Promote and demote operations are the hard to undo, because they involve relinking a list of nodes. We pass the work off to routines dedicated to the task.
@c

elif undoType == "Demote":

	u.undoDemote()

elif undoType == "Promote":
	
	u.undoPromote()</t>
<t tx="T1094">elif undoType in [
	"Convert All Blanks",
	"Convert All Tabs",
	"Extract",
	"Extract Names",
	"Extract Section"]:
	
	self.undoReplace(u.v,u.oldTree)
	u.v,u.oldTree = u.oldTree,u.v
	
	v = u.v
	# selectVnode causes recoloring, so don't do this unless needed.
	if current != u.v:
		c.selectVnode(v)
	# This rewrites the body pane, so we must do a full recolor.
	v.setBodyStringOrPane(v.bodyString())
	c.tree.recolor(u.v)
	redrawFlag = (current != u.v)</t>
<t tx="T1095">@ Sort operations are the hard to undo, because they involve relinking a list of nodes. We pass the work off to routines dedicated to the task.
@c

elif undoType == "Sort Children":
	
	u.undoSortChildren()

elif undoType == "Sort Siblings":
	
	u.undoSortSiblings()</t>
<t tx="T1096"># undoes the previous demote operation.
def undoDemote (self):

	u = self ; c = u.commands
	ins = u.v
	last = u.lastChild
	child = u.v.firstChild()
	assert(child and last)
	c.beginUpdate()
	while 1:
		save_next = child.next()
		child.moveAfter(ins)
		ins = child
		u.lastChild = child
		child = save_next
		assert(ins == last or child)
		if ins == last: break
	c.selectVnode(u.v)
	c.endUpdate()</t>
<t tx="T1097"># Undoes the previous promote operation.
def undoPromote (self):

	u = self ; c = u.commands
	v = v1 = u.v
	assert(v1)
	last = u.lastChild
	next = v.next()
	assert(next and last)
	c.beginUpdate()
	while 1:
		v = next
		assert(v)
		next = v.next()
		n = v1.numberOfChildren()
		v.moveToNthChildOf(v1,n)
		u.lastChild = v
		if v == last: break
	c.selectVnode(v1)
	c.endUpdate()</t>
<t tx="T1098">@ignore</t>
<t tx="T1099">def OnContractChildren(self,event=None):

	self.commands.contractSubheads()
</t>
<t tx="T1100"># Contracts the children of the current node.

def contractSubheads (self):

	c = self ; v = c.currentVnode()
	if not v: return
	
	# trace(`v`)

	child = v.firstChild()
	c.beginUpdate()
	while child:
		c.contractVnode(child)
		child = child.next()
	c.endUpdate()
	c.selectVnode(v) # Needed?
	c.expansionLevel = 0</t>
<t tx="T1101">@ignore

@ Used bind_all to set bindings throught the app.  

Well, everthing gets bound, but the old binding in the headline also has effect!  The fix is to bind to a workaround callback, OnControlT, which returns "break".  This has the effect of stamping out all other bindings.  Alas, it also means that Control-T can have no effect in headlines.

It looks like this is another Tk bug.  Nothing seems to reset the control-T binding.  Not bind("Control-T",""), not bind_all, not bind_class.</t>
<t tx="T1102"># This works around an apparent Tk bug.

def OnControlT (self,event=None):

	# If we don't inhibit further processing the Tx.Text widget switches characters!
	return "break"</t>
<t tx="T1103"># draws text for v at x,y

def drawText(self,v,x,y):

	x += text_indent
	if v.edit_text: # self.canvas.delete("all") may already have done this, but do it anyway.
		v.edit_text.destroy()
	v.edit_text = t = Tkinter.Text(self.canvas,
		font=self.font,bd=0,relief="flat",width=self.headWidth(v),height=1)

	t.insert("end", v.headString())
	&lt;&lt; configure the text depending on state &gt;&gt;
	id1 = t.bind("&lt;1&gt;", v.OnHeadlineClick)
	id2 = t.bind("&lt;3&gt;", v.OnHeadlinePopup) # 9/11/02.
	if 0: # 6/15/02: Bill Drissel objects to this binding.
		t.bind("&lt;Double-1&gt;", v.OnBoxClick)
	id3 = t.bind("&lt;Key&gt;", v.OnHeadlineKey)
	id4 = t.bind("&lt;Control-t&gt;",self.OnControlT)
		# 10/16/02: Stamp out the erroneous control-t binding.
	# Remember the bindings so we can delete them by hand on redraws.
	if self.recycleBindings:
		self.bindings.append((t,id1,"&lt;1&gt;"),)
		self.bindings.append((t,id2,"&lt;3&gt;"),)
		self.bindings.append((t,id3,"&lt;Key&gt;"),)
		self.bindings.append((t,id4,"&lt;Control-t&gt;"),)
	id = self.canvas.create_window(x,y,anchor="nw",window=t)
	if 0: # don't create this reference!
		v.edit_text_id = id
	self.canvas.tag_lower(id)

	return self.line_height</t>
<t tx="T1104">if v == self.currentVnode:
	self.setDisabledLabelState(v) # selected, disabled
else:
	self.setUnselectedLabelState(v) # unselected</t>
<t tx="T1105">@ignore
@nocolor

The problem was that idle uses sys.argv, so the code must set this.

@color</t>
<t tx="T1106">def OnOpenPythonWindow(self,event=None):

	if sys.platform == "linux2":
		&lt;&lt; open idle in Linux &gt;&gt;
	else:
		&lt;&lt; open idle in Windows &gt;&gt;
</t>
<t tx="T1107"># 09-SEP-2002 DHEIN: Open Python window under linux

try:
	pathToLeo = os.path.join(app().loadDir,"leo.py")
	sys.argv = [pathToLeo]
	from idlelib import idle
	if app().idle_imported:
		reload(idle)
	app().idle_imported = true
except:
	try:
		es("idlelib could not be imported.")
		es("Probably IDLE is not installed.")
		es("Run Tools/idle/setup.py to build idlelib.")
		es("Can not import idle")
		es_exception() # This can fail!!
	except: pass
</t>
<t tx="T1108">try:
	executable_dir = os.path.dirname(sys.executable)
	idle_dir=os.path.join(executable_dir,"Tools","idle")
	if idle_dir not in sys.path:
		sys.path.append(idle_dir)
	# Initialize argv: the -t option sets the title of the Idle interp window.
	# pathToLeo = os.path.join(app().loadDir,"leo.py")
	sys.argv = ["leo","-t","leo"]
	import PyShell
	if app().idle_imported:
		reload(idle)
		app().idle_imported = true
	if 1: # Mostly works, but causes problems when opening other .leo files.
		PyShell.main()
	else: # Doesn't work: destroys all of Leo when Idle closes.
		self.leoPyShellMain()
except:
	try:
		es("Can not import idle")
		es("Please add " + `idle_dir` + " to sys.path")
		es_exception() # This can fail!!
	except: pass</t>
<t tx="T1109">@ The key parts of Pyshell.main(), but using Leo's root window instead of a new Tk root window.

This does _not_ work.  Using Leo's root window means that Idle will shut down Leo without warning when the Idle window is closed!
@c

def leoPyShellMain(self):
	
	import PyShell
	root = app().root
	PyShell.fixwordbreaks(root)
	flist = PyShell.PyShellFileList(root)
	shell = PyShell.PyShell(flist)
	flist.pyshell = shell
	shell.begin()</t>
<t tx="T1110">@nocolor

- The font settings in leoConfig.txt are not active when I open Leo. They instantly activate when opening the Edit|Set Font... dialog, without having to click anything in said dialog. Then, once the .leo file is saved, the problem goes away.

@color</t>
<t tx="T1111">@ A convenience method that computes a font from font parameters.
Arguments are the names of settings to be use.
We return None if there is no family setting so we can use system default fonts.
We default to size=12, slant="roman", weight="normal"
@c

def getFontFromParams(self,family,size,slant,weight):
	
	tag = "getFont..." ; family_name = family

	family = self.getWindowPref(family)
	if not family or family == "":
		# print tag,"using default"
		family = self.defaultFontFamily
		
	size = self.getIntWindowPref(size)
	if not size or size == 0: size = 12
	
	slant = self.getWindowPref(slant)
	if not slant or slant == "": slant = "roman"
	
	weight = self.getWindowPref(weight)
	if not weight or weight == "": weight = "normal"
	
	try:
		font = tkFont.Font(family=family,size=size,slant=slant,weight=weight)
	except:
		es("exception setting font from " + `family_name`)
		es("family,size,slant,weight:"+
			`family`+':'+`size`+':'+`slant`+':'+`weight`)
		es_exception()
		return self.defaultFont
	#print family_name,family,size,slant,weight
	#print "actual_name:",font.cget("family")
	return font</t>
<t tx="T1112">def createBothLeoSplitters (self,top):

	Tk = Tkinter ; config = app().config

	# Splitter 1 is the main splitter containing splitter2 and the body pane.
	f1,bar1,split1Pane1,split1Pane2 = self.createLeoSplitter(top, self.splitVerticalFlag)
	self.f1,self.bar1 = f1,bar1
	self.split1Pane1,self.split1Pane2 = split1Pane1,split1Pane2
	# Splitter 2 is the secondary splitter containing the tree and log panes.
	f2,bar2,split2Pane1,split2Pane2 = self.createLeoSplitter(split1Pane1, not self.splitVerticalFlag)
	self.f2,self.bar2 = f2,bar2
	self.split2Pane1,self.split2Pane2 = split2Pane1,split2Pane2
	&lt;&lt; create the body pane &gt;&gt;
	&lt;&lt; create the tree pane &gt;&gt;
	&lt;&lt; create the log pane &gt;&gt;
	# Give the log and body panes the proper borders.
	self.reconfigurePanes()</t>
<t tx="T1113"># A light selectbackground value is needed to make syntax coloring look good.
wrap = config.getBoolWindowPref('body_pane_wraps')
wrap = choose(wrap,"word","none")

self.body = body = Tk.Text(split1Pane2,name='body',
	bd=2,bg="white",relief="flat",
	setgrid=1,wrap=wrap, selectbackground="Gray80")

self.setBodyFontFromConfig()

self.bodyBar = bodyBar = Tk.Scrollbar(split1Pane2,name='bodyBar')
body['yscrollcommand'] = bodyBar.set
bodyBar['command'] = body.yview
bodyBar.pack(side="right", fill="y")

if wrap == "none":
	bodyXBar = Tk.Scrollbar(
		split1Pane2,name='bodyXBar',orient="horizontal")
	body['xscrollcommand'] = bodyXBar.set
	bodyXBar['command'] = body.xview
	bodyXBar.pack(side="bottom", fill="x")
	
body.pack(expand=1, fill="both")</t>
<t tx="T1114">scrolls = config.getBoolWindowPref('outline_pane_scrolls_horizontally')
scrolls = choose(scrolls,1,0)

self.canvas = tree = Tk.Canvas(split2Pane1,name="tree",
	bd=0,bg="white",relief="flat")
	
self.setTreeColorsFromConfig()

# The font is set in the tree code.

# These do nothing...
# selectborderwidth=0,selectforeground="white",selectbackground="white")
self.treeBar = treeBar = Tk.Scrollbar(split2Pane1,name="treeBar")

# Bind mouse wheel event to canvas
if sys.platform != "win32": # Works on 98, crashes on XP.
	self.canvas.bind("&lt;MouseWheel&gt;", self.OnMouseWheel)

tree['yscrollcommand'] = treeBar.set
treeBar['command'] = tree.yview

treeBar.pack(side="right", fill="y")
if scrolls: 
	treeXBar = Tk.Scrollbar( 
		split2Pane1,name='treeXBar',orient="horizontal") 
	tree['xscrollcommand'] = treeXBar.set 
	treeXBar['command'] = tree.xview 
	treeXBar.pack(side="bottom", fill="x")
tree.pack(expand=1,fill="both")</t>
<t tx="T1115">wrap = config.getBoolWindowPref('log_pane_wraps')
wrap = choose(wrap,"word","none")

self.log = log = Tk.Text(split2Pane2,name="log",
	setgrid=1,wrap=wrap,bd=2,bg="white",relief="flat")
	
self.setLogFontFromConfig()

self.logBar = logBar = Tk.Scrollbar(split2Pane2,name="logBar")

log['yscrollcommand'] = logBar.set
logBar['command'] = log.yview

logBar.pack(side="right", fill="y")
# rr 8/14/02 added horizontal elevator 
if wrap == "none": 
	logXBar = Tk.Scrollbar( 
		split2Pane2,name='logXBar',orient="horizontal") 
	log['xscrollcommand'] = logXBar.set 
	logXBar['command'] = log.xview 
	logXBar.pack(side="bottom", fill="x")
log.pack(expand=1, fill="both")</t>
<t tx="T1116">@ write_LEO_file calls config.update() before writing the file, so the put routines can not influence the write.</t>
<t tx="T1117"># All output eventually comes here.
def put (self,s):
	if s and len(s) &gt; 0:
		if self.outputFile: # Write to a file
			try:
				try:
					self.outputFile.write(s)
				except UnicodeError:
					xml_encoding = app().config.xml_version_string
					s = s.encode(xml_encoding)
					self.outputFile.write(s)
			except:
				es("exception writing:" + `s`)
				es_exception()
		elif self.outputString != None: # Write to a string
			self.outputString += s

def put_dquote (self):
	self.put('"')
		
def put_dquoted_bool (self,b):
	if b: self.put('"1"')
	else: self.put('"0"')
		
def put_flag (self,a,b):
	if a:
		self.put(" ") ; self.put(b) ; self.put('="1"')
		
def put_in_dquotes (self,a):
	self.put('"')
	if a: self.put(a) # will always be true if we use backquotes.
	else: self.put('0')
	self.put('"')

def put_nl (self):
	self.put("\n")
	
def put_tab (self):
	self.put("\t")
	
def put_tabs (self,n):
	while n &gt; 0:
		self.put("\t")
		n -= 1</t>
<t tx="T1118">def putFindSettings (self):

	c = self.commands ; config = app().config

	self.put("&lt;find_panel_settings")
	
	&lt;&lt; put find settings that may exist in leoConfig.txt &gt;&gt;
	
	self.put("&lt;/find_panel_settings&gt;") ; self.put_nl()</t>
<t tx="T1119">if config.configsExist and not config.read_only: # 8/6/02
	pass # config.update has already been called.
else:
	self.put_flag(c.batch_flag,"batch")
	self.put_flag(c.ignore_case_flag,"ignore_case")
	self.put_flag(c.mark_changes_flag,"mark_changes")
	self.put_flag(c.mark_finds_flag,"mark_finds")
	self.put_flag(c.pattern_match_flag,"pattern_match")
	self.put_flag(c.reverse_flag,"reverse")
	self.put_flag(c.search_headline_flag,"search_headline")
	self.put_flag(c.search_body_flag,"search_body")
	self.put_flag(c.suboutline_only_flag,"suboutline_only")
	self.put_flag(c.whole_word_flag,"whole_word")
	self.put_flag(c.wrap_flag,"wrap")
	self.put_flag(c.node_only_flag,"node_only")

self.put("&gt;") ; self.put_nl()

if config.configsExist and not config.read_only: # 8/6/02
	self.put_tab()
	self.put("&lt;find_string&gt;&lt;/find_string&gt;") ; self.put_nl()
else:
	self.put_tab()
	self.put("&lt;find_string&gt;") ; self.putEscapedString(c.find_text)
	self.put("&lt;/find_string&gt;") ; self.put_nl()

if config.configsExist and not config.read_only: # 8/6/02
	self.put_tab()
	self.put("&lt;change_string&gt;&lt;/change_string&gt;") ; self.put_nl()
else:
	self.put_tab()
	self.put("&lt;change_string&gt;") ; self.putEscapedString(c.change_text)
	self.put("&lt;/change_string&gt;") ; self.put_nl()</t>
<t tx="T1120">def putPrefs (self):

	c = self.commands ; config = app().config

	self.put("&lt;preferences")
	self.put(" allow_rich_text=") ; self.put_dquoted_bool(0) # no longer used
	
	&lt;&lt; put prefs that may exist in leoConfig.txt &gt;&gt;
	
	self.put("&lt;/preferences&gt;") ; self.put_nl()</t>
<t tx="T1121">language = c.target_language
for name in xml_language_names:
	s = string.lower(name)
	s = string.replace(s,"/","")
	if s == language:
		language = name ; break

if config.configsExist and not config.read_only: # 8/6/02
	pass # config.update has already been called.
else:
	self.put(" tab_width=") ; self.put_in_dquotes(`c.tab_width`)
	self.put(" page_width=") ; self.put_in_dquotes(`c.page_width`)
	self.put(" tangle_bat=") ; self.put_dquoted_bool(c.tangle_batch_flag)
	self.put(" untangle_bat=") ; self.put_dquoted_bool(c.untangle_batch_flag)
	self.put(" output_doc_chunks=") ; self.put_dquoted_bool(c.output_doc_flag)
	self.put(" use_header_flag=") ; self.put_dquoted_bool(c.use_header_flag)
	self.put(" defaultTargetLanguage=") ; self.put_in_dquotes(language) # 10/11/02: fix reversion.

self.put("&gt;") ; self.put_nl()
# New in version 0.16
&lt;&lt; put default directory &gt;&gt;</t>
<t tx="T1122">if config.configsExist:
	pass # Has been done earlier.
elif len(c.tangle_directory) &gt; 0:
	self.put_tab()
	self.put("&lt;defaultDirectory&gt;")
	self.putEscapedString(c.tangle_directory)
	self.put("&lt;/defaultDirectory&gt;")
	self.put_nl()</t>
<t tx="T1123"># Sets config ivars from c.

def setConfigFindIvars (self,c):

	for s in leoFind.ivars:
		# This exec is safe because leoFind.ivars does not depend on leoConfig.txt.
		exec("val=str(c."+s+"_flag)")
		self.setFindPref(s,val)

	self.setFindPref("change_string",c.change_text)
	self.setFindPref("find_string",c.find_text)</t>
<t tx="T1124"># This should be called whenever we need to use find values:
# i.e., before reading or writing

def setIvarsFromFind (self):

	c = self ; find = app().findFrame
	if find:
		find.set_ivars(c)
</t>
<t tx="T1125">def set_ivars (self,c):

	for var in ivars:
		exec("c.%s_flag = self.%s_flag.get()" % (var,var))

	s = self.find_text.get("1.0","end - 1c") # Remove trailing newline
	if type(s) == types.UnicodeType:
		s = s.encode('utf-8')
	c.find_text = s

	s = self.change_text.get("1.0","end - 1c") # Remove trailing newline
	if type(s) == types.UnicodeType:
		s = s.encode('utf-8')
	c.change_text = s
</t>
<t tx="T1126">def write_LEO_file(self,fileName,outlineOnlyFlag):

	c=self.commands ; config = app().config
	
	if not outlineOnlyFlag:
		try:
			# Leo2: write all @file nodes and set orphan bits.
			at = c.atFileCommands
			at.writeAll(c.rootVnode(), false) # forceFlag
		except:
			es("exception writing derived files")
			es_exception()
			return false
			
	if self.read_only:
		es("read only: " + fileName)
		return false

	try:
		&lt;&lt; create backup file &gt;&gt;
		self.mFileName = fileName
		self.outputFile = open(fileName, 'wb') # 9/18/02
		if not self.outputFile:
			es("can not open " + fileName)
			&lt;&lt; delete backup file &gt;&gt;
			return false
		
		# 8/6/02: Update leoConfig.txt completely here.
		c.setIvarsFromFind()
		config.setConfigFindIvars(c)
		c.setIvarsFromPrefs()
		config.setCommandsIvars(c)
		config.update()
		
		self.putProlog()
		self.putHeader()
		self.putGlobals()
		self.putPrefs()
		self.putFindSettings()
		self.putVnodes()
		self.putTnodes()
		self.putPostlog()
		# raise BadLeoFile # testing
	except:
		es("exception writing: " + fileName)
		es_exception() 
		if self.outputFile:
			try:
				self.outputFile.close()
				self.outputFile = None
			except:
				es("exception closing: " + fileName)
				es_exception()
		&lt;&lt; erase filename and rename backupName to fileName &gt;&gt;
		return false

	if self.outputFile:
		try:
			self.outputFile.close()
			self.outputFile = None
		except:
			es("exception closing: " + fileName)
			es_exception()
		&lt;&lt; delete backup file &gt;&gt;
		return true
	else: # This probably will never happen because errors should raise exceptions.
		&lt;&lt; erase filename and rename backupName to fileName &gt;&gt;
		return false</t>
<t tx="T1127"># rename fileName to fileName.bak if fileName exists.
if os.path.exists(fileName):
	try:
		backupName = os.path.join(app().loadDir,fileName)
		backupName = fileName + ".bak"
		if os.path.exists(backupName):
			os.unlink(backupName)
		# os.rename(fileName,backupName)
		utils_rename(fileName,backupName)
	except:
		es("exception creating " + backupName)
		es_exception()
		backupName = None
else:
	backupName = None</t>
<t tx="T1128">if backupName and os.path.exists(backupName):
	try:
		os.unlink(backupName)
	except:
		es("exception deleting " + backupName)
		es_exception()
</t>
<t tx="T1129">es("error writing " + fileName)

if fileName and os.path.exists(fileName):
	try:
		os.unlink(fileName)
	except:
		es("exception deleting " + fileName)
		es_exception()
		
if backupName:
	es("restoring " + fileName + " from " + backupName)
	try:
		# os.rename(backupName, fileName)
		utils_rename(backupName, fileName)
	except:
		es("exception renaming " + backupName + " to " + fileName)
		es_exception()
</t>
<t tx="T1130">@ignore
@nocolor

Where should the font and dialog code go?
	leoDialog.py (put createLabeledFrame here?)
	leoFontDialog.py
	leoColorDialog.py

@color</t>
<t tx="T1131">config = app().config
assert(config)

for name in default_colors_dict.keys(): # Python 2.1 support.
	option_name,default_color = default_colors_dict[name]
	option_color = config.getColorsPref(option_name)
	color = choose(option_color,option_color,default_color)
	# Must use foreground, not fg.
	try:
		body.tag_config(name, foreground=color)
	except: # Recover after a user error.
		body.tag_config(name, foreground=default_color)

underline_undefined = config.getBoolColorsPref("underline_undefined_section_names")
use_hyperlinks      = config.getBoolColorsPref("use_hyperlinks")
self.use_hyperlinks = use_hyperlinks

# underline=var doesn't seem to work.
if use_hyperlinks: 
	body.tag_config("link",underline=1) # defined
	body.tag_config("name",underline=0) # undefined
else:
	body.tag_config("link",underline=0)
	if underline_undefined:
		body.tag_config("name",underline=1)
	else:
		body.tag_config("name",underline=0)
		
# 8/4/02: we only create tags for whitespace when showing invisibles.
if self.showInvisibles:
	body.tag_config("blank",background="Gray90")
	body.tag_config("tab",background="Gray80")</t>
<t tx="T1132"># Returns frames w and f.
# Typically the caller would pack w into other frames, and pack content into f.

def create_labeled_frame (parent,
	caption=None,relief="groove",bd=2,padx=0,pady=0):
	
	Tk = Tkinter
	# Create w, the master frame.
	w = Tk.Frame(parent)
	w.grid(sticky="news")
	
	# Configure w as a grid with 5 rows and columns.
	# The middle of this grid will contain f, the expandable content area.
	w.columnconfigure(1,minsize=bd)
	w.columnconfigure(2,minsize=padx)
	w.columnconfigure(3,weight=1)
	w.columnconfigure(4,minsize=padx)
	w.columnconfigure(5,minsize=bd)
	
	w.rowconfigure(1,minsize=bd)
	w.rowconfigure(2,minsize=pady)
	w.rowconfigure(3,weight=1)
	w.rowconfigure(4,minsize=pady)
	w.rowconfigure(5,minsize=bd)

	# Create the border spanning all rows and columns.
	border = Tk.Frame(w,bd=bd,relief=relief) # padx=padx,pady=pady)
	border.grid(row=1,column=1,rowspan=5,columnspan=5,sticky="news")
	
	# Create the content frame, f, in the center of the grid.
	f = Tk.Frame(w,bd=bd)
	f.grid(row=3,column=3,sticky="news")
	
	# Add the caption.
	if caption and len(caption) &gt; 0:
		caption = Tk.Label(parent,text=caption,highlightthickness=0,bd=0)
		caption.tkraise(w)
		caption.grid(in_=w,row=0,column=2,rowspan=2,columnspan=3,padx=4,sticky="w")

	return w,f</t>
<t tx="T1133">class leoColorPanel:
	@others</t>
<t tx="T1134">def __init__ (self,c):
	
	self.commands = c
	self.frame = c.frame
	# Set by run.
	self.top = None
	# Options provisionally set by callback.
	self.changed_options = []
	# For communication with callback.
	self.buttons = {}
	self.nameButtons = {}
	self.option_names = {}
	# Save colors for revert.  onOk alters this.
	self.revertColors = {}
	config = app().config
	for name,option_name,default_color in colorPanelData:
		self.revertColors[option_name] = config.getColorsPref(option_name)</t>
<t tx="T1135">def run (self):
	
	c = self.commands ; Tk = Tkinter
	config = app().config
	
	self.top = top = Tk.Toplevel(app().root)
	top.title("Syntax colors for " + shortFileName(c.frame.title))
	top.protocol("WM_DELETE_WINDOW", self.onOk)
	attachLeoIcon(top)

	&lt;&lt; create color panel &gt;&gt;
	center_dialog(top) # Do this _after_ building the dialog!
	top.resizable(0,0)
	
	# We are associated with a commander, so
	# There is no need to make this a modal dialog.
	if 0:
		top.grab_set() # Make the dialog a modal dialog.
		top.focus_force() # Get all keystrokes.</t>
<t tx="T1136">outer = Tk.Frame(top,bd=2,relief="groove")
outer.pack(anchor="n",pady=2,ipady=1,expand=1,fill="x")

# Create all the rows.
for name,option_name,default_color in colorPanelData:
	# Get the color.
	option_color = config.getColorsPref(option_name)
	color = choose(option_color,option_color,default_color)
	# Create the row.
	f = Tk.Frame(outer,bd=2)
	f.pack()
	
	lab=Tk.Label(f,text=name,width=17,anchor="e")

	b1 = Tk.Button(f,text="",state="disabled",bg=color,width=4)
	self.buttons[name]=b1 # For callback.
	self.option_names[name]=option_name # For callback.
	
	b2 = Tk.Button(f,width=12,text=option_color)
	self.nameButtons[name]=b2
	
	# 9/15/02: Added self=self to remove Python 2.1 warning.
	callback = lambda name=name,self=self:self.showColorPicker(name)
	b3 = Tk.Button(f,text="Color Picker...",command=callback)

	# 9/15/02: Added self=self to remove Python 2.1 warning.
	callback = lambda name=name,color=color,self=self:self.showColorName(name,color)
	b4 = Tk.Button(f,text="Color Name...",command=callback)

	lab.pack(side="left",padx=3)
	b1.pack (side="left",padx=3)
	b2.pack (side="left",padx=3)
	b3.pack (side="left",padx=3)
	b4.pack (side="left",padx=3)
	
# Create the Ok, Cancel &amp; Revert buttons
f = Tk.Frame(outer,bd=2)
f.pack()
b = Tk.Button(f,width=6,text="OK",command=self.onOk)
b.pack(side="left",padx=4)
b = Tk.Button(f,width=6,text="Cancel",command=self.onCancel)
b.pack(side="left",padx=4,expand=1,fill="x")
b = Tk.Button(f,width=6,text="Revert",command=self.onRevert)
b.pack(side="right",padx=4)</t>
<t tx="T1137">def showColorPicker (self,name):
	
	option_name = self.option_names[name]
	color = app().config.getColorsPref(option_name)
	rgb,val = tkColorChooser.askcolor(color=color)
	if val != None:
		self.update(name,val)</t>
<t tx="T1138">def showColorName (self,name,color):
	
	np = leoColorNamePanel(self,name,color)
	np.run(name,color)</t>
<t tx="T1139">def onOk (self):
	# Update the revert colors
	config = app().config
	for name in self.changed_options:
		option_name = self.option_names[name]
		self.revertColors[option_name] = config.getColorsPref(option_name)
	self.changed_options = []
	if 1: # Hide the window, preserving its position.
		self.top.withdraw()
	else: # works.
		self.commands.frame.colorPanel = None
		self.top.destroy()
	
def onCancel (self):
	self.onRevert()
	if 1: # Hide the window, preserving its position.
		self.top.withdraw()
	else: # works.
		self.commands.frame.colorPanel = None
		self.top.destroy()
	
def onRevert (self):
	config = app().config
	for name in self.changed_options:
		option_name = self.option_names[name]
		old_val = self.revertColors[option_name]
		# Update the current settings.
		config.setColorsPref(option_name,old_val)
		# Update the buttons.
		b = self.buttons[name]
		b.configure(bg=old_val)
		b = self.nameButtons[name]
		b.configure(text=`old_val`)
	self.changed_options = []
	self.commands.recolor()</t>
<t tx="T1140">def update (self,name,val):
	
	config = app().config
	# es(str(name) + " = " + str(val))
	
	# Put the new color in the button.
	b = self.buttons[name]
	b.configure(bg=val)
	option_name = self.option_names[name]
	
	# Put the new color name or value in the name button.
	b = self.nameButtons[name]
	b.configure(text=str(val))
	
	# Save the changed option names for revert and cancel.
	if name not in self.changed_options:
		self.changed_options.append(name)

	# Set the new value and recolor.
	config.setColorsPref(option_name,val)
	self.commands.recolor()</t>
<t tx="T1141">def OnOpenCompareWindow (self,event=None):
	
	c = self.commands
	cp = self.comparePanel
	
	if cp:
		cp.top.deiconify()
	else:
		cmp = leoCompare.leoCompare(c)
		self.comparePanel = cp =  leoCompare.leoComparePanel(c,cmp)
		cp.run()</t>
<t tx="T1142"># Initialize ivars from config parameters.

def finishCreate (self):

	config = app().config
	
	# File names.
	for i,option in (
		(0,"compare_file_1"),
		(1,"compare_file_2"),
		(2,"output_file") ):
			
		name = config.getComparePref(option)
		if name and len(name) &gt; 0:
			e = self.browseEntries[i]
			e.delete(0,"end")
			e.insert(0,name)
			
	name = config.getComparePref("output_file")
	b = choose(name and len(name) &gt; 0,1,0)
	self.useOutputFileVar.set(b)

	# File options.
	b = config.getBoolComparePref("ignore_first_line_of_file_1")
	self.ignoreFirstLine1Var.set(b)
	
	b = config.getBoolComparePref("ignore_first_line_of_file_2")
	self.ignoreFirstLine2Var.set(b)
	
	b = config.getBoolComparePref("append_output_to_output_file")
	if b == None: b = 0
	self.appendOutputVar.set(b)

	ext = config.getComparePref("limit_directory_search_extension")
	b = ext and len(ext) &gt; 0
	b = choose(b and b != 0,1,0)
	self.limitToExtensionVar.set(b)
	if b:
		e = self.extensionEntry
		e.delete(0,"end")
		e.insert(0,ext)
		
	# Print options.
	b = config.getBoolComparePref("print_both_lines_for_matches")
	self.printBothMatchesVar.set(b)
	
	b = config.getBoolComparePref("print_matching_lines")
	self.printMatchesVar.set(b)
	
	b = config.getBoolComparePref("print_mismatching_lines")
	self.printMismatchesVar.set(b)
	
	b = config.getBoolComparePref("print_trailing_lines")
	self.printTrailingMismatchesVar.set(b)
	
	n = config.getIntComparePref("limit_count")
	b = n and n &gt; 0
	b = choose(b and b != 0,1,0)
	self.stopAfterMismatchVar.set(b)
	if b:
		e = self.countEntry
		e.delete(0,"end")
		e.insert(0,`n`)

	# Whitespace options.
	b = config.getBoolComparePref("ignore_blank_lines")
	if b == None: b = 1
	self.ignoreBlankLinesVar.set(b)
	
	b = config.getBoolComparePref("ignore_interior_whitespace")
	self.ignoreInteriorWhitespaceVar.set(b)
	
	b = config.getBoolComparePref("ignore_leading_whitespace")
	self.ignoreLeadingWhitespaceVar.set(b)
	
	b = config.getBoolComparePref("ignore_sentinel_lines")
	self.ignoreSentinelLinesVar.set(b)
	
	b = config.getBoolComparePref("make_whitespace_visible")
	self.makeWhitespaceVisibleVar.set(b)</t>
<t tx="T1143">def setIvarsFromWidgets (self):

	cmp = self.cmp
	
	# File paths. cmp checks for valid file name.
	e = self.browseEntries[0]
	cmp.fileName1 = e.get()
	
	e = self.browseEntries[1]
	cmp.fileName2 = e.get()

	# Ignore first line settings.
	cmp.ignoreFirstLine1 = self.ignoreFirstLine1Var.get()
	cmp.ignoreFirstLine2 = self.ignoreFirstLine2Var.get()
	
	# Output file.  cmp checks for valid file name.
	if self.useOutputFileVar.get():
		e = self.browseEntries[2]
		name = e.get()
		if name != None and len(name) == 0:
			name = None
		cmp.outputFileName = name
	else:
		cmp.outputFileName = None

	# Extension settings.
	if self.limitToExtensionVar.get():
		cmp.limitToExtension = self.extensionEntry.get()
		if len(cmp.limitToExtension) == 0:
			cmp.limitToExtension = None
	else:
		cmp.limitToExtension = None
		
	cmp.appendOutput = self.appendOutputVar.get()
	
	# Whitespace options.
	cmp.ignoreBlankLines         = self.ignoreBlankLinesVar.get()
	cmp.ignoreInteriorWhitespace = self.ignoreInteriorWhitespaceVar.get()
	cmp.ignoreLeadingWhitespace  = self.ignoreLeadingWhitespaceVar.get()
	cmp.ignoreSentinelLines      = self.ignoreSentinelLinesVar.get()
	cmp.makeWhitespaceVisible    = self.makeWhitespaceVisibleVar.get()
	
	# Print options.
	cmp.printMatches            = self.printMatchesVar.get()
	cmp.printMismatches         = self.printMismatchesVar.get()
	cmp.printTrailingMismatches = self.printTrailingMismatchesVar.get()
	
	if cmp.printMatches:
		cmp.printBothMatches = self.printBothMatchesVar.get()
	else:
		cmp.printBothMatches = false
	
	if self.stopAfterMismatchVar.get():
		try:
			count = self.countEntry.get()
			cmp.limitCount = int(count)
		except: cmp.limitCount = 0
	else:
		cmp.limitCount = 0</t>
<t tx="T1144">def compare_files (self, name1, name2):
	
	if name1 == name2:
		self.show("File names are identical.\nPlease pick distinct files.")
		return

	f1 = f2 = None
	try:
		f1 = self.doOpen(name1)
		f2 = self.doOpen(name2)
		if self.outputFileName:
			self.openOutputFile()
		ok = self.outputFileName == None or self.outputFile
		ok = choose(ok and ok != 0,1,0)
		if f1 and f2 and ok: # Don't compare if there is an error opening the output file.
			self.compare_open_files(f1,f2,name1,name2)
	except:
		self.show("exception comparing files")
		es_exception()
	try:
		if f1: f1.close()
		if f2: f2.close()
		if self.outputFile:
			self.outputFile.close() ; self.outputFile = None
	except:
		self.show("exception closing files")
		es_exception()</t>
<t tx="T1145">def openOutputFile (self):
	
	if self.outputFileName == None:
		return
	dir,name = os.path.split(self.outputFileName)
	if len(dir) == 0:
		self.show("empty output directory")
		return
	if len(name) == 0:
		self.show("empty output file name")
		return
	if not os.path.exists(dir):
		self.show("output directory not found: " + dir)
	else:
		try:
			if self.appendOutput:
				self.show("appending to " + self.outputFileName)
				self.outputFile = open(self.outputFileName,"ab")
			else:
				self.show("writing to " + self.outputFileName)
				self.outputFile = open(self.outputFileName,"wb")
		except:
			self.outputFile = None
			self.show("exception opening output file")
			es_exception()</t>
<t tx="T1146">def OnAbout(self,event=None):
	
	# Don't use triple-quoted strings or continued strings here.
	# Doing so would add unwanted leading tabs.
	ver = "$Revision$" # CVS will update this.
	build = ver[10:-1] # Strip off "$Reversion" and "$"
	version = "leo.py 3.9, Build " + build + ", November 23, 2002\n\n"
	copyright = (
		"Copyright 1999-2002 by Edward K. Ream\n" +
		"All Rights Reserved\n" +
		"Leo is distributed under the Python License")
	url = "http://personalpages.tds.net/~edream/front.html"
	email = "edream@tds.net"

	if 1: # Much better looking and includes icon.
		import leoDialog
		d = leoDialog.leoDialog()
		d.aboutLeo(version,copyright,url,email)
	else:
		import tkMessageBox
		tkMessageBox.showinfo("About Leo",
			version + copyright + '\n' + url + '\n' + email)</t>
<t tx="T1147">def aboutLeo(self, version, copyright, url, email):

	Tk = Tkinter ; root = app().root
	self.top = top = Tk.Toplevel(root)
	self.url = url
	self.email = email

	top.title("About Leo")
	frame = Tk.Frame(top)
	
	# Calculate the approximate height &amp; width. (There are bugs in Tk here.)
	lines = string.split(copyright,'\n')
	height = len(lines) + 8 # Add lines for version,url,email,spacing.
	width = 0
	for line in lines:
		width = max(width,len(line))
	width = max(width,len(url))
	width += 10 # 9/9/02

	frame.pack(padx=6,pady=4)
	
	self.text = text = Tk.Text(frame,height=height,width=width,bd=0,bg=frame.cget("background"))
	text.pack(pady=10)
	
	try:
		bitmap_name = os.path.join(app().loadDir,"Icons","Leoapp.GIF")
		image = Tkinter.PhotoImage(file=bitmap_name)
		text.image_create("1.0",image=image,padx=10)
	except:
		es("exception getting icon")
		es_exception()

	text.insert("end",version,"version")
	text.insert("end",copyright,"copyright")
	text.insert("end",'\n')
	text.insert("end",url,"url") # Add "url" tag.
	text.insert("end",'\n')
	text.insert("end",email,"email") # Add "email" tag.
	
	text.tag_config("version",justify="center")
	text.tag_config("copyright",justify="center",spacing1="3")
	
	text.tag_config("url",underline=1,justify="center",spacing1="10")
	text.tag_bind("url","&lt;Button-1&gt;",self.onAboutLeoUrl)
	text.tag_bind("url","&lt;Enter&gt;",self.setArrowCursor)
	text.tag_bind("url","&lt;Leave&gt;",self.setDefaultCursor)

	text.tag_config("email",underline=1,justify="center",spacing1="10")
	text.tag_bind("email","&lt;Button-1&gt;",self.onAboutLeoEmail)
	text.tag_bind("email","&lt;Enter&gt;",self.setArrowCursor)
	text.tag_bind("email","&lt;Leave&gt;",self.setDefaultCursor)

	text.configure(state="disabled")

	self.center() # Do this after packing.
	top.resizable(0,0) # neither height or width is resizable.
	if 0: # No need to make this modal
		top.grab_set() # Make the dialog a modal dialog.
		top.focus_force() # Get all keystrokes.
	root.wait_window(top)</t>
<t tx="T1148">def onAboutLeoUrl(self,event=None):

	try:
		import webbrowser
		webbrowser.open(self.url)
	except:
		es("not found: " + self.url)</t>
<t tx="T1149">def onAboutLeoEmail(self,event=None):
	
	try:
		import webbrowser
		webbrowser.open("mailto:" + self.url)
	except:
		es("not found: " + self.url)</t>
<t tx="T1150">def getIconImage (self, name):

	# Return the image from the cache if possible.
	if self.iconimages.has_key(name):
		return self.iconimages[name]
		
	try:
		if 1: # 8/15/02
			fullname = os.path.join(app().loadDir,name)
			fullname = os.path.normpath(fullname)
		else:
			dir = app().loadDir
			file, ext = os.path.splitext(name)
			fullname = os.path.join(dir, file + ext)
			fullname = os.path.normpath(fullname)

		image = Tkinter.PhotoImage(master=self.canvas, file=fullname)
		self.iconimages[name] = image
		return image
	except:
		es("Exception loading: " + fullname)
		es_exception()
		return None</t>
<t tx="T1151">@ignore
@nocolor

The frame class has ivars that must be kept up-to-date by the various panel classes.  frame.OnCloseLeoEvent closes any panes "owned" by a .leo files when a Leo window closes.

@color</t>
<t tx="T1152">def OnPreferences(self,event=None):
	
	c = self.commands
	if self.prefsPanel:
		# trace()
		self.prefsPanel.top.deiconify()
	else:
		self.prefsPanel = prefs = leoPrefs.LeoPrefs(c)
		top = prefs.top
		center_dialog(top)

		if 0: # No need to make this modal
			top.grab_set() # Make the dialog a modal dialog.
			top.focus_force() # Get all keystrokes.
			app().root.wait_window(top)
</t>
<t tx="T1153">def OnColorPanel(self,event=None):
	
	if self.colorPanel:
		# trace()
		self.colorPanel.top.deiconify()
	else:
		self.colorPanel = cp = leoColor.leoColorPanel(self.commands)
		cp.run()

</t>
<t tx="T1154">def OnFontPanel(self,event=None):

	if self.fontPanel:
		# trace()
		self.fontPanel.top.deiconify()
	else:
		self.fontPanel = fp =  leoFontPanel.leoFontPanel(self.commands)
		fp.run()
</t>
<t tx="T1155">def onOk (self):
	c = self.commands
	self.showSettings()
	&lt;&lt; update the configuration settings &gt;&gt;
	self.setRevertVars()
	if 1: # Hide the window, preserving its position.
		self.top.withdraw()
	else: # works.
		self.commands.frame.fontPanel=None
		self.top.destroy()

def onCancel (self):
	c = self.commands
	self.onRevert()
	self.showSettings()
	if 1: # Hide the window, preserving its position.
		self.top.withdraw()
	else: # works.
		c.frame.fontPanel=None
		self.top.destroy()
	
def onRevert (self):
	c = self.commands
	c.body.configure(font=self.revertBodyFont)
	c.log.configure (font=self.revertLogFont)
	c.tree.setFont  (font=self.revertTreeFont)
	c.redraw()
	self.revertIvars()
	# Don't call update here.</t>
<t tx="T1156">set = app().config.setWindowPref

fn = c.body.cget("font")
font = tkFont.Font(font=fn)
name,size,slant,weight = self.getFontSettings(font)
set("body_text_font_family",name)
set("body_text_font_size",size)
set("body_text_font_slant",slant)
set("body_text_font_weight",weight)
	
fn = c.log.cget("font")
font = tkFont.Font(font=fn)
name,size,slant,weight = self.getFontSettings(font)
set("log_text_font_family",name)
set("log_text_font_size",size)
set("log_text_font_slant",slant)
set("log_text_font_weight",weight)
	
font = c.tree.getFont()
name,size,slant,weight = self.getFontSettings(font)
set("headline_text_font_family",name)
set("headline_text_font_size",size)
set("headline_text_font_slant",slant)
set("headline_text_font_weight",weight)</t>
<t tx="T1157">def OnClosePrefsFrame(self):

	# trace()
	app().config.setConfigIvars(self.commands)
	app().config.update()
	if 1: # Hide the window, preserving its position.
		self.top.withdraw()
	else: # works.
		self.commands.frame.prefsPanel = None
		self.top.destroy()</t>
<t tx="T1158">def onOK (self):
	app().config.setConfigIvars(self.commands)
	app().config.update()
	if 1: # Hide the window, preserving its position.
		self.top.withdraw()
	else: # works.
		self.commands.frame.prefsPanel = None
		self.top.destroy()
	
def onCancel (self):
	c = self.commands
	&lt;&lt; restore options &gt;&gt;
	self.init(c)
	self.set_ivars(c)
	if 1: # Hide the window, preserving its position.
		self.top.withdraw()
	else: # works.
		self.commands.frame.prefsPanel = None
		self.top.destroy()

def onRevert (self):
	c = self.commands
	&lt;&lt; restore options &gt;&gt;
	self.init(c)
	self.set_ivars(c)</t>
<t tx="T1159"># Global options
c.tangle_batch_flag = self.revert_tangle_batch_flag
c.untangle_batch_flag = self.revert_untangle_batch_flag
c.page_width = self.revert_page_width
c.tab_width = self.revert_tab_width
# Default Tangle Options
c.tangle_directory = self.revert_tangle_directory
c.output_doc_flag = self.revert_output_doc_flag
c.use_header_flag = self.revert_use_header_flag
# Default Target Language
c.target_language = self.revert_target_language</t>
<t tx="T1160">@ignore

Changes made:
 - scanColorDirectives no longer sets language to unknown_language when it sees @comment.
 - colorizeAnyLanguage colors directives. (@nocolor can be used to suppress everything.)</t>
<t tx="T1161"> @nocolor
@language plain</t>
<t tx="T1162">@ this should not be colored.
@c

"strings" are not colored in plain text mode.

// comments are not colored in plain text mode.
</t>
<t tx="T1163">@ @first lines are handled at follows:
	
Reading
	
1. scanHeader ignores all lines preceding the @+leo line.  Such lines were presumably written as the result of @first directives.

2. @first directives get turned into @verbatim sentinels, so the read logic for @verbatim handles these directives as usual and turns them into body text.

Writing

1. atFile::write calls &lt;&lt; put @first lines in root &gt;&gt; to scan the body text looking for @first line.  Such lines are output.

2. atFile::write does the following to put the entire tree.

	self.putOpenLeoSentinel("@+leo")
	self.putOpenNodeSentinel(root)
	self.putBodyPart(root)
	...
	self.putCloseNodeSentinel(root)
	self.putSentinel("@-leo")
	
putBodyPart converts @first (and soon, @last) to @verbatim sentinels.

To implement @last we need only to the following:
	
1. putBodyPart and allies will handle @last like @first, namely by converting to @verbatim sentinels.

2. The read logic can just ignore anything after the @-leo sentinel.  Such code was presumably written by @last.</t>
<t tx="T1164"># This is the entry point to the write code.  root should be an @file vnode.

def write(self,root,nosentinels=false):

	c = self.commands
	self.sentinels = not nosentinels
	&lt;&lt; initialize &gt;&gt;
	try:
		&lt;&lt; open the file; return on error &gt;&gt;
		&lt;&lt; write then entire @file tree &gt;&gt;
		self.closeWriteFile()
		&lt;&lt; warn about @ignored and orphans &gt;&gt;
		&lt;&lt; finish writing &gt;&gt;
	except:
		self.handleWriteException()</t>
<t tx="T1165">self.errors = 0 # 9/26/02
c.setIvarsFromPrefs()
self.root = root
self.raw = false
c.endEditing() # Capture the current headline.
</t>
<t tx="T1166">if nosentinels:
	self.targetFileName = root.atNoSentinelsFileNodeName()
else:
	self.targetFileName = root.atFileNodeName()
ok = self.openWriteFile(root)
if not ok: return</t>
<t tx="T1167"># unvisited nodes will be orphans, except in cweb trees.
root.clearVisitedInTree()
next = root.nodeAfterTree()
self.updateCloneIndices(root, next)

&lt;&lt; put all @first lines in root &gt;&gt;
self.putOpenLeoSentinel("@+leo")
&lt;&lt; put optional @comment sentinel lines &gt;&gt;

self.putOpenNodeSentinel(root)
self.putBodyPart(root)
self.putCloseNodeSentinel(root)

root.setVisited()
self.putSentinel("@-leo")
&lt;&lt; put all @last lines in root &gt;&gt;</t>
<t tx="T1168">@ Write any @first lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines preceding the @+leo sentinel.
@c

s = root.t.bodyString
tag = "@first"
i = 0
while match(s,i,tag):
	i += len(tag)
	i = skip_ws(s,i)
	j = i
	i = skip_to_end_of_line(s,i)
	# 21-SEP-2002 DTHEIN: write @first line, whether empty or not
	line = s[j:i]
	self.os(line) ; self.onl()
	i = skip_nl(s,i)</t>
<t tx="T1169">s2 = app().config.output_initial_comment
if s2:
	lines = string.split(s2,"\\n")
	for line in lines:
		line = string.replace(line,"@date",time.asctime())
		if len(line)&gt; 0:
			self.putSentinel("@comment " + line)</t>
<t tx="T1170">@ Write any @last lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines following the @-leo sentinel.
@c

tag = "@last"
lines = string.split(root.t.bodyString,'\n')
n = len(lines) ; j = k = n - 1
# Don't write an empty last line.
if j &gt;= 0 and len(lines[j])==0:
	j = k = n - 2
# Scan backwards for @last directives.
while j &gt;= 0:
	line = lines[j]
	if match(line,0,tag): j -= 1
	else: break
# Write the @last lines.
for line in lines[j+1:k+1]:
	i = len(tag) ; i = skip_ws(line,i)
	self.os(line[i:]) ; self.onl()</t>
<t tx="T1171"># 10/26/02: Always warn, even when language=="cweb"

next = root.nodeAfterTree()
v = root
while v and v != next:
	if not v.isVisited():
		self.writeError("Orphan node:  " + v.headString())
	if v.isAtIgnoreNode():
		self.writeError("@ignore node: " + v.headString())
	v = v.threadNext()
</t>
<t tx="T1172">@ We set the orphan and dirty flags if there are problems writing the file to force Commands::write_LEO_file to write the tree to the .leo file.
@c

if self.errors &gt; 0 or self.root.isOrphan():
	root.setOrphan()
	root.setDirty() # 2/9/02: make _sure_ we try to rewrite this file.
	os.remove(self.outputFileName) # Delete the temp file.
	es("Not written: " + self.outputFileName)
else:
	root.clearOrphan()
	root.clearDirty()
	self.replaceTargetFileIfDifferent()</t>
<t tx="T1173">@ This method sets self.startSentinelComment and self.endSentinelComment based on the first @+leo sentinel line of the file.  We can not call sentinelKind here because that depends on the comment delimiters we set here.  @first lines are written "verbatim", so nothing more needs to be done!

7/8/02: Leading whitespace is now significant here before the @+leo.  This is part of the "REM hack".  We do this so that sentinelKind need not skip whitespace following self.startSentinelComment.  This is correct: we want to be as restrictive as possible about what is recognized as a sentinel.  This minimizes false matches.

14-SEP-2002 DTHEIN:  Queue up the lines before the @+leo.  These will be used to add as parameters to the @first directives, if any.  Empty lines are ignored (because empty @first directives are ignored). NOTE: the function now returns a list of the lines before @+leo.
@c
def scanHeader(self,file):

	valid = true ; tag = "@+leo"
	firstLines = [] # DTHEIN: the first lines, before @+leo
	# Skip any non @+leo lines.
	s = readlineForceUnixNewline(file)
	while len(s) &gt; 0:
		j = string.find(s,tag)
		if j != -1: break
		firstLines.append(s) # DTHEIN: queue the line
		s = readlineForceUnixNewline(file)
	n = len(s)
	valid = n &gt; 0
	# s contains the tag
	i = j = skip_ws(s,0)
	# The opening comment delim is the initial non-whitespace.
	# 7/8/02: The opening comment delim is the initial non-tag
	while i &lt; n and not match(s,i,tag) and not is_nl(s,i): # and not is_ws(s[i]) :
		i += 1
	if j &lt; i:
		self.startSentinelComment = s[j:i]
	else: valid = false
	# Make sure we have @+leo
	if 0:# 7/8/02: make leading whitespace significant.
		i = skip_ws(s, i)
	if match(s, i, tag):
		i += len(tag)
	else: valid = false
	# The closing comment delim is the trailing non-whitespace.
	i = j = skip_ws(s,i)
	while i &lt; n and not is_ws(s[i]) and not is_nl(s,i):
		i += 1
	self.endSentinelComment = s[j:i]
	if not valid:
		self.readError("Bad @+leo sentinel in " + self.targetFileName)
	return firstLines
</t>
<t tx="T1174">@nocolor

Changes made 9/25/02:
	
1. Attempt to create directory if config.path_directive_creates_directories is true.
2. Call getBaseDirectory to handle config.relative_path_base_directory option.

There are _way_ too many paths through this code!

@color</t>
<t tx="T1175">@ignore</t>
<t tx="T1176">This is a test of making directories</t>
<t tx="T1177"># Handles the conventions applying to the "relative_path_base_directory" configuration option.

def getBaseDirectory():

	base = app().config.relative_path_base_directory

	if base and base == "!":
		base = app().loadDir
	elif base and base == ".":
		base = top().openDirectory

	# trace(`base`)
	if base and len(base) &gt; 0 and os.path.isabs(base):
		return base # base need not exist yet.
	else:
		return "" # No relative base given.
</t>
<t tx="T1178">@ignore
@quiet
</t>
<t tx="T1179">@root c:\prog\test\quietTest.txt
root line one
&lt;&lt; ref1 &gt;&gt;
&lt;&lt; ref2 &gt;&gt;
root last line</t>
<t tx="T1180">@c
ref1 line 1
ref1 line 2
&lt;&lt; ref3 &gt;&gt;
ref1 line 3
</t>
<t tx="T1181">@ ref2 doc
&lt;&lt; ref2 &gt;&gt;=
ref2 line1
ref2 line2</t>
<t tx="T1182">@c
ref3 line 1
ref3 line 2</t>
<t tx="T1183">@ I may have to alter the read logic after all.  scanText assumes that the leading whitespace of section references has been added to all expansions of those sections, and that doesn't happen in @raw ranges.  So it looks like scanText may have to deal with this.

To do: test that end-of-body terminates @raw.
@c

@ignore</t>
<t tx="T1184">root line 1
	&lt;&lt; ref &gt;&gt;
	root line 2
root line 3
		&lt;&lt; ref &gt;&gt;
root line 4</t>
<t tx="T1185">line 1
line 2
@raw
line 3
	indented line
		more indented
line 4
@end_raw
line 5
line 6</t>
<t tx="T1186">@ignore

@ Directives _are_ recognized only in the root of @silentfile or @rawfile trees.</t>
<t tx="T1187">@ignore</t>
<t tx="T1188">node 1, line1
node 1, line2 (no newline)</t>
<t tx="T1189">node 2, line1
node 2, line2 (newline)</t>
<t tx="T1190">node 3, line1 (changed)
node 3, line2 (no newline)</t>
<t tx="T1191">@language cweb

rawfile node line 1
</t>
<t tx="T1192">node 1, line1 
node 1, line2 (no newline)</t>
<t tx="T1193">node 2, line1
node 2, line2 (newline)
</t>
<t tx="T1194">node 3, line1 (changed)
node 3, line2 (no newline)</t>
<t tx="T1195">@tabwidth 2
	a</t>
<t tx="T1196">	a
xx
yy
zz</t>
<t tx="T1197">@tabwidth 4
	a</t>
<t tx="T1198">@ignore

@ You must double-click in the icon box to fire up the @url logic.

Thanks to Rich Ries and Dave Hein for code and suggestions.</t>
<t tx="T1199">def OnIconDoubleClick (self,v,event=None):

	c = self.commands
	s = v.headString().strip()
	if match_word(s,0,"@url"):
		flag = handleLeoHook("@url1",c=c,v=v)
		if flag == None:  # Anything other than None overrides.
			url = s[4:].strip()
			&lt;&lt; stop the url after any embedded blank and issue warning &gt;&gt;
			&lt;&lt; check the url; return if bad &gt;&gt;
			&lt;&lt; pass the url to the web browser &gt;&gt;
			handleLeoHook("@url2",c=c,v=v)</t>
<t tx="T1200"># For safety, the URL string should end at the first whitespace.

url = url.replace('\t',' ')
i = url.find(' ')
if i &gt; -1:
	es("ignoring characters after space in url:"+url[i:])
	es("use %20 instead of spaces")
	url = url[:i]
</t>
<t tx="T1201">if not url or len(url) == 0:
	es("no url following @url")
	return
	
@ A valid url is (according to D.T.Hein):

3 or more lowercase alphas, followed by,
one ':', followed by,
one or more of: (excludes !"#;&lt;&gt;[\]^`|)
	$%&amp;'()*+,-./0-9:=?@A-Z_a-z{}~
followed by one of: (same as above, except no minus sign or comma).
	$%&amp;'()*+/0-9:=?@A-Z_a-z}~
@c
urlPattern = "[a-z]{3,}:[\$-:=?-Z_a-z{}~]+[\$-+\/-:=?-Z_a-z}~]"
import re
if not re.match(urlPattern,url):
	es("invalid url: "+url)
	return</t>
<t tx="T1202">@ Most browsers should handle the following urls:
	ftp://ftp.uu.net/public/whatever.
	http://localhost/MySiteUnderDevelopment/index.html
	file:///home/me/todolist.html
@c

try:
	import os
	import webbrowser
	os.chdir(app().loadDir)
	# print "url:",url
	webbrowser.open(url)
except:
	es("exception opening " + url)
	es_exception()</t>
<t tx="T1203"># The problem is that only the top-level directory is created.

@ignore</t>
<t tx="T1204">By: davidmcnab ( David McNab ) 
 Feature Req: auto-create dirs for @file   
2002-11-17 06:33  
Hi, 

I'm getting fond of the practice of distributing source code as a tarball, containing only a .leo file, plus a README telling people to install Leo. 

There's presently one obstacle to this - when @file nodes exist for files in child directories, Leo doesn't (yet) create directories as needed. 

I humbly suggest that when writing out @file nodes, Leo creates all needed subdirectories that don't already exist.

------------------
 
I set create_nonexistent_directories=1 in leoConfig.txt, but Leo still won't create the needed subdirectories. 

</t>
<t tx="T1205">@ This is a generalization of os.makedir.
It attempts to make all non-existent directories.
@c

def makeAllNonExistentDirectories (dir):

	if not app().config.create_nonexistent_directories:
		return None

	dir1 = dir = os.path.normpath(dir)
	# Split dir into all its component parts.
	paths = []
	while len(dir) &gt; 0:
		head,tail=os.path.split(dir)
		if len(tail) == 0:
			paths.append(head)
			break
		else:
			paths.append(tail)
			dir = head
	path = ""
	paths.reverse()
	for s in paths:
		path=os.path.join(path,s)
		if not os.path.exists(path):
			try:
				os.mkdir(path)
				es("created directory: "+path)
			except:
				es("exception creating directory: "+path)
				es_exception()
				return None
	return dir1 # All have been created.</t>
<t tx="T1206">This is a test.</t>
<t tx="T1207">@root c:/prog/test/dir1/dir2/dir3/dirTest.txt

This is a test.</t>
<t tx="T1208">@ Platform-independent rename.

os.rename may fail on some Unix flavors if src and dst are on different filesystems.
@c

def utils_rename(src,dst):
	
	head,tail=os.path.split(dst)
	if head and len(head) &gt; 0:
		makeAllNonExistentDirectories(head)
	
	if sys.platform=="win32":
		os.rename(src,dst)
	else:
		from distutils.file_util import move_file
		move_file(src,dst)</t>
<t tx="T1209">@ignore</t>
<t tx="T1210"># Puts tabs and spaces corresponding to n spaces, assuming that we are at the start of a line.

def putIndent(self,n):

	c = self.commands
	w = self.tab_width
	if w &gt; 1:
		q,r = divmod(n,w) 
		self.otabs(q) 
		self.oblanks(r)
	else:
		self.oblanks(n)</t>
<t tx="T1211"># Puts tabs and spaces corresponding to n spaces, assuming that we are at the start of a line.

def put_leading_ws(self,n):

	# trace("tab_width:" + `self.tab_width` + ", indent:" + `indent`)
	w = self.tab_width

	if w &gt; 1:
		q,r = divmod(n,w) 
		self.otabs(q) 
		self.oblanks(r) 
	else:
		self.oblanks(n)
</t>
<t tx="T1212">def oblank (self):
	self.oblanks(1)

def oblanks (self,n):
	if abs(n) &gt; 0:
		self.output_file.write(' ' * abs(n))
		
def onl(self):
	self.os(self.output_newline)
		
def os (self,s):
	s = string.replace(s,body_ignored_newline,body_newline)
	try:
		self.output_file.write(s)
	except UnicodeError: # 8/9/02
		xml_encoding = app().config.xml_version_string
		s = s.encode(xml_encoding)
		self.output_file.write(s) # 8/14/02

def otab (self):
	self.otabs(1)

def otabs (self,n):
	if abs(n) &gt; 0:
		self.output_file.write('\t' * abs(n))</t>
<t tx="T1213"># Allow test code...
@ignore</t>
<t tx="T1214"># This test shows all relevant cases, I think.

&lt;&lt; class c &gt;&gt;
@others
&lt;&lt; class d &gt;&gt;</t>
<t tx="T1215">class a:
	@others</t>
<t tx="T1216">def one():
	pass</t>
<t tx="T1217">def two():
	pass</t>
<t tx="T1218">class b:
	@others</t>
<t tx="T1219">def one():
	pass</t>
<t tx="T1220">def two():
	pass</t>
<t tx="T1221">class c:
	#class c
	@others</t>
<t tx="T1222">def f():
	pass</t>
<t tx="T1223">class d:
	&lt;&lt; more d &gt;&gt;
	@others
	&lt;&lt; still more d &gt;&gt;</t>
<t tx="T1224"># more d</t>
<t tx="T1225"># still more d</t>
<t tx="T1226">@ Returns true if v should be included in the expansion of the at-others directive in the body text of v's parent.

7/30/02: v will not be included if it is a definition node or if its body text contains an @ignore directive. Previously, a "nested" @others directive would also inhibit the inclusion of v.
@c
def inAtOthers(self,v):

	# Return false if this has been expanded previously.
	if  v.isVisited(): return false
	# Return false if this is a definition node.
	h = v.headString()
	i = skip_ws(h,0)
	isSection, j = self.isSectionName(h,i)
	if isSection: return false
	# Return false if v's body contains an @ignore or at-others directive.
	if 1: # 7/29/02: New code.  Amazingly, this appears to work!
		return not v.isAtIgnoreNode()
	else: # old &amp; reliable code
		return not v.isAtIgnoreNode() and not v.isAtOthersNode()</t>
<t tx="T1227">@ The at-others directive is recognized only at the start of the line.  This code must generate all leading whitespace for the opening sentinel.
@c
def putAtOthers(self,v,delta):

	self.indent += delta
	self.putSentinel("@+others")

	child = v.firstChild()
	while child:
		if self.inAtOthers( child ):
			self.putAtOthersChild( child )
		child = child.next()

	self.putSentinel("@-others")
	self.indent -= delta</t>
<t tx="T1228">def putAtOthersChild(self,v):

	self.putOpenNodeSentinel(v)
	
	# Insert the expansion of v.
	v.setVisited() # Make sure it is never expanded again.
	self.putBodyPart(v)

	# Insert expansions of all children.
	child = v.firstChild()
	while child:
		if self.inAtOthers( child ):
			self.putAtOthersChild( child )
		child = child.next()

	self.putCloseNodeSentinel(v)</t>
<t tx="T1229">if self.treeType == "@file":
	if outerFlag:
		parent.appendStringToBody("\n@others\n")
	else:
		parent.appendStringToBody("\n\t@others\n")
else:
	kind = choose(outerFlag,"classes","methods")
	ref_name = angleBrackets(" " + self.methodName + " " + kind + " ")
	parent.appendStringToBody(leader + ref_name + "\n")</t>
<t tx="T1230">indent =  self.getLeadingIndent(s,i)
start = i = skip_blank_lines(s,i)
parent_vnode = None # 7/6/02
while i &lt; len(s) and indent &gt; classIndent:
	progress = i
	if is_nl(s,i):
		j = skip_nl(s,i)
		indent = self.getLeadingIndent(s,j)
		if indent &gt; classIndent: i = j
		else: break
	elif match_c_word(s,i,"def"):
		if not parent_vnode:
			&lt;&lt; create parent_vnode &gt;&gt;
		i = start = self.scanPythonDef(s,i,start,parent_vnode)
		indent = self.getLeadingIndent(s,i)
	elif match_c_word(s,i,"class"):
		if not parent_vnode:
			&lt;&lt; create parent_vnode &gt;&gt;
		i = start = self.scanPythonClass(s,i,start,parent_vnode)
		indent = self.getLeadingIndent(s,i)
	elif s[i] == '#': i = skip_to_end_of_line(s,i)
	elif s[i] == '"' or s[i] == '\'': i = skip_python_string(s,i)
	else: i += 1
	assert(progress &lt; i)</t>
<t tx="T1231"># This must be done after the declaration reference is generated.
if self.treeType == "@file":
	class_vnode.appendStringToBody("\t@others\n")
else:
	ref = angleBrackets(" class " + classname + " methods ")
	class_vnode.appendStringToBody("\t" + ref + "\n\n")
parent_vnode = class_vnode</t>
<t tx="T1232"># Creates a child of parent for each C function definition seen.

def scanCText (self,s,parent):

	&lt;&lt; define scanCText vars &gt;&gt;
	while i &lt; len(s):
		# line = get_line(s,i) ; trace(`line`)
		ch = s[i]
		# These cases skip tokens.
		if ch == '/':
			&lt;&lt; handle possible C comments &gt;&gt;
		elif ch == '"' or ch == '\'':
			i = skip_string(s,i)
		# These cases help determine where functions start.
		elif ch == '=':
			&lt;&lt; handle equal sign in C &gt;&gt;
		elif ch == '(':
			&lt;&lt; handle open paren in C &gt;&gt;
		elif ch == ';':
			&lt;&lt; handle semicolon in C &gt;&gt;
		# These cases and the default case can create child nodes.
		elif ch == '#':
			&lt;&lt; handle # sign &gt;&gt;
		elif ch == '{':
			&lt;&lt; handle open curly bracket in C &gt;&gt;
		elif is_c_id(ch):
			&lt;&lt; handle id, class, typedef, struct, union, namespace &gt;&gt;
		else: i += 1
	&lt;&lt; Append any unused text to the parent's body text &gt;&gt;</t>
<t tx="T1233">c = self.commands
include_seen = method_seen = false
methodKind = choose(self.fileType==".c","functions","methods")
lparen = None   # Non-null if '(' seen at outer level.
scan_start = function_start = 0
name = None
i = 0</t>
<t tx="T1234"># if statements may contain function definitions.
i += 1  # Skip the '#'
if not include_seen and match_c_word(s,i,"include"):
	include_seen = true
	&lt;&lt; create a child node for all #include statements &gt;&gt;
else:
	j = i
	i = skip_pp_directive(s,i)</t>
<t tx="T1235"># Scan back to the start of the line.
include_start = i = find_line_start(s,i)

# Scan to the next line that is neither blank nor and #include.
i = skip_pp_directive(s,i)
i = skip_nl(s,i)
include_end = i
while i &lt; len(s):
	i = skip_ws_and_nl(s,i)
	if match_c_word(s,i,"#include"):
		i = skip_pp_directive(s,i)
		i = skip_nl(s,i)
		include_end = i
	elif i + 2 &lt; len(s) and s[i] == '\\':
		# Handle possible comment.
		if s[i+1] == '\\':
			i = skip_to_end_of_line(s,i)
		elif s[i+1] == '*':
			i = skip_block_comment(s,i + 2)
		else:
			i = include_end ; break
	else:
		i = include_end ; break
		

headline = angleBrackets(" " + self.methodName + " #includes ")
body = s[include_start:include_end]
body = self.undentBody(body)
prefix = choose(self.treeType == "@file","","@code\n\n")
self.createHeadline(parent,prefix + body,headline)
parent.appendStringToBody("@ignore\n" + self.rootLine + "@language c\n")

# Append any previous text to the parent's body.
save_ip = i ; i = scan_start
while i &lt; include_start and is_ws_or_nl(s,i):
	i += 1
if i &lt; include_start:
	parent.appendStringToBody(s[i:include_start])
scan_start = function_start = i = save_ip
# Append the headline to the parent's body.
parent.appendStringToBody(headline + "\n")</t>
<t tx="T1236">j = i = skip_braces(s,i) # Skip all inner blocks.

# This may fail if #if's contain unmatched curly braces.
if (match(s,i,'}') and lparen and name and function_start):
	# Point i _after_ the last character of the function.
	i += 1
	if is_nl(s,i):
		i = skip_nl(s,i)
	function_end = i
	if method_seen:
		# Include everything after the last function.
		function_start = scan_start 
	else:
		&lt;&lt; create a declaration node &gt;&gt;
		&lt;&lt; append C function/method reference to parent node &gt;&gt;
	headline = name
	body = s[function_start:function_end]
	body = self.massageBody(body,"functions")
	self.createHeadline(parent,body,headline)
	
	method_seen = true
	scan_start = function_start = i # Set the start of the _next_ function.
	lparen = None
else:
	i += 1</t>
<t tx="T1237">save_ip = i
i = scan_start
while i &lt; function_start and is_ws_or_nl(s,i):
	i += 1
if i &lt; function_start:
	headline = angleBrackets(" " + self.methodName + " declarations ")
	# Append the headline to the parent's body.
	parent.appendStringToBody(headline + "\n")
	decls = s[scan_start:function_start]
	decls = self.undentBody(decls)
	if self.treeType == "@file":
		body = decls
	else:
		body = "@code\n\n" + decls
	self.createHeadline(parent,body,headline)
i = save_ip
scan_start = i</t>
<t tx="T1238">if self.treeType == "@file":
	parent.appendStringToBody("@others\n")
else:
	cweb = c.target_language == "cweb"
	lb = choose(cweb,"@&lt;","&lt;&lt;")
	rb = choose(cweb,"@&gt;","&gt;&gt;")
	parent.appendStringToBody(
		lb + " " + self.methodName + " " + methodKind + " " + rb + "\n")</t>
<t tx="T1239">if match_c_word(s,i,"typedef"):
	i = skip_typedef(s,i)
	lparen = None
elif match_c_word(s,i,"struct"):
	i = skip_typedef(s,i)
	# lparen = None ;  # This can appear in an argument list.
elif match_c_word(s,i,"union"):
	i = skip_typedef(s,i)
	# lparen = None ;  # This can appear in an argument list.
elif match_c_word(s,i,"namespace"):
	&lt;&lt; create children for the namespace &gt;&gt;
# elif match_c_word(s,i,"class"):
	# &lt; &lt; create children for the class &gt; &gt;
else:
	# Remember the last name before an open parenthesis.
	if lparen == None:
		j = i ; i = skip_c_id(s,i) ; name = s[j:i]
	else:
		i = skip_c_id(s,i)
	&lt;&lt; test for operator keyword &gt;&gt;</t>
<t tx="T1240">@ Namesspaces change the self.moduleName and recursively call self function with a text covering only the range of the namespace. This effectively changes the definition line of any created child nodes. The namespace is written to the top level.
@c

# skip the "namespace" keyword.
i += len("namespace")
i = skip_ws_and_nl(s,i)
# Skip the namespace name.
namespace_name_start = i
namespace_name_end = None
if i &lt; len(s) and is_c_id(s[i]):
	i = skip_c_id(s,i)
	namespace_name_end = i - 1
else: namespace_name_start = None
# Skip the '{'
i = skip_ws_and_nl(s,i)
if match(s,i,'{') and namespace_name_start:
	inner_ip = i + 1
	i = skip_braces(s,i)
	if match(s,i,'}'):
		# Append everything so far to the body.
		if inner_ip &gt; scan_start:
			parent.appendStringToBody(s[scan_start:inner_ip])
		# Save and change self.moduleName to namespaceName
		savedMethodName = self.methodName
		namespaceName = s[namespace_name_start:namespace_name_end]
		self.methodName = "namespace " + namespaceName
		# Recursively call this function .
		self.scanCText(s[inner_ip:],parent)
		# Restore self.moduleName and continue scanning.
		self.methodName = savedMethodName
		scan_start = function_start = i</t>
<t tx="T1241"># We treat a C++ a construct such as operator + as a function name.
if match(name,0,"operator"):
	j = i
	i = skip_ws(s,i) # Don't allow newline in headline.
	if (i &lt; len(s) and not is_c_id(s[i]) and
		s[i]!=' ' and s[i]!='\n' and s[i]!='\r'):
		while (i &lt; len(s) and not is_c_id(s[i]) and
			s[i]!=' ' and s[i]!='\n' and s[i] != '\r'):
			i += 1
		name = s[j:i] # extend the name.</t>
<t tx="T1242">if match(s,i,"//"):
	i = skip_line(s,i)
elif match(s,i,"/*"):
	i = skip_block_comment(s,i)
else:
	i += 1</t>
<t tx="T1243">@ We can not be seeing a function definition when we find an equal sign at the top level. Equal signs inside parentheses are handled by the open paren logic.
@c

i += 1 # skip the '='
function_start = None # We can't be in a function.
lparen = None   # We have not seen an argument list yet.
if match(s,i,'='):
	i = skip_braces(s,i)</t>
<t tx="T1244">lparen = i
# This will skip any equal signs inside the paren.
i = skip_parens(s,i)
if match(s,i,')'):
	i += 1
	i = skip_ws_and_nl(s,i)
	if match(s,i,';'):
		lparen = None # not a function definition.
else: lparen = None</t>
<t tx="T1245">@ A semicolon signals the end of a declaration, thereby potentially starting the _next_ function defintion.   Declarations end a function definition unless we have already seen a parenthesis, in which case we are seeing an old-style function definition.
@c

i += 1 # skip the semicolon.
if lparen == None:
	function_start = i + 1 # The semicolon ends the declaration.</t>
<t tx="T1246"># Used by C, Java and Pascal parsers.
# Do nothing if only whitespace is left.

i = skip_ws_and_nl(s,scan_start)
if i &lt; len(s):
	parent.appendStringToBody(s[scan_start:])</t>
<t tx="T1247"># Creates a child of parent for each Java function definition seen.

def scanJavaText (self,s,parent,outerFlag): # true if at outer level.

	&lt;&lt; define scanJavaText vars &gt;&gt;
	# if not outerFlag: trace("inner:" + `s`)
	while i &lt; len(s):
		# trace(`get_line(s,i)`)
		ch = s[i]
		# These cases skip tokens.
		if ch == '/':
			&lt;&lt; handle possible Java comments &gt;&gt;
		elif ch == '"' or ch == '\'': i = skip_string(s,i)
		# These cases help determine where functions start.
		elif ch == '=':
			&lt;&lt; handle equal sign in Java &gt;&gt;
		elif ch == '(':
			&lt;&lt; handle open paren in Java &gt;&gt;
		elif ch == ';':
			&lt;&lt; handle semicolon in Java &gt;&gt;
			class_seen = false
		# These cases can create child nodes.
		elif ch == '{':
			&lt;&lt; handle open curly bracket in Java &gt;&gt;
		elif is_c_id(s[i]):
			&lt;&lt; skip and remember the Java id &gt;&gt;
		else: i += 1
	&lt;&lt; Append any unused text to the parent's body text &gt;&gt;</t>
<t tx="T1248">method_seen = false
class_seen = false # true: class keyword seen at outer level.
interface_seen = false # true: interface keyword seen at outer level.
lparen = None  # not None if '(' seen at outer level.
scan_start = 0
name = None
function_start = 0 # choose(outerFlag, None, 0)
i = 0</t>
<t tx="T1249">brace_ip1 = i
i = skip_braces(s,i) # Skip all inner blocks.
brace_ip2 = i

if not match (s,i,'}'):
	es("unmatched '{'")
elif not name:
	i += 1
elif (outerFlag and (class_seen or interface_seen)) or (not outerFlag and lparen):
	# trace("starting:"+name)
	# trace("outerFlag:"+`outerFlag`)
	# trace("lparen:"`lparen`)
	# trace("class_seen:"+`class_seen`)
	# trace("scan_start:"+get_line_after(s,scan_start))
	# trace("func_start:"+get_line_after(s,function_start))
	# trace("s:"+get_line(s,i))

	# Point i _after_ the last character of the method.
	i += 1
	if is_nl(s,i):
		i = skip_nl(s,i)
	function_end = i
	headline = name
	if outerFlag:
		leader = "" ; decl_leader = ""
		if class_seen:
			headline = "class " + headline
			methodKind = "classes"
		else:
			headline = "interface " + headline
			methodKind = "interfaces"
	else:
		leader = "\t" # Indent only inner references.
		decl_leader = "\n"  # Declaration leader for inner references.
		methodKind = "methods"
	if method_seen:
		# Include everything after the last fucntion.
		function_start = scan_start
	else:
		&lt;&lt; create a Java declaration node &gt;&gt;
		&lt;&lt; append Java method reference to parent node &gt;&gt;
	if outerFlag: # Create a class.
		# Backtrack so we remove leading whitespace.
		function_start = find_line_start(s,function_start)
		body = s[function_start:brace_ip1+1]
		body = self.massageBody(body,methodKind)
		v = self.createHeadline(parent,body,headline)
		&lt;&lt; recursively scan the text &gt;&gt;
		# Append the brace to the parent.
		v.appendStringToBody("}")
		i = brace_ip2 + 1 # Start after the closing brace.
	else: # Create a method.
		# Backtrack so we remove leading whitespace.
		function_start = find_line_start(s,function_start)
		body = s[function_start:function_end]
		body = self.massageBody(body,methodKind)
		self.createHeadline(parent,body,headline)
		i = function_end
	method_seen = true
	scan_start = function_start = i # Set the start of the _next_ function.
	lparen = None ; class_seen = false
else: i += 1</t>
<t tx="T1250">save_ip = i
i = scan_start
while i &lt; function_start and is_ws_or_nl(s,i):
	i += 1
	
if outerFlag:
	parent.appendStringToBody("@ignore\n" + self.rootLine + "@language java\n")

if i &lt; function_start:
	decl_headline = angleBrackets(" " + self.methodName + " declarations ")

	# Append the headline to the parent's body.
	parent.appendStringToBody(decl_leader + leader + decl_headline + "\n")
	scan_start = find_line_start(s,scan_start) # Backtrack so we remove leading whitespace.
	decls = s[scan_start:function_start]
	decls = self.undentBody(decls)
	body = choose(self.treeType == "@file",decls,"@code\n\n" + decls)
	self.createHeadline(parent,body,decl_headline)

i = save_ip
scan_start = i</t>
<t tx="T1251"># These mark the points in the present function.
# trace("recursive scan:" + `get_line(s,brace_ip1+ 1)`)
oldMethodName = self.methodName
self.methodName = headline
self.scanJavaText(s[brace_ip1+1:brace_ip2], # Don't include either brace.
	v,false) # inner level
self.methodName = oldMethodName
</t>
<t tx="T1252">if match_c_word(s,i,"class") or match_c_word(s,i,"interface"):
	if match_c_word(s,i,"class"):
		class_seen = true
	else:
		interface_seen = true
	i = skip_c_id(s,i) # Skip the class or interface keyword.
	i = skip_ws_and_nl(s,i)
	if i &lt; len(s) and is_c_id(s[i]):
		# Remember the class or interface name.
		j = i ; i = skip_c_id(s,i) ; name = s[j:i]
else:
	j = i ; i = skip_c_id(s,i)
	if not lparen and not class_seen:
		name = s[j:i] # Remember the name.</t>
<t tx="T1253">if match(s,i,"//"):
	i = skip_line(s,i)
elif match(s,i,"/*"):
	i = skip_block_comment(s,i)
else:
	i += 1</t>
<t tx="T1254">@ We can not be seeing a function definition when we find an equal sign at the top level. Equal signs inside parentheses are handled by the open paren logic.
@c

i += 1 # skip the '='
function_start = None # We can't be in a function.
lparen = None   # We have not seen an argument list yet.
if match(s,i,'='):
	i = skip_braces(s,i)</t>
<t tx="T1255">lparen = i
# This will skip any equal signs inside the paren.
i = skip_parens(s,i)
if match(s,i,')'):
	i += 1
	i = skip_ws_and_nl(s,i)
	if match(s,i,';'):
		lparen = None # not a function definition.
else: lparen = None</t>
<t tx="T1256">@ A semicolon signals the end of a declaration, thereby potentially starting the _next_ function defintion.   Declarations end a function definition unless we have already seen a parenthesis, in which case we are seeing an old-style function definition.
@c

i += 1 # skip the semicolon.
if lparen == None:
	function_start = i + 1 # The semicolon ends the declaration.</t>
<t tx="T1257">@ignore</t>
<t tx="T1258">@language perlpod
@path c:\prog\test</t>
<t tx="T1259">@ Multi-line
doc part
@root perlpod.txt
&lt;&lt;ref&gt;&gt;</t>
<t tx="T1260">@ doc part2
@c
code line1
code line2
@ more doc part</t>
<t tx="T1261">@comment REM_</t>
<t tx="T1262">test 6</t>
<t tx="T1263">@ atFile.directiveKind is return miscDirective on _any_ line that starts with @</t>
<t tx="T1264">@ignore

line 1
@line 2
	@line 3
line 4</t>
<t tx="T1265">if match (s,i,self.startSentinelComment + '@'):
	self.putSentinel("verbatim")</t>
<t tx="T1266">box_padding = 5 # extra padding between box and icon
box_width = 9 + box_padding
icon_width = 20
text_indent = 4 # extra padding between icon and tex
child_indent = 28 # was 20
hline_y = 7 # Vertical offset of horizontal line
root_left = 7 + box_width
root_top = 2
hiding = true # True if we don't reallocate items
line_height = 17 + 2 # To be replaced by Font height</t>
<t tx="T1267">def getFont (self):

	return self.font
		
# Called by leoFontPanel.
def setFont (self, font=None, fontName=None):
	
	if fontName:
		self.fontName = fontName
		self.font = tkFont.Font(font=fontName)
	else:
		self.fontName = None
		self.font = font
		
	self.setLineHeight(self.font)
	
# Called by ctor and when config params are reloaded.
def setFontFromConfig (self):

	font = app().config.getFontFromParams(
		"headline_text_font_family", "headline_text_font_size",
		"headline_text_font_slant",  "headline_text_font_weight")

	self.setFont(font)</t>
<t tx="T1268">def setLineHeight (self,font):
	
	try:
		metrics = font.metrics()
		linespace = metrics ["linespace"]
		self.line_height = linespace + 5 # Same as before for the default font on Windows.
		# print metrics
	except:
		self.line_height = line_height # was 17 + 2
		es("exception setting outline line height")
		es_exception()</t>
<t tx="T1269">def __init__(self,commands,canvas):

	# Objects associated with this tree.
	self.colorizer = leoColor.colorizer(commands)
	self.commands = commands
	self.canvas = canvas
	self.rootVnode = None
	self.topVnode = None
	
	# Miscellaneous info.
	self.iconimages = {} # Image cache set by getIconImage().
	self.vnode_alloc_list = [] # List of all vnodes ever allocated in this tree.
	self.active = false # true if tree is active
	self.revertHeadline = None # Previous headline text for abortEditLabel.
	
	# Set self.font and self.fontName.
	self.setFontFromConfig()
	
	# Recycling bindings.
	self.recycleBindings = true # true: remember bindings and unbind them explicitly.
	self.bindings = [] # List of bindings to be unbound when redrawing.
	self.tagBindings = [] # List of tag bindings to be unbound when redrawing.

	# Controlling redraws
	self.updateCount = 0 # self.redraw does nothing unless this is zero.
	self.redrawCount = 0 # For traces
	self.redrawScheduled = false # true if redraw scheduled.

	# Selection ivars.
	self.currentVnode = None # The presently selected vnode.
	self.editVnode = None # The vnode being edited.
	self.initing = false # true: opening file.
	
	# Drag and drop
	self.dragging = false # true: presently dragging.
	self.controlDrag = false # true: control was down when drag started.
	self.oldcursor = None # To reset cursor after drag
	self.drag_id = None # To reset bindings after drag
	
	# 20-SEP-2002 DTHEIN: keep track of popup menu so we can handle
	#                     behavior better on Linux
	# Context menu
	self.popupMenu = None</t>
<t tx="T1270">def findVnodeWithIconId (self,id):

	v = self.rootVnode
	while v:
		if v.icon_id == id or (v.icon_id,) == id:
			return v
		else: v = v.visNext()
		
	return None</t>
<t tx="T1271">def OnEndDrag(self,v,event):
	
	# es("tree.OnEndDrag" + `v`)
	assert(v == self.drag_v)
	c = self.commands ; canvas = self.canvas

	if event:
		&lt;&lt; set vdrag, childFlag &gt;&gt;
		if vdrag and vdrag != v:
			if self.controlDrag: # Clone v and move the clone.
				if childFlag:
					c.dragCloneToNthChildOf(v,vdrag,0)
				else:
					c.dragCloneAfter(v,vdrag)
			else: # Just drag v.
				if childFlag:
					c.dragToNthChildOf(v,vdrag,0)
				else:
					c.dragAfter(v,vdrag)
		else:
			if v and self.dragging:
				es("not dragged: " + v.headString())
			if 0: # Don't undo the scrolling we just did!
				self.idle_scrollTo(v)
	
	# 10/26/02: always do this.
	self.canvas['cursor'] = self.oldcursor

	if self.drag_id:
		canvas.tag_unbind(self.drag_id , "&lt;B1-Motion&gt;")
		canvas.tag_unbind(self.drag_id , "&lt;Any-ButtonRelease-1&gt;")
		self.drag_id = None
		
	self.dragging = false
</t>
<t tx="T1272">x,y = event.x,event.y
canvas_x = canvas.canvasx(x)
canvas_y = canvas.canvasy(y)

id = self.canvas.find_closest(canvas_x,canvas_y)
vdrag = self.findVnodeWithIconId(id)
childFlag = vdrag and vdrag.hasChildren() and vdrag.isExpanded()</t>
<t tx="T1273"># This precomputes numberOfVisibleNodes(), a significant optimization.
# We also indicate where findVnodeWithIconId() should start looking for tree id's.

def OnDrag(self,v,event):
	
	c = self.commands
	assert(v == self.drag_v)

	if not event:
		return

	if not self.dragging:
		# 11/25/02: Only do this once: greatly speeds drags.
		self.savedNumberOfVisibleNodes = self.numberOfVisibleNodes()
		self.dragging = true
		self.controlDrag = c.frame.controlKeyIsDown
		if self.controlDrag:
			es("dragged node will be cloned")
		else:
			es("dragged node will be moved")
	self.OnContinueDrag(v,event)</t>
<t tx="T1274">def OnContinueDrag(self,v,event):
	
	# trace(`v`)
	assert(v == self.drag_v)
	
	c = self.commands 
	canvas = self.canvas
	frame = self.commands.frame
	
	if event:
		x,y = event.x,event.y
	else:
		x,y = frame.top.winfo_pointerx(),frame.top.winfo_pointery()
		if x == -1 or y == -1: return # Stop the scrolling if we go outside the entire window.

	canvas_x = canvas.canvasx(x)
	canvas_y = canvas.canvasy(y)
	
	id = self.canvas.find_closest(canvas_x,canvas_y)

	if 0: # Confusing: we should only do this if a modifier key is down.
		# Moreover, this would slow down dragging a lot.
		vdrag = self.findVnodeWithIconId(id)
		if vdrag and vdrag != v and expandFlag:
			&lt;&lt; expand vdrag and redraw &gt;&gt;

	# OnEndDrag() halts the scrolling by clearing self.drag_id when the mouse button goes up.
	if self.drag_id: # This gets cleared by OnEndDrag()
		&lt;&lt; scroll the canvas as needed &gt;&gt;</t>
<t tx="T1275"># redrawing will change id's.
if self.drag_id:
	canvas.tag_unbind(self.drag_id , "&lt;B1-Motion&gt;")
	canvas.tag_unbind(self.drag_id , "&lt;Any-ButtonRelease-1&gt;")
	
vdrag.expand()
c.dragToNthChildOf(v,vdrag,0)
self.redraw_now()
self.idle_scrollTo(vdrag)

if 0: # This doesn't work, because we haven't had a mouse down event in the new node.
	# Pretend the expanded node is what we are dragging!
	self.drag_id = vdrag.icon_id
	# es("OnContinueDrag expanding:" + `vdrag` + " " + `self.drag_id`)
	if self.drag_id:
		canvas.tag_bind(self.drag_id, "&lt;B1-Motion&gt;", v.OnDrag)
		canvas.tag_bind(self.drag_id, "&lt;Any-ButtonRelease-1&gt;", v.OnEndDrag)
else:
	self.canvas['cursor'] = self.oldcursor</t>
<t tx="T1276"># Scroll the screen up or down one line if the cursor (y) is outside the canvas.
h = canvas.winfo_height()
if y &lt; 0 or y &gt; h:
	lo, hi = frame.treeBar.get()
	n = self.savedNumberOfVisibleNodes
	line_frac = 1.0 / float(n)
	frac = choose(y &lt; 0, lo - line_frac, lo + line_frac)
	frac = min(frac,1.0)
	frac = max(frac,0.0)
	# es("lo,hi,frac:" + `lo` + " " + `hi` + " " + `frac`)
	canvas.yview("moveto", frac)
	
	# Queue up another event to keep scrolling while the cursor is outside the canvas.
	lo, hi = frame.treeBar.get()
	if (y &lt; 0 and lo &gt; 0.1) or (y &gt; h and hi &lt; 0.9):
		canvas.after_idle(self.OnContinueDrag,v,None) # Don't propagate the event.</t>
<t tx="T1277">def makeVisible(self,v):

	pass # This is now done automatically by the tree class.</t>
<t tx="T1278"># Returns the last visible node of the screen.

def lastVisible (self):

	v = self.rootVnode
	while v:
		last = v
		if v.firstChild():
			if v.isExpanded():
				v = v.firstChild()
			else:
				v = v.nodeAfterTree()
		else:
			v = v.threadNext()
	return last</t>
<t tx="T1279">@ We can't just return icony because the tree hasn't been redrawn yet.  For the same reason we can't rely on any TK canvas methods here.
@c

def yoffset(self, v1):

	# if not v1.isVisible(): print "yoffset not visible:", `v1`
	root = self.rootVnode
	h, flag = self.yoffsetTree(root,v1)
	# flag can be false during initialization.
	# if not flag: print "yoffset fails:", h, `v1`
	return h

# Returns the visible height of the tree and all sibling trees, stopping at v1

def yoffsetTree(self,v,v1):

	h = 0
	while v:
		# print "yoffsetTree:", `v`
		if v == v1:
			return h, true
		h += self.line_height
		child = v.firstChild()
		if v.isExpanded() and child:
			h2, flag = self.yoffsetTree(child,v1)
			h += h2
			if flag: return h, true
		v = v.next()
	return h, false</t>
<t tx="T1280">def expandAllAncestors (self,v):

	redraw_flag = false
	p = v.parent()
	while p:
		if not p.isExpanded():
			p.expand()
			redraw_flag = true
		p = p.parent()
	return redraw_flag</t>
<t tx="T1281">@ This scrolls the canvas so that v is in view.  This is done at idle time after a redraw so that treeBar.get() will return proper values.  Earlier versions of this routine were called _before_ a redraw so that the calls to yoffset() were required.  We could use v.icony instead, and that might be better.

Another approach would be to add a "draw" flat to the drawing routines so that they just compute a height if the draw flag is false.  However, that would complicate the drawing logic quite a bit.
@c

def idle_scrollTo(self,v=None):

	if v == None:
		v = self.currentVnode
	last = self.lastVisible()
	h1 = self.yoffset(v)
	h2 = self.yoffset(last)
	# Compute the fraction to scroll, minus a smidge so the first line will be entirely visible.
	if h2 &gt; 0.1:
		frac = float(h1)/float(h2)
	else:
		frac = 0.0 # probably any value would work here.
	frac = min(frac,1.0)
	frac = max(frac,0.0)
	
	# Do nothing if the line is already in view
	frame = self.commands.frame
	lo, hi = frame.treeBar.get()
	if frac &lt; lo or frac &gt; hi:
		# print "h1, h2, frac, hi, lo:", h1, h2, frac, hi, lo
		self.canvas.yview("moveto", frac)</t>
<t tx="T1282">@ignore
@nocolor

Just putting a call to update() in leoFileCommands.getGlobals() does 90% of what we want.  Moving the calls to

	frame.top.deiconify()
	frame.top.lift()
	
from OpenWithFileName to getGlobals gets us to 99% of perfection.  There is a tiny flash when the frame created in leoFrame.__init__ is drawn then withdrawn.

The last 1% is accomplished by withdrawing the newly-created frame in frame.__init__.  With this last change there is no perceptable flash when a window is opened.  Of course, all callers of frame.__init__ must now call deiconify as needed.

Trying not to create a frame at all until its size is known would be much, much harder, because the frame and commands classes initialize each other.

@color</t>
<t tx="T1283">def OnNew (self,event=None):

	config = app().config
	frame = LeoFrame() # Create another Leo window.
	top = frame.top
	
	# Set the size of the new window.
	h = config.getIntWindowPref("initial_window_height")
	w = config.getIntWindowPref("initial_window_width")
	x = config.getIntWindowPref("initial_window_left")
	y = config.getIntWindowPref("initial_window_top")
	# print h,w,x,y
	if h == None or h &lt; 5: h = 5
	if w == None or w &lt; 5: w = 10
	y = max(y,0) ; x = max(x,0)
	geom = "%dx%d%+d%+d" % (w,h,x,y)
	top.geometry(geom)
	top.deiconify()
	top.lift()
	frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
	c = frame.commands # Use the commander of the _new_ frame.
	c.beginUpdate()
	if 1: # within update
		t = leoNodes.tnode()
		v = leoNodes.vnode(c,t)
		v.initHeadString("NewHeadline")
		v.moveToRoot()
		c.editVnode(v)
	c.endUpdate()
	
	frame.body.focus_set()
</t>
<t tx="T1284">def __init__(self,frame):

	# trace("__init__", "c.__init__")
	self.frame = frame
	self.initIvars(frame)

	# initialize the sub-commanders
	self.fileCommands = leoFileCommands.fileCommands(self)
	self.atFileCommands = leoAtFile.atFile(self)
	self.importCommands = leoImport.leoImportCommands(self)
	self.tangleCommands = leoTangle.tangleCommands(self)
	self.undoer = leoUndo.undoer(self)

def initIvars(self, frame):
	&lt;&lt; initialize ivars &gt;&gt;</t>
<t tx="T1285"># per-document info...
self.hookFunction = None
self.openDirectory = None # 7/2/02

self.expansionLevel = 0  # The expansion level of this outline.
self.changed = false # true if any data has been changed since the last save.
self.loading = false # true if we are loading a file: disables c.setChanged()

# copies of frame info
self.body = frame.body
self.log = frame.log
self.tree = frame.tree
self.canvas = frame.canvas

# For tangle/untangle
self.tangle_errrors = 0

# Global options
self.page_width = 132
self.tab_width = 4
self.tangle_batch_flag = false
self.untangle_batch_flag = false
# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = false
self.output_doc_flag = false
# Default Target Language
self.target_language = "python" # 8/11/02: Required if leoConfig.txt does not exist.

self.setIvarsFromFind()</t>
<t tx="T1286">def leoOpen(fileName=None,*args):
	
	if fileName == None:
		run()
		return

	# Create a hidden main window: this window never becomes visible!
	root = Tkinter.Tk()
	&lt;&lt; set the icon image &gt;&gt;
	root.title("Leo Main Window")
	root.withdraw()
	# Initialize application globals
	app = leoApp.LeoApp(root)
	setApp(app)
	if not app.finishCreate(): # do this after gApp exists.
		root.destroy()
		return
	handleLeoHook("start1")
	# Create the first Leo window
	frame1 = leoFrame.LeoFrame()
	frame1.top.withdraw()
	frame1.top.update()
	# Now open the second Leo window
	fileName = os.path.join(os.getcwd(), fileName)
	fileName = os.path.normpath(fileName)
	if os.path.exists(fileName):
		ok, frame = frame1.OpenWithFileName(fileName)
	else: ok = 0
	if ok:
		app.windowList.remove(frame1)
		frame1.destroy() # force the window to go away now.
		app.log = frame # Sets the log stream for es()
	else:
		frame1.top.deiconify()
		app.log = frame1
		es("File not found: " + fileName)
		# 10/6/02: Set the file's name if it doesn't exist.
		fileName = ensure_extension(fileName, ".leo")
		frame1.mFileName = fileName
		frame1.title = fileName
		frame1.top.title(fileName)
	init_sherlock(args)
	handleLeoHook("start2",fileName=fileName)
	root.mainloop()</t>
<t tx="T1287">if 0: # not yet
	fullname = r"c:\prog\LeoPy\Icons\box05.GIF"
	image = Tkinter.PhotoImage(file=fullname)
	trace(`image`)
	image = Tkinter.BitmapImage(image)
	trace(`image`)
	image = Tkinter.BitmapImage("stop")
	trace(`image`)
	root.iconbitmap(image)</t>
<t tx="T1288">def run(*args):

	# Create a hidden main window: this window never becomes visible!
	root = Tkinter.Tk()
	&lt;&lt; set the icon image &gt;&gt;
	root.title("Leo Main Window")
	root.withdraw()
	# Initialize application globals
	app = leoApp.LeoApp(root)
	setApp(app)
	if not app.finishCreate(): # do this after gApp exists.
		root.destroy()
		return
	handleLeoHook("start1")
	# Create the first Leo window
	frame = leoFrame.LeoFrame()
	frame.top.deiconify() # 7/19/02
	frame.commands.redraw() # 9/1/02
	frame.startupWindow = true
	init_sherlock(args)
	handleLeoHook("start2")
	root.mainloop()</t>
<t tx="T1289">def getGlobals (self):

	if self.getOpenTag("&lt;globals"):
		return

	self.getTag("body_outline_ratio=\"")
	self.ratio = self.getDouble() ; self.getDquote() ; self.getTag("&gt;")

	self.getTag("&lt;global_window_position")
	y,x,h,w = self.getPosition() ; self.getTag("/&gt;")
	# print ("y,x,h,w:" + `y` + "," + `x` + "," + `h` + "," + `w`)
	
	# Bug fix: 7/15/02: use max, not min!!!
	y = max(y,0) ; x = max(x,0)
	geom = "%dx%d%+d%+d" % (w,h,x,y)
	self.frame.top.geometry(geom)
	# 7/15/02: Redraw the window before writing into it.
	self.frame.top.deiconify()
	self.frame.top.lift()
	self.frame.top.update()

	self.getTag("&lt;global_log_window_position")
	self.getPosition() ;
	self.getTag("/&gt;") # no longer used.

	self.getTag("&lt;/globals&gt;")</t>
<t tx="T1290"># End editing for self.editText

def endEditLabel (self):

	v = self.editVnode
	if v and v.edit_text:
		self.setUnselectedLabelState(v)
		self.editVnode = None
	if v: # Bug fix 10/9/02: also redraw ancestor headlines.
		self.redraw_now() # force a redraw of joined and ancestor headlines.
	self.commands.body.focus_force() # 10/14/02
		
def endEditLabelCommand (self):

	v = self.editVnode
	if v and v.edit_text:
		self.select(v)
	if v: # Bug fix 10/9/02: also redraw ancestor headlines.
		self.redraw_now() # force a redraw of joined headlines.
	self.commands.body.focus_force() # 10/14/02</t>
<t tx="T1291">@ v.setDirty now ensures that all cloned nodes are marked dirty and that all ancestor @file nodes are marked dirty.  It is much safer to do it this way.

v.setDirtyDeleted is used only when a node is deleted.
@c

def setDirty (self):

	v = self ; c = v.commands
	# trace(`v`)
	changed = false
	c.beginUpdate()
	if not v.t.isDirty():
		v.t.setDirty()
		changed = true
	# This must _always_ be called, even if v is already dirty.
	if v.setAncestorAtFileNodeDirty():
		changed = true
	v2 = v.getJoinList()
	while v2 and v2 != v: 
		if not v2.t.isDirty():
			v2.t.setDirty()
			changed = true
		# Again, must always be called.
		if v2.setAncestorAtFileNodeDirty():
			changed = true
		v2 = v2.getJoinList()
	c.endUpdate(changed)
	return changed
	
def setDirtyDeleted (self):

	v = self ; c = v.commands
	# trace(`v`)
	changed = false
	c.beginUpdate()
	if not v.t.isDirty():
		v.t.setDirty()
		changed = true
	# This must _always_ be called, even if v is already dirty.
	if v.setAncestorsOfClonedNodesInTreeDirty():
		changed = true
	v2 = v.getJoinList()
	while v2 and v2 != v: 
		if not v2.t.isDirty():
			v2.t.setDirty()
			changed = true
		# Again, must always be called.
		if v2.setAncestorsOfClonedNodesInTreeDirty():
			changed = true
		v2 = v2.getJoinList()
	c.endUpdate(changed)
	return changed

def initDirtyBit (self):
	self.t.setDirty()</t>
<t tx="T1292">def setChanged (self,changedFlag):

	c = self
	if not c.frame: return
	# Clear all dirty bits _before_ setting the caption.
	# 9/15/01 Clear all dirty bits except orphaned @file nodes
	if not changedFlag:
		v = c.rootVnode()
		while v:
			if v.isDirty() and not (v.isAtFileNode() or v.isAtRawFileNode()):
				v.clearDirtyJoined()
			v = v.threadNext()
	# Update all derived changed markers.
	c.changed = changedFlag
	s = c.frame.top.title()
	if len(s) &gt; 2 and not c.loading: # don't update while loading.
		if changedFlag:
			if s [0] != '*': c.frame.top.title("* " + s)
		else:
			if s[0:2]=="* ": c.frame.top.title(s[2:])</t>
<t tx="T1293">@ This is called from the key-event handler, so we must not force a redraw of the screen here. We avoid redraw in most cases by passing redraw_flag to c.endUpdate().

This is called from v.setDirty, so we avoid further calls to v.setDirty here.  The caller, that is, v.setDirty itself, handles all clones.

@c
def setAncestorAtFileNodeDirty(self):

	# Look up the tree for an ancestor @file node.
	v = self ; c = v.commands
	redraw_flag = false
	c.beginUpdate()
	while v:
		if not v.isDirty() and (
			v.isAtFileNode() or v.isAtRawFileNode() or v.isAtNoSentinelsFileNode()):
			redraw_flag = true
			v.t.setDirty() # Do not call v.setDirty here!
		v = v.parent()
	c.endUpdate(redraw_flag) # A crucial optimization!
	return redraw_flag # Allow caller to do the same optimization.</t>
<t tx="T1294">@ This is called from the key-event handler, so we must not force a redraw of the screen here. We avoid redraw in most cases by passing redraw_flag to the caller.

This marks v dirty and all cloned nodes in v's tree.
@c
def setAncestorsOfClonedNodesInTreeDirty(self):

	# Look up the tree for an ancestor @file node.
	v = self ; redraw_flag = false
	
	if v == None:
		return redraw_flag
		
	flag = v.setAncestorAtFileNodeDirty()
	if flag: redraw_flag = true
		
	next = v.nodeAfterTree()
	v = v.threadNext()
	while v and v != next:
		if v.isCloned() and not v.isDirty():
			flag = v.setAncestorAtFileNodeDirty()
			if flag: redraw_flag = true
			v2 = v.getJoinList()
			while v2 and v2 != v:
				flag = v2.setAncestorAtFileNodeDirty()
				if flag: redraw_flag = true
				v2 = v2.getJoinList()
		v = v.threadNext()

	return redraw_flag</t>
<t tx="T1295">@ To do: Enable @file commands if the tree contains any @file nodes.</t>
<t tx="T1296">def OnHeadlineClick(self,event=None):

	self.commands.tree.OnActivate(self)
	
def OnHeadlinePopup(self,event=None):

	self.commands.tree.OnActivate(self)
	self.commands.tree.OnPopup(self,event)
</t>
<t tx="T1297"># 20-SEP-2002 DTHEIN:
# On Linux we must do something special to make the popup menu
# "unpost" if the mouse is clicked elsewhere.  So we have to 
# catch the &lt;FocusOut&gt; event and explicitly unpost.  In order
# to process the &lt;FocusOut&gt; event, we need to be able to find
# the reference to the popup window again, so this needs to be
# an attribute of the tree object; hence, "self.popupMenu".
#
# Aside: though Tk tries to be muli-platform, the interaction with
# different window managers does cause small differences that will
# need to be compensated by system specific application code. :-(

def OnPopup (self,v,event):
	
	# print v,event
	if event == None: return
	
	c = self.commands ; frame = c.frame
	# 20-SEP-2002 DTHEIN: If we are going to recreate it, we'd
	#                     better destroy it.
	if self.popupMenu:
		self.popupMenu.destroy()
		self.popupMenu = None
	self.popupMenu = menu = Tkinter.Menu(app().root, tearoff=0)
	&lt;&lt; create the popup menu &gt;&gt;
	if sys.platform == "linux2": # 20-SEP-2002 DTHEIN: not needed for Windows
		menu.bind("&lt;FocusOut&gt;",self.OnPopupFocusLost)
	menu.post(event.x_root, event.y_root)
	# 20-SEP-2002 DTHEIN: make certain we have focus so we know when we lose it.
	#                     I think this is OK for all OSes.
	menu.focus_set() 
	return "break"

# 20-SEP-2002 DTHEIN: This event handler is only needed for Linux

def OnPopupFocusLost(self,event=None):
	self.popupMenu.unpost()</t>
<t tx="T1298">@ignore</t>
<t tx="T1299"># All params have defaults, so t = tnode() is valid.

def __init__ (self, index = 0, bodyString = None):

	self.bodyString = choose(bodyString, bodyString, "")
	self.joinHead = None # The head of the join list while a file is being read.
	self.statusBits = 0 # status bits
	self.fileIndex = index # The immutable file index for self tnode.
	self.selectionStart = 0 # The start of the selected body text.
	self.selectionLength = 0 # The length of the selected body text.
	self.cloneIndex = 0 # Zero for @file nodes
	self.insertSpot = None # Location of previous insert point.
	self.scrollBarSpot = None # Previous value of scrollbar position.</t>
<t tx="T1300"># This is called inside commands to select a new vnode.

def selectVnode(self,v):

	# All updating and "synching" of nodes are now done in the event handlers!
	c = self
	c.tree.endEditLabel()
	c.tree.select(v)
	c.body.focus_force()
	self.editing = false</t>
<t tx="T1301">def OnActivate (self,v):

	c=self.commands
	# trace(`v`)

	if v == self.currentVnode:
		# w = self.commands.frame.getFocus()
		if self.active:
			self.editLabel(v)
		else:
			self.undimEditLabel()
			self.canvas.focus_set()
	else:
		self.select(v)
		if v.t.insertSpot != None: # 9/1/02
			c.body.mark_set("insert",v.t.insertSpot)
			c.body.see(v.t.insertSpot)
		else:
			c.body.mark_set("insert","1.0")
		c.body.focus_force()

	self.active = true</t>
<t tx="T1302">def loadBodyPaneFromTnode(self, body):

	s = self.bodyString
	if s and len(s) &gt; 0:
		body.delete(1,"end")
		body.insert(1,s)
	else:
		body.delete(1,"end")</t>
<t tx="T1303"></t>
<t tx="T1304">def saveBodyPaneToTnode (self, body):

	self.bodyString = body.GetValue()
	# Set the selection.
	i, j = body.GetSelection()
	if i &gt; j:
		temp = i
		i = j
		j = temp
	self.selectionStart = i
	self.selectionLength = j - i</t>
<t tx="T1305">def setSelection (self, start, length):

	self.selectionStart = start
	self.selectionLength = length</t>
<t tx="T1306"></t>
<t tx="T1307">def abortEditLabelCommand (self):
	
	v = self.currentVnode
	
	if self.revertHeadline and v.edit_text and v == self.editVnode:
		
		# trace(`self.revertHeadline`)
		v.edit_text.delete("1.0","end")
		v.edit_text.insert("end",self.revertHeadline)
		self.idle_head_key(v) # Must be done immediately.
		self.revertHeadline = None
		self.select(v)
		if v and v.joinList:
			self.redraw_now() # force a redraw of joined headlines.</t>
<t tx="T1308"># Convenience methods so the caller doesn't have to know the present edit node.

def dimEditLabel (self):

	v = self.currentVnode
	self.setDisabledLabelState(v)

def undimEditLabel (self):

	v = self.currentVnode
	self.setSelectedLabelState(v)</t>
<t tx="T1309"># Start editing v.edit_text

def editLabel (self, v):

	# End any previous editing
	if self.editVnode and v != self.editVnode:
		self.endEditLabel()
		self.revertHeadline = None
		
	# Start editing
	if v and v.edit_text:
		# trace(`v`)
		self.setNormalLabelState(v)
		v.edit_text.tag_remove("sel","1.0","end")
		v.edit_text.tag_add("sel","1.0","end")
		v.edit_text.focus_force()
		self.editVnode = v
		self.revertHeadline = v.headString() # 9/24/02
	else:
		self.editVnode = None</t>
<t tx="T1310"># Similar to code in scanAllDirectives.

def scanForTabWidth (self, v):
	
	c = self.commands ; w = c.tab_width

	while v:
		s = v.t.bodyString
		dict = get_directives_dict(s)
		&lt;&lt; set w and break on @tabwidth &gt;&gt;
		v = v.parent()

	c.frame.setTabWidth(w)</t>
<t tx="T1311">if dict.has_key("tabwidth"):

	k = dict["tabwidth"]
	i = k + len("@tabwidth")
	i, val = skip_long(s, i)
	if val != None and val != 0:
		w = val
		break
	else:
		if 0: # silently ignore this.
			i = skip_to_end_of_line(s,i)
			es("Ignoring " + s[k:i])</t>
<t tx="T1312">This works in the log and body panes, and not in the outline pane.

proc mscroll {bindtag} {
      bind $bindtag &lt;Button-5&gt; [list %W yview scroll 5 units]
      bind $bindtag &lt;Button-4&gt; [list %W yview scroll -5 units]
      bind $bindtag &lt;Shift-Button-5&gt; [list %W yview scroll 1 units]
      bind $bindtag &lt;Shift-Button-4&gt; [list %W yview scroll -1 units]
      bind $bindtag &lt;Control-Button-5&gt; [list %W yview scroll 1 pages]
      bind $bindtag &lt;Control-Button-4&gt; [list %W yview scroll -1 pages]

from Tkinter import *

def roll(event):
    print event.delta

frame = Frame(width=200, height=200)
frame.pack()
frame.focus_set() # wheel events goes to focussed window
frame.bind("&lt;MouseWheel&gt;", roll)
</t>
<t tx="T1313"></t>
<t tx="T1314">def OnActivateBody (self,event=None):

	c=self.commands ; v = c.currentVnode()
	
	app().log = self
	self.tree.OnDeactivate()
	# trace(`app().log`)

def OnBodyDoubleClick (self,event=None):

	if event: # 8/4/02: prevent wandering insertion point.
		index = "@%d,%d" % (event.x, event.y) # Find where we clicked
	body = self.body
	start = body.index(index + " wordstart")
	end = body.index(index + " wordend")
	setTextSelection(self.body,start,end)
	return "break" # Inhibit all further event processing.</t>
<t tx="T1315">def OnActivateLeoEvent(self,event=None):

	app().log = self
	# trace(`app().log`)

def OnDeactivateLeoEvent(self,event=None):
	
	app().log = None
	# trace(`app().log`)</t>
<t tx="T1316">def OnActivateLog (self,event=None):

	app().log = self
	self.tree.OnDeactivate()
	# trace(`app().log`)</t>
<t tx="T1317">def OnActivateTree (self,event=None):

	app().log = self
	self.tree.undimEditLabel()
	self.tree.canvas.focus_set()
	# trace(`app().log`)</t>
<t tx="T1318">def OnControlKeyDown (self,event=None):
	
	self.controlKeyIsDown = true
	
def OnControlKeyUp (self,event=None):

	self.controlKeyIsDown = false
</t>
<t tx="T1319"># Contributed by Tomaz Ficko.  This works on some systems.
# On XP it causes a crash in tcl83.dll.  Clearly a Tk bug.

def OnMouseWheel(self, event=None):

	if event.delta &lt; 1:
		self.canvas.yview(Tkinter.SCROLL, 1, Tkinter.UNITS)
	else:
		self.canvas.yview(Tkinter.SCROLL, -1, Tkinter.UNITS)</t>
<t tx="T1320"># Handle the "visibility" event and attempt to attach the Leo icon.
# This code must be executed whenever the window is redrawn.

def OnVisibility (self,event):

	if self.icon and event.widget is self.top:

		# print "OnVisibility"
		self.icon.attach(self.top)</t>
<t tx="T1321">def open(self,file,fileName):

	c=self.commands
	# Read the entire file into the buffer
	# t = getTime()
	self.fileBuffer = file.read() ; file.close()
	self.fileIndex = 0
	&lt;&lt; Set the default directory &gt;&gt;
	# esDiffTime("open:read all", t)

	c.beginUpdate()
	if 1: # inside update...
		c.loading = true # disable c.changed
		ok, ratio = self.getLeoFile(self.frame,fileName,true) # readAtFileNodes
		c.loading = false # reenable c.changed
		c.setChanged(false)
		if 0: # This can't be done directly.
			# This should be done after the pane size has been set.
			top = c.tree.topVnode
			if top: c.tree.scrollTo(top)
	c.endUpdate()
	# delete the file buffer
	self.fileBuffer = ""
	# esDiffTime("open: exit",t)
	return ok</t>
<t tx="T1322">@ The most natural default directory is the directory containing the .leo file that we are about to open.  If the user has specified the "Default Directory" preference that will over-ride what we are about to set.
@c

dir = os.path.dirname(fileName) 
if len(dir) &gt; 0:
	c.openDirectory = dir</t>
<t tx="T1323">def initialRatios (self):

	config = app().config
	s = config.getWindowPref("initial_splitter_orientation")
	verticalFlag = s == None or (s != "h" and s != "horizontal")

	if verticalFlag:
		r = config.getFloatWindowPref("initial_vertical_ratio")
		if r == None or r &lt; 0.0 or r &gt; 1.0: r = 0.5
		r2 = config.getFloatWindowPref("initial_vertical_secondary_ratio")
		if r2 == None or r2 &lt; 0.0 or r2 &gt; 1.0: r2 = 0.8
	else:
		r = config.getFloatWindowPref("initial_horizontal_ratio")
		if r == None or r &lt; 0.0 or r &gt; 1.0: r = 0.3
		r2 = config.getFloatWindowPref("initial_horizontal_secondary_ratio")
		if r2 == None or r2 &lt; 0.0 or r2 &gt; 1.0: r2 = 0.8

	# print (`r`,`r2`)
	return verticalFlag,r,r2</t>
<t tx="T1324"># The key invariant: self.splitVerticalFlag tells the alignment of the main splitter.

def OnToggleSplitDirection(self,event=None):
	# Abbreviations.
	frame = self
	bar1 = self.bar1 ; bar2 = self.bar2
	split1Pane1,split1Pane2 = self.split1Pane1,self.split1Pane2
	split2Pane1,split2Pane2 = self.split2Pane1,self.split2Pane2
	# Switch directions.
	verticalFlag = self.splitVerticalFlag = not self.splitVerticalFlag
	orientation = choose(verticalFlag,"vertical","horizontal")
	app().config.setWindowPref("initial_splitter_orientation",orientation)
	# Reconfigure the bars.
	bar1.place_forget()
	bar2.place_forget()
	self.configureBar(bar1,verticalFlag)
	self.configureBar(bar2,not verticalFlag)
	# Make the initial placements again.
	self.placeSplitter(bar1,split1Pane1,split1Pane2,verticalFlag)
	self.placeSplitter(bar2,split2Pane1,split2Pane2,not verticalFlag)
	# Adjust the log and body panes to give more room around the bars.
	self.reconfigurePanes()
	# Redraw with an appropriate ratio.
	vflag,ratio,secondary_ratio = frame.initialRatios()
	self.resizePanesToRatio(ratio,secondary_ratio)</t>
<t tx="T1325">def resizePanesToRatio(self,ratio,secondary_ratio):

	self.divideLeoSplitter(self.splitVerticalFlag, ratio)
	self.divideLeoSplitter(not self.splitVerticalFlag, secondary_ratio)
	# trace(`ratio`)
</t>
<t tx="T1326">@  Warning: it _is_ sometimes useful to have the update_count logic in place even though all drawing is done at idle time.  Indeed, we don't want to schedule a redraw if we will call endupdate(false).

Howevever, we could replace beginUpdate/endUpdate() with c.redraw() and replace endUpdate(flag) with:
	if flag: c.redraw()</t>
<t tx="T1327">def beginUpdate (self):

	self.updateCount += 1</t>
<t tx="T1328">def endUpdate (self, flag=true):

	assert(self.updateCount &gt; 0)
	self.updateCount -= 1
	if flag and self.updateCount == 0:
		self.redraw()</t>
<t tx="T1329">@nocolor

tangle uses self.tab_width.
Everything else should use c.tab_width.

@color</t>
<t tx="T1330">if dict.has_key("pagewidth") and not old.has_key("pagewidth"):

	k = dict["pagewidth"]
	j = i = k + len("@pagewidth")
	i, val = skip_long(s,i)
	if val != None and val &gt; 0:
		self.page_width = val
	else:
		i = skip_to_end_of_line(s,i)
		self.error("Ignoring " + s[k:i])</t>
<t tx="T1331">self.page_width = self.commands.page_width
self.tab_width  = self.commands.tab_width

self.default_directory = None # 8/2: will be set later.

delim1, delim2, delim3 = set_delims_from_language(c.target_language)
self.language = c.target_language</t>
<t tx="T1332"># Initializes prefs ivars and widgets from c's ivars.

def init(self,c):

	self.commands = c
	#trace(`c.tab_width`)

	for var in ivars:
		exec("self.%s = c.%s" % (var,var))

	&lt;&lt; remember values for revert &gt;&gt;
	&lt;&lt; set widgets &gt;&gt;
	# print "init" ; print self.print_ivars()</t>
<t tx="T1333"># Global options
self.revert_tangle_batch_flag = c.tangle_batch_flag
self.revert_untangle_batch_flag = c.untangle_batch_flag
self.revert_page_width = c.page_width
self.revert_tab_width = c.tab_width
# Default Tangle Options
self.revert_tangle_directory = c.tangle_directory
self.revert_output_doc_flag = c.output_doc_flag
self.revert_use_header_flag = c.use_header_flag
# Default Target Language
if c.target_language == None: # 7/29/02
	c.target_language = "python"
self.revert_target_language = c.target_language</t>
<t tx="T1334"># Global options
self.tangle_batch_var.set(c.tangle_batch_flag)
self.untangle_batch_var.set(c.untangle_batch_flag)
self.pageWidthText.delete("1.0","end")
self.pageWidthText.insert("end",`c.page_width`)
self.tabWidthText.delete("1.0","end")
self.tabWidthText.insert("end",`c.tab_width`)
# Default Tangle Options
self.tangleDirectoryText.delete("1.0","end")
self.tangleDirectoryText.insert("end",c.tangle_directory)
self.output_doc_var.set(c.output_doc_flag)
self.use_header_var.set(c.use_header_flag)
# Default Target Language
if c.target_language == None:
	c.target_language = "python" # 7/29/02
self.lang_var.set(c.target_language)</t>
<t tx="T1335"># These event handlers get executed when the user types in the prefs panel.

def set_ivars (self,c):

	&lt;&lt; update ivars &gt;&gt;
	for var in ivars:
		exec("c.%s = self.%s" % (var,var))
	c.frame.setTabWidth(c.tab_width)
	# print "set_ivars" ; print self.print_ivars()

def idle_set_ivars (self, event=None):
	
	c = top() ; v = c.currentVnode()
	self.top.after_idle(self.set_ivars,c)
	c.tree.recolor(v)
	# print "idle_set_ivars" ; print self.print_ivars()
	
def print_ivars (self):
	
	for var in ivars:
		exec("print self.%s, '%s'" % (var,var))</t>
<t tx="T1336"># Global options
w = self.pageWidthText.get("1.0","end")
w = string.strip(w)
try:
	self.page_width = int(w)
except:
	self.page_width = default_page_width
	
w = self.tabWidthText.get("1.0","end")
w = string.strip(w)
try:
	self.tab_width = int(w)
except:
	self.tab_width = default_tab_width

self.tangle_batch_flag = self.tangle_batch_var.get()
self.untangle_batch_flag = self.untangle_batch_var.get()

# Default Tangle options
dir = self.tangleDirectoryText.get("1.0","end")
self.tangle_directory = string.strip(dir)

self.use_header_flag = self.use_header_var.get()
self.output_doc_flag = self.output_doc_var.get()

# Default Target Language
self.target_language = self.lang_var.get()</t>
<t tx="T1337">def setTabWidth (self, w):
	
	try: # 8/11/02: This can fail when called from scripts.
		# 9/20/22: Use the present font for computations.
		font = self.body.cget("font")
		font = font = tkFont.Font(font=font)
		tabw = font.measure(" " * abs(w)) # 7/2/02
		# print "frame.setTabWidth:" + `w` + "," + `tabw`
		self.body.configure(tabs=tabw)
	except:
		# es_exception()
		pass
</t>
<t tx="T1338">@nocolor</t>
<t tx="T1339"># Selects v: sets the focus to v and edits v.

def editVnode(self,v):

	c = self
	if v:
		c.selectVnode(v)
		c.tree.editLabel(v)</t>
<t tx="T1340">@ignore</t>
<t tx="T1341">if   (a==b
	  [or x ==y
	   
</t>
<t tx="T1342">@ignore</t>
<t tx="T1343">@ Enables the "idle" hook.
After enableIdleTimeHook is called, Leo will call the "idle" hook
approximately every idleTimeDelay milliseconds.
@c
def enableIdleTimeHook(idleTimeDelay=100):
	app().idleTimeHook = true
	app().idleTimeDelay = idleTimeDelay # Delay in msec.
	app().root.after_idle(idleTimeHookHandler)
	
# Disables the "idle" hook.
def disableIdleTimeHook():
	app().idleTimeHook = false
	
# An internal routine used to dispatch the "idle" hook.
def idleTimeHookHandler(*args):
	a = app()
	handleLeoHook("idle")
	# Requeue this routine after 100 msec.
	# Faster requeues overload the system.
	if a.idleTimeHook:
		a.root.after(a.idleTimeDelay,idleTimeHookHandler)</t>
<t tx="T1344">@ This global function calls a hook routine.  Hooks are identified by the tag param.
Returns the value returned by the hook routine, or None if the there is an exception.

We look for a hook routine in three places:
1. top().hookFunction
2. app().hookFunction
3. customizeLeo.customizeLeo()
We set app().hookError on all exceptions.  Scripts that reset app().hookError to try again.
@c

def handleLeoHook(tag,**keywords):

	a = app() ; c = top() # c may be None during startup.
	
	if not app().config.use_customizeLeo_dot_py:
		return None # not enabled.

	if a.hookError:
		return None
	elif c and c.hookFunction:
		try:
			title = c.frame.top.title()
			return c.hookFunction(tag)
		except:
			es("exception in hook function for " + title)
	elif a.hookFunction:
		try:
			return a.hookFunction(tag,keywords)
		except:
			es("exception in app().hookFunction")
	else:
		try:
			from customizeLeo import customizeLeo
			try:
				a.hookFunction = customizeLeo
				return customizeLeo(tag,keywords)
			except:
				a.hookFunction = None
				es("exception in customizeLeo")
		except exceptions.ImportError:
			# print "import customizeLeo failed"
			# Import failed.  This is not an error.
			a.hookError = true # Supress this function.
			a.idleTimeHook = false # Supress idle-time hook
			return None
		except:
			es("error error in customizeLeo")

	# Handle all exceptions except import failure.
	es_exception()
	a.hookError = true # Supress this function.
	a.idleTimeHook = false # Supress idle-time hook
	return None # No return value</t>
<t tx="T1345">def OnOpenRecentFile(self,name=None):
	
	c = self.commands
	&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;
	if not name:
		return

	fileName = name
	flag = handleLeoHook("recentfiles1",c=c,fileName=fileName,closeFlag=closeFlag)
	if flag == None:  # Anything other than None overrides.
		ok, frame = self.OpenWithFileName(fileName)
		if ok and closeFlag:
			app().windowList.remove(self)
			self.destroy() # force the window to go away now.
			app().log = frame # Sets the log stream for es()
		handleLeoHook("recentfiles2",c=c,fileName=fileName,closeFlag=closeFlag)</t>
<t tx="T1346">@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c
	
closeFlag = (
	self.startupWindow==true and # The window was open on startup
	c.changed==false and self.saved==false and # The window has never been changed
	app().numberOfWindows == 1) # Only one untitled window has ever been opened
</t>
<t tx="T1347">def OpenWithFileName(self, fileName):

	if not fileName or len(fileName) == 0:
		return false, None

	# Create a full normalized path name.
	# Display the file name with case intact.
	fileName = os.path.join(os.getcwd(), fileName)
	fileName = os.path.normpath(fileName)
	oldFileName = fileName 
	fileName = os.path.normcase(fileName)

	# If the file is already open just bring its window to the front.
	list = app().windowList
	for frame in list:
		fn = os.path.normcase(frame.mFileName)
		fn = os.path.normpath(fn)
		if fileName == fn:
			frame.top.deiconify()
			app().log = frame
			# es("This window already open")
			return true, frame
			
	fileName = oldFileName # Use the idiosyncratic file name.

	try:
		file = open(fileName,'r')
		if file:
			frame = LeoFrame(fileName)
			flag = handleLeoHook("open1",
				old_c=self,new_c=frame.commands,fileName=fileName)
			if flag == None:  # Anything other than None overrides.
				frame.commands.fileCommands.open(file,fileName) # closes file.
			frame.openDirectory=os.path.dirname(fileName)
			&lt;&lt; make fileName the most recent file of frame &gt;&gt;
			handleLeoHook("open2",
				old_c=self,new_c=frame.commands,fileName=fileName)
			return true, frame
		else:
			es("can not open" + fileName)
			return false, None
	except:
		es("exceptions opening" + fileName)
		es_exception()
		return false, None</t>
<t tx="T1348"># Update the recent files list in all windows.
normFileName = os.path.normcase(fileName)

for frame in app().windowList:
	# Remove all versions of the file name.
	for name in frame.recentFiles:
		name2 = os.path.normcase(name)
		name2 = os.path.normpath(name2)
		if normFileName == name2:
			frame.recentFiles.remove(name)
	frame.recentFiles.insert(0,fileName)
	# Recreate the Recent Files menu.
	frame.createRecentFilesMenuItems()
	
# Update the config file.
app().config.setRecentFiles(frame.recentFiles)
app().config.update()</t>
<t tx="T1349">@ignore</t>
<t tx="T1350">def __init__ (self, commands, t):

	assert(t and commands)
	&lt;&lt; initialize vnode data members &gt;&gt;
	if app().deleteOnClose:
		self.commands.tree.vnode_alloc_list.append(self)</t>
<t tx="T1351">self.commands = commands # The commander for this vnode.
self.joinList = None # vnodes on the same joinlist are updated together.
self.t = t # The tnode, i.e., the body text.
self.statusBits = 0 # status bits
self.iconVal = -1 # The icon index.  -1 forces an update of icon.
self.mHeadString = "" # The headline text.

# Structure links
self.mParent = self.mFirstChild = self.mNext = self.mBack = None

# Canvas items.  Set by tree.redraw
self.iconx, self.icony = 0,0 # Coords of icon so icon can be redrawn separately.
self.edit_text = None # Essential: used by many parts of tree code.

if 1:
	self.icon_id = None # 6/15/02: Now cleared in __del__

if 0: # These links are harmful: they prevent old tree items from being recycled properly.
	self.box_id = None
	self.edit_text_id = None # The editable text field for this vnode.</t>
<t tx="T1352"># Rewrites the entire config file from ivars.
# This is called when a .leo file is written and when the preferences panel changes.

def update (self):
	
	# Do nothing if the file does not exist, or if read_only.
	if self.read_only:
		# print "Read only config file"
		return
	if not os.path.exists(self.configFileName):
		# print "No config file"
		return
	
	config = ConfigParser.ConfigParser()
	self.config = config
	try:
		# 9/1/02: apparently Linux requires w+ and XP requires w.
		mode = choose(sys.platform=="win32","wb","wb+")
		cf = open(self.configFileName,mode)
		config.readfp(cf)
		&lt;&lt; write recent files section &gt;&gt;
		for section,dict in self.sectionInfo:
			if dict:
				self.update_section(config,section,dict)
		config.write(cf)
		cf.flush()
		cf.close()
	except:
		es("exception writing: " + self.configFileName)
		es_exception()
	self.config = None</t>
<t tx="T1353">section = self.recentFilesSection
files = self.recentFiles

if config.has_section(section):
	config.remove_section(section)
config.add_section(section)

if 0: # elegant, but may be a security hole.
	config.set(section,"recentFiles",files)
else: # easier to read in the config file.
	for i in xrange(len(files)):
		config.set(section, "file"+`i`, files[i])</t>
<t tx="T1354">def flattenOutline (self,fileName):

	c = self.commands ; v = c.currentVnode()
	nl = self.output_newline
	if not v: return
	after = v.nodeAfterTree()
	firstLevel = v.level()
	try:
		# 10/14/02: support for output_newline setting.
		mode = app().config.output_newline
		mode = choose(mode=="platform",'w','wb')
		file = open(fileName,mode)
		while v and v != after:
			head = v.moreHead(firstLevel)
			file.write(head + nl)
			body = v.moreBody() # Inserts escapes.
			if len(body) &gt; 0:
				file.write(body + nl)
			v = v.threadNext()
		file.close()
	except:
		es("exception while flattening outline")
		es_exception()</t>
<t tx="T1355">def outlineToWeb (self,fileName,webType):

	c = self.commands ; v = c.currentVnode()
	nl = self.output_newline
	if v == None: return
	self.webType = webType
	after = v.nodeAfterTree()
	try: # This can fail if the file is open by another app.
		# 10/14/02: support for output_newline setting.
		mode = app().config.output_newline
		mode = choose(mode=="platform",'w','wb')
		file = open(fileName,mode)
		self.treeType = "@file"
		# Set self.treeType to @root if v or an ancestor is an @root node.
		while v:
			flag, junk = is_special(v.bodyString(),0,"@root")
			if flag:
				self.treeType = "@root" ; break
			else: v = v.parent()
		v = c.currentVnode()
		while v and v != after:
			s = self.convertVnodeToWeb(v)
			if len(s) &gt; 0:
				file.write(s)
				if s[-1] != '\n':
					file.write(nl)
			v = v.threadNext()
		file.close()
	except:
		es("exception in Outline To noweb command")
		es_exception()</t>
<t tx="T1356">try:
	# 10/14/02: support for output_newline setting.
	mode = app().config.output_newline
	mode = choose(mode=="platform",'w','wb')
	file = open(newFileName,mode)
	file.write(s)
	file.close()
	es("creating: " + newFileName)
except:
	es("exception creating: " + newFileName)
	es_exception()</t>
<t tx="T1357">try:
	# 10/14/02: support for output_newline setting.
	mode = app().config.output_newline
	mode = choose(mode=="platform",'w','wb')
	f = open(filename,mode)
	if not f: return
except:
	es("exception opening:" + filename)
	es_exception()
	return</t>
<t tx="T1358">@ This is the top level method of the second pass. It creates a separate C file for each @root directive in the outline. As will be seen later,the file is actually written only if the new version of the file is different from the old version,or if the file did not exist previously. If changed_only_flag FLAG is true only changed roots are actually written.
@c

def put_all_roots(self):

	c = self.commands ; outline_name = c.frame.mFileName

	for section in self.root_list:
	
		# trace(`section.name`)
		file_name = os.path.join(self.tangle_directory,section.name)
		file_name = os.path.normpath(file_name)
		temp_name = create_temp_name()
		if not temp_name:
			es("Can not create temp file")
			break
		# Set the output_file global.
		# Use "text" mode for platform-specific newlines.
		mode = app().config.output_newline
		mode = choose(mode=="platform",'w','wb')
		try:
			self.output_file = open(temp_name,mode)
			if not self.output_file:
				es("Can not create: " + temp_name)
				break
		except:
			es("Can not create: " + temp_name)
			break
		&lt;&lt;Get root specific attributes&gt;&gt;
		&lt;&lt;Put @first lines&gt;&gt;
		if self.use_header_flag and self.print_mode == "verbose":
			&lt;&lt; Write a banner at the start of the output file &gt;&gt;
		for part in section.parts:
			if part.is_root:
				self.tangle_indent = 0 # Initialize global.
				self.put_part_node(part,false) # output first lws
		self.onl() # Make sure the file ends with a cr/lf
		self.output_file.close()
		self.output_file = None
		if self.errors == 0:
			update_file_if_changed(file_name,temp_name)
		else:
			es("unchanged:  " + file_name)
			&lt;&lt; Erase the temporary file &gt;&gt;</t>
<t tx="T1359"># Stephen Schaefer, 9/2/02
# Retrieve the full complement of state for the root node
self.language = section.root_attributes.language
self.single_comment_string = section.root_attributes.single_comment_string
self.start_comment_string = section.root_attributes.start_comment_string
self.end_comment_string = section.root_attributes.end_comment_string
self.use_header_flag = section.root_attributes.use_header_flag
self.print_mode = section.root_attributes.print_mode
self.path = section.root_attributes.path
self.page_width = section.root_attributes.page_width
self.tab_width = section.root_attributes.tab_width
# Stephen P. Schaefer, 9/13/2002
self.first_lines = section.root_attributes.first_lines</t>
<t tx="T1360"># Stephen P. Schaefer 9/13/2002
if self.first_lines:
	self.os(self.first_lines)</t>
<t tx="T1361">if self.single_comment_string:
	self.os(self.single_comment_string)
	self.os(" Created by Leo from: ")
	self.os(outline_name)
	self.onl() ; self.onl()
elif self.start_comment_string and self.end_comment_string:
	self.os(self.start_comment_string)
	self.os(" Created by Leo from: ")
	self.os(outline_name)
	self.oblank() ; self.os(self.end_comment_string)
	self.onl() ; self.onl()
</t>
<t tx="T1362">try: # Just delete the temp file.
	os.remove(temp_name)
except: pass
</t>
<t tx="T1363">@ignore</t>
<t tx="T1364">def __init__ (self):
	
	&lt;&lt; get the default font &gt;&gt;
	self.init()

def init (self):

	try:
		self.configDir = sys.leo_config_directory
	except:
		self.configDir = app().loadDir
	self.configFileName = os.path.join(self.configDir,"leoConfig.txt")
	self.configsExist = false # True when we successfully open leoConfig.txt.
	
	&lt;&lt; initialize constant ivars, lists &amp; dicts &gt;&gt;
	&lt;&lt; initialize ivars that may be set by config options &gt;&gt;

	self.open() # read and process the configuration file.</t>
<t tx="T1365"># Get the default font from a new text widget.
# This should only be done once.

t = Tkinter.Text()
fn = t.cget("font")
font = tkFont.Font(font=fn)
self.defaultFont = font
self.defaultFontFamily = font.cget("family")
</t>
<t tx="T1366"># 10/11/02: Defaults are specified only here.

self.config = None # The current instance of ConfigParser
self.at_root_bodies_start_in_doc_mode = true # For compatibility with previous versions.
self.output_initial_comment = "" # "" or None for compatibility with previous versions.
self.output_newline = "nl"
self.create_nonexistent_directories = false
self.read_only = true # Make sure we don't alter an illegal leoConfig.txt file!
self.relative_path_base_directory = "!"
self.remove_sentinels_extension = ".txt"
self.save_clears_undo_buffer = false
self.stylesheet = None
self.use_relative_node_indices = 1 # Not used.  Will disappear.
self.use_customizeLeo_dot_py = 0 # Should _never_ be 1 (!!)
self.write_clone_indices = 0 # Should be 0 for writes to CVS. Will disappear in 4.0.
self.xml_version_string = "UTF-8" # Upper case for compatibility with previous versions.
</t>
<t tx="T1367">@ Parses the xml version string, and sets the xml version string.

For example, given: &lt;?xml version="1.0" encoding="UTF-8"?&gt;
the version string is the string UTF-8 (without the quotes)
@c

def getXmlVersionTag (self):
	
	a = app() ; config = a.config

	self.getTag(a.prolog_prefix_string)
	version = self.getDqString()
	# config.version overrides the version in the .leo file.
	if not config.xml_version_string:
		config.xml_version_string = version
	self.getTag(a.prolog_postfix_string)
</t>
<t tx="T1368">def putProlog (self):

	a = app() ; c = self.commands ; config = a.config

	&lt;&lt; Put the &lt;?xml...?&gt; line &gt;&gt;
	&lt;&lt; Put the optional &lt;?xml-stylesheet...?&gt; line &gt;&gt;

	self.put("&lt;leo_file&gt;") ; self.put_nl()</t>
<t tx="T1369">version = config.xml_version_string
if not version or len(version) == 0:
	# This is used only for new files without leoConfig.txt.
	if 0: # "UTF-8"
		version = a.prolog_version_string1 # leo.py 2.x
	else: # "ISO-8859-1"
		version = a.prolog_version_string2 # leo.py 3.0

self.put(a.prolog_prefix_string) ; self.put_dquote()
self.put(version) ; self.put_dquote()
self.put(a.prolog_postfix_string) ; self.put_nl()</t>
<t tx="T1370">if config.stylesheet or c.frame.stylesheet:
	
	# The stylesheet in the .leo file takes precedence over the default stylesheet.
	if c.frame.stylesheet:
		s = c.frame.stylesheet
	else:
		s = config.stylesheet
		
	tag = "&lt;?xml-stylesheet "
	# print "writing:", tag + s + "?&gt;"
	self.put(tag) ; self.put(s) ; self.put("?&gt;") ; self.put_nl()
</t>
<t tx="T1371"># This method reads a Leo outline from string s in clipboard format.
def getLeoOutline (self,s):

	self.usingClipboard = true
	self.fileBuffer = s ; self.fileIndex = 0
	self.tnodesDict = {}
	try:
		self.getXmlVersionTag() # leo.py 3.0
		self.getXmlStylesheetTag() # 10/25/02
		self.getTag("&lt;leo_file&gt;")
		self.getClipboardHeader()
		self.getVnodes()
		self.getTnodes()
		self.getTag("&lt;/leo_file&gt;")
		v = self.finishPaste()
	except BadLeoFile:
		v = None
	# Clean up.
	self.fileBuffer = None ; self.fileIndex = 0
	self.tnodesDict = {}
	self.usingClipboard = false
	return v</t>
<t tx="T1372"># The caller should enclose this in begin/endUpdate.

def getLeoFile (self,frame,fileName,atFileNodesFlag):

	c=self.commands
	&lt;&lt; warn on read-only files &gt;&gt;
		
	self.mFileName = frame.mFileName
	self.tnodesDict = {} ; ok = true
	try:
		c.tree.initing = true # inhibit endEditLabel from marking the file changed.
		self.getXmlVersionTag() # leo.py 3.0
		self.getXmlStylesheetTag() # 10/25/02
		self.getTag("&lt;leo_file&gt;")
		self.getLeoHeader()
		self.getGlobals()
		self.getPrefs()
		self.getFindPanelSettings()
		c.frame.resizePanesToRatio(c.frame.ratio,c.frame.secondary_ratio) # Causes window to appear.
		es("reading: " + fileName)
		self.getVnodes()
		self.getTnodes()
		self.getCloneWindows()
		self.getTag("&lt;/leo_file&gt;")
		&lt;&lt; Create join lists of all vnodes &gt;&gt;
	except BadLeoFile, message: # All other exceptions are Leo bugs
		# es_exception()
		alert(self.mFileName + " is not a valid Leo file: " + `message`)
		ok = false
	# Leo2: read all @file nodes and reset orphan bits.
	if ok and atFileNodesFlag:
		at = c.atFileCommands
		at.readAll(c.rootVnode(), false) # partialFlag
	if not c.tree.currentVnode:
		c.tree.currentVnode = c.tree.rootVnode
	c.selectVnode(c.tree.currentVnode) # load body pane
	c.tree.initing = false # Enable changes in endEditLabel
	self.tnodesDict = {}
	return ok, self.ratio</t>
<t tx="T1373"># 8/13/02
try:
	self.read_only = false
	self.read_only = not os.access(fileName,os.W_OK)
	if self.read_only:
		es("read only: " + fileName)
		d = leoDialog.leoDialog()
		d.askOk(
			"Read-only ouline",
			"Warning: the outline: " + fileName + " is read-only.")
except:
	if 0: # testing only: access may not exist on all platforms.
		es("exception getting file access")
		es_exception()</t>
<t tx="T1374"># Pass 1: create all join lists using the joinHead field in each tnode
v = c.rootVnode()
while v:
	v.setJoinList(v.t.joinHead)
	v.t.setJoinHead(v)
	v = v.threadNext()

# Pass 2: Circularize each join list.
v = c.rootVnode()
while v:
	head = v.t.joinHead
	if not head:
		v = v.threadNext() ; continue
	# Make sure we don't handle this list again.
	v.t.setJoinHead(None)
	# Clear the join list if it has only one member.
	if head == v and not v.getJoinList():
		v.setJoinList(None)
		v = v.threadNext() ; continue
	# Point last at the last vnode of the list.
	last = head
	while last and last.getJoinList():
		assert(last != last.getJoinList())
		last = last.getJoinList()
	assert(last)
	# Link last to head.
	last.setJoinList(head)
	v = v.threadNext()</t>
<t tx="T1375">@ It does not appear that &lt; &lt; scan @delims &gt; &gt; was _ever_ executed!</t>
<t tx="T1376">@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1722358
By: nobody

Like a few other folks who have posted in this forum, I'm trying to embed Javascript
in XML.  Leo is a great tool for writing XSLT, and will be even better after
a few bugs are stamped out. :-)

The following text in an @file node can't be roundtripped (i.e., does not survive
a Leo exit and restart) unless the derived file is deleted before the restart.

@language HTML
@delims /* */     
&lt;script a3:scriptImplementation="Adobe" type="text/ecmascript"&gt;

  // Hi Mom!

@delims &lt;!-- --&gt;

&lt;/script&gt;

Upon restart, the second @delims directive appears in Leo as:

/*@@delims &lt;!-- --&gt; */

If one then makes a trivial change and resaves the document, it cannot be reopened
by Leo unless the derived file is deleted.  The error messages in this case are:

reading: C:\users\mjs\tmp\delimsRoundTrip.leo
reading: @file delimsRoundTrip.xml
----- error reading @file delimsRoundTrip.xml
Unexpected end of file. Expecting @-bodysentinel
exceptions openingC:\users\mjs\tmp\delimsRoundTrip.leo
AssertionError


Note that without the leading @language directive, we skip the partially successful
roundtrip and go straight to the errors.  Changing this directive from HTML
to java has no effect that I can see on the outcome.

I'm using the Leo code from CVS, up to date as of 18 Oct 2002, 14:30ish MDT.

Is this a reasonable way to use @delims?  My reading of the other forum threads
might not have been accurate.

Thanks again,
--Michael Stevens
  mstevens at transgenomic dot com
</t>
<t tx="T1377">@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1723814
By: nobody

&lt;&lt;intro&gt;&gt;

So, after reading the forums and then the documentation for the @delims directive,
I said, "Oh, that's what I was supposed to use," and instead wrote:

@delims /* */
&lt;script a3:scriptImplementation="Adobe" type="text/ecmascript"&gt;
  &lt;![CDATA[
@others
]]&gt;
@delims &lt;!-- --&gt;
&lt;/script&gt;


(The first @delims directive has to go before the &lt;script&gt; tag, or else the
sentinel comment for the @delims directive itself appears in the script region
delimited by XML comment delimiters.)

This does the right thing in the derived file:

#@+leo
#@+node:0::@file delimsRoundTrip.xml
#@+body
#@@delims /* */ 
&lt;script a3:scriptImplementation="Adobe" type="text/ecmascript"&gt;
  &lt;![CDATA[

/*@+others*/
/*@+node:1::subnode*/
/*@+body*/

function sendUpFlare() {
  alert("Hi Mom!");
}

/*@-body*/
/*@-node:1::subnode*/
/*@-others*/

]]&gt;

/*@@delims &lt;!-- --&gt; */
&lt;/script&gt;

&lt;!--@-body--&gt;
&lt;!--@-node:0::@file delimsRoundTrip.xml--&gt;
&lt;!--@-leo--&gt;


The contents of the &lt;script&gt;&lt;/script&gt; region will now pass muster with the Javascript
interpreter.  (I'm ignoring the leading # comments for now -- they shouldn't
be a problem if I use @language html somewhere upstream, right?)

But this derived file cannot be read back in by the Leo code in CVS as of Sunday
afternoon:

reading: C:\users\mjs\tmp\delimsRoundTrip.leo
reading: @file delimsRoundTrip.xml
----- error reading @file delimsRoundTrip.xml
Unexpected end of file. Expecting @-bodysentinel
exceptions openingC:\users\mjs\tmp\delimsRoundTrip.leo
AssertionError

Looks to my untrained eye as though the @@delims sentinel marking the return
to XML comment delimiters isn't being processed correctly in the @file reading
code. (?)  Wish I were better at reading Python. :-(

Regarding my earlier comment about mutations of the second @delims directives:
that may be a symptom of this @file parsing issue, rather than a bug in its
own right.

--Michael</t>
<t tx="T1378">Okay, maybe Friday was one of my marginal-competence days. :-)  Looking back,
my first post described the situation a couple of attempted workarounds away
from the straightforward approach, and didn't explain my goal well at all.

The goal is to maintain (in Leo) an XSLT stylesheet, elements of which generate
Javascript functions which are included inside &lt;script&gt;&lt;/script&gt; tags in the
SVG document which is the product of the stylesheet.

Imagine this as the content of an @file node:

&lt;script a3:scriptImplementation="Adobe" type="text/ecmascript"&gt;
  &lt;![CDATA[
@language java

@others

@language html
]]&gt;
&lt;/script&gt;


where the subnodes all contain modules of Javascript.  For this example, there
is a single subnode containing a single Javascript function, sendUpFlare().
(In the real application, there's a lot more stuff going on, and the &lt;script&gt;
element is a couple levels down from the @file node, but I think this test case
is still a valid demonstration of the problem I'm having).

When I try this, the @language java directive appears to have no effect on the
derived file.  The sentinel comments are still delimited in XML style with &lt;!--
and --&gt;, which causes problems for the Javascript interpreter:

&lt;!--@+leo--&gt;
&lt;!--@+node:0::@file delimsRoundTrip.xml--&gt;
&lt;!--@+body--&gt;
&lt;script a3:scriptImplementation="Adobe" type="text/ecmascript"&gt;
  &lt;![CDATA[

&lt;!--@@language java--&gt;


&lt;!--@+others--&gt;
&lt;!--@+node:1::subnode--&gt;
&lt;!--@+body--&gt;

function sendUpFlare() {
  alert("Hi Mom!");
}

&lt;!--@-body--&gt;
&lt;!--@-node:1::subnode--&gt;
&lt;!--@-others--&gt;



&lt;!--@@language html--&gt;
]]&gt;
&lt;/script&gt;

&lt;!--@-body--&gt;
&lt;!--@-node:0::@file delimsRoundTrip.xml--&gt;
&lt;!--@-leo--&gt;



What I [perhaps erroneously] expected was that Leo would begin using Java style
comment delimiters for sentinel comments after the @language java directive,
so that the region of the derived file between the &lt;script&gt;&lt;/script&gt; tags would
be syntactically-acceptable Javascript (except for typos/thinkos therein --
not Leo's problem!).  But it doesn't.</t>
<t tx="T1379">assert(match(s,i-1,"@delims"));

# Skip the keyword and whitespace.
i0 = i-1
i = skip_ws(s,i-1+7)
	
# Get the first delim.
j = i
while i &lt; len(s) and not is_ws(s[i]) and not is_nl(s,i):
	i += 1

if j &lt; i:
	self.startSentinelComment = s[j:i]
	# print "delim1:", self.startSentinelComment

	# Get the optional second delim.
	j = i = skip_ws(s,i)
	while i &lt; len(s) and not is_ws(s[i]) and not is_nl(s,i):
		i += 1
	end = choose(j&lt;i,s[j:i],"")
	i2 = skip_ws(s,i)
	if end == self.endSentinelComment and (i2 &gt;= len(s) or is_nl(s,i2)):
		self.endSentinelComment = "" # Not really two params.
		line = s[i0:j]
		line = string.rstrip(line)
		out.append(line+'\n')
	else:
		self.endSentinelComment = end
		# print "delim2:",end
		line = s[i0:i]
		line = string.rstrip(line)
		out.append(line+'\n')
else:
	self.readError("Bad @delims")
	# Append the bad @delims line to the body text.
	out.append("@delims")</t>
<t tx="T1380">@ignore</t>
<t tx="T1381"># N.B. No longer crashes, but will not work as expected.
# The end of the &lt; &lt; Raw on &gt; &gt; node will reset raw mode.

	&lt;&lt; Raw ON &gt;&gt; 
	&lt;&lt;Stuff&gt;&gt; 
	&lt;&lt; Raw OFF &gt;&gt; 
</t>
<t tx="T1382">@raw

	</t>
<t tx="T1383">@end_raw 
</t>
<t tx="T1384">asfdasdfrdshfyhbsdfdewgs 
fwsgdfgsdfsd</t>
<t tx="T1385">@ We generate the body part only if it contains something besides whitespace. The check for at-ignore is made in atFile::write.
@c
def putBodyPart(self,v):

	# trace(`v`)
	s = v.t.bodyString
	i = skip_ws_and_nl(s, 0)
	if i &gt;= len(s): return
	s = removeTrailingWs(s) # don't use string.rstrip!
	self.putSentinel("@+body")
	&lt;&lt; put code/doc parts and sentinels &gt;&gt;
	self.putSentinel("@-body")</t>
<t tx="T1386">i = 0 ; n = len(s)
firstLastHack = 1

if firstLastHack:
	&lt;&lt; initialize lookingForFirst/Last &amp; initialLastDirective &gt;&gt;
while i &lt; n:
	kind = self.directiveKind(s,i)
	if firstLastHack:
		&lt;&lt; set lookingForFirst/Last &amp; initialLastDirective &gt;&gt;
	j = i
	if kind == atFile.docDirective or kind == atFile.atDirective:
		i = self.putDoc(s,i,kind)
	elif ( # 10/16/02
		kind == atFile.miscDirective or
		kind == atFile.rawDirective or
		kind == atFile.endRawDirective ):
		if firstLastHack:
			&lt;&lt; handle misc directives &gt;&gt;
		else:
			i = self.putDirective(s,i)
	elif kind == atFile.noDirective or kind == atFile.othersDirective:
		i = self.putCodePart(s,i,v)
	elif kind == atFile.cDirective or kind == atFile.codeDirective:
		i = self.putDirective(s,i)
		i = self.putCodePart(s,i,v)
	else: assert(false) # We must handle everything that directiveKind returns
	assert(n == len(s))
	assert(j &lt; i) # We must make progress.

if firstLastHack:
	&lt;&lt; put out the last directives, if any &gt;&gt;</t>
<t tx="T1387"># 14-SEP-2002 DTHEIN: If this is the root node, then handle all @first directives here
lookingForLast = 0
lookingForFirst = 0
initialLastDirective = -1
lastDirectiveCount = 0
if (v == self.root):
	lookingForLast = 1
	lookingForFirst = 1</t>
<t tx="T1388"># 14-SEP-2002 DTHEIN: If first directive isn't @first, then stop looking for @first
if lookingForFirst:
	if kind != atFile.miscDirective:
		lookingForFirst = 0
	elif not match_word(s,i,"@first"):
		lookingForFirst = 0

if lookingForLast:
	if initialLastDirective == -1:
		if (kind == atFile.miscDirective) and match_word(s,i,"@last"):
			# mark the point where the last directive was found
			initialLastDirective = i
	else:
		if (kind != atFile.miscDirective) or (not match_word(s,i,"@last")):
			# found something after @last, so process the @last directives
			# in 'ignore them' mode
			i, initialLastDirective = initialLastDirective, -1
			lastDirectiveCount = 0
			kind = self.directiveKind(s,i)</t>
<t tx="T1389">if lookingForFirst: # DTHEIN: can only be true if it is @first directive
	i = self.putEmptyDirective(s,i)
elif (initialLastDirective != -1) and match_word(s,i,"@last"):
	# DTHEIN: can only be here if lookingForLast is true
	# skip the last directive ... we'll output it at the end if it
	# is truly 'last'
	lastDirectiveCount += 1
	i = skip_line(s,i)
else:
	i = self.putDirective(s,i)</t>
<t tx="T1390"># 14-SEP-2002 DTHEIN
if initialLastDirective != -1:
	d = initialLastDirective
	for k in range(lastDirectiveCount):
		d = self.putEmptyDirective(s,d)</t>
<t tx="T1391">@ In scanText I moved code from the @+node logic to the @+body logic.  I also removed code in atFile::read that set the body text.

So now body text is updated only as the direct result of @+body, so the presence or absence of @+node sentinels can have no effect.

The code is very similar to the old code; it is simply in a new place.  However, this is no guarantee of correctness or completelness.</t>
<t tx="T1392">@ignore</t>
<t tx="T1393">@language html
before
@ Out-of-control comment.
Not.
@c 
after</t>
<t tx="T1394"># Scans the doc part and appends the text out.
# s,i point to the present line on entry.

def scanDoc(self,file,s,i,out,kind):

	endKind = choose(kind == atFile.startDoc, atFile.endDoc, atFile.endAt)
	single = len(self.endSentinelComment) == 0
	&lt;&lt; Skip the opening sentinel &gt;&gt;
	&lt;&lt; Skip an opening block delim &gt;&gt;
	nextLine = None ; kind = atFile.noSentinel
	while len(s) &gt; 0:
		&lt;&lt; set kind, nextLine &gt;&gt;
		if kind == endKind: break
		&lt;&lt; Skip the leading stuff &gt;&gt;
		&lt;&lt; Append s to out &gt;&gt;
		if nextLine:
			s = nextLine ; nextLine = None
		else: s = readlineForceUnixNewline(file)
	if kind != endKind:
		self.readError("Missing " + self.sentinelName(endKind) + " sentinel")
	&lt;&lt; Remove a closing block delim from out &gt;&gt;</t>
<t tx="T1395">assert(match(s,i,choose(kind == atFile.startDoc, "+doc", "+at")))

out.append(choose(kind == atFile.startDoc, "@doc", "@"))
s = readlineForceUnixNewline(file)
</t>
<t tx="T1396">if not single:
	j = skip_ws(s,0)
	if match(s,j,self.startSentinelComment):
		s = readlineForceUnixNewline(file)</t>
<t tx="T1397">@ For non-sentinel lines we look ahead to see whether the next line is a sentinel.
@c

assert(nextLine==None)

kind = self.sentinelKind(s)

if kind == atFile.noSentinel:
	j = skip_ws(s,0)
	blankLine = s[j] == '\n'
	nextLine = readlineForceUnixNewline(file)
	nextKind = self.sentinelKind(nextLine)
	if blankLine and nextKind == endKind:
		kind = endKind # stop the scan now
</t>
<t tx="T1398"># Point i to the start of the real line.

if single: # Skip the opening comment delim and a blank.
	i = skip_ws(s,0)
	if match(s,i,self.startSentinelComment):
		i += len(self.startSentinelComment)
		if match(s,i," "): i += 1
else:
	i = self.skipIndent(s,0, self.indent)
</t>
<t tx="T1399"># Append the line with a newline if it is real

line = s[i:-1] # remove newline for rstrip.

if line == string.rstrip(line):
	# no trailing whitespace: the newline is real.
	out.append(line + '\n')
else:
	# trailing whitespace: the newline is not real.
	out.append(line)
</t>
<t tx="T1400"># This code will typically only be executed for HTML files.

if not single:

	delim = self.endSentinelComment
	n = len(delim)
	
	# Remove delim and possible a leading newline.
	s = string.join(out,"")
	s = string.rstrip(s)
	if s[-n:] == delim:
		s = s[:-n]
	if s[-1] == '\n':
		s = s[:-1]
		
	# Rewrite out in place.
	del out[:]
	out.append(s)
</t>
<t tx="T1401">@ignore
@nocolor

The problem is that a node may contain clones.  It is not enough to the node N dirty, we must call setAncestorAtFileNodeDirty for all cloned nodes in N's tree!  But we only should do that when deleting a node.

Note that the undo and redo cases handle this automatically because they call c.doDelete.

@color</t>
<t tx="T1402">def sortChildren (self):
	
	# Create a list of vnode, headline tuples
	v = self ; pairs = []
	child = v.firstChild()
	if not child: return
	while child:
		pairs.append((string.lower(child.headString()), child))
		child = child.next()
	# Sort the list on the headlines.
	sortedChildren = sortSequence(pairs,0)
	# Move the children.
	index = 0
	for headline,child in sortedChildren:
		child.moveToNthChildOf(v,index)
		index += 1</t>
<t tx="T1403"># Compatibility routine for scripts

def moveToNthChildOf (self, p, n):

	"""Moves the receiver to the nth child of p"""

	v = self ; c = self.commands

	v.destroyDependents()
	v.unlink()
	v.linkAsNthChild(p, n)
	v.createDependents()
	
	# 5/27/02: Moving a node can create a new root node.
	if not p.parent() and not p.back():
		c.tree.rootVnode = p</t>
<t tx="T1404">@ignore</t>
<t tx="T1405">enabling: *
Exception in Tkinter callback
Traceback (most recent call last):
  File "c:\python22\lib\lib-tk\Tkinter.py", line 1292, in __call__
    return apply(self.func, args)
  File "leoFrame.py", line 1368, in OnTangle
    self.commands.tangleCommands.tangle()
  File "leoTangle.py", line 507, in tangle
    self.tangleTree(v,report_errors)
  File "leoTangle.py", line 644, in tangleTree
    self.tanglePass1(v) # sets self.v
  File "leoTangle.py", line 589, in tanglePass1
    self.skip_body(v)
  File "leoTangle.py", line 1062, in skip_body
    self.st_enter_root_name(old_root_name,code,doc)
  File "leoTangle.py", line 2040, in st_enter_root_name
    assert(code)
AssertionError
</t>
<t tx="T1406">@root a.txt
@ 

@root a.txt 
some text 
@ </t>
<t tx="T1407">@ignore</t>
<t tx="T1408">@language c</t>
<t tx="T1409">@root c:/prog/test/MemoryBuffer.txt

&lt;&lt; MemoryBuffer declarations &gt;&gt;
&lt;&lt; MemoyrBuffer classes &gt;&gt;
</t>
<t tx="T1410">@c

package net.javacoding.gfx.core.buffer.memory;



/* javacoding imports */
import net.javacoding.gfx.core.buffer.Buffer;
</t>
<t tx="T1411">@ *
 *  Default implementation of a MemoryBuffer, this abstract class will be
 *  overloaded by different framebuffers for each type of color model
 *  ( Palettized, RGB, Planed RGB, ... ).
 *  
 *  @author  Günther Van Roey
 *  @version 2001/07/18
 *  @since   0.0.1
&lt;&lt; MemoyrBuffer classes &gt;&gt;=

public abstract class MemoryBuffer implements Buffer {
	&lt;&lt; class MemoryBuffer declarations &gt;&gt;
	&lt;&lt; class MemoryBuffer methods &gt;&gt;



  /**
   *  This one will create the buffers.  Can be overloaded.
   */
  protected abstract void instantiate ( );
  
  

  /**
   *  For a palettized buffer.
   *  @return byte array representing the palette index values forming the image.
   */
  public abstract byte[] getPalettizedBuffer ( );



  /**
   *  Returns palette color components array for RED component.
   *  byte array holding the RED component of the color value.
   */
  public abstract byte[] getRPalette ( );



  /**
   *  Returns palette color components array for GREEN component.
   *  byte array holding the GREEN component of the color value.
   */
  public abstract byte[] getGPalette ( );



  /**
   *  Returns palette color components array for BLUE component.
   *  byte array holding the BLUE component of the color value.
   */
  public abstract byte[] getBPalette ( );



  /**
   *  Returns an int buffer holding the RGB image data.
   *  @int array representing the RGB values of all pixels
   */
  public abstract int[] getRGBBuffer ( );



  /**
   *  Red component data structure in planed RGB mode.
   *  @return byte array holding the red components of each pixel.
   */
  public abstract byte[] getPlanedRBuffer ( );



  /**
   *  Green component data structure in planed RGB mode.
   *  @return byte array holding the green components of each pixel.
   */
  public abstract byte[] getPlanedGBuffer ( );



  /**
   *  Blue component data structure in planed RGB mode.
   *  @return byte array holding the blue components of each pixel.
   */
  public abstract byte[] getPlanedBBuffer ( );
  
}</t>
<t tx="T1412">@c

  /** the width of the buffer. */
  protected int width  = 0;

  /** the height of the buffer. */
  protected int height = 0;
</t>
<t tx="T1413">@ *
   *  Constructor that takes the wanted memorybuffer dimensions as parameters.
   *  @param width the wanted width for the buffer
   *  @param height the wanted height for the buffer
&lt;&lt; class MemoryBuffer methods &gt;&gt;=

public MemoryBuffer ( int width, int height ) {
    negotiateDimensions ( width, height );
    instantiate ( );
  }
</t>
<t tx="T1414">@ *
   * Will be called by the gfx producer after each frame.
&lt;&lt; class MemoryBuffer methods &gt;&gt;=

public abstract void update ( );



  /**
   *  Returns the buffer's height.
   *  @return the buffer's height
   */
  public final int getHeight ( ) {
    return height;
  }
</t>
<t tx="T1415">@ *
   *  Returns the buffer's width.
   *  @return the buffer's width
&lt;&lt; class MemoryBuffer methods &gt;&gt;=

public final int getWidth ( ) {
    return width;
  }
</t>
<t tx="T1416">@ *
   *  Can be overloaded by buffers that need to have specific values for dimensions or
   *  specific relationships between the width and height values.
   *  @param width the wanted width for the buffer
   *  @param height the wanted height for the buffer
&lt;&lt; class MemoryBuffer methods &gt;&gt;=

protected void negotiateDimensions ( int width, int height ) {
    this.width  = width;
    this.height = height;
  }
</t>
<t tx="T1417"># Cutting a node definitely does not set the ancestor @file node dirty!</t>
<t tx="T1418">@ignore</t>
<t tx="T1419">this is a test</t>
<t tx="T1420">@ this is a test
@root Icons/test2.txt
more test</t>
<t tx="T1421">@nocolor

Amazingly, the only change required to allow reads and writes of cloned @file nodes was to eliminate the error in updateCloneIndices.  I also fixed a bug: set self.errors = 0 in atFile.read.

@color</t>
<t tx="T1422">@ignore</t>
<t tx="T1423">multiple read test.</t>
<t tx="T1424">@ It is vital that @file nodes remain dirty until they are written without errors.  Otherwise, a Save command will succeeed without warning, and a later read may cause the dreaded "clones have been cleared" message.</t>
<t tx="T1425">assert(match(s,i,"+node:"))
i += 6

childIndex = 0 ; cloneIndex = 0
&lt;&lt; Set childIndex &gt;&gt;
&lt;&lt; Set cloneIndex &gt;&gt;
headline = ""
&lt;&lt; Set headline and ref &gt;&gt;

# print childIndex,headline

if childIndex == 0: # The root node.
	&lt;&lt; Check the filename in the sentinel &gt;&gt;
	# Put the text of the root node in the current node.
	self.scanText(file,v,out,atFile.endNode,implicitChildIndex)
	v.t.setCloneIndex(cloneIndex)
	# if cloneIndex &gt; 0: trace("clone index:" + `cloneIndex` + ", " + `v`)
else:
	# NB: this call to createNthChild is the bottleneck!
	child = self.createNthChild(childIndex,v,headline)
	child.t.setCloneIndex(cloneIndex)
	# if cloneIndex &gt; 0: trace("clone index:" + `cloneIndex` + ", " + `child`)
	self.scanText(file,child,out,atFile.endNode,implicitChildIndex)

&lt;&lt; look for sentinels that may follow a reference &gt;&gt;</t>
<t tx="T1426">i = skip_ws(s,i) ; j = i
while i &lt; len(s) and s[i] in string.digits:
	i += 1

if j == i:
	implicitChildIndex += 1
	childIndex = implicitChildIndex
else:
	childIndex = int(s[j:i])

if match(s,i,':'):
	i += 1 # Skip the ":".
else:
	self.readError("Bad child index in @+node")</t>
<t tx="T1427">while i &lt; len(s) and s[i] != ':' and not is_nl(s,i):
	if match(s,i,"C="):
		# set cloneIndex from the C=nnn, field
		i += 2 ; j = i
		while i &lt; len(s) and s[i] in string.digits:
			i += 1
		if j &lt; i:
			cloneIndex = int(s[j:i])
	else: i += 1 # Ignore unknown status bits.

if match(s,i,":"):
	i += 1
else:
	self.readError("Bad attribute field in @+node")</t>
<t tx="T1428">h = string.strip(headline)

if h[:5] == "@file":
	i,junk = scanAtFileOptions(h)
	fileName = string.strip(h[i:])
	if fileName != self.targetFileName:
		self.readError("File name in @node sentinel does not match file's name")
elif h[:8] == "@rawfile":
	fileName = string.strip(h[8:])
	if fileName != self.targetFileName:
		self.readError("File name in @node sentinel does not match file's name")
else:
	self.readError("Missing @file in root @node sentinel")
</t>
<t tx="T1429">s = readlineForceUnixNewline(file)
kind = self.sentinelKind(s)

if len(s) &gt; 1 and kind == atFile.startVerbatimAfterRef:
	s = readlineForceUnixNewline(file)
	# trace("verbatim:"+`s`)
	out.append(s)
elif kind == atFile.startNewline:
	out.append('\n')
	s = readlineForceUnixNewline(file)
	nextline = s
	trace(`s`)
elif kind == atFile.startNoNewline:
	s = readlineForceUnixNewline(file)
	nextline = s
elif len(s) &gt; 1 and self.sentinelKind(s) == atFile.noSentinel:
	out.append(s)
else:
	nextLine = s # Handle the sentinel or blank line later.
</t>
<t tx="T1430">@ This method expands a code part, terminated by any at-directive except at-others.  It expands references and at-others and outputs @verbatim sentinels as needed.
@c
def putCodePart(self,s,i,v):

	c = self.commands
	atOthersSeen = false # true: at-others has been expanded.
	# j = skip_line(s,i) ; trace(`s[i:j]`)
	while i &lt; len(s):
		&lt;&lt; handle the start of a line &gt;&gt;
		&lt;&lt; put the line &gt;&gt;

	# Raw code parts can only end at the end of body text.
	self.raw = false
	return i</t>
<t tx="T1431">@ The at-others directive is the only directive that is recognized following leading whitespace, so it is just a little tricky to recognize it.
@c

leading_nl = (s[i] == body_newline) # 9/27/02: look ahead before outputting newline.
if leading_nl:
	i = skip_nl(s,i)
	self.onl() # 10/15/02: simpler to do it here.

j,delta = skip_leading_ws_with_indent(s,i,self.tab_width)
kind1 = self.directiveKind(s,i)
kind2 = self.directiveKind(s,j)
if self.raw:
	if kind1 == atFile.endRawDirective:
		&lt;&lt; handle @end_raw &gt;&gt;
else:
	if kind1 == atFile.othersDirective or kind2 == atFile.othersDirective:
		&lt;&lt; handle @others &gt;&gt;
	elif kind1 == atFile.rawDirective:
		&lt;&lt; handle @raw &gt;&gt;
	elif kind1 == atFile.noDirective:
		&lt;&lt; put @verbatim sentinel if necessary &gt;&gt;
	else:
		break # all other directives terminate the code part.</t>
<t tx="T1432"># This skips all indent and delta whitespace, so putAtOthers must generate it all.

if 0: # 9/27/02: eliminates the newline preceeding the @+others sentinel.
	# This does not seem to be a good idea.
	i = skip_line(s,i) 
else:
	i = skip_to_end_of_line(s,i)

if atOthersSeen:
	self.writeError("@others already expanded in: " + v.headString())
else:
	atOthersSeen = true
	self.putAtOthers(v, delta)</t>
<t tx="T1433">self.raw = true
self.putSentinel("@@raw")
i = skip_line(s,i)</t>
<t tx="T1434">self.raw = false
self.putSentinel("@@end_raw")
i = skip_line(s,i)</t>
<t tx="T1435">if not self.raw:
	self.putIndent(self.indent)

newlineSeen = false
while i &lt; len(s) and not newlineSeen:
	ch = s[i]
	if ch == body_newline:
		break
	elif ch == body_ignored_newline:
		i += 1
	elif ch == '&lt;' and not self.raw:
		&lt;&lt; put possible section reference &gt;&gt;
	else:
		self.os(ch)
		i += 1</t>
<t tx="T1436">isSection, j = self.isSectionName(s, i)

if isSection:
	# Output the expansion.
	name = s[i:j]
	j,newlineSeen = self.putRef(name,v,s,j,delta)
	assert(j &gt; i) # isSectionName must have made progress
	i = j
else:
	self.os(s[i]) # This is _not_ an error.
	i += 1</t>
<t tx="T1437"># returns (flag, end). end is the index of the character after the section name.

def isSectionName(self,s,i):

	if not match(s,i,"&lt;&lt;"):
		return false, -1
	i = find_on_line(s,i,"&gt;&gt;")
	if i:
		return true, i + 2
	else:
		return false, -1</t>
<t tx="T1438">def putRef (self,name,v,s,i,delta):

	# trace(get_line(s[i:],0))
	newlineSeen = false
	ref = findReference(name, v)
	if not ref:
		self.writeError("undefined section: " + name +
			"\n\treferenced from: " + v.headString())
		return i,newlineSeen

	&lt;&lt; Generate the expansion of the reference &gt;&gt;

	# 2/25/02: Add a sentinel if required.
	j = skip_ws(s,i)
	if j &lt; len(s) and match(s,j,self.startSentinelComment + '@'):
		self.putSentinel("@verbatimAfterRef")
		# 9/27/02: Put the line immediately, before the @-node sentinel.
		k = skip_to_end_of_line(s,i)
		self.os(s[i:k])
		i = k ; newlineSeen = false
	else:
		if 0: # 9/27/02: generate new directives.
			if is_nl(s,j):
				self.putSentinel("@newline")
				i = skip_nl(s,j) ; newlineSeen = true
			else:
				self.putSentinel("@nonewline")
				i = j ; newlineSeen = false
		if 0: # The old code did nothing
			if is_nl(s,j):
				i = j ; newlineSeen = false
			else:
				k = skip_to_end_of_line(s,i)
				self.os(s[i:k])
				i = k ; newlineSeen = false

	# The newlineSeen allows the caller to break out of the loop.
	return i,newlineSeen</t>
<t tx="T1439"># 2/24/02: adjust indent here so sentinel looks better.
self.indent += delta 
self.putSentinel("@" + name)
self.putOpenSentinels(v,ref)
self.putBodyPart(ref)
ref.setVisited()
self.putCloseSentinels(v,ref)
self.indent -= delta</t>
<t tx="T1440">assert(self.outputFile == None)

if os.path.exists(self.targetFileName): 
	if filecmp.cmp(self.outputFileName, self.targetFileName):
		try: # Just delete the temp file.
			os.remove(self.outputFileName)
		except:
			es("exception deleting:" + self.outputFileName)
			es_exception()
		es("unchanged: " + self.shortFileName)
	else:
		try:
			# 10/6/02: retain the access mode of the previous file,
			# removing any setuid, setgid, and sticky bits.
			mode = (os.stat(self.targetFileName))[0] &amp; 0777
		except:
			mode = None
		try: # Replace target file with temp file.
			os.remove(self.targetFileName)
			utils_rename(self.outputFileName, self.targetFileName)
			if mode: # 10/3/02: retain the access mode of the previous file.
				os.chmod(self.targetFileName,mode)
			es("writing: " + self.shortFileName)
		except:
			self.writeError("exception removing and renaming:" + self.outputFileName +
				" to " + self.targetFileName)
			es_exception()
else:
	try:
		# os.rename(self.outputFileName, self.targetFileName)
		utils_rename(self.outputFileName, self.targetFileName)
		es("creating: " + self.targetFileName)
	except:
		self.writeError("exception renaming:" + self.outputFileName +
			" to " + self.targetFileName)
		es_exception()</t>
<t tx="T1441">@ This function compares two files. If they are different, we replace file_name with temp_name. Otherwise, we just delete temp_name.  Both files should be closed.
@c

def update_file_if_changed(file_name,temp_name):

	if os.path.exists(file_name):
		import filecmp
		if filecmp.cmp(temp_name, file_name):
			try: # Just delete the temp file.
				os.remove(temp_name)
			except: pass
			es("unchanged: " + file_name)
		else:
			try:
				# 10/6/02: retain the access mode of the previous file,
				# removing any setuid, setgid, and sticky bits.
				mode = (os.stat(file_name))[0] &amp; 0777
			except:
				mode = None
			try: # Replace file with temp file.
				os.remove(file_name)
				utils_rename(temp_name, file_name)
				if mode: # 10/3/02: retain the access mode of the previous file.
					os.chmod(file_name,mode)
				es("***updating: " + file_name)
			except:
				es("Rename failed: no file created!")
				es(`file_name` + " may be read-only or in use")
				es_exception()
	else:
		try:
			# os.rename(temp_name, file_name)
			utils_rename(temp_name, file_name)
			es("creating: " + file_name)
		except:
			es("rename failed: no file created!")
			es(`file_name` + " may be read-only or in use")
			es_exception()</t>
<t tx="T1442">@ignore</t>
<t tx="T1443"></t>
<t tx="T1444">def getBool (self):
	self.skipWs() # guarantees at least one more character.
	ch = self.fileBuffer[self.fileIndex]
	if ch == '0':
		self.fileIndex += 1 ; return false
	elif ch == '1':
		self.fileIndex += 1 ; return true
	else:
		raise BadLeoFile("expecting bool constant")
		
def getDqBool (self):
	self.getDquote() ; val = self.getBool() ; self.getDquote()
	return val
	
def getDqString (self): # 7/10/02
	self.getDquote()
	i = self.fileIndex
	self.fileIndex = j = string.find(self.fileBuffer,'"',i)
	if j == -1: raise BadLeoFile("unterminated double quoted string")
	s = self.fileBuffer[i:j]
	self.getDquote()
	return s

def getDouble (self):
	self.skipWs()
	i = self.fileIndex ; buf = self.fileBuffer
	floatChars = string.digits + 'e' + 'E' + '.' + '+' + '-'
	n = len(buf)
	while i &lt; n and buf[i] in floatChars:
		i += 1
	if i == self.fileIndex:
		raise BadLeoFile("expecting float constant")
	val = float(buf[self.fileIndex:i])
	self.fileIndex = i
	return val

def getDquote (self):
	self.getTag('"')
	
def getIndex (self):
	val = self.getLong()
	if val &lt; 0: raise BadLeoFile("expecting index")
	return val
	
def getLong (self):
	self.skipWs() # guarantees at least one more character.
	i = self.fileIndex
	if self.fileBuffer[i] == '-':
		i += 1
	n = len(self.fileBuffer)
	while i &lt; n and self.fileBuffer[i] in string.digits:
		i += 1
	if i == self.fileIndex:
		raise BadLeoFile("expecting int constant")
	val = int(self.fileBuffer[self.fileIndex:i])
	self.fileIndex = i
	return val
		
def getStringToTag (self,tag):
	buf = self.fileBuffer
	blen = len(buf) ; tlen = len(tag)
	i = j = self.fileIndex
	while i &lt; blen:
		if tag == buf[i:i+tlen]:
			self.fileIndex = i
			return buf[j:i]
		else: i += 1
	raise BadLeoFile("expecting string terminated by " + tag)
	return ""
	
# Look ahead for collapsed tag: tag may or may not end in "&gt;"
# Skips tag and /&gt; if found, otherwise does not alter index.
def getOpenTag (self,tag):
	if tag[-1] == "&gt;":
		# Only the tag itself or a collapsed tag are valid.
		if self.matchTag(tag):
			return false # Not a collapsed tag.
		elif self.matchTag(tag[:-1]):
			# It must be a collapsed tag.
			self.skipWs()
			if self.matchTag("/&gt;"):
				return true
		print "getOpenTag(", tag, ") failed:"
		raise BadLeoFile("expecting" + tag)
	else:
		# The tag need not be followed by "/&gt;"
		if self.matchTag(tag):
			old_index = self.fileIndex
			self.skipWs()
			if self.matchTag("/&gt;"):
				return true
			else:
				self.fileIndex = old_index
				return false
		else:
			print "getOpenTag(", tag, ") failed:"
			raise BadLeoFile("expecting" + tag)
	
# 11/24/02: Look ahead for closing /&gt;
# Return true if found.
def getTag (self,tag):
	if self.matchTag(tag):
		return
	else:
		print "getTag(", tag, ") failed:"
		raise BadLeoFile("expecting" + tag)
</t>
<t tx="T1445">def matchChar (self,ch):
	self.skipWs() # guarantees at least one more character.
	if ch == self.fileBuffer[self.fileIndex]:
		self.fileIndex += 1 ; return true
	else: return false

# Warning: does not check for end-of-word,
# so caller must match prefixes first.
def matchTag (self,tag):
	self.skipWsAndNl() # guarantees at least one more character.
	i = self.fileIndex
	if tag == self.fileBuffer[i:i+len(tag)]:
		self.fileIndex += len(tag)
		return true
	else:
		return false

def matchTagWordIgnoringCase (self,tag):
	self.skipWsAndNl() # guarantees at least one more character.
	i = self.fileIndex
	tag = string.lower(tag)
	j = skip_c_id(self.fileBuffer,i)
	word = self.fileBuffer[i:j]
	word = string.lower(word)
	if tag == word:
		self.fileIndex += len(tag)
		return true
	else:
		return false
</t>
<t tx="T1446">@ Parses the optional xml stylesheet string, and sets the corresponding config option.

For example, given: &lt;?xml_stylesheet s?&gt;
the config option is s.
@c

def getXmlStylesheetTag (self):
	
	c = self.commands
	tag = "&lt;?xml-stylesheet "

	if self.matchTag(tag):
		s = self.getStringToTag("?&gt;")
		# print "reading:", tag + s + "?&gt;"
		c.frame.stylesheet = s
		self.getTag("?&gt;")
</t>
<t tx="T1447">@ignore</t>
<t tx="T1448">@path new
@root test1.txt

test1.txt</t>
<t tx="T1449">@root new/test2.txt

test2.txt</t>
<t tx="T1450">@path c:/prog/test
@root test3.txt

test3.txt</t>
<t tx="T1451">@root c:/prog/test/test4.txt

test4.txt</t>
<t tx="T1452"># make sure the simplest case still works!

@root test5.txt

test5 text</t>
<t tx="T1453">@ This code skips the file name used in @root directives.  i points after the @root directive.

File names may be enclosed in &lt; and &gt; characters, or in double quotes.  If a file name is not enclosed be these delimiters it continues until the next newline.
@c
def setRootFromText(self,s,err_flag):
	
	# trace(`s`)
	self.root_name = None
	i,self.start_mode = scanAtRootOptions(s,0)
	i = skip_ws(s,i)
	
	if i &gt;= len(s): return i
	# Allow &lt;&gt; or "" as delimiters, or a bare file name.
	if s[i] == '"':
		i += 1 ; delim = '"'
	elif s[i] == '&lt;':
		i += 1 ; delim = '&gt;'
	else: delim = body_newline

	root1 = i # The name does not include the delimiter.
	while i &lt; len(s) and s[i] != delim and not is_nl(s,i):
		i += 1
	root2 = i

	if delim != body_newline and not match(s,i,delim):
		if err_flag:
			scanError("bad filename in @root " + s[:i])
	else:
		self.root_name = string.strip(s[root1:root2])
	return i</t>
<t tx="T1454">@ Scans root for @directives and returns a dict containing pointers to the start of each directive.

The caller passes [root_node] or None as the second arg.  This allows us to distinguish between None and [None].
@c

def get_directives_dict(s,root=None):

	if root: root_node = root[0]
	dict = {}
	i = 0 ; n = len(s)
	while i &lt; n:
		if s[i] == '@' and i+1 &lt; n:
			&lt;&lt; set dict for @ directives &gt;&gt;
		elif root and match(s,i,"&lt;&lt;"):
			&lt;&lt; set dict["root"] for noweb * chunks &gt;&gt;
		i = skip_line(s,i)
	return dict</t>
<t tx="T1455"># EKR: rewritten 10/10/02
directiveList = (
	"color", "comment", "header", "ignore",
	"language", "nocolor", "noheader",
	"pagewidth", "path", "quiet", "root", "silent",
	"tabwidth", "terse", "unit", "verbose")

j = skip_c_id(s,i+1)
word = s[i+1:j]
if word in directiveList:
	dict [word] = i
</t>
<t tx="T1456">@ The following looks for chunk definitions of the form &lt; &lt; * &gt; &gt; =. If found, we take this to be equivalent to @root filename if the headline has the form @root filename.
@c

i = skip_ws(s,i+2)
if i &lt; n and s[i] == '*' :
	i = skip_ws(s,i+1) # Skip the '*'
	if match(s,i,"&gt;&gt;="):
		# &lt; &lt; * &gt; &gt; = implies that @root should appear in the headline.
		i += 3
		if root_node:
			dict["root"]=0 # value not immportant
		else:
			es(angleBrackets("*") + "= requires @root in the headline")</t>
<t tx="T1457"></t>
<t tx="T1458">def canContractAllHeadlines (self):

	c = self ; v = c.rootVnode()
	if not v: return false
	while v:
		if v.isExpanded():
			return true
		v = v.threadNext()
	return false</t>
<t tx="T1459">def canContractAllSubheads (self):

	c = self
	v = c.currentVnode()
	if not v: return false
	next = v.nodeAfterTree()
	v = v.threadNext()
	while v and v != next:
		if v.isExpanded():
			return true
		v = v.threadNext()
	return false</t>
<t tx="T1460">def canContractParent (self):

	c = self ; v = c.currentVnode()
	return v.parent() != None</t>
<t tx="T1461">def canContractSubheads (self):

	c = self ; v = c.currentVnode()
	if not v: return false
	v = v.firstChild()
	while v:
		if v.isExpanded():
			return true
		v = v.next()
	return false</t>
<t tx="T1462">def canDeleteHeadline (self):

	c = self ; v = c.currentVnode()
	if not v: return false
	if v.parent(): # v is below the top level.
		return true
	else: # v is at the top level.  We can not delete the last node.
		return v.threadBack() or v.next()

canCutOutline = canDeleteHeadline</t>
<t tx="T1463">def canDemote (self):

	c = self
	v = c.currentVnode()
	if not v: return false
	return v.next() != None</t>
<t tx="T1464">def canExpandAllHeadlines (self):

	c = self ; v = c.rootVnode()
	if not v: return false
	while v:
		if not v.isExpanded():
			return true
		v = v.threadNext()
	return false</t>
<t tx="T1465">def canExpandAllSubheads (self):

	c = self
	v = c.currentVnode()
	if not v: return false
	next = v.nodeAfterTree()
	v = v.threadNext()
	while v and v != next:
		if not v.isExpanded():
			return true
		v = v.threadNext()
	return false</t>
<t tx="T1466">def canExpandSubheads (self):

	c = self ; v = c.currentVnode()
	if not v: return false
	v = v.firstChild()
	while v:
		if not v.isExpanded():
			return true
		v = v.next()
	return false</t>
<t tx="T1467">def canExtract (self):

	c = self
	if c.body:
		i, j = getTextSelection(c.body)
		return i and j and c.body.compare(i, "!=", j)
	else:
		return false

canExtractSection = canExtract
canExtractSectionNames = canExtract</t>
<t tx="T1468">def canFindMatchingBracket (self):
	
	c = self ; body = c.body
	brackets = "()[]{}"
	c1=body.get("insert -1c")
	c2=body.get("insert")
	return c1 in brackets or c2 in brackets</t>
<t tx="T1469">def canGoToNextDirtyHeadline (self):

	c = self ; current = c.currentVnode()
	if not current: return false

	v = c.rootVnode()
	while v:
		if v.isDirty()and v != current:
			return true
		v = v.threadNext()
	return false</t>
<t tx="T1470">def canGoToNextMarkedHeadline (self):

	c = self ; current = c.currentVnode()
	if not current: return false

	v = c.rootVnode()
	while v:
		if v.isMarked()and v != current:
			return true
		v = v.threadNext()
	return false</t>
<t tx="T1471">def canMarkChangedHeadlines (self):

	c = self ; v = c.rootVnode()
	while v:
		if v.isDirty():
			return true
		v = v.threadNext()
	return false</t>
<t tx="T1472">def canMarkChangedRoots (self):

	c = self ; v = c.rootVnode()
	while v:
		if v.isDirty():
			return true
		v = v.threadNext()
	return false</t>
<t tx="T1473">def canMoveOutlineDown (self):

	c = self
	if 1: # The permissive way
		current = c.currentVnode()
		if not current: return false
		v = current.visNext()
		while v and current.isAncestorOf(v):
			v = v.visNext()
		return v != None
	else: # The MORE way.
		return c.currentVnode().next() != None</t>
<t tx="T1474">def canMoveOutlineLeft (self):

	c = self ; v = c.currentVnode()
	if 0: # Old code: assumes multiple leftmost nodes.
		return v and v.parent()
	else: # Can't move a child of the root left.
		return v and v.parent() and v.parent().parent()</t>
<t tx="T1475">def canMoveOutlineRight (self):

	c = self ; v = c.currentVnode()
	return v and v.back()</t>
<t tx="T1476">def canMoveOutlineUp (self):

	c = self ; v = c.currentVnode()
	if 1: # The permissive way.
		return v and v.visBack()
	else: # The MORE way.
		return v and v.back()</t>
<t tx="T1477">def canPromote (self):

	c = self ; v = c.currentVnode()
	return v and v.hasChildren()</t>
<t tx="T1478"># 7/29/02: The shortcuts for these commands are now unique.

def canSelectThreadBack (self):
	v = self.currentVnode()
	return v and v.threadBack()
	
def canSelectThreadNext (self):
	v = self.currentVnode()
	return v and v.threadNext()

def canSelectVisBack (self):
	v = self.currentVnode()
	return v and v.visBack()
	
def canSelectVisNext (self):
	v = self.currentVnode()
	return v and v.visNext()</t>
<t tx="T1479">def canShiftBodyLeft (self):

	c = self
	if c.body:
		s = c.body.GetValue()
		return len(s) &gt; 0
	else:
		return false
		
def canShiftBodyRight (self):

	c = self
	if c.body:
		s = c.body.GetValue()
		return len(s) &gt; 0
	else:
		return false</t>
<t tx="T1480">def canSortChildren (self):

	c = self ; v = c.currentVnode()
	return v and v.hasChildren()
	
def canSortSiblings (self):

	c = self ; v = c.currentVnode()
	parent = v.parent()
	return parent and parent.hasChildren()</t>
<t tx="T1481">def canUndo (self):

	c = self
	return c.undoer.canUndo()
	
def canRedo (self):

	c = self
	return c.undoer.canRedo()</t>
<t tx="T1482"># Returns true if any node is marked.

def canUnmarkAll (self):

	c = self ; v = c.rootVnode()
	while v:
		if v.isMarked():
			return true
		v = v.threadNext()
	return false</t>
<t tx="T1483"># Warning:  calling del self will not necessarily call this routine.

def __del__ (self):
	
	# Can't trace while destroying.
	# print "frame.__del__"
	
	self.log = self.body = self.tree = None
	self.treeBar = self.canvas = self.splitter1 = self.splitter2 = None
	# Menu bars.
	del self.menus ; self.menus = None</t>
<t tx="T1484"></t>
<t tx="T1485">@ This code "canonicalizes" both the shortcuts that appear in menus and the arguments to bind, mostly ignoring case and the order in which special keys are specified in leoConfig.txt.

For example, Ctrl+Shift+a is the same as Shift+Control+A.  Either may appear in leoConfig.txt.  Each generates Shift+Ctrl-A in the menu and Control+A as the argument to bind.

Returns (bind_shortcut, menu_shortcut,amp_index)
@c

def canonicalizeShortcut (self,shortcut):
	
	if shortcut == None or len(shortcut) == 0:
		return None,None
	s = shortcut.strip().lower()
	has_alt   = s.find("alt") &gt;= 0
	has_ctrl  = s.find("control") &gt;= 0 or s.find("ctrl") &gt;= 0
	has_shift = s.find("shift") &gt;= 0   or s.find("shft") &gt;= 0
	&lt;&lt; set the last field, preserving case &gt;&gt;
	&lt;&lt; canonicalize the last field &gt;&gt;
	&lt;&lt; synthesize the shortcuts from the information &gt;&gt;
	# print shortcut,bind_shortcut,menu_shortcut
	return bind_shortcut,menu_shortcut</t>
<t tx="T1486">bind_last = menu_last = last
if len(last) == 1:
	ch = last[0]
	if ch in string.letters:
		menu_last = string.upper(last)
		if has_shift:
			bind_last = string.upper(last)
		else:
			bind_last = string.lower(last)
	elif ch in string.digits:
		bind_last = "Key-" + ch # 1-5 refer to mouse buttons, not keys.
	else:
		&lt;&lt; define dict of Tk bind names &gt;&gt;
		if ch in dict.keys():
			bind_last = dict[ch]
elif len(last) &gt; 0:
	&lt;&lt; define dict of special names &gt;&gt;
	last2 = string.lower(last)
	if last2 in dict.keys():
		bind_last,menu_last = dict[last2]</t>
<t tx="T1487"># These are defined at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
dict = {
	"!" : "exclam",
	'"' : "quotedbl",
	"#" : "numbersign",
	"$" : "dollar",
	"%" : "percent",
	"&amp;" : "ampersand",
	"'" : "quoteright",
	"(" : "parenleft",
	")" : "parenright",
	"*" : "asterisk",
	"+" : "plus",
	"," : "comma",
	"-" : "minus",
	"." : "period",
	"/" : "slash",
	":" : "colon",
	";" : "semicolon",
	"&lt;" : "less",
	"=" : "equal",
	"&gt;" : "greater",
	"?" : "question",
	"@" : "at",
	"[" : "bracketleft",
	"\\": "backslash",
	"]" : "bracketright",
	"^" : "asciicircum",
	"_" : "underscore",
	"`" : "quoteleft",
	"{" : "braceleft",
	"|" : "bar",
	"}" : "braceright",
	"~" : "asciitilde" }</t>
<t tx="T1488"># These keys are simply made-up names.  The menu_bind values are known to Tk.
# Case is not significant in the keys.

dict = {
	"bksp"    : ("BackSpace","BkSp"),
	"esc"     : ("Escape","Esc"),
	# Arrow keys...
	"dnarrow" : ("Down", "DnArrow"),
	"ltarrow" : ("Left", "LtArrow"),
	"rtarrow" : ("Right","RtArrow"),
	"uparrow" : ("Up",   "UpArrow"),
	# Page up/down keys...
	"pageup"  : ("Prior","PgUp"),
	"pagedn"  : ("Next", "PgDn")
}

@  The following are not translated, so what appears in the menu is the same as what is passed to Tk.  Case is significant.

Note: the Tk documentation states that not all of these may be available on all platforms.

F1,F2,F3,F4,F5,F6,F7,F8,F9,F10,
BackSpace, Break, Clear, Delete, Escape, Linefeed, Return, Tab,
Down, Left, Right, Up,
Begin, End, Home, Next, Prior,
Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9
</t>
<t tx="T1489">s2 = shortcut
s2 = string.strip(s2)

# Replace all minus signs by plus signs, except a trailing minus:
if len(s2) &gt; 0 and s2[-1] == "-":
	s2 = string.replace(s2,"-","+")
	s2 = s2[:-1] + "-"
else:
	s2 = string.replace(s2,"-","+")

fields = string.split(s2,"+")
if fields == None or len(fields) == 0:
	if not app().menuWarningsGiven:
		print "bad shortcut specifier:", s
	return None,None

last = fields[-1]
if last == None or len(last) == 0:
	if not app().menuWarningsGiven:
		print "bad shortcut specifier:", s
	return None,None</t>
<t tx="T1490">bind_head = menu_head = ""

if has_shift:
	menu_head = "Shift+"
	if len(last) &gt; 1 or (len(last)==1 and last[0] not in string.letters):
		bind_head = "Shift-"

if has_alt:
	bind_head = bind_head + "Alt-"
	menu_head = menu_head + "Alt+"

if has_ctrl:
	bind_head = bind_head + "Control-"
	menu_head = menu_head + "Ctrl+"
	
bind_shortcut = "&lt;" + bind_head + bind_last + "&gt;"
menu_shortcut = menu_head + menu_last</t>
<t tx="T1491">def createMenuBar(self, top):

	c = self.commands
	Tk = Tkinter
	topMenu = Tk.Menu(top,postcommand=self.OnMenuClick)
	self.setMenu("top",topMenu)
	self.menuShortcuts = []
	# To do: use Meta rathter than Control for accelerators for Unix
	&lt;&lt; create the file menu &gt;&gt;
	&lt;&lt; create the edit menu &gt;&gt;
	&lt;&lt; create the outline menu &gt;&gt;
	&lt;&lt; create the window menu &gt;&gt;
	&lt;&lt; create the help menu &gt;&gt;
	top.config(menu=topMenu) # Display the menu.
	app().menuWarningsGiven = true
</t>
<t tx="T1492">editMenu = self.createNewMenu("&amp;Edit")
&lt;&lt; create the first top-level edit entries &gt;&gt;
&lt;&lt; create the edit body submenu &gt;&gt;
&lt;&lt; create the edit headline submenu &gt;&gt;
&lt;&lt; create the find submenu &gt;&gt;
&lt;&lt; create the last top-level edit entries &gt;&gt;
</t>
<t tx="T1493">table = (
	("Can't Undo","Ctrl+Z",self.OnUndo), # &amp;U reserved for Undo
	("Can't Redo","Shift+Ctrl+Z",self.OnRedo), # &amp;R reserved for Redo
	("-",None,None),
	("Cu&amp;t","Ctrl+X",self.OnCutFromMenu), 
	("Cop&amp;y","Ctrl+C",self.OnCopyFromMenu),
	("&amp;Paste","Ctrl+V",self.OnPasteFromMenu),
	("&amp;Delete",None,self.OnDelete),
	("Select &amp;All","Ctrl+A",self.OnSelectAll),
	("-",None,None))

self.createMenuEntries(editMenu,table)
</t>
<t tx="T1494">editBodyMenu = self.createNewMenu("Edit &amp;Body...","Edit")

table = (
	("Extract &amp;Section","Shift+Ctrl+E",self.OnExtractSection),
	("Extract &amp;Names","Shift+Ctrl+N",self.OnExtractNames),
	("&amp;Extract","Shift+Ctrl+D",self.OnExtract),
	("-",None,None),
	("Convert All B&amp;lanks",None,self.OnConvertAllBlanks),
	("Convert All T&amp;abs",None,self.OnConvertAllTabs),
	("Convert &amp;Blanks","Shift+Ctrl+B",self.OnConvertBlanks),
	("Convert &amp;Tabs","Shift+Ctrl+J",self.OnConvertTabs),
	("&amp;Reformat Paragraph","Shift+Ctrl+P",self.OnReformatParagraph),
	("-",None,None),
	("&amp;Indent","Ctrl+]",self.OnIndent),
	("&amp;Unindent","Ctrl+[",self.OnDedent),
	("&amp;Match Brackets","Ctrl+K",self.OnFindMatchingBracket))
	#("-",None,None),
	#("Insert Graphic File...",None,self.OnInsertGraphicFile))
	
self.createMenuEntries(editBodyMenu,table)

</t>
<t tx="T1495">editHeadlineMenu = self.createNewMenu("Edit &amp;Headline...","Edit")

table = (
	("Edit &amp;Headline","Ctrl+H",self.OnEditHeadline),
	("&amp;End Edit Headline","Escape",self.OnEndEditHeadline),
	("&amp;Abort Edit Headline","Shift-Escape",self.OnAbortEditHeadline))
	
self.createMenuEntries(editHeadlineMenu,table)

</t>
<t tx="T1496">findMenu = self.createNewMenu("&amp;Find...","Edit")

table = (
	("&amp;Find Panel","Ctrl+F",self.OnFindPanel),
	("-",None,None),
	("Find &amp;Next","F3",self.OnFindNext),
	("Find &amp;Previous","F4",self.OnFindPrevious),
	("&amp;Replace","Ctrl+=",self.OnReplace),
	("Replace, &amp;Then Find","Ctrl+-",self.OnReplaceThenFind))

self.createMenuEntries(findMenu,table)
</t>
<t tx="T1497">label = choose(c.tree.colorizer.showInvisibles,"Hide In&amp;visibles","Show In&amp;visibles")

table = (
	("&amp;Go To Line Number","Alt+G",self.OnGoToLineNumber),
	("&amp;Execute Script","Alt+Shift+E",self.OnExecuteScript),
	("Set Fon&amp;t...","Shift+Alt+T",self.OnFontPanel),
	("Set &amp;Colors...","Shift+Alt+S",self.OnColorPanel),
	(label,"Alt+V",self.OnViewAllCharacters),
	("-",None,None),
	("Prefere&amp;nces","Ctrl+Y",self.OnPreferences))

self.createMenuEntries(editMenu,table)</t>
<t tx="T1498">fileMenu = self.createNewMenu("&amp;File")
&lt;&lt; create the top-level file entries &gt;&gt;
&lt;&lt; create the recent files submenu &gt;&gt;
fileMenu.add_separator()
&lt;&lt; create the read/write submenu &gt;&gt;
&lt;&lt; create the tangle submenu &gt;&gt;
&lt;&lt; create the untangle submenu &gt;&gt;
&lt;&lt; create the import submenu &gt;&gt;
&lt;&lt; create the export submenu &gt;&gt;
fileMenu.add_separator()
# Create the last entries.
exitTable = (("E&amp;xit","Ctrl-Q",self.OnQuit),)
self.createMenuEntries(fileMenu,exitTable)

</t>
<t tx="T1499">@ It is doubtful that leo.py will ever support a Print command directly.  Rather, users can use export commands to create text files that may then be formatted and printed as desired.
@c

table = (
	("&amp;New","Ctrl+N",self.OnNew),
	("&amp;Open...","Ctrl+O",self.OnOpen),
	("Open &amp;With...","Shift+Ctrl+O",self.OnOpenWith),
	("-",None,None),
	("&amp;Close","Ctrl+W",self.OnClose),
	("&amp;Save","Ctrl+S",self.OnSave),
	("Save &amp;As","Shift+Ctrl+S",self.OnSaveAs),
	("Save To",None,self.OnSaveTo), # &amp;Tangle
	("Re&amp;vert To Saved",None,self.OnRevert)) # &amp;Read/Write
		
self.createMenuEntries(fileMenu,table)

</t>
<t tx="T1500">recentFilesMenu = self.createNewMenu("Recent &amp;Files...","File")
self.recentFiles = app().config.getRecentFiles()
self.createRecentFilesMenuItems()

</t>
<t tx="T1501">readWriteMenu = self.createNewMenu("&amp;Read/Write...","File")

table = (
	("&amp;Read Outline Only","Shift+Ctrl+R",self.OnReadOutlineOnly),
	("Read @file &amp;Nodes",None,self.OnReadAtFileNodes),
	("Write &amp;Outline Only",None,self.OnWriteOutlineOnly),
	("&amp;Write @file Nodes","Shift+Ctrl+W",self.OnWriteAtFileNodes))

self.createMenuEntries(readWriteMenu,table)

</t>
<t tx="T1502">tangleMenu = self.createNewMenu("&amp;Tangle...","File")

table = (
	("Tangle &amp;All","Shift+Ctrl+A",self.OnTangleAll),
	("Tangle &amp;Marked","Shift+Ctrl+M",self.OnTangleMarked),
	("&amp;Tangle","Shift+Ctrl+T",self.OnTangle))

self.createMenuEntries(tangleMenu,table)

</t>
<t tx="T1503">untangleMenu = self.createNewMenu("&amp;Untangle...","File")

table = (
	("Untangle &amp;All",None,self.OnUntangleAll),
	("Untangle &amp;Marked",None,self.OnUntangleMarked),
	("&amp;Untangle","Shift+Ctrl+U",self.OnUntangle))
	
self.createMenuEntries(untangleMenu,table)

</t>
<t tx="T1504">importMenu = self.createNewMenu("&amp;Import...","File")

table = (
	("Import To @&amp;file","Shift+Ctrl+F",self.OnImportAtFile),
	("Import To @&amp;root",None,self.OnImportAtRoot),
	("Import &amp;CWEB Files",None,self.OnImportCWEBFiles),
	("Import &amp;noweb Files",None,self.OnImportNowebFiles),
	("Import Flattened &amp;Outline",None,self.OnImportFlattenedOutline))

self.createMenuEntries(importMenu,table)

</t>
<t tx="T1505">exportMenu = self.createNewMenu("&amp;Export...","File")

table = (
	("Export &amp;Headlines",None,self.OnExportHeadlines),
	("Outline To &amp;CWEB",None,self.OnOutlineToCWEB),
	("Outline To &amp;Noweb",None,self.OnOutlineToNoweb),
	("&amp;Flatten Outline",None,self.OnFlattenOutline),
	("&amp;Remove Sentinels",None,self.OnRemoveSentinels),
	("&amp;Weave",None,self.OnWeave))

self.createMenuEntries(exportMenu,table)
</t>
<t tx="T1506">outlineMenu = self.createNewMenu("&amp;Outline")
&lt;&lt; create top-level outline menu &gt;&gt;
&lt;&lt; create expand submenu &gt;&gt;
&lt;&lt; create contract submenu &gt;&gt;
&lt;&lt; create move submenu &gt;&gt;
&lt;&lt; create mark submenu &gt;&gt;
&lt;&lt; create goto submenu &gt;&gt;</t>
<t tx="T1507">table = (
	("C&amp;ut Node","Shift+Ctrl+X",self.OnCutNode),
	("C&amp;opy Node","Shift+Ctrl+C",self.OnCopyNode),
	("&amp;Paste Node","Shift+Ctrl+V",self.OnPasteNode),
	("&amp;Delete Node","Shift+Ctrl+BkSp",self.OnDeleteNode),
	("-",None,None),
	("&amp;Insert Node","Ctrl+I",self.OnInsertNode),
	("&amp;Clone Node","Ctrl+`",self.OnCloneNode),
	("Sort C&amp;hildren",None,self.OnSortChildren),
	("&amp;Sort Siblings","Alt-A",self.OnSortSiblings),
	("-",None,None))

self.createMenuEntries(outlineMenu,table)</t>
<t tx="T1508">expandMenu = self.createNewMenu("&amp;Expand...","Outline")

table = (
	("Expand &amp;All","Alt+9",self.OnExpandAll),
	("Expand All C&amp;hildren",None,self.OnExpandAllChildren),
	("Expand &amp;Children",None,self.OnExpandChildren),
	("-",None,None),
	("Expand &amp;Next Level","Alt+=",self.OnExpandNextLevel),
	("Expand To Level &amp;2","Alt+2",self.OnExpandToLevel2),
	("Expand To Level &amp;3","Alt+3",self.OnExpandToLevel3),
	("Expand To Level &amp;4","Alt+4",self.OnExpandToLevel4),
	("Expand To Level &amp;5","Alt+5",self.OnExpandToLevel5),
	("Expand To Level &amp;6","Alt+6",self.OnExpandToLevel6),
	("Expand To Level &amp;7","Alt+7",self.OnExpandToLevel7),
	("Expand To Level &amp;8","Alt+8",self.OnExpandToLevel8))

self.createMenuEntries(expandMenu,table)
</t>
<t tx="T1509">contractMenu = self.createNewMenu("Co&amp;ntract...","Outline")

table = (
	("Contract &amp;Parent","Alt+0",self.OnContractParent),
	("Contract &amp;All","Alt+1",self.OnContractAll),
	("Contract All C&amp;hildren",None,self.OnContractAllChildren),
	("Contract &amp;Children",None,self.OnContractChildren))

self.createMenuEntries(contractMenu,table)</t>
<t tx="T1510">moveSelectMenu = self.createNewMenu("&amp;Move...","Outline")

table = (
	("Move &amp;Down", "Ctrl+D",self.OnMoveDown),
	("Move &amp;Left", "Ctrl+L",self.OnMoveLeft),
	("Move &amp;Right","Ctrl+R",self.OnMoveRight),
	("Move &amp;Up",   "Ctrl+U",self.OnMoveUp),
	("-",None,None),
	("&amp;Promote","Ctrl+{",self.OnPromote),
	("&amp;Demote", "Ctrl+}",self.OnDemote))
	
self.createMenuEntries(moveSelectMenu,table)
</t>
<t tx="T1511">markMenu = self.createNewMenu("M&amp;ark/Unmark...","Outline")

table = (
	("&amp;Mark","Ctrl-M",self.OnMark),
	("Mark &amp;Subheads","Alt+S",self.OnMarkSubheads),
	("Mark Changed &amp;Items","Alt+C",self.OnMarkChangedItems),
	("Mark Changed &amp;Roots","Alt+R",self.OnMarkChangedRoots),
	("Mark &amp;Clones","Alt+K",self.OnMarkClones),
	("&amp;Unmark All","Alt+U",self.OnUnmarkAll))
	
self.createMenuEntries(markMenu,table)
</t>
<t tx="T1512">gotoMenu = self.createNewMenu("&amp;Go To...","Outline")

table = (
	("Go To Next &amp;Marked","Alt+M",self.OnGoToNextMarked),
	("Go To Next C&amp;hanged","Alt+D",self.OnGoToNextChanged),
	("Go To &amp;Next &amp;Clone","Alt+N",self.OnGoToNextClone),
	("-",None,None),
	("Go To &amp;Prev Visible","Alt-UpArrow",self.OnGoPrevVisible),
	("Go To Next &amp;Visible","Alt-DnArrow",self.OnGoNextVisible),
	("Go &amp;Back","Alt-Shift+UpArrow",self.OnGoBack),
	("Go &amp;Next","Alt-Shift-DnArrow",self.OnGoNext))
	
self.createMenuEntries(gotoMenu,table)
</t>
<t tx="T1513">windowMenu = self.createNewMenu("&amp;Window")

table = (
	("&amp;Equal Sized Panes","Ctrl-E",self.OnEqualSizedPanes),
	("Toggle &amp;Active Pane","Ctrl-T",self.OnToggleActivePane),
	("Toggle &amp;Split Direction",None,self.OnToggleSplitDirection),
	("-",None,None),
	("Casca&amp;de",None,self.OnCascade),
	("&amp;Minimize All",None,self.OnMinimizeAll),
	("-",None,None),
	("Open &amp;Compare Window",None,self.OnOpenCompareWindow),
	("Open &amp;Python Window","Alt+P",self.OnOpenPythonWindow))

self.createMenuEntries(windowMenu,table)
</t>
<t tx="T1514">helpMenu = self.createNewMenu("&amp;Help")

table = (
	("&amp;About Leo...",None,self.OnAbout),
	("Online &amp;Home Page",None,self.OnLeoHome),
	("-",None,None),
	("Open Online &amp;Tutorial",None,self.OnLeoTutorial))

self.createMenuEntries(helpMenu,table)

if sys.platform=="win32":
	table = (("Open &amp;Offline Tutorial",None,self.OnLeoHelp),)
	self.createMenuEntries(helpMenu,table)

table = (
	("Open Leo&amp;Docs.leo",None,self.OnLeoDocumentation),
	("-",None,None),
	("Open Leo&amp;Config.leo",None,self.OnLeoConfig),
	("Apply &amp;Settings",None,self.OnApplyConfig))

self.createMenuEntries(helpMenu,table)</t>
<t tx="T1515">def createRecentFilesMenuItems (self):
	
	f = self
	recentFilesMenu = f.getMenu("Recent Files...")
	recentFilesMenu.delete(0,len(f.recentFiles))
	i = 1
	for name in f.recentFiles:
		callback = lambda f=f,name=name:f.OnOpenRecentFile(name)
		label = str(i)+" "+name
		recentFilesMenu.add_command(label=label,command=callback,underline=0)
		i += 1
</t>
<t tx="T1516">def getMenu (self,menuName):

	cmn = canonicalizeMenuName(menuName)
	return self.menus.get(cmn)
	
def setMenu (self,menuName,menu):
	
	cmn = canonicalizeMenuName(menuName)
	self.menus [cmn] = menu
	
def destroyMenu (self,menuName):
	
	cmn = canonicalizeMenuName(menuName)
	del self.menus[cmn]
</t>
<t tx="T1517"></t>
<t tx="T1518"></t>
<t tx="T1519"></t>
<t tx="T1520">def OnOpen(self,event=None):

	c = self.commands
	&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;
	# trace(`closeFlag`)

	fileName = tkFileDialog.askopenfilename(
		title="Open",
		filetypes=[("Leo files", "*.leo"), ("All files", "*")],
		defaultextension=".leo")

	if fileName and len(fileName) &gt; 0:
		ok, frame = self.OpenWithFileName(fileName)
		if ok and closeFlag:
			app().windowList.remove(self)
			self.destroy() # force the window to go away now.
			app().log = frame # Sets the log stream for es()
</t>
<t tx="T1521">@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c
	
closeFlag = (
	self.startupWindow==true and # The window was open on startup
	c.changed==false and self.saved==false and # The window has never been changed
	app().numberOfWindows == 1) # Only one untitled window has ever been opened
</t>
<t tx="T1522">def OnSave(self,event=None):

	c = self.commands
	
	# Make sure we never pass None to the ctor.
	if not self.mFileName:
		self.title = ""
		self.mFileName = ""

	if self.mFileName != "":
		c.fileCommands.save(self.mFileName)
		c.setChanged(false)
		return

	fileName = tkFileDialog.asksaveasfilename(
		initialfile = self.mFileName,
		title="Save",
		filetypes=[("Leo files", "*.leo")],
		defaultextension=".leo")

	if len(fileName) &gt; 0:
		# 7/2/02: don't change mFileName until the dialog has suceeded.
		self.mFileName = ensure_extension(fileName, ".leo")
		self.title = self.mFileName
		self.top.title(self.mFileName)
		c.fileCommands.save(self.mFileName)</t>
<t tx="T1523">def OnSaveAs(self,event=None):

	# Make sure we never pass None to the ctor.
	if not self.mFileName:
		self.title = ""
		
	fileName = tkFileDialog.asksaveasfilename(
		initialfile = self.mFileName,
		title="Save As",
		filetypes=[("Leo files", "*.leo")],
		defaultextension=".leo")

	if len(fileName) &gt; 0:
		# 7/2/02: don't change mFileName until the dialog has suceeded.
		self.mFileName = ensure_extension(fileName, ".leo")
		self.title = self.mFileName
		self.top.title(self.mFileName)
		self.commands.fileCommands.saveAs(self.mFileName)
</t>
<t tx="T1524">def OnSaveTo(self,event=None):

	# Make sure we never pass None to the ctor.
	if not self.mFileName:
		self.title = ""

	# set local fileName, _not_ self.mFileName
	fileName = tkFileDialog.asksaveasfilename(
		initialfile = self.mFileName,
		title="Save To",
		filetypes=[("Leo files", "*.leo")],
		defaultextension=".leo")

	if len(fileName) &gt; 0:
		fileName = ensure_extension(fileName, ".leo")
		self.commands.fileCommands.saveTo(fileName)
</t>
<t tx="T1525"></t>
<t tx="T1526"></t>
<t tx="T1527">def OnReadOutlineOnly (self,event=None):

	fileName = tkFileDialog.askopenfilename(
		title="Read Outline Only",
		filetypes=[("Leo files", "*.leo"), ("All files", "*")],
		defaultextension=".leo")

	if not fileName or len(fileName) == 0:
		return
		
	try: # 11/18/02
		file = open(fileName,'r')
		frame = LeoFrame(fileName)
		frame.top.deiconify()
		frame.top.lift()
		app().root.update() # Force a screen redraw immediately.
		frame.commands.fileCommands.readOutlineOnly(file,fileName) # closes file.
	except:
		es("can not open:" + fileName)</t>
<t tx="T1528">def OnReadAtFileNodes (self,event=None):

	c = self.commands
	
	d = leoDialog.leoDialog()
	answer = d.askOkCancel("Proceed?",
		"Read @file Nodes is not undoable." +
		"\nProceed?")

	if answer=="ok":
		c.fileCommands.readAtFileNodes()
		c.undoer.clearUndoState()
</t>
<t tx="T1529">def OnWriteOutlineOnly (self,event=None):

	self.commands.fileCommands.writeOutlineOnly()
</t>
<t tx="T1530">def OnWriteAtFileNodes (self,event=None):

	self.commands.fileCommands.writeAtFileNodes()
</t>
<t tx="T1531"></t>
<t tx="T1532">def OnTangleAll(self,event=None):

	self.commands.tangleCommands.tangleAll()
</t>
<t tx="T1533">def OnTangleMarked(self,event=None):

	self.commands.tangleCommands.tangleMarked()
</t>
<t tx="T1534">def OnTangle (self,event=None):

	self.commands.tangleCommands.tangle()
</t>
<t tx="T1535"></t>
<t tx="T1536">def OnUntangleAll(self,event=None):

	c = self.commands
	c.tangleCommands.untangleAll()
	c.undoer.clearUndoState()
</t>
<t tx="T1537">def OnUntangleMarked(self,event=None):

	c = self.commands
	self.commands.tangleCommands.untangleMarked()
	c.undoer.clearUndoState()
</t>
<t tx="T1538">def OnUntangle(self,event=None):

	c = self.commands
	self.commands.tangleCommands.untangle()
	c.undoer.clearUndoState()
</t>
<t tx="T1539"></t>
<t tx="T1540">def OnExportHeadlines (self,event=None):
	
	filetypes = [("Text files", "*.txt"),("All files", "*")]

	fileName = tkFileDialog.asksaveasfilename(
		title="Export Headlines",filetypes=filetypes,
		initialfile="headlines.txt",defaultextension=".txt")

	if fileName and len(fileName) &gt; 0:
		self.commands.importCommands.exportHeadlines(fileName)
</t>
<t tx="T1541">def OnFlattenOutline (self,event=None):
	
	filetypes = [("Text files", "*.txt"),("All files", "*")]

	fileName = tkFileDialog.asksaveasfilename(
		title="Flatten Outline",filetypes=filetypes,
		initialfile="flat.txt",defaultextension=".txt")

	if fileName and len(fileName) &gt; 0:
		c = self.commands
		c.importCommands.flattenOutline(fileName)
</t>
<t tx="T1542">def OnImportAtRoot (self,event=None):
	
	types = [
		("All files","*"),
		("C/C++ files","*.c"),
		("C/C++ files","*.cpp"),
		("C/C++ files","*.h"),
		("C/C++ files","*.hpp"),
		("Java files","*.java"),
		("Pascal files","*.pas"),
		("Python files","*.py") ]

	fileName = tkFileDialog.askopenfilename(
		title="Import To @root",filetypes=types)
	if fileName and len(fileName) &gt; 0:
		c = self.commands
		paths = [fileName] # alas, askopenfilename returns only a single name.
		c.importCommands.importFilesCommand (paths,"@root")
</t>
<t tx="T1543">def OnImportAtFile (self,event=None):
	
	types = [
		("All files","*"),
		("C/C++ files","*.c"),
		("C/C++ files","*.cpp"),
		("C/C++ files","*.h"),
		("C/C++ files","*.hpp"),
		("Java files","*.java"),
		("Pascal files","*.pas"),
		("Python files","*.py") ]
			
	fileName = tkFileDialog.askopenfilename(
		title="Import To @file",filetypes=types)
	if fileName and len(fileName) &gt; 0:
		c = self.commands
		paths = [fileName] # alas, askopenfilename returns only a single name.
		c.importCommands.importFilesCommand (paths,"@file")
</t>
<t tx="T1544">def OnImportCWEBFiles (self,event=None):
	
	filetypes = [
		("CWEB files", "*.w"),
		("Text files", "*.txt"),
		("All files", "*")]

	fileName = tkFileDialog.askopenfilename(
		title="Import CWEB Files",filetypes=filetypes,
		defaultextension=".w")
	if fileName and len(fileName) &gt; 0:
		c = self.commands
		paths = [fileName] # alas, askopenfilename returns only a single name.
		c.importCommands.importWebCommand(paths,"cweb")
</t>
<t tx="T1545">def OnImportFlattenedOutline (self,event=None):
	
	types = [("Text files","*.txt"), ("All files","*")]
		
	fileName = tkFileDialog.askopenfilename(
		title="Import MORE Text",
		filetypes=types,
		defaultextension=".py")
	if fileName and len(fileName) &gt; 0:
		c = self.commands
		paths = [fileName] # alas, askopenfilename returns only a single name.
		c.importCommands.importFlattenedOutline(paths)
</t>
<t tx="T1546">def OnImportNowebFiles (self,event=None):
	
	filetypes = [
		("Noweb files", "*.nw"),
		("Text files", "*.txt"),
		("All files", "*")]

	fileName = tkFileDialog.askopenfilename(
		title="Import Noweb Files",filetypes=filetypes,
		defaultextension=".nw")
	if fileName and len(fileName) &gt; 0:
		c = self.commands
		paths = [fileName] # alas, askopenfilename returns only a single name.
		c.importCommands.importWebCommand(paths,"noweb")
</t>
<t tx="T1547">def OnOutlineToCWEB (self,event=None):
	
	filetypes=[
		("CWEB files", "*.w"),
		("Text files", "*.txt"),
		("All files", "*")]

	fileName = tkFileDialog.asksaveasfilename(
		title="Outline To CWEB",filetypes=filetypes,
		initialfile="cweb.w",defaultextension=".w")

	if fileName and len(fileName) &gt; 0:
		c = self.commands
		c.importCommands.outlineToWeb(fileName,"cweb")
</t>
<t tx="T1548">def OnOutlineToNoweb (self,event=None):
	
	filetypes=[
		("Noweb files", "*.nw"),
		("Text files", "*.txt"),
		("All files", "*")]

	fileName = tkFileDialog.asksaveasfilename(
		title="Outline To Noweb",filetypes=filetypes,
		initialfile=self.outlineToNowebDefaultFileName,defaultextension=".nw")

	if fileName and len(fileName) &gt; 0:
		c = self.commands
		c.importCommands.outlineToWeb(fileName,"noweb")
		self.outlineToNowebDefaultFileName = fileName
</t>
<t tx="T1549">def OnRemoveSentinels (self,event=None):
	
	types = [
		("All files","*"),
		("C/C++ files","*.c"),
		("C/C++ files","*.cpp"),
		("C/C++ files","*.h"),
		("C/C++ files","*.hpp"),
		("Java files","*.java"),
		("Pascal files","*.pas"),
		("Python files","*.py") ]
		
	fileName = tkFileDialog.askopenfilename(
		title="Remove Sentinels",filetypes=types)

	if fileName and len(fileName) &gt; 0:
		c = self.commands
		# alas, askopenfilename returns only a single name.
		c.importCommands.removeSentinelsCommand (fileName)
</t>
<t tx="T1550">def OnWeave (self,event=None):
	
	filetypes = [("Text files", "*.txt"),("All files", "*")]

	fileName = tkFileDialog.asksaveasfilename(
		title="Weave",filetypes=filetypes,
		initialfile="weave.txt",defaultextension=".txt")

	if fileName and len(fileName) &gt; 0:
		c = self.commands
		c.importCommands.weave(fileName)
</t>
<t tx="T1551"></t>
<t tx="T1552"></t>
<t tx="T1553">def OnUndo(self,event=None):

	self.commands.undoer.undo()
</t>
<t tx="T1554">def OnRedo(self,event=None):

	self.commands.undoer.redo()
</t>
<t tx="T1555">def OnSelectAll(self,event=None):

	setTextSelection(self.body,"1.0","end")
</t>
<t tx="T1556">def OnViewAllCharacters (self, event=None):

	c = self.commands ; v = c.currentVnode() ; colorizer = c.tree.colorizer
	colorizer.showInvisibles = choose(colorizer.showInvisibles,0,1)

	# It is much easier to change the menu name here than in the menu updater.
	menu = self.getMenu("Edit")
	if colorizer.showInvisibles:
		setMenuLabel(menu,"Show Invisibles","Hide Invisibles")
	else:
		setMenuLabel(menu,"Hide Invisibles","Show Invisibles")

	c.tree.recolor_now(v)
</t>
<t tx="T1557"></t>
<t tx="T1558">def OnConvertBlanks(self,event=None):

	self.commands.convertBlanks()

	
def OnConvertAllBlanks(self,event=None):

	self.commands.convertAllBlanks()
</t>
<t tx="T1559">def OnConvertTabs(self,event=None):

	self.commands.convertTabs()
	
def OnConvertAllTabs(self,event=None):

	self.commands.convertAllTabs()

def OnReformatParagraph(self,event=None):
	
	self.commands.reformatParagraph()
</t>
<t tx="T1560">def OnDedent (self,event=None):

	self.commands.dedentBody()
</t>
<t tx="T1561">def OnExtract(self,event=None):

	self.commands.extract()
</t>
<t tx="T1562">def OnExtractNames(self,event=None):

	self.commands.extractSectionNames()
</t>
<t tx="T1563">def OnExtractSection(self,event=None):

	self.commands.extractSection()
</t>
<t tx="T1564">def OnFindMatchingBracket (self,event=None):
	
	c = self ; body = c.body
	brackets = "()[]{}&lt;&gt;"
	ch1=body.get("insert -1c")
	ch2=body.get("insert")

	# Prefer to match the character to the left of the cursor.
	if ch1 in brackets:
		ch = ch1 ; index = body.index("insert -1c")
	elif ch2 in brackets:
		ch = ch2 ; index = body.index("insert")
	else:
		return
	
	index2 = self.findMatchingBracket(ch,body,index)
	if index2:
		if body.compare(index,"&lt;=",index2):
			setTextSelection(self.body,index,index2+"+1c")
		else:
			setTextSelection(self.body,index2,index+"+1c")
		body.mark_set("insert",index2+"+1c")
		body.see(index2+"+1c")
	else:
		es("unmatched " + `ch`)
</t>
<t tx="T1565"># Test  unmatched())
def findMatchingBracket(self,ch,body,index):

	open_brackets  = "([{&lt;"
	close_brackets = ")]}&gt;"
	brackets = open_brackets + close_brackets
	matching_brackets = close_brackets + open_brackets
	forward = ch in open_brackets
	# Find the character matching the initial bracket.
	for n in xrange(len(brackets)):
		if ch == brackets[n]:
			match_ch = matching_brackets[n]
			break
	level = 0
	while 1:
		if (forward and body.compare(index, "&gt;=", "end")):
			return None
		if (not forward and body.compare(index,"&lt;=","1.0")):
			return None
		ch2 = body.get(index)
		if ch2 == ch: level += 1
		if ch2 == match_ch:
			level -= 1
			if level &lt;= 0:
				return index
		index = index + choose(forward,"+1c","-1c")
		index = body.index(index)
	return 0 # unreachable: keeps pychecker happy.
# Test  (
# ([(x){y}]))
# Test  ((x)(unmatched</t>
<t tx="T1566">def OnIndent(self,event=None):

	self.commands.indentBody()
</t>
<t tx="T1567">def OnInsertGraphicFile(self,event=None):
	
	c = self.commands
	
	filetypes = [("Gif", "*.gif"),("All files", "*.*")]
		# Only Gif images are allowed.
		#("Bitmap", "*.bmp"),
		#("Icon", "*.ico"),
	
	fileName = tkFileDialog.askopenfilename(
		title="Insert Graphic",
		filetypes=filetypes,
		defaultextension=".gif")

	if fileName and len(fileName) &gt; 0 and os.path.exists(fileName):
		try:
			fileName = os.path.join(app().loadDir,fileName)
			fileName = os.path.normpath(fileName)
			image = Tkinter.PhotoImage(file=fileName)
		except:
			es("Exception loading: " + fileName)
			es_exception()
			image = None
		if image:
			# print image.height()
			index = c.body.index("insert")
			if 1: # same behavior
				bg = c.body.cget("background")
				w = Tkinter.Label(c.body,image=image,bd=0,bg=bg)
				c.body.window_create(index,window=w,align="baseline")
			else:
				c.body.image_create(index,image=image,align="baseline")
			# c.body.dump(index) # The image isn't drawn unless we take an exception!
</t>
<t tx="T1568"></t>
<t tx="T1569">def OnEditHeadline(self,event=None):

	tree = self.commands.tree
	tree.editLabel(tree.currentVnode)
</t>
<t tx="T1570">def OnEndEditHeadline(self,event=None):
	
	tree = self.commands.tree
	tree.endEditLabelCommand()
</t>
<t tx="T1571">def OnAbortEditHeadline(self,event=None):
	
	tree = self.commands.tree
	tree.abortEditLabelCommand()
</t>
<t tx="T1572"></t>
<t tx="T1573">def OnFindPanel(self,event=None):

	find = app().findFrame
	# 15-SEP-2002 DTHEIN: call withdraw() to force findFrame to top after 
	#                     opening multiple Leo files.
	find.top.withdraw()
	find.top.deiconify()
	find.find_text.focus_set()
	find.commands = self
</t>
<t tx="T1574">def OnFindNext(self,event=None):

	c = self.commands
	app().findFrame.findNextCommand(c)
</t>
<t tx="T1575">def OnFindPrevious(self,event=None):

	c = self.commands
	app().findFrame.findPreviousCommand(c)
</t>
<t tx="T1576">def OnReplace(self,event=None):

	c = self.commands
	app().findFrame.changeCommand(c)
</t>
<t tx="T1577">def OnReplaceThenFind(self,event=None):

	c = self.commands
	app().findFrame.changeThenFindCommand(c)
</t>
<t tx="T1578"></t>
<t tx="T1579"></t>
<t tx="T1580">def OnCutNode(self,event=None):

	self.commands.cutOutline()
</t>
<t tx="T1581">def OnCopyNode(self,event=None):

	self.commands.copyOutline()
</t>
<t tx="T1582">def OnPasteNode(self,event=None):

	self.commands.pasteOutline()
</t>
<t tx="T1583">def OnDeleteNode(self,event=None):

	self.commands.deleteHeadline()
</t>
<t tx="T1584">def OnInsertNode(self,event=None):

	self.commands.insertHeadline()</t>
<t tx="T1585">def OnCloneNode(self,event=None):

	self.commands.clone()
</t>
<t tx="T1586">def OnSortChildren(self,event=None):

	self.commands.sortChildren()
	
def OnSortSiblings(self,event=None):

	self.commands.sortSiblings()</t>
<t tx="T1587"></t>
<t tx="T1588">def OnContractParent(self,event=None):

	self.commands.contractParent()
</t>
<t tx="T1589">def OnExpandAll(self,event=None):

	self.commands.expandAllHeadlines()
</t>
<t tx="T1590">def OnExpandAllChildren(self,event=None):

	self.commands.expandAllSubheads()
</t>
<t tx="T1591">def OnExpandChildren(self,event=None):

	self.commands.expandSubheads()
</t>
<t tx="T1592">def OnContractAll(self,event=None):

	self.commands.contractAllHeadlines()
</t>
<t tx="T1593">def OnContractAllChildren(self,event=None):

	self.commands.contractAllSubheads()
</t>
<t tx="T1594">def OnExpandNextLevel(self,event=None):

	self.commands.expandNextLevel()
</t>
<t tx="T1595">def OnExpandToLevel1(self,event=None):

	self.commands.expandLevel1()
</t>
<t tx="T1596">def OnExpandToLevel2(self,event=None):

	self.commands.expandLevel2()
</t>
<t tx="T1597">def OnExpandToLevel3(self,event=None):

	self.commands.expandLevel3()
</t>
<t tx="T1598">def OnExpandToLevel4(self,event=None):

	self.commands.expandLevel4()
</t>
<t tx="T1599">def OnExpandToLevel5(self,event=None):

	self.commands.expandLevel5()
</t>
<t tx="T1600">def OnExpandToLevel6(self,event=None):

	self.commands.expandLevel6()
</t>
<t tx="T1601">def OnExpandToLevel7(self,event=None):

	self.commands.expandLevel7()
</t>
<t tx="T1602">def OnExpandToLevel8(self,event=None):

	self.commands.expandLevel8()
</t>
<t tx="T1603">def OnExpandToLevel9(self,event=None):

	self.commands.expandLevel9()
</t>
<t tx="T1604"></t>
<t tx="T1605">def OnMoveDown(self,event=None):

	self.commands.moveOutlineDown()
</t>
<t tx="T1606">def OnMoveLeft(self,event=None):

	self.commands.moveOutlineLeft()
</t>
<t tx="T1607">def OnMoveRight(self,event=None):

	self.commands.moveOutlineRight()
</t>
<t tx="T1608">def OnMoveUp(self,event=None):

	self.commands.moveOutlineUp()
</t>
<t tx="T1609">def OnPromote(self,event=None):

	self.commands.promote()
</t>
<t tx="T1610">def OnDemote(self,event=None):

	self.commands.demote()
</t>
<t tx="T1611">def OnGoPrevVisible(self,event=None):

	self.commands.selectVisBack()
</t>
<t tx="T1612">def OnGoNextVisible(self,event=None):

	self.commands.selectVisNext()
</t>
<t tx="T1613">def OnGoBack(self,event=None):

	self.commands.selectThreadBack()
</t>
<t tx="T1614">def OnGoNext(self,event=None):

	self.commands.selectThreadNext()
</t>
<t tx="T1615"></t>
<t tx="T1616">def OnMark(self,event=None):

	self.commands.markHeadline()
</t>
<t tx="T1617">def OnMarkSubheads(self,event=None):

	self.commands.markSubheads()
</t>
<t tx="T1618">def OnMarkChangedItems(self,event=None):

	self.commands.markChangedHeadlines()
</t>
<t tx="T1619">def OnMarkChangedRoots(self,event=None):

	self.commands.markChangedRoots()
</t>
<t tx="T1620">def OnMarkClones(self,event=None):

	self.commands.markClones()
</t>
<t tx="T1621">def OnUnmarkAll(self,event=None):

	self.commands.unmarkAll()
</t>
<t tx="T1622">def OnGoToNextMarked(self,event=None):

	self.commands.goToNextMarkedHeadline()
</t>
<t tx="T1623">def OnGoToNextChanged(self,event=None):

	self.commands.goToNextDirtyHeadline()
</t>
<t tx="T1624">def OnGoToNextClone(self,event=None):

	self.commands.goToNextClone()
</t>
<t tx="T1625"></t>
<t tx="T1626">def OnEqualSizedPanes(self,event=None):

	frame = self

	frame.resizePanesToRatio(0.5,frame.secondary_ratio)
</t>
<t tx="T1627">def OnToggleActivePane (self,event=None):

	# trace(`event`)
	if self.getFocus() == self.body:
		self.canvas.focus_force()
	else:
		self.body.focus_force()</t>
<t tx="T1628">def OnCascade(self,event=None):
	
	c = self ; x,y,delta = 10,10,10
	for frame in app().windowList:
		top = frame.top
		# Compute w,h
		top.update_idletasks() # Required to get proper info.
		geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
		dim,junkx,junky = string.split(geom,'+')
		w,h = string.split(dim,'x')
		w,h = int(w),int(h)
		# Set new x,y and old w,h
		frame.top.geometry("%dx%d%+d%+d" % (w,h,x,y))
		# Compute the new offsets.
		x += 30 ; y += 30
		if x &gt; 200:
			x = 10 + delta ; y = 40 + delta
			delta += 10
</t>
<t tx="T1629">def OnMinimizeAll(self,event=None):

	self.minimize(app().findFrame)
	self.minimize(app().pythonFrame)
	for frame in app().windowList:
		self.minimize(frame)
	
def minimize(self, frame):

	if frame and frame.top.state() == "normal":
		frame.top.iconify()</t>
<t tx="T1630">def OnHideLogWindow (self):
	
	c = self.commands ; frame = c.frame
	frame.divideLeoSplitter2(0.99, not frame.splitVerticalFlag)</t>
<t tx="T1631"></t>
<t tx="T1632">def OnLeoDocumentation (self,event=None):

	dir = app().loadDir
	fileName = os.path.join(dir, "LeoDocs.leo")
	try:
		self.OpenWithFileName(fileName)
	except:
		es("not found: LeoDocs.leo")
</t>
<t tx="T1633">def OnLeoHome (self,event=None):
	
	import webbrowser
	
	url = "http://personalpages.tds.net/~edream/front.html"
	try:
		webbrowser.open_new(url)
	except:
		es("not found: " + url)</t>
<t tx="T1634">def OnLeoHelp (self,event=None):
	
	file = os.path.join(app().loadDir,"sbooks.chm")
	if os.path.exists(file):
		os.startfile(file)
	else:
		d = leoDialog.leoDialog()
		answer = d.askYesNo(
			"Download Tutorial?",
			"Download tutorial (sbooks.chm) from SourceForge?")
		if answer == "yes":
			try:
				if 0: # Download directly.  (showProgressBar needs a lot of work)
					url = "http://umn.dl.sourceforge.net/sourceforge/leo/sbooks.chm"
					import urllib
					self.scale = None
					urllib.urlretrieve(url,file,self.showProgressBar)
					if self.scale:
						self.scale.destroy()
						self.scale = None
				else:
					url = "http://prdownloads.sourceforge.net/leo/sbooks.chm?download"
					import webbrowser
					os.chdir(app().loadDir)
					webbrowser.open_new(url)
			except:
				es("exception dowloading sbooks.chm")
				es_exception()</t>
<t tx="T1635">def showProgressBar (self,count,size,total):

	# trace("count,size,total:" + `count` + "," + `size` + "," + `total`)
	if self.scale == None:
		&lt;&lt; create the scale widget &gt;&gt;
	self.scale.set(count*size)
	self.scale.update_idletasks()</t>
<t tx="T1636">Tk = Tkinter
top = Tk.Toplevel()
top.title("Download progress")
self.scale = scale = Tk.Scale(top,state="normal",orient="horizontal",from_=0,to=total)
scale.pack()
top.lift()</t>
<t tx="T1637">def OnLeoTutorial (self,event=None):
	
	import webbrowser

	if 1: # new url
		url = "http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm"
	else:
		url = "http://www.evisa.com/e/sbooks/leo/sbframetoc_ie.htm"
	try:
		webbrowser.open_new(url)
	except:
		es("not found: " + url)</t>
<t tx="T1638">def OnLeoConfig (self,event=None):

	dir = app().loadDir
	fileName = os.path.join(dir, "leoConfig.leo")
	try:
		self.OpenWithFileName(fileName)
	except:
		es("not found: leoConfig.leo")
	
def OnApplyConfig (self,event=None):

	app().config.init()
	self.commands.frame.reconfigureFromConfig()</t>
<t tx="T1639">@ The following convenience routines make creating menus easier.

The file customizeLeo.py shows gives examples of how to use these routines to create custom menus and to add items to the Open With menu.
</t>
<t tx="T1640">def createNewMenu (self,menuName,parentName="top"):
	
	import Tkinter
	from leoGlobals import app
	try:
		parent = self.getMenu(parentName)
		if parent == None:
			es("unknown parent menu: " + parentName)
			return None
			
		menu = self.getMenu(menuName)
		if menu:
			es("menu already exists: " + menuName)
		else:
			menu = Tkinter.Menu(parent,tearoff=0)
			self.setMenu(menuName,menu)
			label=app().getRealMenuName(menuName)
			amp_index = label.find("&amp;")
			label = label.replace("&amp;","")
			parent.add_cascade(label=label,menu=menu,underline=amp_index)
			return menu
	except:
		es("exception creating " + menuName + " menu")
		es_exception()
		return None</t>
<t tx="T1641">def deleteMenu (self,menuName):

	try:
		menu = self.getMenu(menuName)
		if menu:
			menu.destroy()
			self.destroyMenu(menuName)
		else:
			es("can't delete menu: " + menuName)
	except:
		es("exception deleting " + menuName + " menu")
		es_exception()</t>
<t tx="T1642"># Delete itemName from the menu whose name is menuName.
def deleteMenuItem (self,itemName,menuName="top"):

	from leoGlobals import app
	try:
		menu = self.getMenu(menuName)
		if menu:
			realItemName=app().getRealMenuName(itemName)
			menu.delete(realItemName)
		else:
			es("menu not found: " + menuName)
	except:
		es("exception deleting " + itemName + " from " + menuName + " menu")
		es_exception()</t>
<t tx="T1643">def setRealMenuNamesFromTable (self,table):

	try:
		app().setRealMenuNamesFromTable(table)
	except:
		es("exception in setRealMenuNamesFromTable")
		es_exception()
</t>
<t tx="T1644"></t>
<t tx="T1645"># Returns true if text in the outline or body text is selected.

def hasSelection (self):

	if self.body:
		first, last = getTextSelection(self.body)
		return first != last
	else:
		return false</t>
<t tx="T1646">def updateFileMenu (self):
	
	c = self.commands
	if not c: return

	menu = self.getMenu("File")
	enableMenu(menu,"Revert To Saved", c.canRevert())
	
	openWithMenu = self.getMenu("Open With...")
	enableMenu(menu,"Open With...", openWithMenu != None)</t>
<t tx="T1647">def updateEditMenu (self):

	c = self.commands
	if not c: return
	
	# Top level Edit menu...
	menu = self.getMenu("Edit")
	c.undoer.enableMenuItems()
	if 0: # Always on for now.
		enableMenu(menu,"Cut",c.canCut())
		enableMenu(menu,"Copy",c.canCut()) # delete
		enableMenu(menu,"Paste",c.canPaste())
	if 0: # Always on for now.
		menu = self.getMenu("Find...")
		enableMenu(menu,"Find Next",c.canFind())
		flag = c.canReplace()
		enableMenu(menu,"Replace",flag)
		enableMenu(menu,"Replace, Then Find",flag)
	# Edit Body submenu...
	menu = self.getMenu("Edit Body...")
	enableMenu(menu,"Extract Section",c.canExtractSection())
	enableMenu(menu,"Extract Names",c.canExtractSectionNames())
	enableMenu(menu,"Extract",c.canExtract())
	enableMenu(menu,"Match Brackets",c.canFindMatchingBracket())</t>
<t tx="T1648">def updateOutlineMenu (self):

	c = self.commands ; v = c.currentVnode()
	if not c: return

	# Top level outline menu...
	menu = self.getMenu("Outline")
	enableMenu(menu,"Cut Node",c.canCutOutline())
	enableMenu(menu,"Delete Node",c.canDeleteHeadline())
	enableMenu(menu,"Paste Node",c.canPasteOutline())
	enableMenu(menu,"Sort Siblings",c.canSortSiblings())
	# Contract submenu...
	menu = self.getMenu("Contract...")
	enableMenu(menu,"Contract Parent",c.canContractParent())
	# Move submenu...
	menu = self.getMenu("Move...")
	enableMenu(menu,"Move Down",c.canMoveOutlineDown())
	enableMenu(menu,"Move Left",c.canMoveOutlineLeft())
	enableMenu(menu,"Move Right",c.canMoveOutlineRight())
	enableMenu(menu,"Move Up",c.canMoveOutlineUp())
	enableMenu(menu,"Promote",c.canPromote())
	enableMenu(menu,"Demote",c.canDemote())
	# Go To submenu
	menu = self.getMenu("Go To...")
	enableMenu(menu,"Go To Prev Visible",c.canSelectVisBack())
	enableMenu(menu,"Go To Next Visible",c.canSelectVisNext())
	enableMenu(menu,"Go To Next Marked",c.canGoToNextMarkedHeadline())
	enableMenu(menu,"Go To Next Changed",c.canGoToNextDirtyHeadline())
	enableMenu(menu,"Go To Next Clone",v.isCloned())
	enableMenu(menu,"Go Back",c.canSelectThreadBack())
	enableMenu(menu,"Go Next",c.canSelectThreadNext())
	# Mark submenu
	menu = self.getMenu("Mark/Unmark...")
	label = choose(v and v.isMarked(),"Unmark","Mark")
	setMenuLabel(menu,0,label)
	enableMenu(menu,"Mark Subheads",(v and v.hasChildren()))
	enableMenu(menu,"Mark Changed Items",c.canMarkChangedHeadlines())
	enableMenu(menu,"Mark Changed Roots",c.canMarkChangedRoots())
	enableMenu(menu,"Mark Clones",v.isCloned())
</t>
<t tx="T1649">@ The key invariants used throughout this code:

1. self.splitVerticalFlag tells the alignment of the main splitter and
2. not self.splitVerticalFlag tells the alignment of the secondary splitter.

Only the general-purpose divideAnySplitter routine doesn't know about these invariants.  So most of this code is specialized for Leo's window.  OTOH, creating a single splitter window would be much easier than this code.
</t>
<t tx="T1650">def bindBar (self, bar, verticalFlag):
	
	if verticalFlag == self.splitVerticalFlag:
		bar.bind("&lt;B1-Motion&gt;", self.onDragMainSplitBar)
	else:
		bar.bind("&lt;B1-Motion&gt;", self.onDragSecondarySplitBar)</t>
<t tx="T1651"># Create a splitter window and panes into which the caller packs widgets.
# Returns (f, bar, pane1, pane2)

def createLeoSplitter (self, parent, verticalFlag):

	Tk = Tkinter
	# Create the frames.
	f = Tk.Frame(parent,width="8i",height="6.5i",bd=0,bg="white",relief="flat")
	f.pack(expand=1,fill="both")
	pane1 = Tk.Frame(f,bd=0,bg="white",relief="flat")
	pane2 = Tk.Frame(f,bg="white",relief="flat")
	bar =   Tk.Frame(f,bd=2,relief="raised",bg="LightSteelBlue2")
	# Configure and place the frames.
	self.configureBar(bar,verticalFlag)
	self.bindBar(bar,verticalFlag)
	self.placeSplitter(bar,pane1,pane2,verticalFlag)
	
	return f, bar, pane1, pane2</t>
<t tx="T1652"># This is the general-purpose placer for splitters.
# It is the only general-purpose splitter code in Leo.

def divideAnySplitter (self, frac, verticalFlag, bar, pane1, pane2):

	if verticalFlag:
		# Panes arranged vertically; horizontal splitter bar
		bar.place(rely=frac)
		pane1.place(relheight=frac)
		pane2.place(relheight=1-frac)
	else:
		# Panes arranged horizontally; vertical splitter bar
		bar.place(relx=frac)
		pane1.place(relwidth=frac)
		pane2.place(relwidth=1-frac)</t>
<t tx="T1653"># Divides the main or secondary splitter, using the key invariant.
def divideLeoSplitter (self, verticalFlag, frac):
	if self.splitVerticalFlag == verticalFlag:
		self.divideLeoSplitter1(frac,verticalFlag)
		self.ratio = frac # Ratio of body pane to tree pane.
	else:
		self.divideLeoSplitter2(frac,verticalFlag)
		self.secondary_ratio = frac # Ratio of tree pane to log pane.

# Divides the main splitter.
def divideLeoSplitter1 (self, frac, verticalFlag): 
	self.divideAnySplitter(frac, verticalFlag,
		self.bar1, self.split1Pane1, self.split1Pane2)

# Divides the secondary splitter.
def divideLeoSplitter2 (self, frac, verticalFlag): 
	self.divideAnySplitter (frac, verticalFlag,
		self.bar2, self.split2Pane1, self.split2Pane2)</t>
<t tx="T1654">def onDragMainSplitBar (self, event):
	self.onDragSplitterBar(event,self.splitVerticalFlag)
	
def onDragSecondarySplitBar (self, event):
	self.onDragSplitterBar(event,not self.splitVerticalFlag)

def onDragSplitterBar (self, event, verticalFlag):

	# x and y are the coordinates of the cursor relative to the bar, not the main window.
	bar = event.widget
	x = event.x
	y = event.y
	top = bar.winfo_toplevel()

	if verticalFlag:
		# Panes arranged vertically; horizontal splitter bar
		wRoot	= top.winfo_rooty()
		barRoot = bar.winfo_rooty()
		wMax	= top.winfo_height()
		offset = float(barRoot) + y - wRoot
	else:
		# Panes arranged horizontally; vertical splitter bar
		wRoot	= top.winfo_rootx()
		barRoot = bar.winfo_rootx()
		wMax	= top.winfo_width()
		offset = float(barRoot) + x - wRoot

	# Adjust the pixels, not the frac.
	if offset &lt; 3: offset = 3
	if offset &gt; wMax - 2: offset = wMax - 2
	# Redraw the splitter as the drag is occuring.
	frac = float(offset) / wMax
	# trace(`frac`)
	self.divideLeoSplitter(verticalFlag, frac)</t>
<t tx="T1655">def placeSplitter (self,bar,pane1,pane2,verticalFlag):

	if verticalFlag:
		# Panes arranged vertically; horizontal splitter bar
		pane1.place(relx=0.5, rely =   0, anchor="n", relwidth=1.0, relheight=0.5)
		pane2.place(relx=0.5, rely = 1.0, anchor="s", relwidth=1.0, relheight=0.5)
		bar.place  (relx=0.5, rely = 0.5, anchor="c", relwidth=1.0)
	else:
		# Panes arranged horizontally; vertical splitter bar
		# adj gives tree pane more room when tiling vertically.
		adj = choose(verticalFlag != self.splitVerticalFlag,0.65,0.5)
		pane1.place(rely=0.5, relx =   0, anchor="w", relheight=1.0, relwidth=adj)
		pane2.place(rely=0.5, relx = 1.0, anchor="e", relheight=1.0, relwidth=1.0-adj)
		bar.place  (rely=0.5, relx = adj, anchor="c", relheight=1.0)</t>
<t tx="T1656">def configureBarsFromConfig (self):
	
	config = app().config

	w = config.getWindowPref("split_bar_width")
	if not w or w &lt; 1: w = 7
	
	relief = config.getWindowPref("split_bar_relief")
	if not relief or relief == "": relief = "flat"

	color = config.getWindowPref("split_bar_color")
	if not color or color == "": color = "LightSteelBlue2"

	if self.splitVerticalFlag:
		bar1,bar2=self.bar1,self.bar2
	else:
		bar1,bar2=self.bar2,self.bar1
		
	try:
		bar1.configure(relief=relief,height=w,bg=color)
		bar2.configure(relief=relief,width=w,bg=color)
	except: # Could be a user error.
		es("exception in user configuration for splitbar")
		es_exception()</t>
<t tx="T1657">def reconfigureFromConfig (self):
	
	f = self ; c = f.commands
	
	# Not ready yet: just reset the width and color.
	# We need self.bar1 and self.bar2 ivars.
	# self.reconfigureBar(...)
	
	# The calls to redraw are workarounds for an apparent Tk bug.
	# Without them the text settings get applied to the wrong widget!
	# Moreover, only this order seems to work on Windows XP...
	f.tree.setFontFromConfig()
	f.setTreeColorsFromConfig()
	f.configureBarsFromConfig()
	c.redraw()
	f.setBodyFontFromConfig()
	f.setTabWidth(c.tab_width)
	c.redraw()
	f.setLogFontFromConfig()
	c.redraw()</t>
<t tx="T1658">def setBodyFontFromConfig (self):
	
	config = app().config ; body = self.body
	#print "body",self.body
	
	font = config.getFontFromParams(
		"body_text_font_family", "body_text_font_size",
		"body_text_font_slant",  "body_text_font_weight")

	body.configure(font=font)
	
	bg = config.getWindowPref("body_text_background_color")
	if bg:
		try: body.configure(bg=bg)
		except: pass
	
	fg = config.getWindowPref("body_text_foreground_color")
	if fg:
		try: body.configure(fg=fg)
		except: pass
		
	if sys.platform != "win32": # Maybe a Windows bug.
		fg = config.getWindowPref("body_cursor_foreground_color")
		bg = config.getWindowPref("body_cursor_background_color")
		# print fg, bg
		if fg and bg:
			cursor="xterm" + " " + fg + " " + bg
			try: body.configure(cursor=cursor)
			except:
				import traceback
				traceback.print_exc()</t>
<t tx="T1659">def setLogFontFromConfig (self):

	log = self.log ; config = app().config
	#print "log",self.log

	font = config.getFontFromParams(
		"log_text_font_family", "log_text_font_size",
		"log_text_font_slant",  "log_text_font_weight")
	
	log.configure(font=font)
	
	bg = config.getWindowPref("log_text_background_color")
	if bg:
		try: log.configure(bg=bg)
		except: pass
	
	fg = config.getWindowPref("log_text_foreground_color")
	if fg:
		try: log.configure(fg=fg)
		except: pass
</t>
<t tx="T1660">@ignore</t>
<t tx="T1661">try:
	self.scanAllDirectives(root)
	valid = self.errors == 0
except:
	es("exception in atFile.scanAllDirectives")
	es_exception()
	valid = false

if valid:
	try:
		fn = root.atFileNodeName()
		self.shortFileName = fn # name to use in status messages.
		self.targetFileName = os.path.join(self.default_directory,fn)
		self.targetFileName = os.path.normpath(self.targetFileName)
		path = os.path.dirname(self.targetFileName)
		if path and len(path) &gt; 0:
			valid = os.path.exists(path)
			if not valid:
				self.writeError("path does not exist: " + path)
		else:
			valid = false
	except:
		es("exception creating path:" + fn)
		es_exception()
		valid = false

if valid:
	if os.path.exists(self.targetFileName):
		try: # 8/13/02
			read_only = not os.access(self.targetFileName,os.W_OK)
			if read_only:
				es("read only: " + self.targetFileName)
				valid = false
		except: pass # os.access() may not exist on all platforms.
	
if valid:
	try:
		self.outputFileName = self.targetFileName + ".tmp"
		# Use "text" mode for platform-specific newlines.
		mode = app().config.output_newline
		mode = choose(mode=="platform",'w','wb')
		self.outputFile = open(self.outputFileName, mode)
		valid = self.outputFile != None
		if not valid:
			self.writeError("can not open " + self.outputFileName)
	except:
		es("exception opening:" + self.outputFileName)
		es_exception()
		valid = false

if not valid:
	root.setOrphan()
	root.setDirty()
	return</t>
<t tx="T1662">def getOutputNewline ():
	
	s = app().config.output_newline
	s = string.lower(s)
	if s == "nl" or s == "lf": s = '\n'
	elif s == "cr": s = '\r'
	elif s == "crlf": s = "\r\n"
	else: s = '\n'
	return s
</t>
<t tx="T1663"></t>
<t tx="T1664">@ Headlines not containing a section reference are ignored in noweb and generate index index in cweb.
@c

def convertCodePartToWeb (self,s,i,v,result):

	# line = get_line(s,i) ; trace(`line`)
	c = self.commands ; nl = self.output_newline
	lb = choose(self.webType=="cweb","@&lt;","&lt;&lt;")
	rb = choose(self.webType=="cweb","@&gt;","&gt;&gt;")
	h = string.strip(v.headString())
	&lt;&lt; put v's headline ref in head_ref &gt;&gt;
	&lt;&lt; put name following @root or @file in file_name &gt;&gt;
	if match_word(s,i,"@root"):
		i = skip_line(s,i)
		&lt;&lt; append ref to file_name &gt;&gt;
	elif match_word(s,i,"@c") or match_word(s,i,"@code"):
		i = skip_line(s,i)
		&lt;&lt; append head_ref &gt;&gt;
	elif match_word(h,0,"@file"):
		# Only do this if nothing else matches.
		&lt;&lt; append ref to file_name &gt;&gt;
		i = skip_line(s,i) # 4/28/02
	else:
		&lt;&lt; append head_ref &gt;&gt;
	i,result = self.copyPart(s,i,result)
	return i, string.strip(result) + nl
	
@ %defs a b c
</t>
<t tx="T1665">@ We look for either noweb or cweb brackets. head_ref does not include these brackets.
@c

head_ref = None
j = 0
if match(h,j,"&lt;&lt;"):
	k = string.find(h,"&gt;&gt;",j)
elif match(h,j,"&lt;@"):
	k = string.find(h,"@&gt;",j)
else:
	k = -1

if k &gt; -1:
	head_ref = string.strip(h[j+2:k])
	if len(head_ref) == 0:
		head_ref = None</t>
<t tx="T1666">if match(h,0,"@file") or match(h,0,"@root"):
	line = h[5:]
	line = string.strip(line)
	&lt;&lt; set file_name &gt;&gt;
else:
	file_name = line = None
</t>
<t tx="T1667"># set j &amp; k so line[j:k] is the file name.
# trace(`line`)

if match(line,0,"&lt;"):
	j = 1 ; k = string.find(line,"&gt;",1)
elif match(line,0,'"'):
	j = 1 ; k = string.find(line,'"',1)
else:
	j = 0 ; k = string.find(line," ",0)
if k == -1:
	k = len(line)

file_name = string.strip(line[j:k])
if file_name and len(file_name) == 0:
	file_name = None</t>
<t tx="T1668">if self.webType == "cweb":
	if not file_name:
		result += "@&lt;root@&gt;=" + nl
	else:
		result += "@(" + file_name + "@&gt;" + nl # @(...@&gt; denotes a file.
else:
	if not file_name:
		file_name = "*"
	result += lb + file_name + rb + "=" + nl
</t>
<t tx="T1669">if self.webType == "cweb":
	if not head_ref:
		result += "@^" + h + "@&gt;" + nl # Convert the headline to an index entry.
		result += "@c" + nl # @c denotes a new section.
	else: 
		escaped_head_ref = string.replace(head_ref,"@","@@")
		result += "@&lt;" + escaped_head_ref + "@&gt;=" + nl
else:
	if not head_ref:
		if v == c.currentVnode():
			head_ref = choose(file_name,file_name,"*")
		else:
			head_ref = "@others"

	result += lb + head_ref + rb + "=" + nl</t>
<t tx="T1670">def convertDocPartToWeb (self,s,i,result):
	
	nl = self.output_newline

	# line = get_line(s,i) ; trace(`line`)
	if match_word(s,i,"@doc"):
		i = skip_line(s,i)
	elif match(s,i,"@ ") or match(s,i,"@\t") or match(s,i,"@*"):
		i += 2
	elif match(s,i,"@\n"):
		i += 1
	i = skip_ws_and_nl(s,i)
	i, result2 = self.copyPart(s,i,"")
	if len(result2) &gt; 0:
		# Break lines after periods.
		result2 = string.replace(result2,".  ","." + nl)
		result2 = string.replace(result2,". ","." + nl)
		result += nl+"@"+nl+string.strip(result2)+nl+nl
	else:
		# All nodes should start with '@', even if the doc part is empty.
		result += choose(self.webType=="cweb",nl+"@ ",nl+"@"+nl)
	return i, result</t>
<t tx="T1671">@ This code converts a vnode to noweb text as follows:

Convert @doc to @
Convert @root or @code to &lt;&lt; name &gt;&gt;=, assuming the headline contains &lt;&lt; name &gt;&gt;
Ignore other directives
Format doc parts so they fit in pagewidth columns.
Output code parts as is.
@c

def convertVnodeToWeb (self,v):

	if not v: return ""
	nl = self.output_newline
	s = v.bodyString()
	lb = choose(self.webType=="cweb","@&lt;","&lt;&lt;")
	i = 0 ; result = "" ; docSeen = false
	while i &lt; len(s):
		progress = i
		# line = get_line(s,i) ; trace(`line`)
		i = skip_ws_and_nl(s,i)
		if self.isDocStart(s,i) or match_word(s,i,"@doc"):
			i,result = self.convertDocPartToWeb(s,i,result)
			docSeen = true
		elif (match_word(s,i,"@code") or match_word(s,i,"@root") or
			match_word(s,i,"@c") or match(s,i,lb)):
			&lt;&lt; Supply a missing doc part &gt;&gt;
			i,result = self.convertCodePartToWeb(s,i,v,result)
		elif self.treeType == "@file":
			&lt;&lt; Supply a missing doc part &gt;&gt;
			i,result = self.convertCodePartToWeb(s,i,v,result)
		else:
			i,result = self.convertDocPartToWeb(s,i,result)
			docSeen = true
		assert(progress &lt; i)
	result = string.strip(result)
	if len(result) &gt; 0:
		result += nl
	return result</t>
<t tx="T1672">if not docSeen:
	docSeen = true
	result += choose(self.webType=="cweb",nl+"@ ",nl+"@"+nl)</t>
<t tx="T1673"># Copies characters to result until the end of the present section is seen.

def copyPart (self,s,i,result):

	# line = get_line(s,i) ; trace(`line`)
	lb = choose(self.webType=="cweb","@&lt;","&lt;&lt;")
	rb = choose(self.webType=="cweb","@&gt;","&gt;&gt;")
	type = self.webType
	while i &lt; len(s):
		progress = j = i # We should be at the start of a line here.
		# line = get_line(s,i) ; trace(`line`)
		i = skip_nl(s,i) ; i = skip_ws(s,i)
		if self.isDocStart(s,i):
			return i, result
		if match_word(s,i,"@doc") or match_word(s,i,"@c") or match_word(s,i,"@root"):
			return i, result
		elif (match(s,i,"&lt;&lt;") and # must be on separate lines.
			find_on_line(s,i,"&gt;&gt;=") &gt; -1):
			return i, result
		else:
			# Copy the entire line, escaping '@' and
			# Converting @others to &lt; &lt; @ others &gt; &gt;
			i = skip_line(s,j) ; line = s[j:i]
			if type == "cweb":
				line = string.replace(line,"@","@@")
			else:
				j = skip_ws(line,0)
				if match(line,j,"@others"):
					line = string.replace(line,"@others",lb + "@others" + rb)
				elif match(line,0,"@"):
					# Special case: do not escape @ %defs.
					k = skip_ws(line,1)
					if not match(line,k,"%defs"):
						line = "@" + line
			result += line
		assert(progress &lt; i)
	return i, string.rstrip(result)</t>
<t tx="T1674">def exportHeadlines (self,fileName):
	
	c = self.commands ; v = c.currentVnode()
	nl = self.output_newline
	if not v: return
	after = v.nodeAfterTree()
	firstLevel = v.level()
	try:
		mode = app().config.output_newline
		mode = choose(mode=="platform",'w','wb')
		file = open(fileName,mode)
		while v and v != after:
			head = v.moreHead(firstLevel)
			file.write(head + nl)
			v = v.threadNext()
		file.close()
	except:
		es("exception while exporting headlines")
		es_exception()</t>
<t tx="T1675">def removeSentinelsCommand (self,fileName):

	path, self.fileName = os.path.split(fileName) # path/fileName
	# trace(`self.fileName`)
	&lt;&lt; Read file into s &gt;&gt;
	valid = true
	line_delim = start_delim = end_delim = None
	&lt;&lt; set delims from the header line &gt;&gt;
	if valid == false:
		es("invalid @+leo sentinel in " + fileName)
	else:
		if 0:
			trace("line:"+`line_delim`+","+
				"start:"+`start_delim`+","+
				"end:"+`end_delim`)
		s = self.removeSentinelLines(s,line_delim,start_delim,end_delim)
		ext = app().config.remove_sentinels_extension
		if ext == None or len(ext) == 0:
			ext = ".txt"
		if ext[0] == '.':
			newFileName = os.path.join(path,fileName+ext)
		else:
			head,ext2 = os.path.splitext(fileName) 
			newFileName = os.path.join(path,head+ext+ext2)
		# newFileName = os.path.join(path,fileName+".txt") # 8/4/02: use txt, not tmp.
		&lt;&lt; Write s into newFileName &gt;&gt;</t>
<t tx="T1676">try:
	file = open(fileName)
	s = file.read()
	file.close()
except:
	es("exception while reading " + fileName)
	es_exception()
	return</t>
<t tx="T1677">@ This code is similar to atFile::scanHeader.
@c

tag = "@+leo"
# Skip any non @+leo lines.
i = 0
while i &lt; len(s) and not find_on_line(s,i,tag):
	i = skip_line(s,i)
# We should be at the @+leo line.
i = j = skip_ws(s,i)
# The opening comment delim is the initial non-whitespace.
while i &lt; len(s) and not match(s,i,tag) and not is_ws(s[i]) and not is_nl(s,i):
	i += 1
if j &lt; i: line_delim = s[j:i]
else: valid = false
# Make sure we have @+leo
i = skip_ws(s,i)
if match(s,i,tag): i += len(tag)
else: valid = false
# The closing comment delim is the trailing non-whitespace.
i = j = skip_ws(s,i)
while i &lt; len(s) and not is_ws(s[i]) and not is_nl(s,i):
	i += 1
if j &lt; i:
	start_delim = line_delim
	end_delim = s[j:i]
	line_delim = None</t>
<t tx="T1678">@ Properly removes all sentinel lines in s.  Only leading single-line comments may be sentinels.

line_delim, start_delim and end_delim are the comment delimiters.
@c

def removeSentinelLines(self,s,line_delim,start_delim,end_delim):

	i = 0 ; result = "" ; first = true
	while i &lt; len(s):
		start = i # The start of the next syntax element.
		if first or is_nl(s,i):
			first = false
			&lt;&lt; handle possible sentinel &gt;&gt;
		elif match(s,i,line_delim):
			i = skip_to_end_of_line(s,i)
		elif match(s,i,start_delim):
			i = skip_matching_delims(s,i,start_delim,end_delim)
		elif match(s,i,"'") or match(s,i,'"'):
			i = skip_string(s,i)
		else:
			i += 1
		assert(i==0 or start&lt;i)
		result += s[start:i]
	return result</t>
<t tx="T1679">i = skip_nl(s,i)
i = skip_ws(s,i)

if line_delim:
	if match(s,i,line_delim):
		j = i + len(line_delim)
		i = skip_to_end_of_line(s,i)
		if match(s,j,"@"):
			continue # Remove the sentinel.
elif start_delim:
	if match(s,i,start_delim):
		j = i + len(start_delim)
		i = skip_matching_delims(s,i,start_delim,end_delim)
		if match(s,j,"@"):
			continue # Remove the sentinel.</t>
<t tx="T1680">def weave (self,filename):
	
	c = self.commands ; v = c.currentVnode()
	nl = self.output_newline
	if not v: return
	&lt;&lt; open filename to f, or return &gt;&gt;
	after = v.nodeAfterTree()
	while v and v != after:
		s = v.bodyString()
		s2 = string.strip(s)
		if s2 and len(s2) &gt; 0:
			f.write("-" * 60) ; f.write(nl)
			&lt;&lt; write the context of v to f &gt;&gt;
			f.write("-" * 60) ; f.write(nl)
			f.write(string.rstrip(s) + nl)
		v = v.threadNext()
	f.flush()
	f.close()</t>
<t tx="T1681"># write the headlines of v, v's parent and v's grandparent.
context = [] ; v2 = v
for i in xrange(3):
	if not v2: break
	context.append(v2.headString())
	v2 = v2.parent()

context.reverse()
indent = ""
for line in context:
	f.write(indent)
	indent += '\t'
	f.write(line)
	f.write(nl)
</t>
<t tx="T1682">@ignore</t>
<t tx="T1683">@ These routines are involved in many projects.  Cloning them over and over can slow down Leo a lot.</t>
<t tx="T1684">@ The &lt;Key&gt; event generates the event before the body text is changed(!), so we register an idle-event handler to do the work later.

1/17/02: Rather than trying to figure out whether the control or alt keys are down, we always schedule the idle_handler.  The idle_handler sees if any change has, in fact, been made to the body text, and sets the changed and dirty bits only if so.  This is the clean and safe way.

2/19/02: We must distinguish between commands like "Find, Then Change", that call onBodyChanged, and commands like "Cut" and "Paste" that call onBodyWillChange.  The former commands have already changed the body text, and that change must be captured immediately.  The latter commands have not changed the body text, and that change may only be captured at idle time.
@c

# Called by command handlers that have already changed the text.
def onBodyChanged (self,v,undoType,oldSel=None,oldYview=None):
	c = self.commands
	if not v: v = c.currentVnode()
	if not oldSel:
		first,last = getTextSelection(c.body)
		oldSel = (first,last) # trace(`oldSel`)
	self.idle_body_key(v,oldSel,undoType,oldYview=oldYview)
	
# Called by command handlers that change the text just before idle time.
def onBodyWillChange (self,v,undoType,oldSel=None,oldYview=None):
	c = self.commands
	if not v: v = c.currentVnode()
	if not oldSel:
		first,last = getTextSelection(c.body)
		oldSel = (first,last) # trace(`oldSel`)
	self.commands.body.after_idle(self.idle_body_key,v,oldSel,undoType,oldYview)

# Bound to any key press..
def OnBodyKey (self,event):
	c = self.commands ; v = c.currentVnode() ; ch = event.char
	first,last = getTextSelection(c.body)
	oldSel = (first,last)
	# if ch and len(ch)&gt;0: trace(`oldSel`)
	self.commands.body.after_idle(self.idle_body_key,v,oldSel,"Typing",ch)

# Does the real work of updating the body pane.
def idle_body_key (self,v,oldSel,undoType,ch=None,oldYview=None):

	c = self.commands
	if not c or not v or v != c.currentVnode():
		return "break"
	# Call the pre-key hook.
	flag = handleLeoHook("bodykey1",c=c,v=v,ch=ch,oldSel=oldSel,undoType=undoType)
	if flag != None:  # Anything other than None overrides.
		return "break" # The hook claims to have handled the event.
	body = v.bodyString()
	s = c.body.get("1.0", "end")
	first,last = getTextSelection(c.body)
	newSel = (first,last)
	body,junk = convertUnicodeToString(body)
	s,u       = convertUnicodeToString(s)
	if u: # u is s with invalid chars replaced by '?'
		&lt;&lt; replace body text by u &gt;&gt;
	# Do nothing if nothing has changed.
	if s == body: return "break"
	# Do nothing for control characters.
	if (ch == None or len(ch) == 0) and body == s[:-1]: return "break"
	# print ch,len(body),len(s)
	&lt;&lt; set removeTrailing &gt;&gt;
	# trace(`ch`)
	if ch == '\r' or ch == '\n':
		&lt;&lt; Do auto indent &gt;&gt;
	elif ch == '\t' and c.tab_width &lt; 0:
		&lt;&lt; convert leading tab to blanks &gt;&gt;
	s = c.body.get("1.0", "end")
	s,junk = convertUnicodeToString(s)
	if len(s) &gt; 0 and s[-1] == '\n' and removeTrailing:
		s = s[:-1]
	c.undoer.setUndoTypingParams(v,undoType,body,s,oldSel,newSel,oldYview=oldYview)
	v.t.bodyString = s
	v.t.insertSpot = c.body.index("insert") # 9/1/02
	# print v.t.insertSpot,v
	# Recolor the body.
	self.scanForTabWidth(v) # 9/13/02
	self.recolor_now(v,incremental=true)
	# Update dirty bits and changed bit.
	if not c.changed:
		c.setChanged(true) 
	redraw_flag = false
	c.beginUpdate()
	if not v.isDirty() and v.setDirty(): # Sets all cloned and @file dirty bits
		redraw_flag = true
	# update icons.
	val = v.computeIcon()
	if val != v.iconVal:
		v.iconVal = val
		redraw_flag = true
	c.endUpdate(redraw_flag) # redraw only if necessary
	# Call the post-key hook.
	handleLeoHook("bodykey2",c=c,v=v,ch=ch,oldSel=oldSel,undoType=undoType)
	return "break"
</t>
<t tx="T1685">ins = c.body.index("insert")
c.body.delete("1.0","end")
c.body.insert("end",u) # Always put unicode in the Tk.Text widget!
c.body.mark_set("insert",ins)</t>
<t tx="T1686">@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually done. We need only make a reasonable guess here.   setUndoTypingParams stores the number of trailing newlines in each undo bead, so whatever we do here can be faithfully undone and redone.
@c
new = s ; old = body

if len(new) == 0 or new[-1] != '\n':
	# There is no newline to remove.  Probably will never happen.
	# trace("false: no newline to remove")
	removeTrailing = false
elif len(old) == 0:
	# Ambigous case.
	# trace("false: empty old")
	removeTrailing = ch != '\n' # false
elif old == new[:-1]:
	# A single trailing character has been added.
	# trace("false: only changed trailing.)
	removeTrailing = false
else:
	# The text didn't have a newline, and now it does.
	# Moveover, some other change has been made to the text,
	# So at worst we have misreprented the user's intentions slightly.
	# trace("true")
	removeTrailing = true
	
# trace(`ch`+","+`removeTrailing`)

</t>
<t tx="T1687"># Do nothing if we are in @nocolor mode or if we are executing a Change command.
if self.colorizer.useSyntaxColoring(v) and undoType != "Change":

	# Get the previous line.
	s=c.body.get("insert linestart - 1 lines","insert linestart -1c")

	# Add the leading whitespace to the present line.
	junk,width = skip_leading_ws_with_indent(s,0,c.tab_width)
	if s and len(s) &gt; 0 and s[-1]==':':
		# For Python: increase auto-indent after colons.
		language = self.colorizer.scanColorDirectives(v)
		if language == "python":
			width += abs(c.tab_width)
	if app().config.getBoolWindowPref("smart_auto_indent"):
		# Added Nov 18 by David McNab, david@rebirthing.co.nz
		# Determine if prev line has unclosed parens/brackets/braces
		brackets = [width]
		tabex = 0
		for i in range(0, len(s)):
			if s[i] == '\t':
				tabex += c.tab_width - 1
			if s[i] in '([{':
				brackets.append(i+tabex + 1)
			elif s[i] in '}])' and len(brackets) &gt; 1:
				brackets.pop()
		width = brackets.pop()
		# end patch by David McNab
	ws = computeLeadingWhitespace (width,c.tab_width)
	if ws and len(ws) &gt; 0:
		c.body.insert("insert", ws)
		removeTrailing = false # bug fix: 11/18</t>
<t tx="T1688"># Do nothing if we are in @nocolor mode or if we are executing a Change command.
if self.colorizer.useSyntaxColoring(v) and undoType != "Change":
	# Get the characters preceeding the tab.
	prev=c.body.get("insert linestart","insert -1c")
	# Do nothing if there are non-whitespace in prev:
	all_ws = true
	for ch in prev:
		if ch != ' ' and ch != '\t':
			all_ws = false
	if all_ws:
		w = computeWidth(prev,c.tab_width)
		w2 = (abs(c.tab_width) - (w % abs(c.tab_width)))
		# print "prev w:" + `w` + ", prev chars:" + `prev`
		c.body.delete("insert -1c")
		c.body.insert("insert",' ' * w2)</t>
<t tx="T1689">@ The &lt;Key&gt; event generates the event before the headline text is changed(!), so we register an idle-event handler to do the work later.
@c

def onHeadChanged (self,v):
	self.commands.body.after_idle(self.idle_head_key,v)

def OnHeadlineKey (self,v,event):

	# v = self.currentVnode ;
	ch = event.char
	self.commands.body.after_idle(self.idle_head_key,v,ch)

def idle_head_key (self,v,ch=None):

	c = self.commands
	if not v or not v.edit_text or v != c.currentVnode():
		return "break"
	flag = handleLeoHook("headkey1",c=c,v=v,ch=ch)
	if flag != None:  # Anything other than None overrides.
		return "break" # The hook claims to have handled the event.
	s = v.edit_text.get("1.0","end")
	&lt;&lt; Make sure that the headline text is valid in the encoding &gt;&gt;
			
	# remove all newlines and update the vnode
	if not s: s = ""
	s = string.replace(s,'\n','')
	s = string.replace(s,'\r','')
	
	head = v.headString()
	if type(head) == types.UnicodeType:
		# vnode strings are encoded using the xml_encoding.
		head = head.encode(xml_encoding)
	
	changed = s != head
	done = ch and (ch == '\r' or ch == '\n')
	if not changed and not done:
		return "break"
	if changed:
		c.undoer.setUndoParams("Change Headline",v,newText=s,oldText=head)
	index = v.edit_text.index("insert")
	# trace(`s`)
	if changed:
		c.beginUpdate()
		# Update changed bit.
		if not c.changed:
			c.setChanged(true)
		# Update all dirty bits.
		v.setDirty() 
		# Update v.
		v.initHeadString(s)
		v.edit_text.delete("1.0","end")
		v.edit_text.insert("end",s)
		v.edit_text.mark_set("insert",index)
		# Update all joined nodes.
		v2 = v.joinList
		while v2 and v2 != v:
			v2.initHeadString(s)
			if v2.edit_text: # v2 may not be visible
				v2.edit_text.delete("1.0","end")
				v2.edit_text.insert("end",s)
			v2 = v2.joinList
		c.endUpdate(false) # do not redraw now.

	# Reconfigure v's headline.
	if done:
		self.setDisabledLabelState(v)
	v.edit_text.configure(width=self.headWidth(v))

	# Reconfigure all joined headlines.
	v2 = v
	while v2 and v2 != v:
		if v2.edit_text: # v2 may not be visible
			v2.edit_text.configure(width=self.headWidth(v2))
		v2 = v2.joinList
		
	# Update the screen.
	if done:
		c.beginUpdate()
		self.endEditLabel()
		c.endUpdate()
	elif changed:
		# update v immediately.  Joined nodes are redrawn later by endEditLabel.
		# Redrawing the whole screen now messes up the cursor in the headline.
		self.drawIcon(v,v.iconx,v.icony) # just redraw the icon.

	handleLeoHook("headkey2",c=c,v=v,ch=ch)
	return "break"</t>
<t tx="T1690">xml_encoding = app().config.xml_version_string

if type(s) == types.UnicodeType:
	try: # This can fail, e.g., if character &gt; 256 used in Latin-1 encoding.
		s2 = s.encode(xml_encoding) # result is a string.
		s = s2 # don't destroy s until we know that all is well.
	except:
		es_exception()
		es_nonEncodingChars(s,xml_encoding)
		u = replaceNonEncodingChars(s,"?",xml_encoding)
		s = u.encode(xml_encoding) # result is a string.
		ins = v.edit_text.index("insert")
		v.edit_text.delete("1.0","end")
		v.edit_text.insert("end",u) # Always put unicode in the Tk.Text widget!
		v.edit_text.mark_set("insert",ins)
		return "break"</t>
<t tx="T1691">@ These routines are involved in many projects.  Cloning them over and over can slow down Leo a lot.</t>
<t tx="T1692">@ This code scans the node v and all of v's ancestors looking for directives.  If found, the corresponding Tangle/Untangle globals are set.

Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node v, no @color or @nocolor directives are examined in any ancestor of v.

This code is similar to Commands::scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,v):

	c = self.commands
	&lt;&lt; Set ivars &gt;&gt;
	&lt;&lt; Set path from @file node &gt;&gt;
	old = {}
	while v:
		s = v.t.bodyString
		dict = get_directives_dict(s)
		&lt;&lt; Test for @path &gt;&gt;
		&lt;&lt; Test for @comment and @language &gt;&gt;
		&lt;&lt; Test for @header and @noheader &gt;&gt;
		&lt;&lt; Test for @pagewidth &gt;&gt;
		&lt;&lt; Test for @tabwidth &gt;&gt;
		old.update(dict)
		v = v.parent()
	&lt;&lt; Set current directory &gt;&gt;
	&lt;&lt; Set comment Strings from delims &gt;&gt;</t>
<t tx="T1693"># An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

# Bug fix: 10/16/02
if v.isAtFileNode():
	name = v.atFileNodeName()
elif v.isAtRawFileNode():
	name = v.atRawFileNodeName()
elif v.isAtNoSentinelsFileNode():
	name = v.atNoSentinelsFileNodeName()
else:
	name = ""

dir = choose(name,os.path.dirname(name),None)
if dir and len(dir) &gt; 0 and os.path.isabs(dir):
	if os.path.exists(dir):
		self.default_directory = dir
	else: # 9/25/02
		self.default_directory = makeAllNonExistentDirectories(dir)
		if not self.default_directory:
			self.error("Directory \"" + dir + "\" does not exist")
			
</t>
<t tx="T1694"># 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

if not old.has_key("comment") and dict.has_key("comment"):
	k = dict["comment"]
	# 11/14/02: Similar to fix below.
	delim1, delim2, delim3 = set_delims_from_string(s[k:])

if not old.has_key("language") and dict.has_key("language"):
	k = dict["language"]
	# 11/14/02: Fix bug reported by J.M.Gilligan.
	self.language,delim1,delim2,delim3 = set_language(s,k)</t>
<t tx="T1695"># EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if dict.has_key("header") and dict.has_key("noheader"):
	es("conflicting @header and @noheader directives")</t>
<t tx="T1696"># We set the current director to a path so future writes will go to that directory.

loadDir = app().loadDir

if not self.default_directory and not old.has_key("path") and dict.has_key("path"):

	k = dict["path"]
	&lt;&lt; compute relative path from s[k:] &gt;&gt;
	if path and len(path) &gt; 0:
		base = getBaseDirectory() # returns "" on error.
		path = os.path.join(base,path)
		if os.path.isabs(path):
			&lt;&lt; handle absolute path &gt;&gt;
		else:
			self.error("ignoring bad @path: " + path)
	else:
		self.error("ignoring empty @path")</t>
<t tx="T1697">j = i = k + len("@path")
i = skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) &gt; 2 and (
	(path[0]=='&lt;' and path[-1] == '&gt;') or
	(path[0]=='"' and path[-1] == '"') ):
	path = path[1:-1]
path = string.strip(path)

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
	path = os.path.join(loadDir,path)</t>
<t tx="T1698"># path is an absolute path.

if os.path.exists(path):
	self.default_directory = path
else: # 9/25/02
	self.default_directory = makeAllNonExistentDirectories(path)
	if not self.default_directory:
		self.error("invalid @path: " + path)
</t>
<t tx="T1699">if dict.has_key("tabwidth") and not old.has_key("tabwidth"):

	k = dict["tabwidth"]
	j = i = k + len("@tabwidth")
	i, val = skip_long(s, i)
	if val != None and val != 0:
		self.tab_width = val
	else:
		i = skip_to_end_of_line(s,i)
		self.error("Ignoring " + s[k:i])
</t>
<t tx="T1700"># This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
	base = getBaseDirectory() # returns "" on error.
	for dir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
		if dir and len(dir) &gt; 0:
			dir = os.path.join(base,dir)
			if os.path.isabs(dir): # Errors may result in relative or invalid path.
				if os.path.exists(dir):
					self.default_directory = dir ; break
				else: # 9/25/02
					self.default_directory = makeAllNonExistentDirectories(dir)

if not self.default_directory:
	# This should never happen: c.openDirectory should be a good last resort.
	self.error("No absolute directory specified anywhere.")
	self.default_directory = ""</t>
<t tx="T1701"># Use single-line comments if we have a choice.
# 8/2/01: delim1,delim2,delim3 now correspond to line,start,end
if delim1:
	self.startSentinelComment = delim1
	self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
	self.startSentinelComment = delim2
	self.endSentinelComment = delim3
else: # Emergency!
	# assert(0)
	es("Unknown language: using Python comment delimiters")
	es("c.target_language:"+`c.target_language`)
	es("delim1,delim2,delim3:" + `delim1`+":"+`delim2`+":"+`delim3`)
	self.startSentinelComment = "#" # This should never happen!
	self.endSentinelComment = ""</t>
<t tx="T1702">@ This code scans the node v and all its ancestors looking for directives.  If found,the corresponding globals are set for use by Tangle, Untangle and syntax coloring.

Once a directive is seen, related directives in ancesors have no effect.  For example, if an @color directive is seen in node x, no @color or @nocolor directives are examined in any ancestor of x.
@c

def scanAllDirectives(self,v,require_path_flag,issue_error_flag):

	c = self.commands
	# trace(`v`)
	old = {} ; print_mode_changed = false
	self.init_directive_ivars()
	if v:
		s = v.bodyString()
		&lt;&lt; Collect @first attributes &gt;&gt;
	while v:
		s = v.bodyString()
		dict = get_directives_dict(s)
		# trace("dict:" + `dict`, ", " + `v`)
		&lt;&lt; Test for @comment and @language &gt;&gt;
		&lt;&lt; Test for print modes directives &gt;&gt;
		&lt;&lt; Test for @path &gt;&gt;
		&lt;&lt; Test for @pagewidth &gt;&gt;
		&lt;&lt; Test for @root &gt;&gt;
		&lt;&lt; Test for @tabwidth &gt;&gt;
		&lt;&lt; Test for @header and @noheader &gt;&gt;
		old.update(dict)
		v = v.parent()
	&lt;&lt; Set self.tangle_directory &gt;&gt;</t>
<t tx="T1703">@ Stephen P. Schaefer 9/13/2002: Add support for @first.
Unlike other root attributes, does *NOT* inherit from parent nodes.
@c
tag = "@first"
sizeString = len(s) # DTHEIN 13-OCT-2002: use to detect end-of-string
i = 0
while 1:
	# DTHEIN 13-OCT-2002: directives must start at beginning of a line
	if not match_word(s,i,tag):
		i = skip_line(s,i)
	else:
		i = i + len(tag)
		j = i = skip_ws(s,i)
		i = skip_to_end_of_line(s,i)
		if i&gt;j:
			self.first_lines += s[j:i] + '\n'
		i = skip_nl(s,i)
	if i &gt;= sizeString:  # DTHEIN 13-OCT-2002: get out when end of string reached
		break

</t>
<t tx="T1704">if old.has_key("comment") or old.has_key("language"):
	 pass # Do nothing more.

elif dict.has_key("comment"):

	i = dict["comment"]
	delim1,delim2,delim3 = set_delims_from_string(s[i:])
	if delim1 or delim2:
		self.single_comment_string = delim1
		self.start_comment_string = delim2
		self.end_comment_string = delim3
		# @comment effectively disables Untangle.
		self.language = "unknown"
	else:
		if issue_error_flag:
			es("ignoring: " + s[i:])

elif dict.has_key("language"):

	i = dict["language"]
	language,delim1,delim2,delim3 = set_language(s,i)
	self.language = language
	self.single_comment_string = delim1
	self.start_comment_string = delim2
	self.end_comment_string = delim3
	if 0:
		trace(`self.single_comment_string` + "," +
			`self.start_comment_string` + "," +
			`self.end_comment_string`)
		
	# 10/30/02: These ivars must be updated here!
	# trace(`self.language`)
	self.use_noweb_flag = true
	self.use_cweb_flag = false # Only raw cweb mode is ever used.
	self.raw_cweb_flag = self.language == "cweb" # A new ivar.
</t>
<t tx="T1705">@ It is valid to have more than one of these directives in the same body text: the more verbose directive takes precedence.
@c

if not print_mode_changed:
	for name in ("verbose","terse","quiet","silent"):
		if dict.has_key(name):
			self.print_mode = name
			print_mode_changed = true
			break
</t>
<t tx="T1706">if require_path_flag and not old.has_key("path") and dict.has_key("path"):

	k = dict["path"]
	&lt;&lt; compute dir and relative_path from s[k:] &gt;&gt;
	if len(dir) &gt; 0:
		base = getBaseDirectory() # May return "".
		if dir and len(dir) &gt; 0:
			dir = os.path.join(base,dir)
			if os.path.isabs(dir):
				&lt;&lt; handle absolute @path &gt;&gt;
			elif issue_error_flag and not self.path_warning_given:
				self.path_warning_given = true # supress future warnings
				self.error("ignoring relative path in @path:" + dir)
	elif issue_error_flag and not self.path_warning_given:
		self.path_warning_given = true # supress future warnings
		self.error("ignoring empty @path")
</t>
<t tx="T1707">j = i = k + len("@path")
i = skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) &gt; 2 and (
	(path[0]=='&lt;' and path[-1] == '&gt;') or
	(path[0]=='"' and path[-1] == '"') ):
	path = path[1:-1]

dir = relative_path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
	dir = os.path.join(app().loadDir,dir)

# trace("dir: " + dir)</t>
<t tx="T1708">if os.path.exists(dir):
	self.tangle_directory = dir
else: # 11/19/02
	self.tangle_directory = makeAllNonExistentDirectories(dir)
	if not self.tangle_directory:
		if issue_error_flag and not self.path_warning_given:
			self.path_warning_given = true # supress future warnings
			self.error("@path directory does not exist: " + dir)
			if base and len(base) &gt; 0:
				es("relative_path_base_directory: " + base)
			if relative_path and len(relative_path) &gt; 0:
				es("relative path in @path directive: " + relative_path)</t>
<t tx="T1709">if not old.has_key("pagewidth") and dict.has_key("pagewidth"):

	i = dict["pagewidth"]
	i, val = skip_long(s,i+10) # Point past @pagewidth
	if val != None and val &gt; 0:
		self.page_width = val
	else:
		if issue_error_flag:
			j = skip_to_end_of_line(s,i)
			es("ignoring " + s[i:j])
</t>
<t tx="T1710">@ 10/27/02: new code:  self.root may not be defined here, so any relative directory specified in the @root node will have no effect unless we have this code.

@c
if self.root_name == None and dict.has_key("root"):

	i = dict["root"]
	# i += len("@root")
	self.setRootFromText(s[i:],issue_error_flag)</t>
<t tx="T1711">if not old.has_key("tabwidth") and dict.has_key("tabwidth"):

	i = dict["tabwidth"] # 7/18/02 (!)
	i, val = skip_long(s,i+9) # Point past @tabwidth.
	if val != None and val != 0:
		self.tab_width = val
	else:
		if issue_error_flag:
			j = skip_to_end_of_line(s,i)
			es("ignoring " + s[i:j])
</t>
<t tx="T1712">if old.has_key("header") or old.has_key("noheader"):
	pass # Do nothing more.
	
elif dict.has_key("header") and dict.has_key("noheader"):
	if issue_error_flag:
		es("conflicting @header and @noheader directives")

elif dict.has_key("header"):
	self.use_header_flag = true

elif dict.has_key("noheader"):
	self.use_header_flag = false
</t>
<t tx="T1713">@ This code sets self.tangle_directory if it has not already been set by an @path directive.

An absolute file name in an @root directive will override the directory set here.
A relative file name gets appended later to the default directory.
That is, the final file name will be os.path.join(self.tangle_directory,fileName)
@c

if c.frame and require_path_flag and not self.tangle_directory:
	if self.root_name and len(self.root_name) &gt; 0:
		root_dir = os.path.dirname(self.root_name)
	else:
		root_dir = None
	# print "root_dir:", root_dir

	table = ( # This is a precedence table.
		(root_dir,"@root"), 
		(c.tangle_directory,"default tangle"), # Probably should be eliminated.
		(c.frame.openDirectory,"open"))

	base = getBaseDirectory() # May return "".

	for dir2, kind in table:
		if dir2 and len(dir2) &gt; 0:
			# print "base,dir:",`base`,`dir`
			dir = os.path.join(base,dir2)
			if os.path.isabs(dir): # Errors may result in relative or invalid path.
				&lt;&lt; handle absolute path &gt;&gt;

if not self.tangle_directory and require_path_flag: # issue_error_flag:
	self.pathError("No absolute directory specified by @root, @path or Preferences.")
</t>
<t tx="T1714">if os.path.exists(dir):
	if kind == "@root" and not os.path.isabs(root_dir):
		self.tangle_directory = base
	else:
		self.tangle_directory = dir 
	break
else: # 9/25/02
	self.tangle_directory = makeAllNonExistentDirectories(dir)
	if not self.tangle_directory:
		# 10/27/02: It is an error for this not to exist now.
		self.error("@root directory does not exist:" + dir)
		if base and len(base) &gt; 0:
			es("relative_path_base_directory: " + base)
		if dir2 and len(dir2) &gt; 0:
			es(kind + " directory: " + dir2)
</t>
<t tx="T1715">@ This code scans the node v and all of v's ancestors looking for @color and @nocolor directives.
@c

def scanColorDirectives(self,v):

	c = self.commands
	language = c.target_language
	self.comment_string = None
	self.rootMode = None # None, "code" or "doc"
	while v:
		s = v.t.bodyString
		dict = get_directives_dict(s)
		&lt;&lt; Test for @comment or @language &gt;&gt;
		&lt;&lt; Test for @root, @root-doc or @root-code &gt;&gt;
		v = v.parent()
	# trace(`language`)
	return language</t>
<t tx="T1716"># 10/17/02: @comment and @language may coexist in the same node.

if dict.has_key("comment"):
	k = dict["comment"]
	self.comment_string = s[k:]

if dict.has_key("language"):
	i = dict["language"]
	language,junk,junk,junk = set_language(s,i)

if dict.has_key("comment") or dict.has_key("language"):
	break</t>
<t tx="T1717">if dict.has_key("root") and not self.rootMode:

	k = dict["root"]
	if match_word(s,k,"@root-code"):
		self.rootMode = "code"
	elif match_word(s,k,"@root-doc"):
		self.rootMode = "doc"
	else:
		doc = app().config.at_root_bodies_start_in_doc_mode
		self.rootMode = choose(doc,"doc","code")
</t>
<t tx="T1718">@ A general-purpose routine that scans v and its ancestors for directives.  It returns a dict containing the settings in effect as the result of the @comment, @language, @pagewidth, @path and @tabwidth directives.  This code does not check on the existence of paths, and issues no error messages.

Perhaps this routine should be the basis of atFile.scanAllDirectives and tangle.scanAllDirectives, but I am loath to make any further to these two already-infamous routines.  Also, this code does not check for @color and @nocolor directives: leoColor.useSyntaxColoring does that.
@c

def scanDirectives(c,v=None):

	if v == None: v = c.currentVnode()
	&lt;&lt; Set local vars &gt;&gt;
	old = {}
	while v:
		s = v.t.bodyString
		dict = get_directives_dict(s)
		&lt;&lt; Test for @comment and @language &gt;&gt;
		&lt;&lt; Test for @pagewidth &gt;&gt;
		&lt;&lt; Test for @path &gt;&gt;
		&lt;&lt; Test for @tabwidth &gt;&gt;
		old.update(dict)
		v = v.parent()
	return {
		"delims"    : (delim1,delim2,delim3),
		"language"  : language,
		"pagewidth" : page_width,
		"path"      : path,
		"tabwidth"  : tab_width }
</t>
<t tx="T1719">loadDir = app().loadDir

page_width = c.page_width
tab_width  = c.tab_width
language = c.target_language
delim1, delim2, delim3 = set_delims_from_language(c.target_language)
path = None
</t>
<t tx="T1720"># @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

if not old.has_key("comment") and dict.has_key("comment"):
	k = dict["comment"]
	delim1,delim2,delim3 = set_delims_from_string(s[k:])

if not old.has_key("language") and dict.has_key("language"):
	k = dict["language"]
	language,delim1,delim2,delim3 = set_language(s,k)</t>
<t tx="T1721">if dict.has_key("pagewidth") and not old.has_key("pagewidth"):

	k = dict["pagewidth"]
	j = i = k + len("@pagewidth")
	i, val = skip_long(s,i)
	if val != None and val &gt; 0:
		page_width = val</t>
<t tx="T1722">if not path and not old.has_key("path") and dict.has_key("path"):

	k = dict["path"]
	&lt;&lt; compute relative path from s[k:] &gt;&gt;
	if path and len(path) &gt; 0:
		base = getBaseDirectory() # returns "" on error.
		path = os.path.join(base,path)</t>
<t tx="T1723">j = i = k + len("@path")
i = skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) &gt; 2 and (
	(path[0]=='&lt;' and path[-1] == '&gt;') or
	(path[0]=='"' and path[-1] == '"') ):
	path = path[1:-1]

path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
	path = os.path.join(loadDir,path)</t>
<t tx="T1724">if dict.has_key("tabwidth") and not old.has_key("tabwidth"):

	k = dict["tabwidth"]
	j = i = k + len("@tabwidth")
	i, val = skip_long(s, i)
	if val != None and val != 0:
		tab_width = val</t>
<t tx="T1725">@ignore
@others</t>
<t tx="T1726">aëÃ®</t>
<t tx="T1727"></t>
<t tx="T1728">def convertCharToXMLCharRef(c,xml_encoding):

	try:
		if type(c) == types.UnicodeType:
			xml_encoding = app().config.xml_version_string
			e = c.encode(xml_encoding)
			e = unicode(e,xml_encoding)
			return e
		else:
			s = unicode(c,xml_encoding)
			return s
	except:
		#Convert to a character reference.
		return u"&amp;#%d;" % ord(c)

def convertStringToXMLCharRef(s,xml_encoding):
	
	s2 = u""
	for c in s:
		s2 += convertCharToXMLCharRef(c,xml_encoding)
	return s2</t>
<t tx="T1729"># Converts s to a string type, returns non-None unicode u on an error.
# This should be called whenever getting text from a Tk.Text widget.

def convertStringToUnicode (s):
	
	if not s: s = ""

	try:
		encoding = app().config.xml_version_string
		if type(s) == types.StringType:
			# This can fail, e.g., if character &gt; 256 used in Latin-1 encoding.
			s = unicode(s)
		u = None
	except:
		es_nonEncodingChars(s,encoding)
		u = replaceNonEncodingChars(s,"?",encoding)
		s = u.encode(xml_encoding)

	# result is always a unicode string.
	assert(type(s)==types.UnicodeType)
	return s,u</t>
<t tx="T1730"># Converts s to a string type, returns non-None unicode u on an error.
# This should be called whenever getting text from a Tk.Text widget.

def convertUnicodeToString (s):
	
	if not s: s = ""

	try:
		encoding = app().config.xml_version_string
		if type(s) == types.UnicodeType:
			# This can fail, e.g., if character &gt; 256 used in Latin-1 encoding.
			s = s.encode(encoding)
		u = None
	except:
		es_nonEncodingChars(s,encoding)
		u = replaceNonEncodingChars(s,"?",encoding)
		s = u.encode(xml_encoding)

	# result is always a string.
	assert(type(s)==types.StringType)
	return s,u</t>
<t tx="T1731">def es_nonEncodingChars(s,xml_encoding):

	for c in s:
		s2 = returnNonEncodingChar(c,xml_encoding)
		if len(s2) &gt; 0:
			es(s2)
		
def returnNonEncodingChar(c,xml_encoding):
	try:
		if type(c) == types.UnicodeType:
			xml_encoding = app().config.xml_version_string
			e = c.encode(xml_encoding)
			unicode(e,xml_encoding)
			return u""
		else:
			unicode(c,xml_encoding)
			return u""
	except:
		if ord(c) &lt; 32 or ord(c) &gt;= 128:
			return c + "=" + hex(ord(c))
		else:
			return c</t>
<t tx="T1732">def replaceNonEncodingChar(c,c2,xml_encoding):

	try:
		if type(c) == types.UnicodeType:
			xml_encoding = app().config.xml_version_string
			e = c.encode(xml_encoding)
			e = unicode(e,xml_encoding)
			return e
		else:
			s = unicode(c,xml_encoding)
			return s
	except:
		if 0:
			m = "invalid in "+xml_encoding+": "
			c2 = c.encode("utf-8")
			m = unicode(m,"utf-8") + unicode(c2,"utf-8")
			es(m)
		return c2
			
def replaceNonEncodingChars(s,c2,xml_encoding):
	
	s2 = u""
	for c in s:
		s2 += replaceNonEncodingChar(c,c2,xml_encoding)
	return s2</t>
<t tx="T1733">def setHeadString(self, s):
	s,junk = convertUnicodeToString(s)
	self.mHeadString = s
	self.setDirty()

def initHeadString (self, s):
	s,junk = convertUnicodeToString(s)
	self.mHeadString = s
</t>
<t tx="T1734">leoAtFile uses readline.  Maybe we should substitute self.readLine(s) for s.readline()</t>
<t tx="T1735">def ecnl():
	ecnls(1)

def ecnls(n):
	log = app().log
	if log:
		while log.es_newlines &lt; n:
			enl()

def enl():
	log = app().log
	if log:
		log.es_newlines += 1
		log.putnl()

def es(s):
	if s == None or len(s) == 0: return
	log = app().log
	if log:
		log.put(s) # No change needed for Unicode!
		# 6/2/02: This logic will fail if log is None.
		for ch in s:
			if ch == '\n': log.es_newlines += 1
			else: log.es_newlines = 0
		ecnl() # only valid here
	else:
		# print "Null log:",
		print s</t>
<t tx="T1736">@ignore
@nocolor</t>
<t tx="T1737">- set app().gid ivar, set from leoID.txt
- add gti ivar to tnodes
- create all vnodes and tnodes when reading preamble.
- create dict of tnodes when reading preamble
	doStartTnode initializes a tnode using this dict.

- fat v. thin options?
- Backup Leo file command

Leo 4.0 will write only 4.0 files, but be able to read old and new files.</t>
<t tx="T1738">We use single-line comments by default.
If a language has only block comments, then we must know how to escape the ending delim.
	This solves the problem of creating a general-purpose escape mechanisme.
Everything between the @+-xml_header sentinels will be valid xml when stripped of comment delims.

#@+leo_preamble
&lt;leo_preamble&gt;
	&lt;leo_settings&gt;...&lt;/leo_settings&gt;
	&lt;vnodes&gt;...&lt;/vnodes&gt;
&lt;/leo_preamble&gt;
#@-leo_preamble

The format of vnodes will be similar (same?) as used in 4.x .leo files:
&lt;v a="..." gti="..."&gt;&lt;vh&gt;headline&lt;/vh&gt;&lt;/v&gt;

As in previous versions of Leo, the headline is redundant, and nice to have anyway.

Following the preamble is code interspersed with sentinels:

@@+tnode gti="..." nonewline=1
# (The actual headline)
...code...
@@-tnode gti="..." nonewline=1  (or just @@-tnode??)

I think it is best _not_ to follow @@-tnode sentinels by headlines.

As usual, directives get turned into sentinels:

@@nocolor
@@others
</t>
<t tx="T1739">@color

@ Read code will use a dispatch dictionary rather than if,elif code.</t>
<t tx="T1740">def readDerivdFile(f)

	scanPreamble()
	scanTnodes()</t>
<t tx="T1741">@ This method is the heart of the 4.x read code.  It reads lines from the file until the given ending sentinel is found, and warns if any other ending sentinel is found instead.  It calls itself recursively to handle most nested sentinels.

On entry, self.v, self.out and self.file must be set properly.  (Is this right?  Is this all?)

To do:
	
- change v to self.v (how to do this?)
	We can probably _omit_ the v param (and the child params in inner calls)
	We can do this because the gti uniquely defines a node,
	and that node will already have been created by scanPreamble!
	So all we need is a setTnode(gti) routine.
		We can use a dict to make this very fast.
		This dict is created by scanPreamble.
- doEndSentinel must tell whether to return or break.
- rewrite doStartTnode
- have sentinelKindString return string?? 

@c
def scanTnodeDoc (self,s,i,kind):
	return self.scanDoc(self.file,s,i,self.out,kind)
	
def scanTnodes (self,v,endSentinelKind):

	&lt;&lt; set the ivars for this invocation &gt;&gt;
	&lt;&lt; define the dispatching table &gt;&gt;
	try:
		breakFlag = false
		while not breakFlag:
			&lt;&lt; get the next line into s or break &gt;&gt;
			&lt;&lt; set kind, nextKind &gt;&gt;
			if kind == atFile.noSentinel:
				self.doNormalLine(s,i)
			else:
				&lt;&lt; set lineIndent, linep and leading_ws &gt;&gt;
				i = self.skipSentinelStart(s,0)
				&lt;&lt; use kind to dispatch the sentinel's handler &gt;&gt;
		&lt;&lt; handle unexpected end of text &gt;&gt;
		assert(len(s)==0 and self.nextLine==None) # We get here only if readline fails.
	except:
		es_exception()

	self.endSentinelKind = oldEndSentinelKind
	return self.lastLines</t>
<t tx="T1742">self.lastLines = []
self.lineIndent = 0 ; self.linep = 0 # Changed only for sentinels.
self.nextLine = None

# We must save the previous endSentinelKind so we can restore it on exit.
oldEndSentinelKind = self.endSentinelKind
self.endSentinelKind = endSentinelKind</t>
<t tx="T1743"># To do: this can initted in the ctor.

self.dispatch_table = {
	startAt : self.doStartAt,
	# startBody : self.doStartBody,
	startComment : self.doStartComment,
	startDelims : self.doStartDelims,
	startDirective : self.doStartDirective,
	startDoc : self.doStartDoc,
	startLeo : self.doStartLeo,
	startTnode : self.doStartTnode,
	startOthers : self.doStartOthers,
	startRef : self.doStartRef,
	startVerbatim : self.doStartVerbatim }

for kind in (endAt, endDoc, endLeo, endTnode, endOthers):
	self.dispatch_table [kind] = self.doEndSentinel
</t>
<t tx="T1744">if self.nextLine:
	s = self.nextLine ; self.nextLine = None
else:
	s = readlineForceUnixNewline(self.file)
	if len(s) == 0: break

# trace(`s`)</t>
<t tx="T1745">@ For non-sentinel lines we look ahead to see whether the next line is a sentinel.  If so, the newline that ends a non-sentinel line belongs to the next sentinel.
@c

assert(self.nextLine==None)

kind = self.sentinelKind(s)

if kind == atFile.noSentinel:
	self.nextLine = readlineForceUnixNewline(self.file)
	nextKind = self.sentinelKind(self.nextLine)
else:
	self.nextLine = nextKind = None

# self.nextLine != None only if we have a non-sentinel line.
# Therefore, self.nextLine == None whenever scanTnodes returns.</t>
<t tx="T1746">@ self.lineIndent is the total indentation on a sentinel line.  The first self.indent portion of that must be removed when recreating text.  self.leading_ws is the remainder of the leading whitespace.  self.linep points to the first "real" character of a line, the character following the self.indent whitespace.
@c

# Point self.linep past the first self.indent whitespace characters.
if self.raw:
	self.linep = 0
else:
	self.linep = self.skipIndent(s,0,self.indent)

# Set self.lineIndent to the total indentation on the line.
self.lineIndent = 0 ; i = 0
while i &lt; len(s):
	if s[i] == '\t': self.lineIndent += (abs(self.tab_width) - (self.lineIndent % abs(self.tab_width)))
	elif s[i] == ' ': self.lineIndent += 1
	else: break
	i += 1
# trace("self.lineIndent:" +`self.lineIndent` + ", " + `s`)

# Set self.leading_ws to the additional indentation on the line.
self.leading_ws = s[self.linep:i]</t>
<t tx="T1747">func = self.dispatch_table.get(kind)
if func:
	data = func(s,i)
	if data != None:
		breakFlag, self.lastLines = data
else:
	self.doUnknownSentinel(s,i)</t>
<t tx="T1748"># Issue the error.
name = self.sentinelName(self.endSentinelKind)
self.readError("Unexpected end of file. Expecting " + name + "sentinel" )
</t>
<t tx="T1749">@others</t>
<t tx="T1750">def doEndSentinel (self,s,i):

	if kind == self.endSentinelKind:
		if kind == "-leo":
			# 9/11/02: ignore everything after @-leo.
			# Such lines were presumably written by @last
			while 1:
				s = readlineForceUnixNewline(self.file)
				if len(s) == 0: return 
				# Capture _all_ the trailing lines, even if empty
				self.lastLines.append(s) # Capture the trailing lines
		elif kind == "-tnode":
			self.raw = false
		# self.nextLine != None only if we have a non-sentinel line.
		# Therefore, self.nextLine == None whenever scanTnodes returns.
		assert(self.nextLine==None)
		return # self.lastLines # Return the captured lines after @-leo
	else:
		# Tell of the structure error.
		name = self.sentinelName(kind)
		expect = self.sentinelName(self.endSentinelKind)
		self.readError("Ignoring " + name + " sentinel.  Expecting " + expect)
		
	# To do: The caller must check self.lastLines
	# To do: do we need a returnFlag?
</t>
<t tx="T1751">def doNormalLine (self,s,i):

	# We don't output the trailing newline if the next line is a sentinel.
	if self.raw:
		i = 0
	else:
		i = self.skipIndent(s,0,self.indent)
	
	assert(self.nextLine != None)
	
	if nextKind == atFile.noSentinel:
		line = s[i:]
		self.out.append(line)
	else:
		line = s[i:-1] # don't output the newline
		self.out.append(line)
</t>
<t tx="T1752">def doStartAt (self,s,i):

	assert(match(s,i,"+at"))
	self.scanTnodeDoc(s,i,kind)</t>
<t tx="T1753">def doStartComment (self,s,i):
	
	assert(match(s,i,"comment"))
	# Do nothing more!
</t>
<t tx="T1754">def doStartDelims (self,s,i):

	tag = "@delims"
	assert(match(s,i-1,tag));
	
	# Skip the keyword and whitespace.
	i0 = i-1
	i = skip_ws(s,i-1+len(tag))

	# Get the first delim.
	j = i
	while i &lt; len(s) and not is_ws(s[i]) and not is_nl(s,i):
		i += 1
	
	if j &lt; i:
		self.startSentinelComment = s[j:i]
		# print "delim1:", self.startSentinelComment
	
		# Get the optional second delim.
		j = i = skip_ws(s,i)
		while i &lt; len(s) and not is_ws(s[i]) and not is_nl(s,i):
			i += 1
		end = choose(j&lt;i,s[j:i],"")
		i2 = skip_ws(s,i)
		if end == self.endSentinelComment and (i2 &gt;= len(s) or is_nl(s,i2)):
			self.endSentinelComment = "" # Not really two params.
			line = s[i0:j]
			line = string.rstrip(line)
			self.out.append(line+'\n')
		else:
			self.endSentinelComment = end
			# print "delim2:",end
			line = s[i0:i]
			line = string.rstrip(line)
			self.out.append(line+'\n')
	else:
		self.readError("Bad @delims")
		# Append the bad @delims line to the body text.
		self.out.append("@delims")
</t>
<t tx="T1755">def doStartDirective (self,s,i):

	assert(match(s,i,"@"))
	
	if match_word(s,i,"@raw"):
		self.raw = true
	elif match_word(s,i,"@end_raw"):
		self.raw = false
	
	# The first '@' has already been eaten.
	if len(self.endSentinelComment) == 0:
		self.out.append(s[i:])
	else:
		# 10/2/04: changed find to rfind, per suggestion of Rich Ries
		k = string.rfind(s,self.endSentinelComment,i)
		if k == -1:
			self.out.append(s[i:])
		else:
			self.out.append(s[i:k] + '\n')
</t>
<t tx="T1756">def doStartDoc (self,s,i):

	assert(match(s,i,"+doc"))
	self.scanTnodeDoc(s,i,kind)
</t>
<t tx="T1757">def doStartLeo (self,s,i):

	assert(match(s,i,"+leo"))
	self.readError("Ignoring unexpected @+leo sentinel")
</t>
<t tx="T1758">def doStartOthers (self,s,i):

	assert(match(s,i,"+others"))
	
	self.out.append(self.leading_ws + "@others")
	self.scanTnodes(v,atFile.endOthers)
</t>
<t tx="T1759">def doStartTnode (self,s,i):
	
	assert(match(s,i,"+tnode"))
	
	&lt;&lt; scan the +tnode sentinel line &gt;&gt;
	&lt;&lt; scan the following headline &gt;&gt;
	
	# recursively call scanTnodes
	
	# Set the given tnode.</t>
<t tx="T1760">def doStartBody (self,s,i):
	
	assert(match(s,i,"+body"))

	# Save ivars before recursive call.
	oldIndent = self.indent ; 
	old_out = self.out
	
	# Set the ivars for the recursive call.
	self.indent = self.lineIndent
	self.out = [] 
	child = v # Do not change v!
	self.scanTnodes(child,atFile.endBody)

	if 0: # Probably not needed in 4.0
		if child.isOrphan():
			self.readError("Replacing body text of orphan: " + child.headString())

	# Set the body, removing cursed newlines.
	# This must be done here, not in the @+node logic.
	body = string.join(self.out, "")
	body = string.replace(body, '\r', '')
	child.t.setTnodeText(body)
	
	# Restore ivars from recursive call.
	self.indent = oldIndent
	self.out = old_out
</t>
<t tx="T1761">def doStartNode (self,s,i):

	assert(match(s,i,"+node:"))
	i += 6
	
	childIndex = 0 ; cloneIndex = 0
	&lt;&lt; Set childIndex &gt;&gt;
	&lt;&lt; Set cloneIndex &gt;&gt;
	headline = ""
	&lt;&lt; Set headline and ref &gt;&gt;
	
	# print `childIndex`,`headline`
	
	if childIndex == 0: # The root node.
		&lt;&lt; Check the filename in the sentinel &gt;&gt;
		# Put the text of the root node in the current node.
		self.scanTnodes(v,atFile.endNode)
		v.t.setCloneIndex(cloneIndex)
		# if cloneIndex &gt; 0: trace("clone index:" + `cloneIndex` + ", " + `v`)
	else:
		# NB: this call to createNthChild is the bottleneck!
		child = self.createNthChild(childIndex,v,headline)
		child.t.setCloneIndex(cloneIndex)
		# if cloneIndex &gt; 0: trace("clone index:" + `cloneIndex` + ", " + `child`)
		self.scanTnodes(child,atFile.endNode)
	
	&lt;&lt; look for sentinels that may follow a reference &gt;&gt;
</t>
<t tx="T1762">i = skip_ws(s,i) ; j = i
while i &lt; len(s) and s[i] in string.digits:
	i += 1

if j == i:
	self.readError("Bad child index in @+node")
else:
	childIndex = int(s[j:i])

if match(s,i,':'):
	i += 1 # Skip the ":".
else:
	self.readError("Bad child index in @+node")
</t>
<t tx="T1763">while i &lt; len(s) and s[i] != ':' and not is_nl(s,i):
	if match(s,i,"C="):
		# set cloneIndex from the C=nnn, field
		i += 2 ; j = i
		while i &lt; len(s) and s[i] in string.digits:
			i += 1
		if j &lt; i:
			cloneIndex = int(s[j:i])
	else: i += 1 # Ignore unknown status bits.

if match(s,i,":"):
	i += 1
else:
	self.readError("Bad attribute field in @+node")</t>
<t tx="T1764"># Set headline to the rest of the line.
if len(self.endSentinelComment) == 0:
	headline = string.strip(s[i:-1])
else:
	# 10/24/02: search from the right, not the left.
	k = string.rfind(s,self.endSentinelComment,i)
	headline = string.strip(s[i:k]) # works if k == -1
	
# 10/23/02: The cweb hack: undouble @ signs if the opening comment delim ends in '@'.
if self.startSentinelComment[-1:] == '@':
	headline = string.replace(headline,'@@','@')

# Set reference if it exists.
i = skip_ws(s,i)</t>
<t tx="T1765">fileName = string.strip(headline)

if fileName[:5] == "@file":
	fileName = string.strip(fileName[5:])
	if fileName != self.targetFileName:
		self.readError("File name in @node sentinel does not match file's name")
elif fileName[:8] == "@rawfile":
	fileName = string.strip(fileName[8:])
	if fileName != self.targetFileName:
		self.readError("File name in @node sentinel does not match file's name")
else:
	self.readError("Missing @file in root @node sentinel")</t>
<t tx="T1766">s = readlineForceUnixNewline(self.file)
kind = self.sentinelKind(s)

if len(s) &gt; 1 and kind == atFile.startVerbatimAfterRef:
	s = readlineForceUnixNewline(self.file)
	# trace("verbatim:"+`s`)
	self.out.append(s)
elif kind == atFile.startNewline:
	self.out.append('\n')
	s = readlineForceUnixNewline(self.file)
	nextline = s
	trace(`s`)
elif kind == atFile.startNoNewline:
	s = readlineForceUnixNewline(self.file)
	nextline = s
elif len(s) &gt; 1 and self.sentinelKind(s) == atFile.noSentinel:
	self.out.append(s)
else:
	self.nextLine = s # Handle the sentinel or blank line later.
</t>
<t tx="T1767">pass</t>
<t tx="T1768">pass</t>
<t tx="T1769">@ The sentinel contains an @ followed by a section name in angle brackets.  This code is different from the code for the @@ sentinel: the expansion of the reference does not include a trailing newline.
@c

def doStartRef (self,s,i):

	assert(match(s,i,"&lt;&lt;"))
	
	if len(self.endSentinelComment) == 0:
		line = s[i:-1] # No trailing newline
	else:
		k = string.find(s,self.endSentinelComment,i)
		line = s[i:k] # No trailing newline, whatever k is.
		
	self.out.append(line)
</t>
<t tx="T1770">def doStartVerbatim (self,s,i):

	assert(match(s,i,"verbatim"))
	
	# Skip the sentinel.
	s = readlineForceUnixNewline(self.file) 
	
	# Append the next line to the text.
	i = self.skipIndent(s,0,self.indent)
	self.out.append(s[i:])
</t>
<t tx="T1771">def doUnknownSentinel (self,s,i):

	self.readError("Unknown sentinel: " + get_line(s,i))
</t>
<t tx="T1772">@nocolor

This is also the time to handle bold &amp; italics, colors and "extra" fonts.

	Styles and colors require changes to the Font and Colors panels.</t>
<t tx="T1773">Every tnode should have a "tags list" giving "extra" attributes.  We probably want to keep such info separately from the actual body or headline text.

We can get the tags from the Tk text widget using the tag ranges command, and set the tags as usual.
</t>
<t tx="T1774">@ignore

@ The new 4.0 format for derived files should fix this.</t>
<t tx="T1775"># Returns the name of the sentinel for warnings.

sentinelNameDict = {
	endAt: "@-at", endBody: "@-body",
	endDoc: "@-body", endLeo: "@-leo",
	endNode: "@-node", endOthers: "@-others",
	noSentinel: "&lt;no sentinel&gt;",
	startAt: "@+at", startBody: "@+body",
	startDirective: "@@", startDoc: "@+doc",
	startLeo: "@+leo", startNode: "@+node",
	startNewline : "@newline", startNoNewline : "@nonewline",
 	startOthers: "@+others", startVerbatim: "@verbatim" }

def sentinelName(self, kind):
	if atFile.sentinelNameDict.has_key(kind):
		return atFile.sentinelNameDict[kind]
	else:
		return "&lt;unknown sentinel!&gt;"</t>
<t tx="T1776">assert(match(s,i,"+others"))

# Make sure that the generated at-others is properly indented.
if 0: # # 9/27/02
	out.append('\n')
out.append(leading_ws + "@others")

# 9/26/02: @others temporarily resets the implicit child index.
oldImplicitChildIndex = implicitChildIndex
implicitChildIndex = 0
self.scanText(file,v,out,atFile.endOthers,implicitChildIndex)
implicitChildIndex = oldImplicitChildIndex</t>
<t tx="T1777">assert(match(s,i,"+body"))

child_out = [] ; child = v # Do not change out or v!
oldIndent = self.indent ; self.indent = lineIndent
self.scanText(file,child,child_out,atFile.endBody,implicitChildIndex)

if child.isOrphan():
	self.readError("Replacing body text of orphan: " + child.headString())

# Set the body, removing cursed newlines.
# Note:  This code must be done here, not in the @+node logic.
body = string.join(child_out, "")
body = string.replace(body, '\r', '')
child.t.setTnodeText(body)
self.indent = oldIndent</t>
<t tx="T1778">@ This method is the same as putSentinel except we don't put an opening newline and leading whitespace.
@c
def putOpenLeoSentinel(self,s):
	
	if not self.sentinels: return # Handle @nosentinelsfile.

	self.os(self.startSentinelComment)
	self.os(s)
	self.os(self.endSentinelComment)
	if self.suppress_newlines: # 9/27/02
		self.newline_pending = true # Schedule a newline.
	else:
		self.onl() # End of sentinel.</t>
<t tx="T1779">&lt;&lt; ref &gt;&gt; # xx
between
@others
after</t>
<t tx="T1780">ref line</t>
<t tx="T1781">a line</t>
<t tx="T1782">b line</t>
<t tx="T1783">@ To do:

- ** Use a general purpose XML parser to parse the jEdit mode files.
- ** Do incremental syntax coloring
	- Create lines table.
	- Initialize lines table when select new node.
- Use strings for states.
- Define colorizeLine method.
- Create self.state ivar
- Use a keyword lead-in table.
	- Use this for latex keywords and Leo keywords.
	- Add ignore-case ivar.
- Define @language xml.
- Defined syntax coloring for all jEdit token types:
	KEYWORD1,KEYWORD2,KEYWORD3,LABEL,LITERAL1,LITERAL2,MARKUP,OPERATOR
	Where do Leo keywords fit in?

</t>
<t tx="T1784">@ignore

@ The following gives the general idea.

The self.known_languages dict contains all the data structures for a particular language.  This dict is created dynamically.  Each entry is a tuple of other info:
	
	"c"      : (dict1,...,dictM,list1,...,listN,etc.),
	"python" : (dict1,...,dictM,list1,...,listN,etc.),
	
These tuples, i.e., all the data structures, are created by the initialization routine.

@c
data = self.known_languages.get(self.language)
if not data:
	# Create all the data structures for the language.
	data = parse_xml_file(self.language) 
	if data: self.known_languages[language] = data
if data:
	self.dict1,...,self.listN=data

# The subsidiary data structures will be created from the xml files.
# The exact data structures used depends on the format of the xml files.

self.reserved_words1 = {} # Main language keywords: reserved words.
self.reserved_words2 = {} # Functions etc. to be colored separately.
self.keyword_chars1 = {} # Characters that appear as the first character of a keyword.
self.keyword_chars2 = {} # Characters that appear as second or following characters of a keyword.
self.string_start1,self.string.start2 # Opening characters of strings.

# The code might scan for keywords as follows:
n = len(s)
if i &lt; n and self.keywords1.get(s[i]):
	j = i ; i += 1
	while i &lt; n and self.keywords2.get(s[i]):
		i += 1
	word = s[j:i]
	if self.reserved_words1.get(word):
		# colorize the reserved word
	elif self.reserved_words2.get(word):
		# colorize the reserved word
</t>
<t tx="T1785">special_keywords_dict = {
	'\\' : (latex_keywords_dict,"keyword"),
	'@' :  (leo_keywords_dict,"leoKeword") }
	
if &lt;&lt; ch is alphabetic &gt;&gt;:
	word = scan_c_word(s,i)
	kind = keywords_dict.get(word)
	if kind:
		&lt;&lt; colorize word using kind &gt;&gt;
else:
	data = special_keywords_dict.get(ch)
	if data:
		dict,kind = data
		word = scan_c_word(s,i+1)
		key = d.get(word)
		if key:
			&lt;&lt; colorize ch and word using kind &gt;&gt;</t>
<t tx="T1786">@language html</t>
<t tx="T1787">&lt;!-- ekr uses the MARK_FOLLOWING to mark _anything_ after \ --&gt;

&lt;?xml version="1.0"?&gt;

&lt;!DOCTYPE MODE SYSTEM "xmode.dtd"&gt;

&lt;MODE&gt;
	&lt;PROPS&gt;
		&lt;PROPERTY NAME="lineComment" VALUE="%" /&gt;
	&lt;/PROPS&gt;

	&lt;RULES&gt;
		&lt;&lt; general rules &gt;&gt;
	&lt;/RULES&gt;

	&lt;RULES SET="MATH" DEFAULT="MARKUP"&gt;
		&lt;&lt; math rules &gt;&gt;
	&lt;/RULES&gt;
&lt;/MODE&gt;</t>
<t tx="T1788">&lt;!-- $$...$$ --&gt;
&lt;SPAN TYPE="MARKUP" DELEGATE="MATH"&gt;
	&lt;BEGIN&gt;$$&lt;/BEGIN&gt;
	&lt;END&gt;$$&lt;/END&gt;
&lt;/SPAN&gt;

&lt;!-- $...$ --&gt;
&lt;SPAN TYPE="MARKUP" DELEGATE="MATH"&gt;
	&lt;BEGIN&gt;$&lt;/BEGIN&gt;
	&lt;END&gt;$&lt;/END&gt;
&lt;/SPAN&gt;

&lt;!-- \[...\] (LaTeX math mode) --&gt;
&lt;SPAN TYPE="MARKUP" DELEGATE="MATH"&gt;
	&lt;BEGIN&gt;\[&lt;/BEGIN&gt;
	&lt;END&gt;\]&lt;/END&gt;
&lt;/SPAN&gt;

&lt;!-- some commands must be handled specially --&gt;
&lt;SEQ TYPE="KEYWORD1"&gt;\$&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD1"&gt;\\&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD1"&gt;\%&lt;/SEQ&gt;

&lt;!-- \... commands --&gt;
&lt;MARK_FOLLOWING TYPE="KEYWORD1"&gt;\&lt;/MARK_FOLLOWING&gt;

&lt;!-- comments --&gt;
&lt;EOL_SPAN TYPE="COMMENT1"&gt;%&lt;/EOL_SPAN&gt;

&lt;!-- word separators --&gt;
&lt;SEQ TYPE="OPERATOR"&gt;{&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;}&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;[&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;]&lt;/SEQ&gt;</t>
<t tx="T1789">&lt;!-- some commands must be handled specially --&gt;
&lt;SEQ TYPE="KEYWORD3"&gt;\$&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD3"&gt;\\&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD3"&gt;\%&lt;/SEQ&gt;

&lt;!-- \... commands --&gt;
&lt;MARK_FOLLOWING TYPE="KEYWORD3"&gt;\&lt;/MARK_FOLLOWING&gt;

&lt;!-- word separators --&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;)&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;(&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;{&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;}&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;[&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;]&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;!&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;+&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;-&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;/&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;*&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;&amp;gt;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;&amp;lt;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;&amp;amp;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;|&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;^&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;~&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;.&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;,&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;?&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;:&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;'&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;"&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;`&lt;/SEQ&gt;

&lt;!-- comments --&gt;
&lt;EOL_SPAN TYPE="COMMENT1"&gt;%&lt;/EOL_SPAN&gt;</t>
<t tx="T1790">&lt;?xml version="1.0"?&gt;

&lt;!DOCTYPE MODE SYSTEM "xmode.dtd"&gt;
&lt;&lt; remarks &gt;&gt;

&lt;MODE&gt;
	&lt;PROPS&gt;
		&lt;PROPERTY NAME="indentPrevLine" VALUE="\s*.{3,}:\s*(#.*)?" /&gt;
		&lt;PROPERTY NAME="lineComment" VALUE="#" /&gt;
	&lt;/PROPS&gt;
	&lt;RULES ESCAPE="\" IGNORE_CASE="FALSE" HIGHLIGHT_DIGITS="TRUE"&gt;
		&lt;&lt; comments &gt;&gt;
		&lt;&lt; literals &gt;&gt;
		&lt;&lt; operators &gt;&gt;
		&lt;MARK_PREVIOUS TYPE="FUNCTION" EXCLUDE_MATCH="TRUE"&gt;(&lt;/MARK_PREVIOUS&gt;
		&lt;&lt; keywords &gt;&gt;
	&lt;/RULES&gt;
&lt;/MODE&gt;</t>
<t tx="T1791">&lt;!-- Python mode, by Slava Pestov. Based on PythonTokenMarker by --&gt;
&lt;!-- Jonathan Revusky --&gt;

&lt;!-- Modified 19-Jul-00 by Ivan Frohne to: --&gt;
&lt;!--  (a) implement 'indentOnEnter'; --&gt;
&lt;!--  (b) indent next line automatically after control structures followed --&gt;
&lt;!--	  by ':'; --&gt;
&lt;!--  (c) make """ or ''' multiline quotes TYPE LITERAL2; --&gt;
&lt;!--  (d) add TYPE FUNCTION identified by a following '(' --&gt;
&lt;!--  (e) eliminate the '?' SEQ TYPE ('?' has no meaning in Python); --&gt;
&lt;!--  (f) change the TYPE of 'and', 'or', and 'not' to KEYWORD1; and --&gt;
&lt;!--  (g) add all builtin functions, builtin exceptions, --&gt;
&lt;!--	  builtin type methods, File object methods, and special type --&gt;
&lt;!--	  attributes as TYPE KEYWORD3. --&gt;</t>
<t tx="T1792">&lt;!-- Comment --&gt;
&lt;EOL_SPAN TYPE="COMMENT1"&gt;#&lt;/EOL_SPAN&gt;

&lt;!-- Triple-quotes --&gt;
&lt;SPAN TYPE="LITERAL2"&gt;
	&lt;BEGIN&gt;"""&lt;/BEGIN&gt;
	&lt;END&gt;"""&lt;/END&gt;
&lt;/SPAN&gt;

&lt;SPAN TYPE="LITERAL2"&gt;
	&lt;BEGIN&gt;'''&lt;/BEGIN&gt;
	&lt;END&gt;'''&lt;/END&gt;
&lt;/SPAN&gt;</t>
<t tx="T1793">&lt;!-- Standard literals --&gt;
&lt;SPAN TYPE="LITERAL1"&gt;
	&lt;BEGIN&gt;"&lt;/BEGIN&gt;
	&lt;END&gt;"&lt;/END&gt;
&lt;/SPAN&gt;

&lt;SPAN TYPE="LITERAL1"&gt;
	&lt;BEGIN&gt;'&lt;/BEGIN&gt;
	&lt;END&gt;'&lt;/END&gt;
&lt;/SPAN&gt;
</t>
<t tx="T1794">&lt;SEQ TYPE="OPERATOR"&gt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;!&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;gt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;lt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;+&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;-&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;/&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;*&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;gt;&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;lt;&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;%&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;amp;&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;|&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;^&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;~&lt;/SEQ&gt;</t>
<t tx="T1795">&lt;KEYWORDS&gt;
	&lt;&lt; reserved words &gt;&gt;
	&lt;&lt; builtins &gt;&gt;
	&lt;&lt; exceptions &gt;&gt;
	&lt;&lt; types &gt;&gt;
&lt;/KEYWORDS&gt;</t>
<t tx="T1796">&lt;!--  Reserved Words  --&gt;
&lt;KEYWORD1&gt;and&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;as&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;assert&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;break&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;class&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;continue&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;def&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;del&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;elif&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;else&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;except&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;exec&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;finally&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;for&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;from&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;global&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;if&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;import&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;in&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;is&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;lambda&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;not&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;or&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;pass&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;print&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;raise&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;return&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;try&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;while&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;yield&lt;/KEYWORD1&gt;</t>
<t tx="T1797">&lt;!-- builtins --&gt;
&lt;KEYWORD2&gt;abs&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;apply&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;bool&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;buffer&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;callable&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;chr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;classmethod&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;cmp&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;coerce&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;compile&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;complex&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;delattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;dict&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;dir&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;divmod&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;eval&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;execfile&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;file&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;filter&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;float&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;getattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;globals&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;hasattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;hash&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;hex&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;id&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;input&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;int&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;intern&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;isinstance&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;issubclass&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;iter&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;len&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;list&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;locals&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;long&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;map&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;max&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;min&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;object&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;oct&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;open&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;ord&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;pow&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;property&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;range&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;raw_input&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;reduce&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;reload&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;repr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;round&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;setattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;slice&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;staticmethod&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;str&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;super&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;tuple&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;type&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;unichr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;unicode&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;vars&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;xrange&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;zip&lt;/KEYWORD2&gt;</t>
<t tx="T1798">&lt;!-- exceptions --&gt;
&lt;KEYWORD3&gt;ArithmeticError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;AssertionError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;AttributeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DeprecationWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;EOFError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;EnvironmentError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;Exception&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FloatingPointError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IOError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ImportError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IndentationError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IndexError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;KeyError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;KeyboardInterrupt&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;LookupError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;MemoryError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NameError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NotImplemented&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NotImplementedError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;OSError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;OverflowError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;OverflowWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ReferenceError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;RuntimeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;RuntimeWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StandardError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StopIteration&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SyntaxError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SyntaxWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SystemError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SystemExit&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TabError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TypeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnboundLocalError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnicodeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UserWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ValueError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;Warning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;WindowsError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ZeroDivisionError&lt;/KEYWORD3&gt;</t>
<t tx="T1799">&lt;!-- types (from types module) --&gt;
&lt;KEYWORD3&gt;BufferType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;BuiltinFunctionType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;BuiltinMethodType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ClassType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;CodeType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ComplexType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DictProxyType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DictType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DictionaryType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;EllipsisType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FileType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FloatType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FrameType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FunctionType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;GeneratorType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;InstanceType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IntType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;LambdaType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ListType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;LongType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;MethodType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ModuleType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NoneType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ObjectType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SliceType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StringType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StringTypes&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TracebackType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TupleType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TypeType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnboundMethodType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnicodeType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;XRangeType&lt;/KEYWORD3&gt;

&lt;KEYWORD3&gt;False&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;None&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;True&lt;/KEYWORD3&gt;

&lt;KEYWORD3&gt;__abs__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__add__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__all__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__author__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__bases__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__builtins__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__call__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__class__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__cmp__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__coerce__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__contains__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__debug__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__del__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__delattr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__delitem__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__delslice__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__dict__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__div__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__divmod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__doc__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__eq__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__file__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__float__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__floordiv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__future__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__ge__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getattr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getattribute__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getitem__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getslice__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__gt__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__hash__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__hex__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__iadd__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__import__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__imul__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__init__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__int__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__invert__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__iter__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__le__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__len__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__long__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__lshift__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__lt__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__members__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__metaclass__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__mod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__mro__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__mul__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__name__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__ne__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__neg__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__new__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__nonzero__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__oct__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__or__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__path__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__pos__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__pow__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__radd__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rdiv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rdivmod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__reduce__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__repr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rfloordiv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rlshift__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rmod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rmul__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__ror__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rpow__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rrshift__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rsub__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rtruediv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rxor__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__setattr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__setitem__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__setslice__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__self__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__slots__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__str__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__sub__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__truediv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__version__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__xor__&lt;/KEYWORD3&gt;</t>
<t tx="T1800">@nocolor

</t>
<t tx="T1801">Each mode definition must begin with the following: 

&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE MODE SYSTEM "xmode.dtd"&gt; 

Each mode definition must also contain exactly one MODE tag. All other tags (PROPS, RULES) must be placed inside the MODE tag. The MODE tag does not have any defined attributes. Here is an example: 

&lt;MODE&gt;
    ... mode definition goes here ...
&lt;/MODE&gt; 
</t>
<t tx="T1802">The PROPS tag and the PROPERTY tags inside it are used to define mode-specific properties. Each PROPERTY tag must have a NAME attribute set to the property's name, and a VALUE attribute with the property's value. 

All buffer-local properties listed in the section called "Buffer-Local Properties" may be given values in edit modes. In addition, the following mode properties have no buffer-local equivalent: 

commentEnd - the comment end string, used by the Range Comment command. 

commentStart - the comment start string, used by the Range Comment command. 

lineComment - the line comment string, used by the Line Comment command. 

doubleBracketIndent - If a line matches the indentPrevLine regular expression and the next line contains an opening bracket, a level of indent will not be added to the next line, unless this property is set to "true". For example, with this property set to "false", Java code will be indented like so: 

while(objects.hasMoreElements())
{
        ((Drawable)objects.nextElement()).draw();
} 

On the other hand, settings this property to "true" will give the following result: 

while(objects.hasMoreElements())
        {
                ((Drawable)objects.nextElement()).draw();
        } 

indentCloseBrackets - A list of characters (usually brackets) that subtract indent from the current line. For example, in Java mode this property is set to "}".

indentOpenBrackets - A list of characters (usually brackets) that add indent to the next line. For example, in Java mode this property is set to "{".

indentPrevLine - When indenting a line, jEdit checks if the previous line matches the regular expression stored in this property. If it does, a level of indent is added. For example, in Java mode this regular expression matches language constructs such as "if", "else", "while", etc.

Here is the complete &lt;PROPS&gt; tag for Java mode: 

&lt;PROPS&gt;
    &lt;PROPERTY NAME="indentOpenBrackets" VALUE="{" /&gt;
    &lt;PROPERTY NAME="indentCloseBrackets" VALUE="}" /&gt;
    &lt;PROPERTY NAME="indentPrevLine" VALUE="\s*(((if|while)
        \s*\(|else|case|default)[^;]*|for\s*\(.*)" /&gt;
    &lt;PROPERTY NAME="doubleBracketIndent" VALUE="false" /&gt;
    &lt;PROPERTY NAME="commentStart" VALUE="/*" /&gt;
    &lt;PROPERTY NAME="commentEnd" VALUE="*/" /&gt;
    &lt;PROPERTY NAME="blockComment" VALUE="//" /&gt;
    &lt;PROPERTY NAME="wordBreakChars" VALUE=",+-=&lt;&gt;/?^&amp;*" /&gt;
&lt;/PROPS&gt; 
</t>
<t tx="T1803">RULES tags must be placed inside the MODE tag. Each RULES tag defines a ruleset.

A ruleset consists of a number of parser rules, with each parser rule specifying how to highlight a specific syntax token. There must be at least one ruleset in each edit mode. There can also be more than one, with different rulesets being used to highlight different parts of a buffer (for example, in HTML mode, one rule set highlights HTML tags, and another highlights inline JavaScript). For information about using more than one ruleset, see the section called "The SPAN Rule". 

The RULES tag supports the following attributes, all of which are optional: 

SET - the name of this ruleset. All rulesets other than the first must have a name. 

HIGHLIGHT_DIGITS - if set to TRUE, digits (0-9, as well as hexadecimal literals prefixed with "0x") will be highlighted with the DIGIT token type. Default is FALSE. 

IGNORE_CASE - if set to FALSE, matches will be case sensitive. Otherwise, case will not matter. Default is TRUE. 

DEFAULT - the token type for text which doesn't match any specific rule. Default is NULL. See the section called "Token Types" for a list of token types. 

Here is an example RULES tag: 

&lt;RULES IGNORE_CASE="FALSE" HIGHLIGHT_DIGITS="TRUE"&gt;
    ... parser rules go here ...
&lt;/RULES&gt; 

Rule Ordering Requirements

You might encounter this very common pitfall when writing your own modes. 

Since jEdit checks buffer text against parser rules in the order they appear in the ruleset, more specific rules must be placed before generalized ones, otherwise the generalized rules will catch everything. 

This is best demonstrated with an example. The following is incorrect rule ordering: 

&lt;SPAN TYPE="MARKUP"&gt;
    &lt;BEGIN&gt;[&lt;/BEGIN&gt;
    &lt;END&gt;]&lt;/END&gt;
&lt;/SPAN&gt;

&lt;SPAN TYPE="KEYWORD1"&gt;
    &lt;BEGIN&gt;[!&lt;/BEGIN&gt;
    &lt;END&gt;]&lt;/END&gt;
&lt;/SPAN&gt; 

If you write the above in a rule set, any occurrence of "[" (even things like "[!DEFINE", etc) will be highlighted using the first rule, because it will be the first to match. This is most likely not the intended behavior. 

The problem can be solved by placing the more specific rule before the general one: 

&lt;SPAN TYPE="KEYWORD1"&gt;
    &lt;BEGIN&gt;[!&lt;/BEGIN&gt;
    &lt;END&gt;]&lt;/END&gt;
&lt;/SPAN&gt;

&lt;SPAN TYPE="MARKUP"&gt;
    &lt;BEGIN&gt;[&lt;/BEGIN&gt;
    &lt;END&gt;]&lt;/END&gt;
&lt;/SPAN&gt; 

Now, if the buffer contains the text "[!SPECIAL]", the rules will be checked in order, and the first rule will be the first to match. However, if you write "[FOO]", it will be highlighted using the second rule, which is exactly what you would expect. 

Per-Ruleset Properties

The PROPS tag (described in the section called "The PROPS Tag") can also be placed inside the RULES tag to define ruleset-specific properties. Only the following properties can be set on a per-ruleset basis: 

commentEnd - the comment end string. 

commentStart - the comment start string. 

lineComment - the line comment string. 

These properties are used by the commenting commands to implement context-sensitive comments; see the section called "Commenting Out Code". 

The TERMINATE Rule

The TERMINATE rule specifies that parsing should stop after the specified number of characters have been read from a line. The number of characters to terminate after should be specified with the AT_CHAR attribute. Here is an example: 

&lt;TERMINATE AT_CHAR="1" /&gt; 

This rule is used in Patch mode, for example, because only the first character of each line affects highlighting. 

The SPAN Rule

The SPAN rule highlights text between a start and end string. The start and end strings are specified inside child elements of the SPAN tag. The following attributes are supported: 

TYPE - The token type to highlight the span with. See the section called "Token Types" for a list of token types

AT_LINE_START - If set to TRUE, the span will only be highlighted if the start sequence occurs at the beginning of a line

EXCLUDE_MATCH - If set to TRUE, the start and end sequences will not be highlighted, only the text between them will

NO_LINE_BREAK - If set to TRUE, the span will be highlighted with the INVALID token type if it spans more than one line

NO_WORD_BREAK - If set to TRUE, the span will be highlighted with the INVALID token type if it includes whitespace

DELEGATE - text inside the span will be highlighted with the specified ruleset. To delegate to a ruleset defined in the current mode, just specify its name. To delegate to a ruleset defined in another mode, specify a name of the form mode::ruleset. Note that the first (unnamed) ruleset in a mode is called "MAIN".

Here is a SPAN that highlights Java string literals, which cannot include line breaks: 

&lt;SPAN TYPE="LITERAL1" NO_LINE_BREAK="TRUE"&gt;
   &lt;BEGIN&gt;"&lt;/BEGIN&gt;
   &lt;END&gt;"&lt;/END&gt;
&lt;/SPAN&gt; 

Here is a SPAN that highlights Java documentation comments by delegating to the "JAVADOC" ruleset defined elsewhere in the current mode: 

&lt;SPAN TYPE="COMMENT2" DELEGATE="JAVADOC"&gt;
   &lt;BEGIN&gt;/**&lt;/BEGIN&gt;
   &lt;END&gt;*/&lt;/END&gt;
&lt;/SPAN&gt; 

Here is a SPAN that highlights HTML cascading stylesheets inside &lt;STYLE&gt; tags by delegating to the main ruleset in the CSS edit mode: 

&lt;SPAN TYPE="MARKUP" DELEGATE="css::MAIN"&gt;
   &lt;BEGIN&gt;&amp;lt;style&amp;gt;&lt;/BEGIN&gt;
   &lt;END&gt;&amp;lt;/style&amp;gt;&lt;/END&gt;
&lt;/SPAN&gt; 

Tip
The &lt;END&gt; tag is optional. If it is not specified, any occurrence of the start string will cause the remainder of the buffer to be highlighted with this rule. 

This can be very useful when combined with delegation. 

The EOL_SPAN Rule
An EOL_SPAN is similar to a SPAN except that highlighting stops at the end of the line, not after the end sequence is found. The text to match is specified between the opening and closing EOL_SPAN tags. The following attributes are supported: 

TYPE - The token type to highlight the span with. See the section called "Token Types" for a list of token types

AT_LINE_START - If set to TRUE, the span will only be highlighted if the start sequence occurs at the beginning of a line

EXCLUDE_MATCH - If set to TRUE, the start sequence will not be highlighted, only the text after it will

Here is an EOL_SPAN that highlights C++ comments: 

&lt;EOL_SPAN TYPE="COMMENT1"&gt;//&lt;/EOL_SPAN&gt; 

The MARK_PREVIOUS Rule
The MARK_PREVIOUS rule highlights from the end of the previous syntax token to the matched text. The text to match is specified between opening and closing MARK_PREVIOUS tags. The following attributes are supported: 

TYPE - The token type to highlight the text with. See the section called "Token Types" for a list of token types

AT_LINE_START - If set to TRUE, the text will only be highlighted if it occurs at the beginning of the line

EXCLUDE_MATCH - If set to TRUE, the match will not be highlighted, only the text before it will

Here is a rule that highlights labels in Java mode (for example, "XXX:"): 

&lt;MARK_PREVIOUS AT_LINE_START="TRUE"
    EXCLUDE_MATCH="TRUE"&gt;:&lt;/MARK_PREVIOUS&gt; 

The MARK_FOLLOWING Rule
The MARK_FOLLOWING rule highlights from the start of the match to the next syntax token. The text to match is specified between opening and closing MARK_FOLLOWING tags. The following attributes are supported: 

TYPE - The token type to highlight the text with. See the section called "Token Types" for a list of token types

AT_LINE_START - If set to TRUE, the text will only be highlighted if the start sequence occurs at the beginning of a line

EXCLUDE_MATCH - If set to TRUE, the match will not be highlighted, only the text after it will

Here is a rule that highlights variables in Unix shell scripts ("$CLASSPATH", "$IFS", etc): 

&lt;MARK_FOLLOWING TYPE="KEYWORD2"&gt;$&lt;/MARK_FOLLOWING&gt; 

The SEQ Rule
The SEQ rule highlights fixed sequences of text. The text to highlight is specified between opening and closing SEQ tags. The following attributes are supported: 

TYPE - the token type to highlight the sequence with. See the section called "Token Types" for a list of token types

AT_LINE_START - If set to TRUE, the sequence will only be highlighted if it occurs at the beginning of a line

The following rules highlight a few Java operators: 

&lt;SEQ TYPE="OPERATOR"&gt;+&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;-&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;*&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;/&lt;/SEQ&gt; 

The KEYWORDS Rule

There can only be one KEYWORDS tag per ruleset. The KEYWORDS rule defines keywords to highlight. Keywords are similar to SEQs, except that SEQs match anywhere in the text, whereas keywords only match whole words. 

The KEYWORDS tag does not define any attributes. 

Each child element of the KEYWORDS tag should be named after the desired token type, with the keyword text between the start and end tags. For example, the following rule highlights the most common Java keywords: 

&lt;KEYWORDS IGNORE_CASE="FALSE"&gt;
   &lt;KEYWORD1&gt;if&lt;/KEYWORD1&gt;
   &lt;KEYWORD1&gt;else&lt;/KEYWORD1&gt;
   &lt;KEYWORD3&gt;int&lt;/KEYWORD3&gt;
   &lt;KEYWORD3&gt;void&lt;/KEYWORD3&gt;
&lt;/KEYWORDS&gt; 

Token Types

Parser rules can highlight tokens using any of the following token types: 

NULL - no special highlighting is performed on tokens of type NULL 

COMMENT1 

COMMENT2 

FUNCTION 

INVALID - tokens of this type are automatically added if a NO_WORD_BREAK or NO_LINE_BREAK SPAN spans more than one word or line, respectively. 

KEYWORD1 

KEYWORD2 

KEYWORD3 

LABEL 

LITERAL1 

LITERAL2 

MARKUP 

OPERATOR 
</t>
<t tx="T1804">@ignore

@ It's not clear whether speeding up checkMoveWithParentWithWarning is enough.  I should look at the vnode move code as well.</t>
<t tx="T1805"># Returns false if any node of tree is a clone of parent or any of parents ancestors.

def checkMoveWithParentWithWarning (self,root,parent,warningFlag):

	clone_message = "Illegal move or drag: no clone may contain a clone of itself"
	drag_message  = "Illegal drag: Can't drag a node into its own tree"

	# 10/25/02: Create dictionaries for faster checking.
	parents = {} ; clones = {}
	while parent:
		parents [parent.t] = parent.t
		if parent.isCloned():
			clones [parent.t] = parent.t
		parent = parent.parent()
	
	# 10/25/02: Scan the tree only once.
	v = root ; next = root.nodeAfterTree()
	while v and v != next:
		ct = clones.get(v.t)
		if ct != None and ct == v.t:
			if warningFlag:
				alert(clone_message)
			return false
		v = v.threadNext()

	pt = parents.get(root.t)
	if pt == None:
		return true
	else:
		if warningFlag:
			alert(drag_message)
		return false
</t>
<t tx="T1806"></t>
<t tx="T1807"></t>
<t tx="T1808">@ignore

@ It probably won't help to use dicts rather than lists.  We still have to iterate either through join lists of joinDict.values().  I don't believe there is any big performance gain here.</t>
<t tx="T1809">@ The following methods are "middleware".  They stand between the "outer" code that executes commands, and the "raw" code that work only on a single tree or node at a time.

These routines act on the given node and all dependents joined to v's parent.</t>
<t tx="T1810">def create_dependent_trees (self,v):

	p = v.parent()
	n = v.childIndex()
	for j in p.joinDict:
		if j != v:
			c = self.copyEntireTree(v) # Use old copyNode and copyTree to do this.
			c = linkAsNthChild(p,n)
</t>
<t tx="T1811"># This destroys (i.e. unlinks) v and all dependent trees of v.
# Because of undo we _never_ actually destroy nodes.

def destroy_dependent_trees (self,v):

	p = v.parent()
	n = v.childIndex()
	for j in p.joinDict:
		c = j.nthChild(n)
		c.unlink()
</t>
<t tx="T1812">def move_dependent_trees_up (self,v):
	
	assert(v.next())
	p = v.parent()
	n = v.childIndex()
	for j in p.joinDict:
		c = j.nthChild(n)
		c.raw_move_down()
</t>
<t tx="T1813"># Move lefts may destroy dependent trees.
# The caller is responsible for doing that.

def move_dependent_trees_left (self,v):

	p = v.parent()
	n = v.childIndex()
	for j in p.joinDict:
		c = j.nthChild(n)
		c.raw_move_left()
</t>
<t tx="T1814"># Moving a node right may create dependent trees.
# The caller is responsible for doing that.
def move_dependent_trees_right (self,v):

	p = v.parent()
	n = v.childIndex()
	for j in p.joinDict:
		c = j.nthChild(n)
		c.raw_move_right()
</t>
<t tx="T1815">def move_dependent_trees_up (self,v):
	
	assert(v.back()
	p = v.parent()
	n = v.childIndex()
	for j in p.joinDict:
		c = j.nthChild(n)
		c.raw_move_up()
		
</t>
<t tx="T1816">@ Same as @file except puts no sentinels in the derived file.  Same as @silentfile except that section references and definitions are valid.
@c
</t>
<t tx="T1817">@ignore</t>
<t tx="T1818">line 1
&lt;&lt; ref &gt;&gt;
@others
last line</t>
<t tx="T1819">ref line 1
ref line 2</t>
<t tx="T1820">others line 1.</t>
<t tx="T1821">def __init__(self,theCommander):

	# trace("__init__", "atFile.__init__")
	self.commands = theCommander # The commander for the current window.
	self.initIvars()

def initIvars(self):

	&lt;&lt; initialize atFile ivars &gt;&gt;</t>
<t tx="T1822">@ errors is the number of errors seen while reading and writing.  structureErrors are errors reported by createNthChild.  If structure errors are found we delete the outline tree and rescan.
@c
self.errors = 0
self.structureErrors = 0

@ Initialized by atFile.scanAllDirectives.  8/1/02: set all to None here.
@c
self.default_directory = None
self.page_width = None
self.tab_width  = None
self.startSentinelComment = None
self.endSentinelComment = None
self.language = None

@ The files used by the output routines.  When tangling, we first write to a temporary output file.  After tangling is temporary file.  Otherwise we delete the old target file and rename the temporary file to be the target file.
@c
self.shortFileName = "" # short version of file name used for messages.
self.targetFileName = ""
self.outputFileName = ""
self.outputFile = None # The temporary output file.

@ The indentation used when outputting section references or at-others sections.  We add the indentation of the line containing the at-node directive and restore the old value when the
expansion is complete.
@c
self.indent = 0  # The unit of indentation is spaces, not tabs.

# The root of tree being written.
self.root = None

# Ivars used to suppress newlines between sentinels.
self.suppress_newlines = true # true: enable suppression of newlines.
self.newline_pending = false # true: newline is pending on read or write.

# Support of output_newline option
self.output_newline = getOutputNewline()

# Support of @raw
self.raw = false # true: in @raw mode
self.sentinels = true # true: output sentinels while expanding refs.</t>
<t tx="T1823">@ This method scans all vnodes, calling write for every @file node found.  If partialFlag is true we write all @file nodes in the selected outline.  Otherwise we write @file nodes in the entire outline.
@c
def writeAll(self,v,partialFlag):

	self.initIvars()
	# Kludge: look at whole tree if forceFlag is false;
	if partialFlag: after = v.nodeAfterTree()
	else: after = None
	&lt;&lt; Clear all orphan bits &gt;&gt;
	written = false
	while v and v != after:
		# trace(`v`)
		if v.isAtSilentFileNode(): # @ignore not recognised in @silentfile nodes.
			if v.isDirty() or partialFlag:
				self.silentWrite(v)
				written = true
			v = v.nodeAfterTree()
		elif v.isAtIgnoreNode():
			v = v.nodeAfterTree()
		elif v.isAtRawFileNode():
			if v.isDirty() or partialFlag:
				self.rawWrite(v)
				written = true
			v = v.nodeAfterTree()
		elif v.isAtNoSentinelsFileNode():
			if v.isDirty() or partialFlag:
				self.write(v,nosentinels=true)
				written = true
			v = v.nodeAfterTree()
		elif v.isAtFileNode():
			if v.isDirty() or partialFlag:
				self.write(v)
				written = true
			else:
				self.checkForLeoCustomize(v)
			v = v.nodeAfterTree()
		else: v = v.threadNext()
	if partialFlag: # This is the Write @file Nodes command.
		if written:
			es("finished")
		else:
			es("no @file or similar nodes in the selected tree")</t>
<t tx="T1824">@ We must clear these bits because they may have been set on a previous write.  Calls to atFile::write may set the orphan bits in @file nodes.  If so, write_LEO_file will write the entire @file tree.
@c

v2 = v
while v2 and v2 != after:
	v2.clearOrphan()
	v2 = v2.threadNext()</t>
<t tx="T1825">@ To do:

- Start syntax coloring of @root parts in @doc mode for @root-doc.</t>
<t tx="T1826"> @ignore</t>
<t tx="T1827">@ doc for @root-code

@root-code c:\prog\test\rootcode.txt

&lt;&lt;ref&gt;&gt;
&lt;&lt;ref2&gt;&gt;
&lt;&lt;ref3&gt;&gt;</t>
<t tx="T1828">should start in code mode.
</t>
<t tx="T1829">@ doc for ref2
&lt;&lt; ref2 &gt;&gt;=
ref2 code, part 1
&lt;&lt; ref2 &gt;&gt;=
ref2 code, part 2</t>
<t tx="T1830">@ doc for ref2
@c
ref3 code, part 1
@c
ref3 code, part 2</t>
<t tx="T1831">@ doc for @root-doc

@root-doc c:\prog\test\rootdoc.txt

&lt;&lt;ref&gt;&gt;</t>
<t tx="T1832">should start in doc mode
</t>
<t tx="T1833">def skip_doc(self,s,i):

	# trace(`get_line(s,i)`)
	# Skip @space, @*, @doc, @chapter and @section directives.
	doc1 = i
	while i &lt; len(s):
		if is_nl(s,i):
			doc1 = i = skip_nl(s,i)
		elif match(s,i,"@ ") or match(s,i,"@\t") or match(s,i,"@*"):
			i = skip_ws(s,i+2) ; doc1 = i
		elif match(s,i,"@\n"):
			i += 1 ; doc1 = i
		elif (match_word(s,i,"@doc") or
			  match_word(s,i,"@chapter") or
			  match_word(s,i,"@section")):
			doc1 = i = skip_line(s,i)
		else: break

	while i &lt; len(s):
		kind, end = self.token_type(s,i,dont_report_errors)
		if kind == at_code or kind == at_root or kind == section_def:
			break
		i = skip_line(s,i)

	doc = s[doc1:i]
	# trace(doc)
	return i, doc</t>
<t tx="T1834">@nocolor

Bugs item #642952, was opened at 2002-11-23 19:38
You can respond by visiting: 
https://sourceforge.net/tracker/?func=detail&amp;atid=103458&amp;aid=642952&amp;group_id=3458

Initial Comment: XML GLITCHES - ELEMENT COLLAPSE IS BAD

Converting an empty &lt;tnodes&gt;&lt;/tnodes&gt; element to a "collapsed" &lt;tnodes /&gt;
element will cause the LEO editor to interpret the file as a bad leo file.
Generally, it appears that collapsing any expanded tags, or expanding any
collapsed tags, will cause the 'bad file' error. This makes it impossible to
edit a .leo file in any XML editor that automatically converts empty elements
to either all-collapsed or all expanded (like XMLSpy does). Technically,
collapsed elements do not violate the 'well-formed' standard of XML 1.0 (the
standard treats collapsed and expanded tags as syntactically identical), but
apparently well-formed XML is not enough for the LEO editor, or whatever it
uses to parse XML.</t>
<t tx="T1835"></t>
<t tx="T1836">def createVnode(self,parent,back,tref,headline):

	# trace(`headline` + ", parent:" + `parent` + ", back:" + `back`)
	v = None ; c = self.commands
	# Shared tnodes are placed in the file even if empty.
	if tref == -1:
		t = leoNodes.tnode()
	else:
		t = self.getT(tref)
		if not t:
			t = self.newTnode(tref)
	if back: # create v after back.
		v = back.insertAfter(t)
	elif parent: # create v as the parent's first child.
		v = parent.insertAsNthChild(0,t)
	else: # create a root vnode
		v = leoNodes.vnode(c, t)
		v.moveToRoot()
		c.tree.rootVnode = v
	v.initHeadString(headline)
	return v</t>
<t tx="T1837"># This method finishes pasting the outline from the clipboard.
def finishPaste(self):

	c=self.commands
	current = c.currentVnode()
	after = current.nodeAfterTree()
	c.beginUpdate()
	if 1: # inside update...
		if 0: # Warning: this will only join pasted clones, and is very dangerous.
			&lt;&lt; Create join lists of all pasted vnodes &gt;&gt;
		&lt;&lt; Recompute clone bits for pasted vnodes &gt;&gt;
		self.compactFileIndices()
		c.selectVnode(current)
	c.endUpdate()
	return current</t>
<t tx="T1838"># Pass 1: create all join lists using tnode::joinHead
v = c.currentVnode()
while v and v != after:
	# Put v at the head of t's list of joined vnodes.
	v.setJoinList(v.t.joinHead)
	v.t.setJoinHead(v)
	v = v.threadNext()
	
# Pass 2: circularize each join list.
v = c.currentVnode()
while v and v != after:
	head = v.t.joinHead
	if not head:
		v = v.threadNext() ;continue
	# Make sure we don't handle this list again.
	v.t.setJoinHead(None)
	# Clear the join list if it has only one member.
	if head == v and not v.getJoinList():
		v.setJoinList(None)
		v = v.threadNext() ; continue
	# Point last at the last vnode of the list.
	last = head
	while last and last.getJoinList():
		last = last.getJoinList()
	assert(last)
	# Link last to head.
	last.setJoinList(head)
	v = v.threadNext()</t>
<t tx="T1839">@ This must be done after the join lists have been created.  The saved clone bit is unreliable for pasted nodes.
@c

v = c.currentVnode()
while v and v != after:
	v.initClonedBit(v.shouldBeClone())
	v.clearDirty()
	v = v.threadNext()</t>
<t tx="T1840"></t>
<t tx="T1841">def getClipboardHeader (self):

	if self.getOpenTag("&lt;leo_header"):
		return # 11/24/02

	while 1:
		if self.matchTag("file_format="):
			self.getDquote() ; self.fileFormatNumber = self.getLong() ; self.getDquote()
		elif self.matchTag("tnodes="):
			self.getDquote() ; self.getLong() ; self.getDquote() # no longer used
		elif self.matchTag("max_tnode_index="):
			self.getDquote() ; self.getLong() ; self.getDquote() # no longer used
		else:
			self.getTag("/&gt;")
			break</t>
<t tx="T1842"># For compatibility with old file formats.

def getCloneWindows (self):

	if not self.matchTag("&lt;clone_windows&gt;"):
		return

	while self.matchTag("&lt;clone_window vtag=\"V"):
		self.getLong() ; self.getDquote() ; self.getTag("&gt;")
		if not self.getCollapsedOpenTag("&lt;global_window_position"):
			self.getTag("&lt;global_window_position")
			self.getPosition()
			self.getTag("/&gt;")
		self.getTag("&lt;/clone_window&gt;")
	self.getTag("&lt;/clone_windows&gt;")</t>
<t tx="T1843">def getEscapedString (self):

	# The next '&lt;' begins the ending tag.
	i = self.fileIndex
	self.fileIndex = j = string.find(self.fileBuffer,'&lt;',i)
	if j == -1:
		raise BadLeoFile("unterminated escaped string")
	else:
		# Allocates memory
		return self.xmlUnescape(self.fileBuffer[i:j])</t>
<t tx="T1844">def getFindPanelSettings (self):

	c = self.commands ; config = app().config
	&lt;&lt; Set defaults of all flags &gt;&gt;
	if not self.getOpenTag("&lt;find_panel_settings"):
		while 1:
			if   self.matchTag("batch="): c.batch_flag = self.getDqBool()
			elif self.matchTag("wrap="): c.wrap_flag = self.getDqBool()
			elif self.matchTag("whole_word="): c.whole_word_flag = self.getDqBool()
			elif self.matchTag("ignore_case="): c.ignore_case_flag = self.getDqBool()
			elif self.matchTag("pattern_match="): c.pattern_match_flag = self.getDqBool()
			elif self.matchTag("search_headline="): c.search_headline_flag = self.getDqBool()
			elif self.matchTag("search_body="): c.search_body_flag = self.getDqBool()
			elif self.matchTag("suboutline_only="): c.suboutline_only_flag = self.getDqBool()
			elif self.matchTag("mark_changes="): c.mark_changes_flag = self.getDqBool()
			elif self.matchTag("mark_finds="): c.mark_finds_flag = self.getDqBool()
			elif self.matchTag("reverse="): c.reverse_flag = self.getDqBool()
			elif self.matchTag("node_only="): c.node_only_flag = self.getDqBool()
			else: break
		self.getTag("&gt;")
		#
		self.getTag("&lt;find_string&gt;")
		c.find_text = self.getEscapedString()
		self.getTag("&lt;/find_string&gt;")
		#
		self.getTag("&lt;change_string&gt;")
		c.change_text = self.getEscapedString()
		self.getTag("&lt;/change_string&gt;")
		#
		self.getTag("&lt;/find_panel_settings&gt;")
	
	# Override .leo file's preferences if settings are in leoConfig.txt.
	config.setCommandsFindIvars(c)
	# Update the settings immediately.
	app().findFrame.init(c)</t>
<t tx="T1845">import leoFind

for var in leoFind.ivars:
	exec("c.%s_flag = false" % var)
</t>
<t tx="T1846">def getLeoHeader (self):

	# Set defaults.
	self.maxTnodeIndex = 0
	self.numberOfTnodes = 0
	if self.getOpenTag("&lt;leo_header"):
		return

	# New in version 1.7: attributes may appear in any order.
	while 1:
		if self.matchTag("file_format="):
			self.getDquote() ; self.fileFormatNumber = self.getLong() ; self.getDquote()
		elif self.matchTag("tnodes="):
			self.getDquote() ; self.numberOfTnodes = self.getLong() ; self.getDquote()
		elif self.matchTag("max_tnode_index="):
			self.getDquote() ; self.maxTnodeIndex = self.getLong() ; self.getDquote()
		elif self.matchTag("clone_windows="):
			self.getDquote() ; self.getLong() ; self.getDquote() # no longer used.
		else:
			self.getTag("/&gt;")
			break</t>
<t tx="T1847">def getPosition (self):

	top = left = height = width = 0
	# New in version 1.7: attributes may appear in any order.
	while 1:
		if self.matchTag("top=\""):
			top = self.getLong() ; self.getDquote()
		elif self.matchTag("left=\""):
			left = self.getLong() ; self.getDquote()
		elif self.matchTag("height=\""):
			height = self.getLong() ; self.getDquote()
		elif self.matchTag("width=\""):
			width = self.getLong() ; self.getDquote()
		else: break
	return top, left, height, width</t>
<t tx="T1848">def getSize (self):

	# New in version 1.7: attributes may appear in any order.
	height = 0 ; width = 0
	while 1:
		if self.matchTag("height=\""):
			height = self.getLong() ; self.getDquote()
		elif self.matchTag("width=\""):
			width = self.getLong() ; self.getDquote()
		else: break
	return height, width</t>
<t tx="T1849">def getT (self,index):

	if self.tnodesDict.has_key(index):
		return self.tnodesDict[index]
	else:
		return None</t>
<t tx="T1850">def getTnode (self):

	# we have already matched &lt;t.
	index = -1
	# New in version 1.7: attributes may appear in any order.
	while 1:
		if self.matchTag("tx=\"T"):
			index = self.getIndex() ; self.getDquote()
		elif self.matchTag("rtf=\"1\""): pass # ignored
		elif self.matchTag("rtf=\"0\""): pass # ignored
		else: break
	self.getTag("&gt;")
	t = self.getT(index)
	if t:
		s = self.getEscapedString()
		t.setTnodeText(s)
	else: # No vnode refers to this tnode.
		es("no tnode with index: " + `index` + ".  The text will be discarded")
		self.getEscapedString()
	self.getTag("&lt;/t&gt;")</t>
<t tx="T1851">def getTnodes (self):

	# A slight change: we require a tnode element.  But Leo always writes this.
	if self.getOpenTag("&lt;tnodes&gt;"):
		return
		
	while self.matchTag("&lt;t"):
		self.getTnode()
	self.getTag("&lt;/tnodes&gt;")
</t>
<t tx="T1852">def getVnode (self,parent,back):

	# trace("parent:" + `parent` + ", back:" + `back`)
	c=self.commands
	# Create a single dummy vnode to carry status bits.
	if not self.dummy_v:
		self.dummy_t = leoNodes.tnode(0,"")
		self.dummy_v = leoNodes.vnode(c, self.dummy_t)
		self.dummy_v.initHeadString("dummy")
	self.dummy_v.statusBits=0
	currentVnodeFlag = false # true if the 'V' attribute seen.
	topVnodeFlag = false # true if 'T' attribute seen.
	tref = -1 ; headline = ""
	# we have already matched &lt;v.
	while 1:
		if self.matchTag("t=\"T"):
			tref = self.getIndex() ; self.getDquote()
		elif self.matchTag("vtag=\"V"):
			self.getIndex() ; self.getDquote() # ignored
		elif self.matchTag("a=\""):
			&lt;&lt; Handle vnode attribute bits &gt;&gt;
		else: break
	self.getTag("&gt;")
	# Leo2: headlines are optional.
	if self.matchTag("&lt;vh&gt;"):
		headline = self.getEscapedString() ; self.getTag("&lt;/vh&gt;")
	# Link v into the outline using parent and back.
	v = self.createVnode(parent,back,tref,headline)
	v.statusBits = self.dummy_v.statusBits
	# Remember various info that may have been specified.
	if currentVnodeFlag:
		c.tree.currentVnode = v
	if topVnodeFlag: c.mTopVnode = v
	# Recursively create all nested nodes.
	parent = v ; back = None
	while self.matchTag("&lt;v"):
		back = self.getVnode(parent,back)
	# End this vnode.
	self.getTag("&lt;/v&gt;")
	return v</t>
<t tx="T1853"># The a=" has already been seen.
while 1:
	if   self.matchChar('C'): self.dummy_v.initClonedBit(true)
	elif self.matchChar('D'): pass # no longer used.
	elif self.matchChar('E'): self.dummy_v.initExpandedBit()
	elif self.matchChar('M'): self.dummy_v.initMarkedBit()
	elif self.matchChar('O'): self.dummy_v.setOrphan()
	elif self.matchChar('T'): topVnodeFlag = true
	elif self.matchChar('V'): currentVnodeFlag = true
	else: break
self.getDquote()</t>
<t tx="T1854">def getVnodes (self):

	c=self.commands
	if  self.usingClipboard:
		# Paste after the current vnode.
		back = c.currentVnode() ; parent = back.parent()
	else:
		back = None ; parent = None

	if self.getOpenTag("&lt;vnodes&gt;"):
		return

	while self.matchTag("&lt;v"):
		back = self.getVnode(parent,back)

	self.getTag("&lt;/vnodes&gt;")</t>
<t tx="T1855">def skipWs (self):

	while self.fileIndex &lt; len(self.fileBuffer):
		ch = self.fileBuffer[self.fileIndex]
		if ch == ' ' or ch == '\t':
			self.fileIndex += 1
		else: break

	# The caller is entitled to get the next character.
	if  self.fileIndex &gt;= len(self.fileBuffer):
		raise BadLeoFile("")</t>
<t tx="T1856">def skipWsAndNl (self):

	while self.fileIndex &lt; len(self.fileBuffer):
		ch = self.fileBuffer[self.fileIndex]
		if ch == ' ' or ch == '\t' or ch == '\r' or ch == '\n':
			self.fileIndex += 1
		else: break

	# The caller is entitled to get the next character.
	if  self.fileIndex &gt;= len(self.fileBuffer):
		raise BadLeoFile("")</t>
<t tx="T1857">def newTnode(self,index):

	if self.tnodesDict.has_key(index):
		es("bad tnode index: " + `index` + ". Using empty text.")
		return leoNodes.tnode()
	else:
		t = leoNodes.tnode()
		t.setFileIndex(index)
		self.tnodesDict[index] = t
		return t</t>
<t tx="T1858">def readAtFileNodes (self):

	c = self.commands
	c.atFileCommands.readAll(c.currentVnode(), true) # partialFlag</t>
<t tx="T1859">def readOutlineOnly (self,file,fileName):

	c=self.commands
	# Read the entire file into the buffer
	self.fileBuffer = file.read() ; file.close()
	self.fileIndex = 0
	&lt;&lt; Set the default directory &gt;&gt;
	c.beginUpdate()
	ok, ratio = self.getLeoFile(self.frame,fileName,false) # readAtFileNodes
	c.endUpdate()
	c.frame.top.deiconify()
	c.setChanged(false)
	vflag,junk,secondary_ratio = self.frame.initialRatios()
	c.frame.resizePanesToRatio(ratio,secondary_ratio)
	# This should be done after the pane size has been set.
	if 0: # This can not be done at present.
		if self.topVnode:
			c.tree.scrollTo(self.topVnode)
			c.tree.Refresh()
	# delete the file buffer
	self.fileBuffer = ""
	return ok</t>
<t tx="T1860">def xmlUnescape(self,s):

	if s:
		s = string.replace(s, '\r', '')
		s = string.replace(s, "&amp;lt;", '&lt;')
		s = string.replace(s, "&amp;gt;", '&gt;')
		s = string.replace(s, "&amp;amp;", '&amp;')
	return s</t>
<t tx="T1861">@ignore</t>
<t tx="T1862">def clone (self):

	c = self ; v = c.currentVnode()
	if not v: return
	c.beginUpdate()
	clone = v.clone(v)
	if clone:
		clone.setDirty() # essential in Leo2
		c.setChanged(true)
		if c.validateOutline():
			c.selectVnode(clone)
			c.undoer.setUndoParams("Clone",clone)
	c.endUpdate() # updates all icons</t>
<t tx="T1863"># Draws icon for v at x,y

def drawIcon(self,v,x,y):

	v.iconx, v.icony = x,y

	y += 2 # draw icon at y + 2

	# Always recompute icon.
	val = v.iconVal = v.computeIcon()
	assert(0 &lt;= val &lt;= 15)
	
	# Compute the image name
	imagename = os.path.join("Icons", "box")
	if val &lt; 10: imagename += "0"
	imagename += `val`

	# Get the image
	image = self.getIconImage(imagename + ".GIF")
	id = self.canvas.create_image(x,y,anchor="nw",image=image)
	if 1: # 6/15/02: this reference is now cleared in v.__del__
		v.icon_id = id
	id1 = self.canvas.tag_bind(id,"&lt;1&gt;",v.OnIconClick)
	id2 = self.canvas.tag_bind(id,"&lt;Double-1&gt;",v.OnIconDoubleClick)
	if self.recycleBindings:
		self.tagBindings.append((id,id1,"&lt;1&gt;"),)
		self.tagBindings.append((id,id2,"&lt;Double-1&gt;"),)

	return 0 # dummy icon height
</t>
<t tx="T1864">def numberOfVisibleNodes(self):
	
	n = 0 ; v = self.rootVnode
	while v:
		n += 1
		v = v.visNext()
	return n</t>
<t tx="T1865">def OnIconClick (self,v,event):

	canvas = self.canvas
	# print "OnIconClick1:", v
	
	if event:
		canvas_x = canvas.canvasx(event.x)
		canvas_y = canvas.canvasy(event.y)
		id = canvas.find_closest(canvas_x,canvas_y)
		if id:
			self.drag_id = id
			self.drag_v = v
			canvas.tag_bind(id,"&lt;B1-Motion&gt;", v.OnDrag)
			canvas.tag_bind(id,"&lt;Any-ButtonRelease-1&gt;", v.OnEndDrag)
			self.oldcursor = self.canvas['cursor']
			self.canvas['cursor'] = "hand2" # "center_ptr"

	self.select(v)</t>
<t tx="T1866"># Creates a clone of back and insert it as the next sibling of back.

def clone (self,back):

	clone = self.cloneTree(back)
	clone.createDependents()
	# Set the clone bit in all nodes joined to back.
	clone.setClonedBit()
	back.setClonedBit()
	v = back.joinList
	while v and v != back:
		v.setClonedBit()
		v = v.joinList
	return clone</t>
<t tx="T1867">@nocolor

As we've discussed before, Leo chews up large chunks of memory when outlines
are expanded/collapsed, and even when the same sections of the outline are
expanded/collapsed, the memory usage grows by significant amounts. I don't see
how this relates to undo since there's no change in the text.
</t>
<t tx="T1868">def collectGarbage():
	
	if 0: # not needed.
		try:
			import gc
			gc.collect()
			# es("len(garbage):"+`len(gc.garbage)`)
		except:
			# es_exception()
			pass
</t>
<t tx="T1869"></t>
<t tx="T1870">@ About drawing and updating strategy.

This version of Leo draws the outline "by hand" using the Tk canvas widget.  Surprisingly, this is not only easy, but simplifies the vnode and Commands classes.

1.  Updating and redraw.  The tree.redraw() method is called automatically from the "outermost" call to tree.endUpdate.  Moreover, calling .tree.redraw() inside a tree.beginUpdate/tree.endUpdate pair does nothing.  c.redraw(), c.beginUpdate() and c.endUpdate() just call the corresponding tree methods.  Finally, beginUpdate()/endUpdate(false) can be used to suppress redrawing entirely.

Therefore, the Commands class never needs to worry about extra calls to tree.redraw() provided all code that draws to the tree is enclosed in a tree.beginUpdate/tree.endUpdate pair.  The tree.idle_body_key event handler manages redrawing "by hand" by maintaining a redraw_flag and then calling endUpdate(redraw_flag).

2.  The tree.redraw() method deletes all old canvas items and recomputes all data, including v.iconVal.  This means that v.doDelete need not actually delete vnodes for them to disappear from the screen.  Indeed, vnode are never actually deleted, only unlinked.  It would be valid for "dependent" vnodes to be deleted, but there really is no need to do so.
</t>
<t tx="T1871">def drawBox (self,v,x,y):

	y += 7 # draw the box at x, y+7

	# Portability fix for linux.
	minus_node = os.path.join("Icons", "minusnode.gif")
	plus_node = os.path.join("Icons", "plusnode.gif")
	iconname = choose(v.isExpanded(), minus_node, plus_node)
	
	image = self.getIconImage(iconname)
	id = self.canvas.create_image(x,y,image=image)
	if 0: # don't create a reference to this!
		v.box_id = id
	id1 = self.canvas.tag_bind(id, "&lt;1&gt;", v.OnBoxClick)
	id2 = self.canvas.tag_bind(id, "&lt;Double-1&gt;", lambda x: None)
	
	if self.recycleBindings:
		self.tagBindings.append((id,id1,"&lt;1&gt;"),)
		self.tagBindings.append((id,id2,"&lt;Double-1&gt;"),)</t>
<t tx="T1872">def drawNode(self,v,x,y):

	# Draw horizontal line from vertical line to icon.
	self.canvas.create_line(x, y+7, x+box_width, y+7,tag="lines",fill="gray50") # stipple="gray25")
	if v.firstChild(): self.drawBox(v,x,y)
	icon_height = self.drawIcon(v,x+box_width,y)
	text_height = self.drawText(v,x+box_width+icon_width,y)
	return max(icon_height, text_height)</t>
<t tx="T1873">def drawTree(self,v,x,y,h,level):

	yfirst = ylast = y
	if level==0: yfirst += 10
	while v:
		# trace(`x` + ", " + `y` + ", " + `v`)
		h = self.drawNode(v,x,y)
		y += h ; ylast = y
		if v.isExpanded() and v.firstChild():
			y = self.drawTree(v.firstChild(),x+child_indent,y,h,level+1)
		v = v.next()
	&lt;&lt; draw vertical line &gt;&gt;
	return y</t>
<t tx="T1874">id = self.canvas.create_line(
	x, yfirst-hline_y+4,
	x, ylast+hline_y-h,
	fill="gray50", # stipple="gray50"
	tag="lines")

self.canvas.tag_lower(id)</t>
<t tx="T1875">@ Returns the proper width of the entry widget for the headline. This has been a problem.
@c

def headWidth(self,v):

	return max(10,5 + len(v.headString()))</t>
<t tx="T1876">def hideAllChildren(self,v):

	child = v.firstChild()
	while child:
		self.hideTree(child)
		child = child.next()</t>
<t tx="T1877">def hideNode(self,v):

	self.canvas.delete(v.box_id)
	self.canvas.delete(v.icon_id)
	self.canvas.delete(v.edit_text)
	self.canvas.delete(v.edit_text_id)
	v.box_id = v.icon_id = None
	v.edit_text = v.edit_text_id = None</t>
<t tx="T1878">def hideTree(self,v):

	last = v.lastNode()
	while v:
		self.hideNode(v)
		if v == last: break
		v = v.threadNext()</t>
<t tx="T1879">def deleteBindings (self):
	
	if self.recycleBindings:
		count = 0
		# Unbind all the tag bindings.
		for id,id2,binding in self.tagBindings:
			self.canvas.tag_unbind(id,binding,id2)
			count += 1
		self.tagBindings = []
		# Unbind all the text bindings.
		for t,id,binding in self.bindings:
			t.unbind(binding,id)
			count += 1
		self.bindings = []
		# es("bindings freed:"+`count`)
	else:
		self.tagBindings = []
		self.bindings = []</t>
<t tx="T1880">Like Flatten text but w/o any body text.</t>
<t tx="T1881">a

aa</t>
<t tx="T1882">This node should not be searched.

a

aa</t>
<t tx="T1883">This node should not be searched.

a

aa</t>
<t tx="T1884"># Sets ivars of c that can be overridden by leoConfig.txt

def setCommandsFindIvars (self,c):

	config = self

	for s in leoFind.ivars:
		# This exec is safe because leoFind.ivars does not depend on leoConfig.txt.
		val = config.getBoolFindPref(s)
		if val: 
			exec("c."+s+"_flag = val")
			
	val = config.getStringFindPref("change_string")
	if val: c.change_text = val
	
	val = config.getStringFindPref("find_string")
	if val: c.find_text = val

	app().findFrame.init(c)</t>
<t tx="T1885">@ignore</t>
<t tx="T1886">@ This code requires Fredrik Lundh's PIL and tkIcon packages:

Download PIL    from http://www.pythonware.com/downloads/index.htm#pil
Download tkIcon from http://www.effbot.org/downloads/#tkIcon

We wait until the window has been drawn once before attaching the icon in OnVisiblity.

Many thanks to Jonathan M. Gilligan for suggesting this code.
@c

leoIcon = None

def attachLeoIcon (w):
	try:
		import Image,_tkicon
		import tkIcon
		global leoIcon
		
		f = onVisibility
		callback = lambda event,w=w,f=f:f(w,event)
		w.bind("&lt;Visibility&gt;",callback)
		if not leoIcon:
			# Using a .gif rather than an .ico allows us to specify transparency.
			icon_file_name = os.path.join(app().loadDir,'Icons','LeoWin.gif')
			icon_file_name = os.path.normpath(icon_file_name)
			icon_image = Image.open(icon_file_name)
			if 1: # Doesn't resize.
				leoIcon = createLeoIcon(icon_image)
			else: # Assumes 64x64
				leoIcon = tkIcon.Icon(icon_image)
			
	except:
		# es_exception()
		leoIcon = None</t>
<t tx="T1887"># This code is adapted from tkIcon.__init__
# Unlike the tkIcon code, this code does _not_ resize the icon file.

def createLeoIcon (icon):
	
	try:
		import Image,_tkicon
		import tkIcon
		
		i = icon ; m = None
		# create transparency mask
		if i.mode == "P":
			try:
				t = i.info["transparency"]
				m = i.point(lambda i, t=t: i==t, "1")
			except KeyError: pass
		elif i.mode == "RGBA":
			# get transparency layer
			m = i.split()[3].point(lambda i: i == 0, "1")
		if not m:
			m = Image.new("1", i.size, 0) # opaque
		# clear unused parts of the original image
		i = i.convert("RGB")
		i.paste((0, 0, 0), (0, 0), m)
		# create icon
		m = m.tostring("raw", ("1", 0, 1))
		c = i.tostring("raw", ("BGRX", 0, -1))
		return _tkicon.new(i.size, c, m)
	except:
		return None</t>
<t tx="T1888"># Handle the "visibility" event and attempt to attach the Leo icon.
# This code must be executed whenever the window is redrawn.

def onVisibility (w,event):

	global leoIcon

	try:
		import Image,_tkicon
		import tkIcon
		if leoIcon and w and event and event.widget == w:
			if 1: # Allows us not to resize the icon.
				leoIcon.attach(w.winfo_id())
			else:
				leoIcon.attach(w)
	except: pass</t>
<t tx="T1889">def markClones (self):

	c = self ; current = v = c.currentVnode()
	if not v: return
	if not v.isCloned(): return
	
	v = c.rootVnode()
	c.beginUpdate()
	while v:
		if v.t == current.t:
			v.setMarked()
		v = v.threadNext()
	c.endUpdate()</t>
<t tx="T1890">def goToNextClone(self):

	c = self ; current = c.currentVnode()
	if not current: return
	if not current.isCloned(): return

	v = current.threadNext()
	while v and v.t != current.t:
		v = v.threadNext()
		
	if not v:
		# Wrap around.
		v = c.rootVnode()
		while v and v != current and v.t != current.t:
			v = v.threadNext()

	if v:
		c.beginUpdate()
		c.endEditing()
		c.selectVnode(v)
		c.endUpdate()</t>
<t tx="T1891">@ignore</t>
<t tx="T1892">@file-nosent
&lt;&lt; ref &gt;&gt;</t>
<t tx="T1893">ref line</t>
<t tx="T1894">@file-noref
&lt;&lt; ref &gt;&gt;</t>
<t tx="T1895">ref line</t>
<t tx="T1896">@file-asis
&lt;&lt; ref &gt;&gt;</t>
<t tx="T1897">ref line</t>
<t tx="T1898"></t>
<t tx="T1899"># 12/03/02: We now handle @file options here.

def afterHeadlineMatch(self,s):
	
	h = self.mHeadString

	if s != "@file" and match_word(h,0,s):
		# No options are valid.
		return string.strip(h[len(s):])
	elif match(h,0,"@file"):
		i,atFileType = scanAtFileOptions(h)
		if s == atFileType:
			# print "s,h:",s,h
			return string.strip(h[i:])
		else: return ""
	else: return ""
</t>
<t tx="T1900">@ Returns the filename following @file or @rawfile, in the receivers's headline, or the empty string if the receiver is not an @file node.
@c

def atFileNodeName (self):
	return self.afterHeadlineMatch("@file")
	
def atNoSentinelsFileNodeName (self):
	return self.afterHeadlineMatch("@nosentinelsfile")
	
def atRawFileNodeName (self):
	return self.afterHeadlineMatch("@rawfile")
	
def atSilentFileNodeName (self):
	return self.afterHeadlineMatch("@silentfile")
</t>
<t tx="T1901"># Returns true if the receiver's headline starts with @file.
def isAtFileNode (self):
	s = self.atFileNodeName()
	return len(s) &gt; 0
	
# Returns true if the receiver's headline starts with @rawfile.
def isAtNoSentinelsFileNode (self):
	s = self.atNoSentinelsFileNodeName()
	return len(s) &gt; 0
	
# Returns true if the receiver's headline starts with @rawfile.
def isAtRawFileNode (self):
	s = self.atRawFileNodeName()
	return len(s) &gt; 0

# Returns true if the receiver's headline starts with @silentfile.
def isAtSilentFileNode (self):
	s = self.atSilentFileNodeName()
	return len(s) &gt; 0
</t>
<t tx="T1902">@ Returns true if the receiver contains @ignore in its body at the start of a line.
@c

def isAtIgnoreNode (self):

	flag, i = is_special(self.t.bodyString, 0, "@ignore")
	return flag</t>
<t tx="T1903">@ Returns true if the receiver contains @others in its body at the start of a line.
@c

def isAtOthersNode (self):

	flag, i = is_special(self.t.bodyString,0,"@others")
	return flag</t>
<t tx="T1904">@ Returns true if the headline matches the pattern ignoring whitespace and case.  The headline may contain characters following the successfully matched pattern.
@c

def matchHeadline (self,pattern):

	h = string.lower(self.mHeadString)
	h = string.replace(h,' ','')
	h = string.replace(h,'\t','')

	p = string.lower(pattern)
	p = string.replace(p,' ','')
	p = string.replace(p,'\t','')

	# ignore characters in the headline following the match
	return p == h[0:len(p)]</t>
<t tx="T1905">def scanAtFileOptions (h,err_flag=false):
	
	assert(match(h,0,"@file"))
	i = len("@file")
	atFileType = "@file"
	
	while match(h,i,'-'):
		&lt;&lt; scan another @file option &gt;&gt;

	return i,atFileType</t>
<t tx="T1906">i += 1 ; err = -1

if match(h,i,"noref"): # Just match the prefix.
	if atFileType == "@file":
		atFileType = "@rawfile"
	elif atFileType == "@nosentinelsfile":
		atFileType = "@silentfile"
	elif err_flag:
		es("ignoring redundant -noref in:" + h)
elif match(h,i,"nosent"): # Just match the prefix.
	if atFileType == "@file":
		atFileType = "@nosentinelsfile"
	elif atFileType == "@rawfile":
		atFileType = "@silentfile"
	elif err_flag:
		es("ignoring redundant -nosent in:" + h)
elif match_word(h,i,"asis"):
	if atFileType == "@file":
		atFileType = "@silentfile"
	elif err_flag:
		es("using -asis option in:" + h)
else:
	err = i-1
# Scan to the next minus sign.
while i &lt; len(h) and h[i] not in (' ','\t','-'):
	i += 1
if err &gt; -1:
	es("unknown option:" + h[err:i] + " in " + h)
</t>
<t tx="T1907">def scanAtRootOptions (s,i,err_flag=false):
	
	assert(match(s,i,"@root"))
	i += len("@root")
	mode = None 
	while match(s,i,'-'):
		&lt;&lt; scan another @root option &gt;&gt;

	if mode == None:
		doc = app().config.at_root_bodies_start_in_doc_mode
		mode = choose(doc,"doc","code")
	return i,mode</t>
<t tx="T1908">i += 1 ; err = -1

if match_word(s,i,"code"): # Just match the prefix.
	if not mode: mode = "code"
	elif err_flag: es("modes conflict in:" + get_line(s,i))
elif match(s,i,"doc"): # Just match the prefix.
	if not mode: mode = "doc"
	elif err_flag: es("modes conflict in:" + get_line(s,i))
else:
	err = i-1
	
# Scan to the next minus sign.
while i &lt; len(s) and s[i] not in (' ','\t','-'):
	i += 1

if err &gt; -1 and err_flag:
	es("unknown option:" + s[err:i] + " in " + get_line(s,i))</t>
<t tx="T1909">def setRootFromHeadline (self,v):

	# trace(`v`)
	s = v.headString()

	if s[0:5] == "@root":
		i,self.start_mode = scanAtRootOptions(s,0)
		i = skip_ws(s,i)

		if i &lt; len(s): # Non-empty file name.
			# self.root_name must be set later by token_type().
			self.root = s[i:]</t>
<t tx="T1910">@ The fix was to change match(s,i,"class") to match_word(s,i,"class") in
&lt; &lt; handle possible Python function or class &gt; &gt;
</t>
<t tx="T1911">#!/usr/bin/python

"""
params: --file d:/download/alwernia/snort.alert --scan d:/download/alwernia/portscan.log --sidmap d:/download/alwernia/sid-msg.map --class d:/download/alwernia/classification.config --gen snortgen.ini --excl siggen:100 --excl sigid:480
"""

import exceptions, string, sys, time, getopt, socket, struct, os
import HTMLgen

_SDATE = time.mktime((2002, 6, 28, 0, 0, 0, 0, 0, -1))

OUTDIR = 'c:/temp/results/'

OP_NONE = 0
OP_EQ = 1
OP_NE = 2
OP_LT = 3
OP_LE = 4
OP_GT = 5
OP_GE = 6

_SIG_GEN_IDX  = 0
_SIG_ID_IDX   = 1
_SIG_REV_IDX  = 2
_CLASS_IDX    = 3
_PRIO_IDX     = 4
_EV_ID_IDX    = 5
_EV_REF_IDX   = 6
_RTS_SEC_IDX  = 7
_RTS_MSEC_IDX = 8
_TS_SEC_IDX   = 9
_TS_MSEC_IDX  = 10
_SIP_IDX      = 11
_DIP_IDX      = 12
_SP_IDX       = 13
_DP_IDX       = 14
_PROTO_IDX    = 15
_FLAGS_IDX    = 16

_SCAN_TS_IDX    = 0
_SCAN_SIP_IDX   = 1
_SCAN_DIP_IDX   = 2
_SCAN_SP_IDX    = 3
_SCAN_DS_IDX    = 4
_SCAN_TYPE_IDX  = 5
_SCAN_FLAGS_IDX = 6

_GEN_ID_OPT = 'GENERATOR_ID'
_SNORT_ENGINE_GEN = 1


def loadalerts(fnames):
    alerts = []
    for fname in fnames:
        falerts = open(fname, 'rb')
        """
        typedef struct _UnifiedAlertFileHeader {
        u_int32_t magic;
        u_int32_t version_major;
        u_int32_t version_minor;
        u_int32_t timezone;
        } UnifiedAlertFileHeader;
        """
        headfmt = 'LLLL'
        binstr = falerts.read(struct.calcsize(headfmt))
        if len(binstr) != struct.calcsize(headfmt):
            raise exceptions.EOFError
    ##    head = struct.unpack(headfmt, binstr)
    ##    print hex(head[0]), head[1], head[2], head[3]
        """
        typedef struct _Event {
        u_int32_t sig_generator;   /* which part of snort generated the alert? */
        u_int32_t sig_id;          /* sig id for this generator */
        u_int32_t sig_rev;         /* sig revision for this id */
        u_int32_t classification;  /* event classification */
        u_int32_t priority;        /* event priority */
        u_int32_t event_id;        /* event ID */
        u_int32_t event_reference; /* reference to other events that have gone off,
                                    * such as in the case of tagged packets... */
        struct timeval ref_time;   /* reference time for the event reference */
        } Event;
        typedef struct _UnifiedAlert {
        Event event;
        struct timeval ts;         /* event timestamp */
        u_int32_t sip;             /* src ip */
        u_int32_t dip;             /* dest ip */
        u_int16_t sp;              /* src port */
        u_int16_t dp;              /* dest port */
        u_int32_t protocol;        /* protocol id */
        u_int32_t flags;           /* any other flags (fragmented, etc) */
        } UnifiedAlert;
        """
        recordfmt = 'LLLLLLLLLLL4s4sHHLL'
        recordlen = struct.calcsize(recordfmt)
        while 1:
            binstr = falerts.read(recordlen)
            if len(binstr) != recordlen:
                break
            issue = struct.unpack(recordfmt, binstr)
            if issue[_TS_SEC_IDX] &lt; _SDATE:
                continue
            alerts.append(issue)
        falerts.close()
    return alerts


def abmonth2num(abmonth):
    if abmonth == "Jan": return 1
    elif abmonth == "Feb": return 2
    elif abmonth == "Mar": return 3
    elif abmonth == "Apr": return 4
    elif abmonth == "May": return 5
    elif abmonth == "Jun": return 6
    elif abmonth == "Jul": return 7
    elif abmonth == "Aug": return 8 
    elif abmonth == "Sep": return 9
    elif abmonth == "Oct": return 10
    elif abmonth == "Nov": return 11
    elif abmonth == "Dec": return 12
    else: raise exceptions.ValueError


def _strptime(elems):
    """
    convert list of form:
    ['Apr', '15', '01:00:27']
    to default time module ticks (seconds)
    """
    curdate = time.localtime()
    syear = curdate[0]
    smonth = abmonth2num(elems[0])
    sday = int(elems[1])
    stime = string.split(elems[2], ':')
    shour = int(stime[0])
    smin = int(stime[1])
    ssec = int(stime[2])
    if smonth &gt; curdate[1] or \
       (smonth == curdate[1] and sday &gt; curdate[2]) or \
       (smonth == curdate[1] and sday == curdate[2] and shour &gt; curdate[3]) or \
       (smonth == curdate[1] and sday == curdate[2] and shour == curdate[3] and \
        smin &gt; curdate[4]) or \
       (smonth == curdate[1] and sday == curdate[2] and shour == curdate[3] and \
        smin == curdate[4] and ssec &gt; curdate[5]):
        syear = syear - 1
    return time.mktime((syear, smonth, sday, shour, smin, ssec, 0, 0, -1))


def loadscans(fnames):
    """
    parse line of form:
    Apr 15 01:00:27 195.205.251.110:22 -&gt; 212.160.142.84:22 SYNFIN ******SF
    """
    scans = []
    for fname in fnames:
        fscans = open(fname, 'r')
        for line in fscans.readlines():
            line = string.strip(line)
            if len(line) == 0:
                continue
            elems = string.split(line)
            if len(elems) != 8:
                continue
            sipandport = string.split(elems[3], ':')
            dipandport = string.split(elems[5], ':')
            sdate = _strptime(elems[:3])
            if sdate &lt; _SDATE:
                continue
            scans.append((sdate,
                          socket.inet_aton(sipandport[0]),
                          socket.inet_aton(dipandport[0]),
                          int(sipandport[1]), int(dipandport[1]),
                          elems[6], elems[7]))
        fscans.close()
    return scans


def loadsidmap(sidmapfname):
    fmap = open(sidmapfname, 'r')
    sidmap = {}
    lines = []
    for line in fmap.readlines():
        if line[0] == '#':
            continue
        line = string.strip(line)
        if len(line) == 0:
            continue
        siddef = string.split(line, ' || ')
        references = {}
        if len(siddef) &gt; 2:
            for ref in siddef[2:]:
                refelems = string.split(ref, ',')
                if len(refelems) ==2:
                    references[refelems[0]] = refelems[1]
        sidmap[int(siddef[0])] = (siddef[1], references)
    fmap.close()
    return sidmap


def loadclass(classlst):
    cmap = open(classlst, 'r')
    classifications = []
    lines = []
    for line in cmap.readlines():
        if line[0] == '#':
            continue
        line = string.strip(line)
        if len(line) == 0:
            continue
        classdef = string.split(line, ': ')
        if len(classdef) != 2:
            continue
        cdefs = string.split(classdef[1], ',')
        if len(cdefs) != 3:
            continue
        classifications.append((cdefs[0], cdefs[1], int(cdefs[2])))
    cmap.close()
    return classifications


def loadgen(genconf):
    import ConfigParser
    p = ConfigParser.ConfigParser()
    p.read(genconf)
    generators = {}
    for sec in p.sections():
        if p.has_option(sec, _GEN_ID_OPT):
            gen_id = p.getint(sec, _GEN_ID_OPT)
            generators[gen_id] = (sec, {})
            for opt in p.options(sec):
                if opt != string.lower(_GEN_ID_OPT):
                    generators[gen_id][1][p.getint(sec, opt)] = opt
    return generators
    

def cmpval(issue, pos, op, val):
    if (op == OP_NONE or op == OP_EQ) and issue[pos] == val:
        return 1
    elif op == OP_NE and issue[pos] != val:
        return 1
    elif op == OP_LT and issue[pos] &lt; val:
        return 1
    elif op == OP_LE and issue[pos] &lt;= val:
        return 1
    elif op == OP_GT and issue[pos] &gt; val:
        return 1
    elif op == OP_GE and issue[pos] &gt;= val:
        return 1
    return 0


def filterissues(issue, excludes):
    for ex in excludes:
        if ex[0](issue, ex[1], ex[2], ex[3]):
            return 0
    return 1


def groupby(issuelist, keymaker):
    groupedissues = {}
    for i in issuelist:
        key = keymaker(i)
        if groupedissues.has_key(key):
            groupedissues[key].append(i)
        else:
            groupedissues[key] = [i]
    return groupedissues


def calcunique(alertlist, keymaker):
    countedalerts = {}
    for a in alertlist:
        key = keymaker(a)
        if key not in countedalerts:
            countedalerts[key] = None
    keys = countedalerts.keys()
    return len(keys)


def compexcludes(exlist):
    excludeslist = []
    for elem in exlist:
        ex = string.split(elem, ':')
        fun = cmpval
        op = OP_NONE
        valstr = ex[1]
        if valstr[0] not in string.letters and \
           valstr[0] not in string.digits:
            if len(valstr) &lt; 2:
                continue
            if valstr[0] == '=':
                op = OP_EQ
                valstr = valstr[1:]
            elif valstr[0] == '!':
                op = OP_NE
                valstr = valstr[1:]
            elif valstr[0] == '&lt;':
                if valstr[1] == '=':
                    op = OP_LE
                    valstr = valstr[2:]
                else:
                    op = OP_LT
                    valstr = valstr[1:]
            elif valstr[0] == '&gt;':
                if valstr[1] == '=':
                    op = OP_GE
                    valstr = valstr[2:]
                else:
                    op = OP_GT
                    valstr = valstr[1:]
        if ex[0] == "siggen":
            pos = _SIG_GEN_IDX
            val = int(valstr)
        elif ex[0] == "sigid":
            pos = _SIG_ID_IDX
            val = int(valstr)
        elif ex[0] == "class":
            pos = _CLASS_IDX
            val = int(valstr)
        elif ex[0] == "sip":
            pos = _SIP_IDX
            val = socket.inet_aton(valstr)
        elif ex[0] == "dip":
            pos = _DIP_IDX
            val = socket.inet_aton(valstr)
        elif ex[0] == "ssip":
            pos = _SCAN_SIP_IDX
            val = socket.inet_aton(valstr)
        elif ex[0] == "sdip":
            pos = _SCAN_DIP_IDX
            val = socket.inet_aton(valstr)
        elif ex[0] == "prio":
            pos = _PRIO_IDX
            val = int(valstr)
        else:
            continue
        excludeslist.append((fun, pos, op, val))
    return excludeslist


def getscanURL(signature):
    return 'sig%03d%04d.html' % (signature[_SIG_GEN_IDX], signature[_SIG_ID_IDX])


def getipURL(ip, asdst):
    ipelems = string.split(socket.inet_ntoa(ip), '.')
    if asdst:
        prefix = 'd'
    else:
        prefix = 's'
    return '%sip%s_%s_%s_%s.html' % (prefix,
                                        ipelems[0], ipelems[1],
                                        ipelems[2], ipelems[3])


def getsidhrefs(sid, references):
    hrefs = [HTMLgen.Href('http://www.snort.org/snort-db/sid.html?id=' + str(sid),
                          '[sid]', target='siginfo')]
    for refkey in references.keys():
        if refkey == 'arachnids':
            hrefs.append(HTMLgen.Href('http://whitehats.com/IDS/IDS' + references[refkey],
                                      '[arachNIDS]', target='siginfo'))
        elif refkey == 'url':
            hrefs.append(HTMLgen.Href('http://' + references[refkey],
                                      string.split(references[refkey], '/')[0],
                                      target='siginfo'))
        elif refkey == 'bugtraq':
            hrefs.append(HTMLgen.Href('http://www.securityfocus.com/bid/' + references[refkey],
                                      '[BUGTRAQ]', target='siginfo'))
        elif refkey == 'arachnids':
            hrefs.append(HTMLgen.Href('http://cve.mitre.org/cgi-bin/cvename.cgi?name=' + references[refkey],
                                      references[refkey], target='siginfo'))
    return hrefs

def findearliest(issues, pos=_TS_SEC_IDX):
    if issues == None or len(issues) == 0:
        return 0
    earliest = time.time()
    for a in issues:
        if earliest &gt; a[pos]:
            earliest = a[pos]
    return earliest

def findlatest(issues, pos=_TS_SEC_IDX):
    if issues == None or len(issues) == 0:
        return time.time()
    latest = 0
    for a in issues:
        if latest &lt; a[pos]:
            latest = a[pos]
    return latest


def getfreqsortedlist(alerts):
    gen_grouped = groupby(alerts, lambda a: a[_SIG_GEN_IDX])
    gens = gen_grouped.keys()
    allalerts = []
    for gen in gens:
        grouped = groupby(gen_grouped[gen], lambda a: a[_SIG_ID_IDX])
        sids = grouped.keys()
        for sid in sids:
            allalerts.append(grouped[sid])
    allalerts.sort(lambda a1, a2: -cmp(len(a1), len(a2)))
    return allalerts
    

def outsignature(alerts, classlist, siddict, generators, sgrouped, dgrouped):
    subst = {'noalerts':len(alerts)}
    subst['earliest'] = time.strftime('%c', time.localtime(findearliest(alerts)))
    subst['latest'] = time.strftime('%c', time.localtime(findlatest(alerts)))
    subst['details'] = ''
    subst['signame'] = 'Unknown'
    sid = alerts[0][_SIG_ID_IDX]
    classiffy = alerts[0][_CLASS_IDX]
    generator = alerts[0][_SIG_GEN_IDX]
    if generator == _SNORT_ENGINE_GEN:
        if siddict.has_key(sid):
            subst['signame'] = siddict[sid][0]
            rowdata = []
            trow = HTMLgen.TR()
            for href in getsidhrefs(sid, siddict[sid][1]):
                rowdata.append(HTMLgen.TD(href))
            trow = HTMLgen.TR()
            trow = trow + rowdata
            subst['details'] = HTMLgen.TableLite(trow, cellpadding=5, border=0)
    else:
        if generators.has_key(generator):
            subst['signame'] = 'Generator: '+ generators[generator][0] + \
                               ' [' + str(generator) + ']'
            if generators[generator][1].has_key(sid):
                subst['signame'] = subst['signame'] + \
                                   'Event: '+ generators[generator][1][sid] + \
                                   ' [' + str(sid) + ']'
    subst['class'] = classlist[classiffy][1]
    subst['prio'] = str(classlist[classiffy][2]) + \
                    ',' + str(alerts[0][_PRIO_IDX])
    srcgrouped = groupby(alerts, lambda a: a[_SIP_IDX])
    sips = srcgrouped.keys()
    sips.sort(lambda a1, a2, d=srcgrouped: -cmp(len(d[a1]), len(d[a2])))
    dstgrouped = groupby(alerts, lambda a: a[_DIP_IDX])
    dips = dstgrouped.keys()
    dips.sort()
    t = HTMLgen.Table('Sources triggering this attack signature',
                      cell_align="center")
    t.heading = ['Source', '# Alerts (sig)', '# Alerts (total)',
                 '# Dsts (sig)', '# Dsts (total)']
    t.body = []
    for sip in sips:
        t.body.append([HTMLgen.Href(getipURL(sip, 0), socket.inet_ntoa(sip)),
                       str(len(srcgrouped[sip])), str(len(sgrouped[sip])),
                       str(calcunique(srcgrouped[sip], lambda a: a[_DIP_IDX])),
                       str(calcunique(sgrouped[sip], lambda a: a[_DIP_IDX]))])
    subst['srctable'] = t
    t = HTMLgen.Table('Destinations receiving this attack signature',
                      cell_align="center")
    t.heading = ['Destinations', '# Alerts (sig)', '# Alerts (total)',
                 '# Srcs (sig)', '# Srcs (total)']
    t.body = []
    for dip in dips:
        t.body.append([HTMLgen.Href(getipURL(dip, 1), socket.inet_ntoa(dip)),
                       str(len(dstgrouped[dip])), str(len(dgrouped[dip])),
                       str(calcunique(dstgrouped[dip], lambda a: a[_SIP_IDX])),
                       str(calcunique(dgrouped[dip], lambda a: a[_SIP_IDX]))])
    subst['dsttable'] = t
    subst['gendate'] = time.strftime('%c')
    doc = HTMLgen.TemplateDocument('templ_sig.html')
    doc.substitutions = subst
    doc.write(OUTDIR + getscanURL(alerts[0]))


def outsigline(alert, siddict, generators):
    generator = alert[_SIG_GEN_IDX]
    sid = alert[_SIG_ID_IDX]
    if generator == _SNORT_ENGINE_GEN:
        if siddict.has_key(sid):
            aname = siddict[sid][0] + ' [' + str(sid) + ']'
        else:
            aname = 'Unknown signature ID: ' + str(sid)
    else:
        if generators.has_key(generator):
            aname = 'Generator: '+ generators[generator][0] 
            if generators[generator][1].has_key(sid):
                aname = aname + '&amp;nbsp;&amp;nbsp;&amp;nbsp;Event: ' + \
                        generators[generator][1][sid]
        else:
            aname = 'Unknown generator ID: ' + str(generator)
    return aname

    
def outalerts(alerts, classlist, siddict, generators):
    sgrouped = groupby(alerts, lambda a: a[_SIP_IDX])
    dgrouped = groupby(alerts, lambda a: a[_DIP_IDX])
    t = HTMLgen.TableLite(cellpadding=3, border=2)
    for grouped in getfreqsortedlist(alerts):
        outsignature(grouped, classlist, siddict, generators,
                     sgrouped, dgrouped)
        row = HTMLgen.TR()
        row = row + [HTMLgen.TD(HTMLgen.Href(getscanURL(grouped[0]),
                                             outsigline(grouped[0],
                                                        siddict,
                                                        generators))),
                     HTMLgen.TD(str(len(grouped)))]
        t.append(row)
    doc = HTMLgen.TemplateDocument('templ_alerts.html')
    doc.substitutions = {'sigstable':t,
                         'gendate':time.strftime('%c')}
    doc.write(OUTDIR + 'alerts.html')    


def outscans(scans):
    subst = {'noscans':len(scans)}
    grouped = groupby(scans, lambda s: s[_SCAN_SIP_IDX])
    sips = grouped.keys()
    sips.sort(lambda a1, a2, d=grouped: -cmp(len(d[a1]), len(d[a2])))
    t = HTMLgen.TableLite(cellpadding=3, border=2)
    for sip in sips:
        row = HTMLgen.TR()
        row = row + [HTMLgen.TD(HTMLgen.Href(getipURL(sip, 0),
                                             socket.inet_ntoa(sip))),
                     HTMLgen.TD(str(len(grouped[sip])))]
        t.append(row)
    subst['srctable'] = t
    grouped = groupby(scans, lambda s: s[_SCAN_DIP_IDX])
    dips = grouped.keys()
    dips.sort(lambda a1, a2, d=grouped: -cmp(len(d[a1]), len(d[a2])))
    t = HTMLgen.TableLite(cellpadding=3, border=2)
    for dip in dips:
        row = HTMLgen.TR()
        row = row + [HTMLgen.TD(HTMLgen.Href(getipURL(dip, 1),
                                             socket.inet_ntoa(dip))),
                     HTMLgen.TD(str(len(grouped[dip])))]
        t.append(row)
    subst['dsttable'] = t
    subst['gendate'] = time.strftime('%c')
    doc = HTMLgen.TemplateDocument('templ_scans.html')
    doc.substitutions = subst
    doc.write(OUTDIR + 'scans.html')    

    
def outips(alerts, scans, siddict, generators):
    grouped = groupby(alerts, lambda a: a[_SIP_IDX])
    sips = grouped.keys()
    sips.sort(lambda a1, a2, d=grouped: -cmp(len(d[a1]), len(d[a2])))
    groupeds = groupby(scans, lambda s: s[_SCAN_SIP_IDX])
    t = HTMLgen.TableLite(cellpadding=3, border=2)
    for sip in sips:
        if groupeds.has_key(sip):
            sscans = groupeds[sip]
        else:
            sscans = []
        outip(grouped[sip], sscans, siddict, generators, 0)
        row = HTMLgen.TR()
        row = row + [HTMLgen.TD(HTMLgen.Href(getipURL(sip, 0),
                                             socket.inet_ntoa(sip))),
                     HTMLgen.TD(str(len(grouped[sip])))]
        t.append(row)
    for sip in filter(lambda s, ips=sips: s not in ips, groupeds):
        outip([], groupeds[sip], siddict, generators, 0)
    doc = HTMLgen.TemplateDocument('templ_sips.html')
    doc.substitutions = {'sipstable':t,
                         'gendate':time.strftime('%c')}
    doc.write(OUTDIR + 'sips.html')    
    grouped = groupby(alerts, lambda a: a[_DIP_IDX])
    dips = grouped.keys()
    dips.sort(lambda a1, a2, d=grouped: -cmp(len(d[a1]), len(d[a2])))
    groupeds = groupby(scans, lambda s: s[_SCAN_DIP_IDX])
    t = HTMLgen.TableLite(cellpadding=3, border=2)
    for dip in dips:
        if groupeds.has_key(dip):
            dscans = groupeds[dip]
        else:
            dscans = []
        outip(grouped[dip], dscans, siddict, generators, 1)
        row = HTMLgen.TR()
        row = row + [HTMLgen.TD(HTMLgen.Href(getipURL(dip, 1),
                                             socket.inet_ntoa(dip))),
                     HTMLgen.TD(str(len(grouped[dip])))]
        t.append(row)
    for dip in filter(lambda s, ips=dips: s not in ips, groupeds):
        outip([], groupeds[dip], siddict, generators, 1)
    doc = HTMLgen.TemplateDocument('templ_dips.html')
    doc.substitutions = {'dipstable':t,
                         'gendate':time.strftime('%c')}
    doc.write(OUTDIR + 'dips.html')    


def outip(alerts, scans, siddict, generators, asdst):
    substs = {}
    colorlist = ['antiquewhite', '#E0CDD0', '#D5E2CE']
    if len(alerts) &gt; 0:
        if asdst:
            outname = OUTDIR + getipURL(alerts[0][_DIP_IDX], asdst)
            substs['ip'] = socket.inet_ntoa(alerts[0][_DIP_IDX])
        else:
            outname = OUTDIR + getipURL(alerts[0][_SIP_IDX], asdst)
            substs['ip'] = socket.inet_ntoa(alerts[0][_SIP_IDX])
        substs['noissues'] = len(alerts) + len(scans)
        substs['earliest'] = time.strftime('%c',
                                           time.localtime(min(findearliest(alerts),
                                                              findearliest(scans, _SCAN_TS_IDX))))
        substs['latest'] = time.strftime('%c',
                                         time.localtime(max(findlatest(alerts),
                                                            findlatest(scans, _SCAN_TS_IDX))))
        allalerts = getfreqsortedlist(alerts)
        substs['nosigs'] = len(allalerts)
        l = HTMLgen.List()
        for alertgrp in allalerts:
            ipurl = getscanURL(alertgrp[0])
            desc = outsigline(alertgrp[0], siddict, generators)
            l.append(HTMLgen.StringTemplate('{nr} instances of {sig}',
                                            {'nr':len(alertgrp),
                                             'sig':HTMLgen.Href(ipurl, desc)}))
        substs['siglist'] = l
        if asdst:
            grouped = groupby(alerts, lambda a: a[_SIP_IDX])
        else:
            grouped = groupby(alerts, lambda a: a[_DIP_IDX])
        ips = grouped.keys()
        substs['noips'] = len(ips)
        coloridx = 0
        alerts.sort(lambda a1, a2: cmp(a1[_TS_SEC_IDX], a2[_TS_SEC_IDX]))
        t = HTMLgen.TableLite(cellpadding=4, border=2)
        for a in alerts:
            adesc = outsigline(a, siddict, generators)
            rowlist = [HTMLgen.TD(time.strftime('%b %d %H:%M:%S',
                                                  time.localtime(a[_TS_SEC_IDX]))),
                       HTMLgen.TD(substs['ip']),
                       HTMLgen.TD(HTMLgen.Href(getscanURL(a), adesc))]
            if asdst:
                rowlist.insert(1, HTMLgen.TD(HTMLgen.Href(getipURL(a[_SIP_IDX], 0),
                                                          socket.inet_ntoa(a[_SIP_IDX]))))
            else:
                rowlist.insert(2, HTMLgen.TD(HTMLgen.Href(getipURL(a[_DIP_IDX], 1),
                                                          socket.inet_ntoa(a[_DIP_IDX]))))
            templstr = 'http://www.portsdb.org/bin/portsdb.cgi?' + \
                       'portnumber=%d&amp;protocol=%s'
            if a[_PROTO_IDX] == socket.IPPROTO_TCP:
                spref = HTMLgen.Href(templstr % (a[_SP_IDX], 'TCP'),
                                     str(a[_SP_IDX]), target='lookup')
                dpref = HTMLgen.Href(templstr % (a[_DP_IDX], 'TCP'),
                                     str(a[_DP_IDX]), target='lookup')
            elif a[_PROTO_IDX] == socket.IPPROTO_UDP:
                spref = HTMLgen.Href(templstr % (a[_SP_IDX], 'UDP'),
                                     str(a[_SP_IDX]), target='lookup')
                dpref = HTMLgen.Href(templstr % (a[_DP_IDX], 'UDP'),
                                     str(a[_DP_IDX]), target='lookup')
            else:
                spref = ''
                dpref = ''
            rowlist.insert(2, HTMLgen.TD(spref))
            rowlist.insert(4, HTMLgen.TD(dpref))
            row = HTMLgen.TR(bgcolor=colorlist[coloridx])
            row = row + rowlist
            t.append(row)
            coloridx += 1
            coloridx %= len(colorlist)
        substs['sigtable'] = t
    else:
        if asdst:
            outname = OUTDIR + getipURL(scans[0][_SCAN_DIP_IDX], asdst)
            substs['ip'] = socket.inet_ntoa(scans[0][_SCAN_DIP_IDX])
        else:
            outname = OUTDIR + getipURL(scans[0][_SCAN_SIP_IDX], asdst)
            substs['ip'] = socket.inet_ntoa(scans[0][_SCAN_SIP_IDX])
        substs['noissues'] = len(scans)
        substs['earliest'] = time.strftime('%c', time.localtime(findearliest(scans, _SCAN_TS_IDX)))
        substs['latest'] = time.strftime('%c', time.localtime(findlatest(scans, _SCAN_TS_IDX)))
        substs['nosigs'] = 0
        substs['siglist'] = ''
        substs['sigtable'] = ''
        substs['noips'] = 0
    if asdst:
        substs['dir'] = 'to'
        substs['srcordst'] = 'destination'
        substs['invsrcordst'] = 'source'
        grouped = groupby(scans, lambda s: s[_SCAN_SIP_IDX])
    else:
        substs['dir'] = 'from'
        substs['srcordst'] = 'source'
        substs['invsrcordst'] = 'destination'
        grouped = groupby(scans, lambda s: s[_SCAN_DIP_IDX])
    ips = grouped.keys()
    substs['noips'] += len(grouped.keys())
    ipelems = string.split(substs['ip'], '.')
    substs['ip1'] = ipelems[0]
    substs['ip2'] = ipelems[1]
    substs['ip3'] = ipelems[2]
    substs['ip4'] = ipelems[3]
    if len(scans) &gt; 0:
        coloridx = 0
        scans.sort(lambda s1, s2: cmp(s1[_SCAN_TS_IDX], s2[_SCAN_TS_IDX]))
        t = HTMLgen.TableLite(cellpadding=4, border=2)
        for s in scans:
            rowlist = [HTMLgen.TD(time.strftime('%b %d %H:%M:%S',
                                                  time.localtime(s[_SCAN_TS_IDX]))),
                       HTMLgen.TD(substs['ip']),
                       HTMLgen.TD(s[_SCAN_TYPE_IDX] + ' [' + s[_SCAN_FLAGS_IDX] + ']')]
            if asdst:
                rowlist.insert(1, HTMLgen.TD(HTMLgen.Href(getipURL(s[_SCAN_SIP_IDX], 0),
                                                          socket.inet_ntoa(s[_SCAN_SIP_IDX]))))
            else:
                rowlist.insert(2, HTMLgen.TD(HTMLgen.Href(getipURL(s[_SCAN_DIP_IDX], 1),
                                                          socket.inet_ntoa(s[_SCAN_DIP_IDX]))))
            row = HTMLgen.TR(bgcolor=colorlist[coloridx])
            row = row + rowlist
            t.append(row)
            coloridx += 1
            coloridx %= len(colorlist)
        substs['scantable'] = t
    else:
        substs['scantable'] = None
    substs['gendate'] = time.strftime('%c')
    doc = HTMLgen.TemplateDocument('templ_ip.html')
    doc.substitutions = substs
    doc.write(outname)
    

def usage():
    print "Parameters:\n" \
          "--file --sidmap --class --exclude --gen"


def parseargs():
    fnames = []
    fscans = []
    sidmap = "sid-msg.map"
    classlst = "classification.config"
    exclude = []
    try:
        opts, args = getopt.getopt(sys.argv[1:],
                                   "",
                                   ["file=", "scan=", "sidmap=",
                                    "class=", "gen=", "excl="])
    except getopt.GetoptError ,e:
        # print help information and exit:
        print "something wrong with options: ", e
        usage()
        sys.exit(1)
    for o, a in opts:
        if o == "--file":
            fnames.append(a)
        if o == "--scan":
            fscans.append(a)
        elif o == "--sidmap":
            sidmap = a
        elif o == "--excl":
            exclude.append(a)
        elif o == "--gen":
            genconf = a
        elif o == "--class":
            classlst = a
    if len(fnames) == 0:
        fnames = ["snort.alert",]
    return fnames, fscans, sidmap, classlst, genconf, exclude


def printscan(scan):
    ts = time.localtime(scan[0])
    outstr = "%04d.%02d.%02d %02d:%02d:%02d " % \
             (ts[0], ts[1], ts[2], ts[3], ts[4], ts[5])
    outstr = outstr + socket.inet_ntoa(scan[1]) + ':' + str(scan[3]) + \
             ' -&gt; ' + socket.inet_ntoa(scan[2]) + ':' + str(scan[4]) + '\n'
    outstr = outstr + scan[5] + ' scan attempt [' + scan[6] + ']'
    print outstr


if __name__ == '__main__':
    print "\nStart."
    os.chdir('c:/temp')
    start = time.clock()
    fnames, fscans, sidmap, classlst, genconf, exclude = parseargs()
    siddict = loadsidmap(sidmap)
    classlist = loadclass(classlst)
    generators = loadgen(genconf)
    alerts = loadalerts(fnames)
    scans = loadscans(fscans)
    if len(exclude) &gt; 0:
        exlist = compexcludes(exclude)
        alerts = filter(lambda a, excludes=exlist: filterissues(a, excludes), alerts)
        scans = filter(lambda s, excludes=exlist: filterissues(s, excludes), scans)
    outalerts(alerts, classlist, siddict, generators)
    outscans(scans)
    outips(alerts, scans, siddict, generators)
    print "\nDone (", time.clock()-start, "s)."
    </t>
<t tx="T1912">@ The wrong file was being opened.

- (done) replaced index by normalized file name.  That should be bulletproof.
- (done) fixed lambda.

to do: test on Python 2.1.</t>
<t tx="T1913">By: paulpaterson ( Paul Paterson ) 
 Bug?: tangle_done root_list   
2002-12-04 16:48

I wrote a tangle done routine to do some markup on some files and noticed that the file paths you get in the root_list are based on the default tangle directory and not the actual directory that the files were writen. 

To see this problem (on 3.9) put a @path directive in a node, then create a child @root node as below, 

Parent node: '@path c:\temp' 
Child node: '@root myfile.txt' 

Add some text to the child node and then tangle it. You get a c:\temp\myfile.txt file but the tangle_done.run function is called with a root_list of ["&lt;default leo tangle dir&gt;\myfile.txt"] 

You don't get this problem if you fully specify the path in the @root directive.</t>
<t tx="T1914">@ignore
@path c:\prog</t>
<t tx="T1915">@root test\tangleDone.txt

tangleDone test</t>
<t tx="T1916"># This code is called from tangleTree and untangleTree.

def cleanup (self):
	
	if self.errors == 0:
		&lt;&lt; call tangle_done.run() or untangle_done.run() &gt;&gt;

	# Reinitialize the symbol tables and lists.
	self.tst = {}
	self.ust = {}
	self.root_list = []
	self.def_stack = []</t>
<t tx="T1917"># Create a list of root names:
root_names = []
dir = self.tangle_directory # Bug fix: 12/04/02
if not dir: dir = ""
for section in self.root_list:
	for part in section.parts:
		if part.is_root:
			root_names.append(os.path.join(dir,part.name))

if self.tangling and self.tangle_batch_flag:
	try:
		import tangle_done
		tangle_done.run(root_names)
	except:
		es("Can not execute tangle_done.run()")
		es_exception()
if not self.tangling and self.untangle_batch_flag:
	try:
		import untangle_done
		untangle_done.run(root_names)
	except:
		es("Can not execute tangle_done.run()")
		es_exception()</t>
<t tx="T1918">@

to do:
	
- check data in createOpenWithMenuFromTable (catch exceptions).</t>
<t tx="T1919">@ Entries in the following table are the tuple (commandName,shortcut,data).
data is the tuple (command,arg,ext).
command is one of "os.system", "os.startfile", "os.spawnl", "os.spawnv" or "exec".
Leo executes command(arg+path) where path is the full path to the temp file.
If ext is not None, the temp file has the extension ext,
Otherwise, Leo computes an extension based on what @language directive is in effect.
@c

idle_arg = "c:/python22/tools/idle/idle.py -e "
table = (
	("&amp;Idle",   "Alt+Shift+I",("os.system",idle_arg,".py")),
	("&amp;Word",   "Alt+Shift+W",("os.startfile",None,".doc")),
	("Word&amp;Pad","Alt+Shift+T",("os.startfile",None,".txt")))
top().frame.createOpenWithMenuFromTable(table)
</t>
<t tx="T1920">@ignore

@ to do:
	- (done) use underline param to specify underlined characters in menu names.
	- (done) translate &amp; to underline index before removing &amp;.
	- (done) document how to use &amp; in realMenus.
	- (done) Alt-E conflicts with Edit menu: changed to Alt+Shift+E
	- (done) Add f.get/setMenu (canonicalize menu names)
	- (done) use realMenuNames for undo/redo
	- (done) disable Can't Undo, Can't Redo</t>
<t tx="T1921">def canonicalizeMenuName (name):
	
	name = name.lower() ; newname = ""
	for ch in name:
		if ch in string.letters:
			newname = newname+ch
	return newname
</t>
<t tx="T1922"># 11/17/02: Fail gracefully if the item name does not exist.
def enableMenu (menu,name,val):
	state = choose(val,"normal","disabled")
	try:
		menu.entryconfig(name,state=state)
	except:
		try:
			realName = app().getRealMenuName(name)
			realName = realName.replace("&amp;","")
			menu.entryconfig(realName,state=state)
		except:
			es_exception()
			pass

def disableMenu (menu,name):
	try:
		menu.entryconfig(name,state="disabled")
	except: 
		try:
			realName = app().getRealMenuName(name)
			realName = realName.replace("&amp;","")
			menu.entryconfig(realName,state="disabled")
		except: pass

def setMenuLabel (menu,name,label,underline=-1):
	try:
		menu.entryconfig(name,label=label,underline=underline)
	except:
		print "setMenuLabel menu,name,label:",menu,name,label
		es_exception()
		pass</t>
<t tx="T1923">@language python

@ This section contains all the source code of leo.py.

We use the following conventions throughout the code:

a: the application object.
c: a commander
ch: a character
d: a dialog or a dict.
i, j, k: indices into a string
lst: a list (Do _not_ use list, it is a Python global!)
s: a string
t: a tnode or a Tk.Text widget.
u: an undoer
v: a vnode</t>
<t tx="T1924">@nocolor
@ignore

This documentation describes leo.py. Other versions of Leo are similar in design; the differences between versions are generally not interesting enough to describe here.

All versions of Leo are organized as a collection of classes.  The general organization of Leo has remained remarkably stable throughout all versions of Leo, although the names of classes are different in different versions. Smalltalk's Model/View/Controller terminology is a good way to organize Leo's classes conceptually.

Model classes represent the fundamental data. The vnode and tnode classes are Leo's primary model classes.

View classes draw the screen. The main view classes are leoFrame.py and leoTree.py.  The colorizer class in leoColor.py handles syntax coloring in the body pane. In leo.py, the view classes know about data stored in the vnode class. Most events (keystrokes and mouse actions) in the outline and body pane are handled in the leoTree class. The leoFrame class also creates the Leo window, including menus, and dispatches the appropriate members of the controller classes in response to menu commands.

Controller classes (aka commanders) control the application. In Leo, controllers mostly handle menu commands. In leo.py, the Commands class creates subcommanders to handle complex commands. The atFile class reads and writes files derived from @file trees. The LeoFind class handles the Find and Change commands. The leoImportCommands class handles the Import and Export commands, the tangleCommands class handles the Tangle and Untangle commands and the undoer class handles the Undo command. Other classes could be considered controller classes.

Each Leo window has its own commander and subcommanders. Subcommanders are not subclasses of their commander. Instead, subcommanders know the commander that created them, and call that commander as needed. Commanders and subcommanders call the model and view classes as needed. For example, the Commands class handles outline commands. To move a headline, the commander for the window calls a vnode move routine to alter the data, then calls the view class to redraw the screen based on the new data.

A singleton instance of the LeoApp class represents the application itself. All code uses the app() global function to gain access to this singleton member. The ivars of the LeoApp object are the equivalent of Leo's global variables. leo.py uses no global Python variables, except the gApp variable returned by app(). leoGlobals.py defines all application constants.  Naturally, most constants are local to the class that uses them.

Several classes combine aspects of model, view and controller. For example, the LeoPrefs class represents user preferences (model), the Preference Panel (view) and the Preferences menu command (controller). Similarly, the LeoFind class represents find settings, the Find/Change dialog, and the Find/Change commands.

The children of this node are clones of code-level documentation found throughout this code.</t>
<t tx="T1925">@ This is the design document for clones in Leo. It covers all important aspects of clones. Clones are inherently complex, and this paper will include several different definitions of clones and related concepts.

The following is a definition of clones from the user's point of view.

Definition 1

A clone node is a copy of a node that changes when the original changes. Changes to the children, grandchildren, etc. of a node are simultaneously made to the corresponding nodes contained in all cloned nodes. Clones are marked by a small clone arrow by its leader character.

As we shall see, this definition glosses over a number of complications. Note that all cloned nodes (including the original node) are equivalent. There is no such thing as a "master" node from which all clones are derived. When the penultimate cloned node is deleted, the remaining node becomes an ordinary node again.

Internally, the clone arrow is represented by a clone bit in the status field of the vnode. The Clone Node command sets the clone bits of the original and cloned vnodes when it creates the clone. Setting and clearing clone bits properly when nodes are inserted, deleted or moved, is non-trivial. We need the following machinery to do the job properly.

Two vnodes are joined if a) they share the same tnode (body text) and b) changes to any subtree of either joined vnodes are made to the corresponding nodes in all joined nodes.  For example, Definition 1 defines clones as joined nodes that are marked with a clone arrow.  Leo links all vnodes joined to each other in a circular list, called the join list. For any vnode n, let J(n) denote the join list of n, that is, the set of all vnodes joined to n. Again, maintaining the join lists in an outline is non-trivial.

The concept of structurally similar nodes provides an effective way of determining when two joined nodes should also have their cloned bit set.  Two joined nodes are structurally similar if a) their parents are distinct but joined and b) they are both the nth child of their (distinct) parents.  We can define cloned nodes using the concept of structurally similar nodes as follows:

Definition 2

Clones are joined vnodes such that at least two of the vnodes of J(n) are not structurally similar to each other. Non-cloned vnodes are vnodes such that all of the vnodes of J(n) are structurally similar. In particular, n is a non-cloned vnode if J(n) is empty.

Leo ensures that definitions 1 and 2 are consistent. Definition 1 says that changes to the children, grandchildren, etc. of a node are simultaneously made to the corresponding nodes contained in all cloned nodes. Making "corresponding changes" to the non-cloned descendents of all cloned nodes insures that the non-cloned joined nodes will be structurally similar. On the other hand, cloned nodes are never structurally similar. They are created as siblings, so they have the same parent with different "child indices."  To see how this works in practice, let's look at some examples.

Example 1

+ root
	+ a' (1)
	+ a' (2)

This example shows the simplest possible clone. A prime (') indicates a cloned node.  Node a in position (1) has just been cloned to produce a' in position (2). Clearly, these two cloned nodes are not structurally similar because their parents are not distinct and they occupy different positions relative to their common parent.

Example 2

If we add a node b to either a' node we get the following tree:

+ root
	+ a'
		+ b
	+ a'
		+ b

The b nodes are structurally similar because the a' nodes are joined and each b node is the first child of its parent.

Example 3

If we now clone either b, we will get:

+ root
	+ a'
		+ b' (1)
		+ b' (2)
	+ a'
		+ b' (1)
		+ b' (2)

All b' nodes must be clones because the nodes marked (1) are not structurally similar to the nodes marked (2).

Dependent nodes are nodes created or destroyed when corresponding linked nodes are created or destroyed in another tree. For example, going from example 1 to example 2 above, adding node b to either node a' causes another (dependent) node to be created as the ancestor of the other node a'. Similarly, going from example 2 to example 1, deleting node b from either node a' causes the other (dependent) node b to be deleted from the other node a'.  Cloned nodes may also be dependent nodes. In Example 3, all the b' nodes are dependent on any of the other b' nodes.

We can now give simple rules for inserting and deleting dependent vnodes when other vnodes are created, moved or destroyed. For the purposes of this discussion, moving a node is handled exactly like deleting the node then inserting the node; we need not consider moving nodes further.  We insert a new node n as the nth child of a parent node p as follows. We insert n, then for every node pi linked to p, we insert a dependent node ni as the nth child of pi. Each ni is linked to n. Clearly, each ni is structurally similar to n.  Similarly, it is easy to delete a node n that is the nth child of a parent node p. We delete each dependent node ni that is the nth child of any node pi linked to p. We then delete n.  When inserting or deleting any vnode n we must update its join list, J(n). Updating the join list is easy because the join list is circular: the entire list is accessible from any of its members.

Inserting or deleting nodes can cause the clone bits of all joined nodes to change in non-trivial ways. To see the problems that can arise, consider deleting any of the b' nodes from Example 3. We would be left with the tree in Example 2. There are two remaining b nodes, each with the clone bit set. Unless we know that both b nodes are structurally similar, there would be no way to conclude that we should clear the clone bits in each node. In order to update clone links properly we could examine many special cases, but there is an easier way. Because of definition 2, we can define a shouldBeCloned function that checks J(n) to see whether all nodes of J(n) are structurally similar.

Leo's XML file format does not contain join lists. This makes it easy to change a Leo file "by hand." If join lists were a part of the file, as they are in the Mac version of Leo, corrupting a join list would corrupt the entire file. It is easy to recreate the join lists when reading a file using a dedicated field in the tnode.  This field is the head of a list of all vnodes that points to the tnode. After reading all nodes, Leo creates this list with one pass through the vnodes.  Leo then convert each list to a circular list with one additional pass through the tnodes.
</t>
<t tx="T1926">@ Leo must redraw the outline pane when commands are executed and as the result of mouse and keyboard events.  The main challenges are eliminating flicker and handling events properly.  These topics are interrelated.

Eliminating flicker.  Leo must update the outline pane with minimum flicker.  Various versions of Leo have approached this problem in different ways.  The drawing code in leo.py is robust, flexible, relatively simple and should work in almost any conceivable environment.

Leo assumes that all code that changes the outline pane will be enclosed in matching calls to the c.beginUpdate and c.endUpdate  methods of the Commands class. c.beginUpdate() inhibits drawing until the matching c.endUpdate().  These calls may be nested; only the outermost call to c.endUpdate() calls c.redraw() to force a redraw of the outline pane.

In leo.py, code may call c.endUpdate(flag) instead of c.endUpdate().  Leo redraws the screen only if flag is true.  This allows code to suppress redrawing entirely when needed.  For example, study the idle_body_key event handler to see how Leo conditionally redraws the outline pane.

The leoTree class redraws all icons automatically when c.redraw() is called.  This is a major simplification compared to previous versions of Leo.  The entire machinery of drawing icons in the vnode class has been eliminated.  The v.computeIcon method tells what the icon should be.  The v.iconVal ivar that tells what the present icon is. The event handler simply compares these two values and sets redraw_flag if they don't match.

Handling events. Besides redrawing the screen, Leo must handle events or commands that change the text in the outline or body panes.  It is surprisingly difficult to ensure that headline and body text corresponds to the vnode and tnode corresponding to presently selected outline, and vice versa. For example, when the user selects a new headline in the outline pane, we must ensure that 1) the vnode and tnode of the previously selected node have up-to-date information and 2) the body pane is loaded from the correct data in the corresponding tnode.  Early versions of Leo attempted to satisfy these conditions when the user switched outline nodes.  Such attempts never worked well; there were too many special cases.  Later versions of Leo, including leo.py, use a much more direct approach.  The event handlers make sure that the vnode and tnode corresponding to the presently selected node are always kept up-to-date.  In particular, every keystroke in the body pane causes the presently selected tnode to be updated immediately.  There is no longer any need for the c.synchVnode method, though that method still exists for compatibility with old scripts.

The leoTree class contains all the event handlers for the body and outline panes.  The actual work is done in the idle_head_key and idle_body_key methods.  These routines are surprisingly complex; they must handle all the tasks mentioned above, as well as others. The idle_head_key and idle_body_key methods should not be called outside the leoTree class.  However, it often happens that code that handles user commands must simulate an event.  That is, the code needs to indicate that headline or body text has changed so that the screen may be redrawn properly.   The leoTree class defines the following simplified event handlers: onBodyChanged, onBodyWillChange, onBodyKey, onHeadChanged and onHeadlineKey.  Commanders and subcommanders call these event handlers to indicate that a command has changed, or will change, the headline or body text.  Calling event handlers rather than c.beginUpdate and c.endUpdate ensures that the outline pane is redrawn only when needed.
</t>
<t tx="T1927">@ The Tangle command translates the selected @root tree into one or more well-formatted C source files. The outline should contain directives, sections references and section definitions, as described in Chapter 4. The Untangle command is essentially the reverse of the Tangle command. The Tangle command creates a derived file from an @root tree; the Untangle command incorporates changes made to derived files back into the @root tree.

The Tangle command operates in two passes. The first pass discovers the complete definitions of all sections and places these definitions in a symbol table. The first pass also makes a list of root sections. Definitions can appear in any order, so we must scan the entire input file to know whether any particular definition has been completed.

Tangle's second pass creates one file for each @root node. Tangle rescans each section in the list of roots, copying the root text to the output and replacing each section reference by the section's definition. This is a recursive process because any definition may contain other references. We can not allow a section to be defined in terms of itself, either directly or indirectly. We check for such illegally recursive definitions in pass 2 using the section stack class.  Tangle indicates where sections begin and end using comment lines called sentinel lines.  The this part of the appendix discusses the format of the sentinels output by the Tangle command.

The key design principle of the Tangle command is this: Tangle must output newlines in a context-free manner. That is, Tangle must never output conditional newlines, either directly or indirectly. Without this rule Untangle could not determine whether to skip or copy newlines.

The Tangle command increases the indentation level of a section expansion the minimum necessary to align the section expansion with the surrounding code. In essence, this scheme aligns all section expansions with the line of code in which the reference to the section occurs. In some cases, several nested sections expansions will have the same indentation level. This can occur, for example, when a section reference in an outline occurs at the left margin of the outline.

This scheme is probably better than more obvious schemes that indent more "consistently." Such schemes would produce too much indentation for deeply nested outlines. The present scheme is clear enough and avoids indentation wherever possible, yet indents sections adequately. End sentinel lines make this scheme work by making clear where the expansion of one section ends and the expansion of a containing section resumes.

Tangle increases indentation if the section reference does not start a line. Untangle is aware of this hack and adjusts accordingly. This extra indentation handles several common code idioms, which otherwise would create under-indented code. In short, Tangle produces highly readable, given the necessity of preserving newlines for Untangle.

Untangle is inherently complex.  It must do a perfect job of updating the outline, especially whitespace, from expansions of section definitions created by the Tangle command.  Such expansions need not be identical because they may have been generated at different levels of indentation.  The Untangle command can not assume that all expansions of a section will be identical in the derived file; within the derived file, the programmer may have made incompatible changes to two different expansions of the same section. Untangle must check to see that all expansions of a section are "equivalent".  As an added complication, derived files do not contain all the information found in @root trees.  @root trees may contain headlines that generate no code at all.  Also, an outline may define a section in several ways: with an @c or @code directive or with a section definition line.  To be useful, Untangle must handle all these complications flawlessly. The appendix discusses the various conventions used in the sentinels output by the Tangle command.  These conventions allow the Untangle command to recreate whitespace correctly.

Untangle operates in two passes. The first pass finds definitions in the derived file and enters them into the Untangle Symbol Table, or UST.   Definitions often include references to other sections, so definitions often include nested definitions of referenced sections. The first pass of Untangle uses a definition stack to keep track of nested definitions. The top of the stack represents the definition following the latest reference, except for the very first entry pushed on the stack, which represents the code in the outline that contains the @root directive. The stack never becomes empty because of the entry for the @root section. All definitions of a section should match--otherwise there is an inconsistent definition. This pass uses a forgiving compare routine that ignores differences that do not affect the meaning of a program.

Untangle's second pass enters definitions from the outline into the Tangle Symbol Table, or TST. The second pass simultaneously updates all sections in the outline whose definition in the TST does not match the definition in the UST.  The central coding insight of the Untangle command is that the second pass of Untangle is almost identical to the first pass of Tangle! That is, Tangle and Untangle share key parts of code, namely the skip_body() method and its allies.  Just when skip_body() enters a definition into the symbol table, all the information is present that Untangle needs to update that definition.
</t>
<t tx="T1928">@ The vnode and tnode classes represent most of the data contained in the outline. These classes are Leo's fundamental Model classes.

A vnode (visual node) represents a headline at a particular location on the screen. When a headline is cloned, vnodes must be copied. vnodes persist even if they are not drawn on the screen. Commanders call vnode routines to insert, delete and move headlines.

The vnode contains data associated with a headline, except the body text data which is contained in tnodes. A vnode contains headline text, a link to its tnode and other information. In leo.py, vnodes contain structure links: parent, firstChild, next and back ivars. To insert, delete, move or clone a vnode the vnode class just alters those links. The Commands class calls the leoTree class to redraw the outline pane whenever it changes. The leoTree class knows about these structure links; in effect, the leoTree and vnode classes work together. The implementation of vnodes is quite different in the Borland version of Leo. This does not affect the rest of the Leo. Indeed, vnodes are designed to shield Leo from such implementation details.

A tnode, (text node) represents body text: a tnode is shared by all vnodes that are clones of each other. In other words, tnodes are the unit of sharing of body text. The tnode class is more private than the vnode class. Most commanders deal only with vnodes, though there are exceptions.

Because leo.py has unlimited Undo commands, vnodes and tnodes can be deleted only when the window containing them is closed. Nodes are deleted indirectly. Several classes, including the vnode, tnode, leoFrame and leoTree classes, have destroy() routines. These destroy() routines merely clear links so that Python's and Tkinter's reference counting mechanisms will eventually delete vnodes, tnodes and other data when a window closes.

Leo uses several kinds of node indices. Leo's XML file format uses tnode indices to indicate which tnodes (t elements) belong to which vnodes (v elements). Such indices are required. Even if we duplicated the body text of shared tnodes within the file, the file format would still need an unambiguous way to denote that tnodes are shared.

Present versions of Leo recompute these tnodes indices whenever Leo writes any .leo file. Earlier versions of Leo remembered tnode indices and rewrote the same indices whenever possible. Those versions of Leo recomputed indices when executing the Save As and Save To commands, so using these commands was a way of "compacting" indices. The main reason for not wanting to change tnode indices in .leo files was to reduce the number of changes reported by CVS and other Source Code Control Systems. I finally abandoned this goal in the interest of simplifying the code. Also, CVS will likely report many differences between two versions of the same .leo file, regardless of whether tnode indices are conserved.

A second kind of node index is the clone index used in @+node sentinels in files derived from @file trees. As with indices in .leo files, indices in derived files are required so that Leo can know unambiguously which nodes are cloned to each other.

It is imperative that clone indices be computed correctly, that is, that tnode @+node sentinels have the same index if and only if the corresponding vnodes are cloned. Early versions of leo.py had several bugs involving these clone indices. Such bugs are extremely serious because they corrupt the derived file and cause read errors when Leo reads the @file tree. Leo must guarantee that clone indices are always recomputed properly. This is not as simple as it might appear at first. In particular, Leo's commands must ensure that @file trees are marked dirty whenever any changed is made that affects cloned nodes within the tree. For example, a change made outside any @file tree may make several @file trees dirty if the change is made to a node with clones in those @file trees.
</t>
<t tx="T1929">@ Only leo.py supports unlimited undo.  Unlimited undo is straightforward; it merely requires that all commands that affect the outline or body text must be undoable. In other words, everything that affects the outline or body text must be remembered.

We may think of all the actions that may be Undone or Redone as a string of beads (undo nodes). Undoing an operation moves backwards to the next bead; redoing an operation moves forwards to the next bead. A bead pointer points to the present bead. The bead pointer points in front of the first bead when Undo is disabled.  The bead pointer points at the last bead when Redo is disabled. An undo node is a Python dictionary containing all information needed to undo or redo the operation.

The Undo command uses the present bead to undo the action, then moves the bead pointer backwards. The Redo command uses the bead after the present bead to redo the action, then moves the bead pointer forwards. All undoable operations call setUndoParams() to create a new bead. The list of beads does not branch; all undoable operations (except the Undo and Redo commands themselves) delete any beads following the newly created bead.

I did not invent this model of unlimited undo.  I first came across it in the documentation for Apple's Yellow Box classes.
</t>
<t tx="T1930">The following batch files use @rawfile so that no extraneous lines get generated.

The go.bat batch loads leo.py and opens LeoPy.leo by default, so to work on leo.py I just open a Windows console window and type go.  Add LeoPy folder to your PATH environment variable, or put go.bat in c:\Windows.

The sdist.bat batch file creates a source distribution using distutils and setup.py.

The bdist.bat batch file creates a binary distribution.  It does not work yet.

The manifest.in file contains a list of files to be included in the distutils distribution.</t>
<t tx="T1931">rem Create binary distribution using information in setup.py
rem cd c:\prog\LeoPy
c:\python22\python setup.py bdist --formats=wininst</t>
<t tx="T1932">cd c:\prog\LeoCVS\leo
c:\python22\python openLeo.py</t>
<t tx="T1933">rem print help message re setup.py
c:\python22\python setup.py sdist --help</t>
<t tx="T1934">rem creates source distribution using setup.py
rem cd c:\prog\LeoPy
rem --formats=gztar,zip
c:\python22\python setup.py sdist --force-manifest</t>
<t tx="T1935"># customizeLeo.py is a potentially dangerous file; it should usually be @ignore'd here.

@ignore

</t>
<t tx="T1936">@nocolor</t>
<t tx="T1937">@nocolor

Scripting is fully documented in Leo's Users Guide, and the following should be get you started:

@color

top() # The commander of the top (current) windows.
top().rootVnode() # The root vnode of the outline.
top().currentVnode() # The presently selected vnode.

@nocolor

If v is any vnode:
	
@color

v.headString() # is the headline of v.
v.bodyString() # is the body of v.
v.threadNext() # is node after v in outline order.

@nocolor

For example, this prints every headline of an outline:
	
@color

v = top().rootVnode()
while v:
	print v.headString()
	v = v.threadNext()
</t>
<t tx="T1938">Leo calls customizeLeo() at various times during execution.  Leo catches exceptions, including syntax errors in this code, so it is safe to hack away on this code.

The code in customizeLeo() corresponding to each tag is known as the "hook" routine for that tag.
keywords is a Python dictionary containing information unique to each hook.  For example,
keywords["label"] indicates the kind of command for "command1" and "command2" hooks.

For some hooks, returning anything other than None "overrides" Leo's default action.
Hooks have full access to all of Leo's source code.  Just import the relevant file.
For example, top() returns the commander for the topmost Leo window.

The following table summarizes the arguments passed to customizeLeo().

Overrides is "yes" if returning anything other than None overrides
Leo's normal command or event processing.

tag argument                                             keys in keywords
(hook name)  overrides       when called                dictionary argument
---------    ---------       -----------               -------------------
"bodykey1"     yes      before body keystrokes          v,ch,oldSel,undoType
"bodykey2"              after body keystrokes           v,ch,oldSel,undoType
"command1"     yes      before each command             label
"command2"              after each command              label
"end1"                  start of app.quit()
"headkey1"     no       before body keystrokes          c,v,ch
"headkey2"              after body keystrokes           c,v,ch
"idle"                  periodically (at idle time)
"menu1"        yes      before creating menus
"menu2"        yes      before updating menus
"open1"        yes      before opening any file         old_c,new_c,fileName
"open2"                 after opening any file          old_c,new_c,fileName
"openwith1"    yes      before Open With command        c,v,openType,arg,ext
"openwith2"             after Open With command         c,v,openType,arg,ext
"recentfiles1" yes      before Recent Files command     c,fileName,closeFlag
"recentfiles2"          after Recent Files command      c,fileName,closeFlag
"select1"      yes      before selecting a vnode        c,v,new_v
"select2"               after selecting a vnode         c,v,old_v
"start1"       no       after app.finishCreate()
"start2"                after opening first Leo window  fileName
"@url1"        yes      before double-click @url node   c,v
"@url2"                 after double-click @url node    c,v

Notes:

Both "open1" and "open2" are called with a keywords dict containing the following entries:
old_c: The commander of the previously open window.
new_c: The commander of the newly opened window.
fileName: The name of the file being opened.

Neiter customizeLeo("open1") nor customizeLeo("open2") is called if the file is already open when frame.OpenWithFileName was called.

Leo calls frame.OpenWithFileName, and thus possibly customizeLeo("open1") and customizeLeo("open2"), when opening a file using either the Open command or the Recent Files menu.

Setting app().realMenuNameDict when customizeLeo("menu1") is called is an easy way of translating menu names to other languages.  Please note that the "new" names created this way affect only the actual spelling of the menu items, they do _not_ affect how you specify shortcuts in leoConfig.txt, nor do they affect the "official" command names passed in app().commandName.  For example, suppose you set app().realMenuNameDict["Open..."] = "Ouvre".  When customizeLeo("command1") is called, app().commandName will be "open", not "ouvre".</t>
<t tx="T1939">Naively using customizeLeo.py can expose you and your .leo files to malicious attacks.  You will be safe as long as you follow these basic principles:

1. Never share customizeLeo.py with anyone else, and never accept a copy of customizeLeo.py from anyone else.  Think of customizeLeo.py as a lock to be carefully guarded.  Anyone who sends you a copy of customizeLeo.py is committing a hostile act.

2. Never write code in customizeLeo.py that executes Python scripts in .leo files.  It is safe to import and execute code from Leo itself, provided that you got Leo from Leo's SourceForge site.  A child of this node gives an example of code that opens up security problems.

3. Use only authentic copies of Leo that come from Leo's SourceForgse site.</t>
<t tx="T1940">@color
@ WARNING ***** Using the following routine exposes you malicious code in .leo files! *****

Do not EVER use code that blindly executes code in .leo files!
Someone could send you malicious code embedded in the .leo file.

WARNING 1: Changing "@onloadpythonscript" to something else will NOT protect
           you if you EVER share either your files with anyone else.

WARNING 2: Replacing exec by rexec below provides NO additional protection!
           A malicious rexec script could trash your .leo file in subtle ways.
@c
if 0: # WRONG: This blindly execute scripts found in an .leo file! NEVER DO THIS!
	def onLoadFile():
		v = top().rootVnode()
		while v:
			h = v.headString().lower()
			if match_word(h,0,"@onloadpythonscript"):
				s = v.bodyString()
				if s and len(s) &gt; 0:
					try: # SECURITY BREACH: s may be malicious!
						exec(s + '\n',__builtins__,__builtins__)
					except:
						es_exception()
			v = v.threadNext()</t>
<t tx="T1941">@nocolor

The following sections contain convenience routines that scripts in customizeLeo.py may call to create menus and to schedule events.

@color

</t>
<t tx="T1942">@ When the "idle" hook is enabled, Leo will call customizeLeo("idle") periodically.

You scripts should call only enableIdleTimeHook and disableIdleTimeHook.  The idleTimeHookHandler is used to dispatch the "idle" hook.  Your code should not call it directly.</t>
<t tx="T1943">@ Leo calls customizeLeo() at various times during execution.  Leo catches all exceptions in this code, so it is safe to hack away on this code.

The code in customizeLeo() corresponding to each tag is known as the "hook" routine for that tag.
The keywords argument is a Python dictionary containing information unique to each hook.  For example,
keywords["label"] indicates the kind of command for "command1" and "command2" hooks.

For some hooks, returning anything other than None "overrides" Leo's default action.

Hooks have full access to all of Leo's source code.  Just import the relevant file.
For example, top() returns the commander for the topmost Leo window.
@c
from leoGlobals import *

def customizeLeo(tag,keywords):
	
	&lt;&lt; sign on (a security precaution) &gt;&gt;
	if 0: # These are handy to have when debugging hooks.
		&lt;&lt; trace tags &gt;&gt;
	&lt;&lt; create and handle the Open With menu &gt;&gt;
	&lt;&lt; enable gc checking &gt;&gt;

	if 0: # Examples of what you can do with hooks.
		# Accessing information...
		print "customizeLeo",tag,keywords
		&lt;&lt; print the commander for each open window &gt;&gt;
		# Commands...
		&lt;&lt; do something at the start of each command &gt;&gt;
		&lt;&lt; override the Equal Sized panes command &gt;&gt;
		# Menus...
		&lt;&lt; create Scripts menu for LeoPy.leo &gt;&gt;
		&lt;&lt; translate a few menu items into french &gt;&gt;
		# Events and exceptions...
		&lt;&lt; trace the key handlers &gt;&gt;
		&lt;&lt; test how Leo handles exceptions in this file &gt;&gt;
</t>
<t tx="T1944">if tag == "start2":
	# Announce the presence of this file.
	es("customizeLeo loaded. EKR 12/04/02")
</t>
<t tx="T1945">if tag in ("command1","command2"):
	print tag,keywords.get("label")
elif tag in ("open1","open2"):
	print tag,keywords.get("fileName")
elif tag not in ("bodykey1","bodykey2","headkey1","headkey2","idle"):
	print tag</t>
<t tx="T1946">if (tag == "start2" or tag == "open2" or
	(tag=="command2" and keywords.get("label")=="new")):
	# print "leoCustomize:creating Open With menu"
	&lt;&lt; create the Open With menu &gt;&gt;
	# Enable the idle-time hook so we can check temp files created by Open With.
	enableIdleTimeHook(idleTimeDelay=500)

if tag == "idle":
	&lt;&lt; check the temp files created by the Open With command &gt;&gt;
</t>
<t tx="T1947">import os
a = app()

# frame.OnOpenWith creates the dict as follows:
# dict = {"c":c, "v":v, "f":f, "path":path, "time":time}
for dict in a.openWithFiles:
	path = dict.get("path")
	if path and os.path.exists(path):
		try:
			time=os.path.getmtime(path)
		except:
			time=None
		old_time = dict.get("time")
		if time and time!=old_time:
			print "changed: "+ shortFileName(path)
			es("changed: "+ shortFileName(path))
			dict["time"]=time
			try:
				# Update v from the changed temp file.
				c = dict.get("c")
				v = dict.get("v")
				f=open(path)
				s=f.read()
				f.close()
				v.setBodyStringOrPane(s)
				c.selectVnode(v)
				# We would like to force Leo to the front.
				# This doesn't work on XP.
				c.frame.top.tkraise()
				c.frame.body.focus_force()
			except:
				es("exception updating: "+ v.headString())
				es_exception()</t>
<t tx="T1948">if 0:
	if tag == "start1":
		try:
			import gc
			print "Enabling gc debugging"
			gc.set_debug(gc.DEBUG_LEAK)
		except: pass</t>
<t tx="T1949">if tag == "open2":
	if top().frame.shortFileName() == "LeoPy.leo":
		table = (
			("Show Current Working Directory",None,show_cwd),
			("Import All Python Files From CWD",None,importPythonFiles),
			("Import All Cweb Files From CWD",None,importCwebFiles))
		
		es("creating Scripts menu for LeoPy.leo")
		top().frame.createNewMenu("Scripts","top")
		top().frame.createMenuItemsFromTable("Scripts",table)
</t>
<t tx="T1950">if tag in ("bodykey1","bodykey2","headkey1","headkey2"):
	ch = keywords.get("ch")
	if ch and len(ch) &gt; 0:
		print "customizeLeo",tag,keywords</t>
<t tx="T1951">@ 12/6/02: The translation table used by setRealMenuNamesFromTable has entries of the form:

	("official name","translated name"),

Ampersands in the translated name indicate that the following character is to be underlined.

The official name can be any name equivalent to the standard English menu names.  Leo "canonicalizes" the official name by converting to lower case and removing any non-letters.  Thus, the following are  equivalent:
	("Open...","&amp;Ouvre"),
	("open",   "&amp;Ouvre"),
	("&amp;Open",  "&amp;Ouvre"),
@c
if tag == "menu1":
	table = (
		("Open...","&amp;Ouvre"),
		("OpenWith","O&amp;uvre Avec..."),
		("close","&amp;Ferme"),
		("Undo Typing","French &amp;Undo Typing"), # Shows you how much French I know ;-)
		("Redo Typing","French &amp;Redo Typing"),
		("Can't Undo", "French Can't Undo"),
		("Can't Redo", "French Can't Redo"))
	# 12/6/02: A new convenience routine.
	app().setRealMenuNamesFromTable(table)
</t>
<t tx="T1952">for w in app().windowList:
	print w.commands # The commander for each open window.
top().frame.menus.sort()
for name,menu in top().frame.menus:
	print name,
print</t>
<t tx="T1953">if tag == "end1":
	print `app().doesNotExist` # Test of exception handling.</t>
<t tx="T1954">if tag == "command1":
	if keywords.get("label")=="equalsizedpanes":
		print "over-riding Equal Sized Panes"
		return "override" # Anything other than None overrides.</t>
<t tx="T1955">if tag == "command1":
	print "end  ", keywords.get("label")</t>
<t tx="T1956">@nocolor</t>
<t tx="T1957">@color

@ NSIS Script for LEO - Literate Programming Editor with Outlines
http://sourceforge.net/projects/leo

How to create an installer for Leo using this script:
	1. Install NSIS (from http://www.nullsoft.com)
	2. Put the leo.nsi file in the directory containing the Leo program files.
	3. Right-click on the leo.nsi file and choose "Compile"
	
Version 1.0 of this script by Joe Orr, donated to public domain.
</t>
<t tx="T1958">@comment ;
@silent
@root leo.nsi

; NOTE: this .NSI script is designed for NSIS v1.8+

&lt;&lt; installer settings &gt;&gt;
&lt;&lt; required files section &gt;&gt;
&lt;&lt; optional files section &gt;&gt;
&lt;&lt; file association &gt;&gt;
&lt;&lt; post install section &gt;&gt;
&lt;&lt; uninstall section &gt;&gt;

; eof</t>
<t tx="T1959">@code

# [Installer Attributes]
Name "Leo"
OutFile "leosetup.exe"
Caption "Leo Installer"

&lt;&lt; Additional Installer Settings &gt;&gt;

&lt;&lt; icons used by the installer &gt;&gt;
&lt;&lt; the user license &gt;&gt;
&lt;&lt; the installation dir &gt;&gt;

ComponentText "This will install Leo on your computer. Select which optional components you would also like to install."</t>
<t tx="T1960">@code
Icon Icons\leo_inst.ico
EnabledBitmap Icons\leo_on.bmp
DisabledBitmap Icons\leo_off.bmp</t>
<t tx="T1961">@code
InstallDir "$PROGRAMFILES\Leo"
InstallDirRegKey HKEY_LOCAL_MACHINE "SOFTWARE\EKR\leo" ""
DirShow show # (make this hide to not let the user change it)
DirText "Select the directory to install Leo in:"</t>
<t tx="T1962">@code
LicenseText "You must agree to this license before installing."
LicenseData "LICENSE.TXT"</t>
<t tx="T1963">@ You may not need to change these for your own app...
@c
ShowInstDetails show
AutoCloseWindow false
SilentInstall normal
CRCCheck on
SetCompress auto
SetDatablockOptimize on
SetOverwrite ifnewer
WindowIcon off</t>
<t tx="T1964">@code

Section "Leo" ; (default, required section)

  &lt;&lt; check to see whether Python is installed &gt;&gt;

ok:
  # here we list all files to included in installer	
  # first list the folder (using SetOutPath) then the filespec
  SetOutPath "$INSTDIR"
  File LeoPy.leo
  File LeoDocs.leo
  File leoConfig.leo
  File leo*.py
  File leoConfig.txt
  File c2py.py
  File disStats.py
  File openLeo.py
  File tangle_done.py
  File untangle_done.py
  File __init__.py
  File README.TXT
  File INSTALL.TXT
  File PKG-INFO.TXT
  File LICENSE.TXT
  File leo.rc
  File leo.res
  File manifest.in
  SetOutPath "$INSTDIR\Icons"
  File "Icons\*.*"

SectionEnd ; end of default section</t>
<t tx="T1965">@code
# I sure hope there is a better way to do this, but other techniques don't seem to work.

# Supposedly the Python installer creates the following registry entry
# HKEY_LOCAL_MACHINE\Software\Python\PythonCore\CurrentVersion
# and then we can read find the Python folder location via
# HKEY_LOCAL_MACHINE\Software\Python\PythonCore\{versionno}. 
# Unfortunately, at the time of this writing, the Python installer is NOT writing the first entry. There is no way to know what the current versionno is.
# Hence, the following hack.

# Get pythonw.exe path from registry... except it isn't there, nor is it an environment variable... thanks guys!
# We'll have to get it in a roundabout way
ReadRegStr $9 HKEY_LOCAL_MACHINE "SOFTWARE\Classes\Python.NoConFile\shell\open\command" ""

# cut 8 characters from back of the open command
StrCpy $8 $9 -8

IfFileExists $8 ok tryagain

tryagain:
# ok, that  didn't work, but since the Python installer doesn't seem to be consistent, we'll try again
# cut 3 characters from back of the open command
StrCpy $8 $9 -3

IfFileExists $8 ok ng

ng:
  MessageBox MB_OK "Python is not installed on this system. $\nPlease install Python first. $\n$\nClick OK to cancel installation and remove installation Files."
  Delete "$INSTDIR\Icons\*.*" ; Icons dir
  RMDir "$INSTDIR\Icons"
  Delete "$INSTDIR\*.*" ; 
  RMDir "$INSTDIR"
  Quit
  
</t>
<t tx="T1966">@code

# optional sections

Section "Start Menu Shortcuts"
  CreateDirectory "$SMPROGRAMS\Leo"
  CreateShortCut "$SMPROGRAMS\Leo\Uninstall.lnk" "$INSTDIR\uninst.exe" "" "$INSTDIR\uninst.exe" 0
  CreateShortCut "$SMPROGRAMS\Leo\Leo.lnk" "$8" '"$INSTDIR\leo.py"' "$INSTDIR\Icons\LeoApp.ico" 0  
SectionEnd

Section "Desktop Shortcut"
  CreateShortCut "$DESKTOP\Leo.lnk" "$8" '"$INSTDIR\leo.py"' "$INSTDIR\Icons\LeoApp.ico" 0
SectionEnd</t>
<t tx="T1967">@code

Section ".leo File Association"
  SectionIn 1
  SectionIn 2
  SectionIn 3

  # back up old value of .leo in case some other program was using it
  ReadRegStr $1 HKCR ".leo" ""
  StrCmp $1 "" Label1
  StrCmp $1 "LeoFile" Label1
  WriteRegStr HKCR ".leo" "backup_val" $1
 
Label1:
  WriteRegStr HKCR ".leo" "" "LeoFile"
  WriteRegStr HKCR "LeoFile" "" "Leo File"
  WriteRegStr HKCR "LeoFile\shell" "" "open"
  WriteRegStr HKCR "LeoFile\DefaultIcon" "" $INSTDIR\Icons\LeoDoc.ico,0 
  WriteRegStr HKCR "LeoFile\shell\open\command" "" '$8 "$INSTDIR\leo.py" %1'  

SectionEnd</t>
<t tx="T1968">@code

Section "-post" # (post install section, happens last after any optional sections)

  # add any commands that need to happen after any optional sections here
  WriteRegStr HKEY_LOCAL_MACHINE "SOFTWARE\EKR\leo" "" "$INSTDIR"
  WriteRegStr HKEY_LOCAL_MACHINE "Software\Microsoft\Windows\CurrentVersion\Uninstall\leo" "DisplayName" "Leo (remove only)"
  WriteRegStr HKEY_LOCAL_MACHINE "Software\Microsoft\Windows\CurrentVersion\Uninstall\leo" "UninstallString" '"$INSTDIR\uninst.exe"'

  # write out uninstaller
  WriteUninstaller "$INSTDIR\uninst.exe"

SectionEnd ; end of -post section

</t>
<t tx="T1969">@code

# [ begin uninstall settings/section ]
UninstallText "This will uninstall Leo from your system"
UninstallCaption "Uninstall Leo"
UninstallIcon Icons\uninst.ico

Section Uninstall

DeleteRegKey HKEY_LOCAL_MACHINE "SOFTWARE\EKR\leo"
DeleteRegKey HKEY_LOCAL_MACHINE "SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\leo"

&lt;&lt; remove file association &gt;&gt;
&lt;&lt; remove program folder &gt;&gt;
&lt;&lt; remove shortcuts &gt;&gt;

; remove directories used.
RMDir "$SMPROGRAMS\Leo"

SectionEnd ; end of uninstall section</t>
<t tx="T1970">@code

  ReadRegStr $1 HKCR ".leo" ""
  StrCmp $1 "LeoFile" 0 NoOwn ; only do this if we own it
    ReadRegStr $1 HKCR ".leo" "backup_val"
    StrCmp $1 "" 0 RestoreBackup ; if backup == "" then delete the whole key
      DeleteRegKey HKCR ".leo"
    Goto NoOwn
    RestoreBackup:
      WriteRegStr HKCR ".leo" "" $1
      DeleteRegValue HKCR ".leo" "backup_val"
  NoOwn:
</t>
<t tx="T1971">@code
MessageBox MB_YESNO|MB_ICONQUESTION \
             "Delete all files in Leo Program folder?" \
             IDNO NoDelete
  Delete "$INSTDIR\Icons\*.*" ; Icons dir
  RMDir "$INSTDIR\Icons"
  Delete "$INSTDIR\*.*" ; 
  RMDir "$INSTDIR"
NoDelete:
</t>
<t tx="T1972">@code
Delete "$SMPROGRAMS\Leo\*.*"
Delete "$DESKTOP\Leo.lnk"</t>
<t tx="T1973">@ignore</t>
<t tx="T1974"># yo - why doesn't this work?
#ExecShell open "$INSTDIR\getpypath.pyw"

#IfFileExists "$INSTDIR\pypath.txt" ok ng
#ok:
#  FileOpen $9 "$INSTDIR\pypath.txt" "r"
#  FileRead $9 $8
#  FileClose $9
#  Delete "$INSTDIR\pypath.txt"
#  MessageBox MB_OK "urk"
#  Return
#ng:
#  MessageBox MB_OK "Python is not installed on this system. $\nPlease install Python first. $\n$\nClick OK to cancel installation and remove installation Files."
#  Delete "$INSTDIR\Icons\*.*" ; Icons dir
#  RMDir "$INSTDIR\Icons"
#  Delete "$INSTDIR\*.*" ; 
#  RMDir "$INSTDIR"
#  Quit

</t>
<t tx="T1975">Leo is Open Software and is distributed under the terms of the Python License. The gist of the license is that Leo is absolutely free, even for commercial use (including resale). There is no GNU-like "copyleft" restriction. The Open Source Initiative board has voted to certify the Python license as Open Source. This license is compatible with the GPL.

Copyright (c) 1997-2002 by Edward K. Ream. All Rights Reserved.

Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the names of Leo or Edward K. Ream not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.

DISCLAIMER OF WARRANTIES

EDWARD K. REAM (REAM) SPECIFICALLY DISCLAIMS ALL WARRANTIES, EXPRESSED OR IMPLIED, WITH RESPECT TO THIS COMPUTER SOFTWARE, INCLUDING BUT NOT LIMITED TO IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL REAM BE LIABLE FOR ANY LOSS OF PROFIT OR ANY COMMERCIAL DAMAGE, INCLUDING BUT NOT LIMITED TO SPECIAL, INCIDENTAL, CONSEQUENTIAL OR OTHER DAMAGES.</t>
<t tx="T1976">Warning: please do _not_ run setup.py.  This script is intended for internal use only.  I haven't found a way to delete it from the distribution.

</t>
<t tx="T1977">Installing leo.py
-----------------

Important note: You can install leo.py on Windows using the single-click installer called leosetup.exe.

leo.py 3.9 requires Python 2.1 and tcl/tk 8.3 or above.

	Download Python from http://python.org/ 
	Download tcl/Tk from http://tcl.activestate.com/software/tcltk/

Warning: When building Tcl on Linux, do not specify "--enable-threads" . Only use Tcl with the default "threads not enabled" case.

Leo is distributed as a single compressed folder.  Simply uncompress this folder and run leo.py.  You can run leo.py by double-clicking leo.py.  You can also run leo.py from a Python interpreter as follows:

	import leo
	leo.run() # runs leo.py, opening a new outline.
	leo.go() # runs leo.py after reloading all modules.
	leo.leoOpen(fileName) # runs leo.py, reloads all modules, and opens fileName.

You may specify options using the configuration file called leoConfig.txt.  You should generate this file using leoConfig.leo.</t>
<t tx="T1978">Using shell scripts and batch files to make using Leo easier
------------------------------------------------------------

On Linux, the following shell script will allow you to open foo.leo files by typing leo foo

#!/bin/sh 
python &lt;leopath&gt;/leo.py $1

where &lt;leopath&gt; is replaced with the path to the leo directory. 

On Windows, the equivalent batch file would be:

c:\python22\python &lt;leopath&gt;leo.py %1



</t>
<t tx="T1979">Installing the Borland version of Leo
-------------------------------------

The Icons folder contains two Icons, called LeoApp and LeoDoc, that represent the Leo application and Leo documents respectively.

In Windows, to associate LeoDoc with .leo files, open the Setting:Folder Options:File Type panel, create an entry for .leo files.  Then choose Change Icon and select the LeoDoc icon.  Associate leo.py as the application to open .leo files.



</t>
<t tx="T1980">Installing leo.py on MacOs
--------------------------

Bruce M. Bolden, bruceb@cs.uidaho.edu, is using Leo on MaxOS X.  Here is his description of how to get Leo working there:

I installed: 
- Latest OS X Developer tools
- latest (as of about two weeks ago) tk/tcl
         MacOSXTk8.4a4-2.tar.gz
- the machopython distribution
http://prdownloads.sourceforge.net/wxpython/MachoPython-2.2.1.dmg

For OS X 10.1, I followed the directions at:
    http://tony.lownds.com/macosx/tkinter.html

That worked fine for 10.1, but didn't work for 10.2.  It
took awhile to find a Python distribution that worked
correctly with tk/tcl.

I was just getting into Leo about a week before 10.2 was released and thought about---what if it breaks....10.2 broke it, but I was able to find a solution as described above.


More re MacOS from Bruce Bolden
-------------------------------

I just finished building tk successfully!  The magic step was the execution of the command

cp ../generic/prolog.ps to ../library/prolog.ps

AFTER 

cd ../../tk/macosx

in the instructions on "Steps to build Tcl/Tk 8.4.0 on MacOS X":

http://mini.net/tcl/4052

I found this solution while looking at the tcl-mac mailing list archive.  The earlier (current?) tar ball on SourceForge did not have the file prolog.ps in the library directory:

http://sourceforge.net/mailarchive/forum.php?thread_id=1060496&amp;forum_id=3853

Copy and Paste seem to work just fine now in Leo!  This was my original question for you.

I also noticed that someone else built everything on OS X 10.2 (Jaguar), but they did it under X.  Since, the new version of Tk appears to support the OS X interface quite well, I'm not going to bother installing X (for now).

So, Leo works two different ways on OS X 10.2.</t>
<t tx="T1981">Metadata-Version: 1.0
Name: leo
Version: 3.9
Summary: Leo: Literate Editor with Outlines
Home-page: http://personalpages.tds.net/~edream/front.html
Author: Edward K. Ream
Author-email: edream@tds.net
License: Python
Description: Leo is an outline-oriented editor written in 100% pure Python.
        Leo works on any platform that supports Python 2.1 or 2.2 and the Tk toolkit.
        This version of Leo was developed with Python 2.2.1 and Tk 8.3.2.
        You may download Python from http://python.org/ and
        tcl/Tk from http://tcl.activestate.com/software/tcltk/
        Leo features a multi-window outlining editor, Python colorizing,
        powerful outline commands and many other things, including 
        Unlimited Undo/Redo and an integrated Python shell(IDLE) window.
        Leo will place its own icon in Leo windows provided that you have
        installed Fredrik Lundh's PIL and tkIcon packages:
        Download PIL from http://www.pythonware.com/downloads/index.htm#pil
        Download tkIcon from http://www.effbot.org/downloads/#tkIcon
Platform: Windows, Linux, Macintosh
</t>
<t tx="T1982">Important note: See INSTALL.TXT for installation instructions.

leo.py 3.9                               Nov 23, 2002

This is one of the most interesting versions of Leo ever released:

* Major performance improvements:
  - Incremental syntax coloring speeds response when typing.
  - Incremental undo drastically reduces memory used.

* Major improvements in customizing Leo:
  - Leo looks in the file customizeLeo.py for user-specific customizations.
  - Leo calls "hook routines" in customizeLeo.py for all commands and events.
    These hook routines can modify or replace any command or event.
  - New convenience routines simplify creating and modifying menus.
  - Easy translation of menus to other languages using customizeLeo.py.

* Better integration with other tools:
  - The Open With command allows you to communicate back and forth to other editors.
  - The Go To Line Number command converts lines numbers in derived files
    to locations in the outline.
  - Double-clicking the icon of a @url node launches any url in your web browser.
  - The Execute Script command executes Python code in any body pane.
    This is much more convenient than opening Leo's Idle window.
  - Much better support for cweb. At last, Leo has a power user of cweb.
    By default, @space, @* and @** sections are colored as latex text.
	Leo properly generates @q..@&gt; sentinels.
  - @nosentinelfile is like @file except Leo writes no sentinel lines.

* Other improvements:
  - Optional Emacs-style auto-indent.
  - Reformat Paragraph command.
  - Leo will optionally create nonexistent directories specified in
    @file, @root or @path, including all nonexistent parent directories.
  - Leo will place its own icon in Leo windows provided that you have
    installed Fredrik Lundh's PIL and tkIcon packages.
  - The usual assortment of bug fixes.

leo.py 3.8                                 October 29, 2002

Many major improvements have been made to Leo, all made as the result of user requests:

- New @rawfile and @silentfile trees complement @file trees.
  @rawfile and @silentfile trees create derived files without using sections.
  @rawfile files contain only those sentinels needed to automatically untangle them.
  @silentfile trees contain no sentinels at all.
- New @raw and @end_raw directives allow unformatted code within @file trees.
- Much better support for CWEB.  You may organize .w files using noweb!
- The @comment and @language directives may now apply simultaneously.
- Leo can now read, remember and write &lt;?xml-stylesheet...?&gt; lines,
  under control of the new stylesheet option.
- The new output_newline option specifies the line endings used when writing files.
- The new output_initial_comment option secifies the text to appear
  in an @comment sentinel at the start of each derived file.
- New commands in the help menu make it much easier to change configuration options.
- Dozens of minor improvements and bug fixes.

leo.py 3.7                                 October 9, 2002

Many improvements have been made to Leo.  The highlights:

- Now works with Python 2.1.  Previous versions required Python 2.2.
- Many new user options, including user-definable shortcuts for all commands.
  and colors for all parts of Leo's windows.
  As a result, it is now possible to use arrow keys as you desire.
- Minimal support for Unicode Latin-1 (iso-8859-1) encoding. Better support is coming.
- Improved handling of relative path names.
- The @first directive allows lines to precede the opening @+leo sentinel line.
- The @last  directive allows lines to follow  the closing @-leo sentinel line.
- Better support for Perl+pod.
- Leo now ends all lines with '\n' regardless of platform.
- Leo is now compatible with Python 2.1.
- Simplified sentinels reduce spurious CVS diffs.
- Many other minor improvements and bug fixes.

Warning: Leo expects that all characters in derived files and .leo files are contained in the encoding specified by the xml_version_string option in leoConfig.txt.  Characters will be garbled if this restriction is not followed.  This restriction will be removed in a future release.

leo.py 3.6                                   September 11, 2002

Highlights:

- Fixed a large number of bugs, especially bugs that appear only on Linux.
- Leo now remembers the previous insertion point and location of the scrollbar when switching between nodes.
- Added Match Brackets command.
- Added support for MouseWheel (Linux only).
- Added support for LaTex and PHP.
- Improved all aspects of the Help menu.
- Discovered a minor bug involving the Python (Idle) window and documented a workaround.

leo.py 3.5                                    August 14, 2002

The many bugs were reported in 3.4 show that leo.py is being heavily used.  This version corrects all known bugs and adds some new features:

- Added new entries in the help menu,
  (Including a link to Joe Orr's excellent ScreenBook tutorial).
- Added configuration options for horizontal scrollbars.
- Added an importFiles script for mass imports.
- Added better warnings for read-only files.
- Removed all '\r' characters when reading derived files.
- Fixed crasher in Read Outline Only command.
- Fixed crasher when leoConfig.txt did not exist.
- Many small improvements and bug fixes.

leo.py 3.4                                     August 11, 2002

This version contains many small improvements and bug fixes:

- Fixed several crashers involving Unicode.
- The Show Invisibles command now makes blanks and tabs look much better.
- Created leoConfig.leo, from which leoConfig.txt is now derived.
- Added save_clears_undo_buffer configuration option.
- Fixed a large number of problems with the configuration code.
- The usual minor improvements and bug fixes.

leo.py 3.3                                     August 3, 2002

This version of Leo:

- Adds support for Unicode.
- Improved the Import commands.
- Fixed numerous bugs related to configuration settings.
- Fixed the "Javadoc" bug and several latent bugs related to it.

leo.py 3.2                                     July 30, 2002

This version generalizes the @others directive, improves the Import command and fixes several bugs.  See the children of this node for full details.

The highlights:

- Nested @others directives are now valid, an important improvement.
  This simplifies files that define more than one class.
- Improved the Import command and squashed several bugs lurking there.
- Made the various Go commands in the Outline-Move/Select menu functional
  by reassigning keyboard shorts
- Fixed a crasher in the Prefs Panel.
- Fixed numerous bugs in the Set Colors command.
- Fixed syntax coloring of C strings that span multiple lines.
- The usual minor improvements and bug fixes.

leo.py 3.1                                     July 20, 2002

This version fixes a blunder that affects only leo.py 3.0.
I recommend that all users of 3.0 upgrade to 3.1.

With this release Leo's to-do list is now empty!
I shall fix bugs as they are reported.
I'll add new features only if convinced that they contribute significantly to Leo.

The highlights:

- Fixed a blunder: Leo 3.0 did nothing when it was opened directly from leo.py.
  (Opening leo using openLeo.py did work.)
- Created a compare panel to control scripts in leoCompare.py.
- Added many new settings in leoConfig.txt to initialize the compare panel.
- The FAQ tells how to add support for new languages.
- The usual minor improvements and bug fixes.

leo.py 3.0                                     July 16, 2002

This version is called 3.0 because it can optionally produce files that
can _not_ be read by the leo.py 2.x or the Borland version of Leo.
By default, leo.py 3.0 _does_ produce files that all previous versions of Leo can read.

As always, see LeoDocs.leo for full details.  The highlights:

- Many new user options in leoConfig.txt, including, among others,
  fonts in all panes, colors for syntax coloring and default window size and position.
- Support for .leo files with XML types like "ISO-8859-1", controlled by a user option.
  Note: by default, Leo writes files compatible with previous versions of Leo.
- Powerful new Color and Font pickers, fully connected to user options.
- Added Toggle Split Direction command, under control of user options.
- Added autoscrolling in the outline pane.
- Windows open at the position in which they were saved.
- The size and position of new windows can be controlled with user options.
- Eliminated drawing problems while opening files.
- Improved syntax coloring for @comment plain.
- The Convert All Blanks and Convert All Tabs commands are now undoable.
- Leo warns and aborts if Python 2.2 or above is not running.
- The usual bug fixes.

leo.py version 2.5.1                           July 7, 2002

This version corrects crashers that affect undo/redo move commands.
Version 2.5 has been withdrawn.

ANYONE USING 2.5 SHOULD IMMEDIATELY SWITCH TO 2.5.1.

leo.py version 2.5                             July 7, 2002

See LeoDocs.leo for full details.  The highlights:

- Leo supports tab widths properly, and negative tab widths cause
  Leo to convert tabs to blanks as you type.
- Three new commands appear in the Edit Body menu:
  Convert Tabs, Convert All Tabs and Convert All Blanks.
  Convert All Tabs and Convert All Spaces convert the entire selected tree.
- Leo now allows you to override selected preferences using a
  configuration file called leoConfig.txt.
  Leo acts as before if this file does not exist.
- The Preferences panel is now contains Ok, Cancel and Revert buttons.
- Cut and paste work properly in all situations.
  You can cut and paste between Leo and other applications,
  or between two different copies of Leo.
- Added the Recent Files submenu to the File menu.
- Fixed several crashers.
- Fixed several bugs in the Import commands.
- Leo will no longer abort reading if it detects an invalid directory name
  in the Default Tangle Directory in the Preferences panel.

leo.py version 2.4                             June 20, 2002

This version fixes some annoying bugs and adds some nice features:

- Leo now properly highlights the headline of a newly created node.
- The Edit Headline command now works properly.
  Double and triple clicking in a headline now works as expected.
- You can now reorganize drag headlines around.
  You must drag from a node's icon and release on another node's icon.
- You can now open .leo files in leo.py by double clicking on .leo files,
  provided that you associate leo.py with .leo files.
- Improved error recovery when there are errors writing .leo files.
- All parts of LeoDocs.leo now match the documentation on Leo's web site.

leo.py version 2.3                             June 12, 2002

This version fixes a minor problem with Leo.

- The code that reads and writes @file nodes now uses the directory containing the
 .leo file as a default when the Default Tangle Directory setting is empty in the Preferences panel.
- The Tangle and Untangle commands have used this convention for a long time.
- This default allows us to distribute LeoPy.leo without specifying
  a directory in the Preferences Panel.

leo.py version 2.2                             June 2, 2002

The version fixes two bugs that happen rarely and can cause loss of data when they do happen.

- In certain circumstances leo.py v2.1 would delete most of an outline when
  a node was moved in front of the previous root node!
- All previous versions of leo.py will crash when saving body text containing unicode characters.
  This could occur as the result of cutting and pasting text from another application into the body pane.
- Leo.py now writes body text containing unicode characters using Python's u-prefixed notation.
  That is, the body text is written as: u'escaped_text', where escaped text replaces unicode characters
  not in the ascii character set by escape sequences of the form \uxxxx.
- The result contains nothing but ascii characters, so leo.py will have no problem reading it.
  Naturally, compilers and other tools may not understand Python's notation,
  so you may have to convert escaped text to something that your tools can understand.

Edward K. Ream
</t>
<t tx="T1983"># The manifest template: specifies all files to be included in the distribution.

include LeoPy.leo
include LeoDocs.leo
include leoConfig.leo
include leo*.py
include leoConfig.txt
include c2py.py
include disStats.py
include openLeo.py
include tangle_done.py
include untangle_done.py
include __init__.py
include README.TXT
include INSTALL.TXT
include PKG-INFO.TXT
include LICENSE.TXT
include Icons/*.*
include leo.rc
include leo.res
include manifest.in</t>
<t tx="T1984">@language python

@ This section contains scripts and other files for creating, testing and distributing leo.py.  leo.py itself does not use any of the code in these scripts, nor do these scripts use any code in leo.py.
@c

# To convert from C to Python, do the following from Leo's Python window:
import c2py
c2py.convertCurrentTree()

# To convert from Leo1 to Leo2, do the following from Leo's Python window:
import c2py
c2py.leo1to2()

@  To create a source distribution using Python's distutils:

On windows: do the following from inside a console window:
	cd c:\prog\LeoPy
	sdist

On Linux do the following:
	cd LeoPy
	python setup.py sdist --force-manifest --formats=gztar,zip</t>
<t tx="T1985">@first #! /usr/bin/env python
@language python

@ When using c2py as a script to translate entire files, use convertCFileToPython().  When using c2py within Leo, use convertCurrentTree().

Please set user data in the &lt;&lt; specifying user types &gt;&gt; section.
@c

&lt;&lt; what c2py does &gt;&gt;
&lt;&lt; theory of operation &gt;&gt;
import string
&lt;&lt; specifying user types &gt;&gt;
true = 1 ; false = None
tabWidth = 4 # how many blanks in a tab.
printFlag = false
doLeoTranslations = true ; dontDoLeoTranslations = false
&lt;&lt; define testData &gt;&gt;
@others

gClassName = "" # The class name for the present function.  Used to modify ivars.
gIvars = [] # List of ivars to be converted to self.ivar

def test():
	global printFlag ; printFlag = true
	for s in testData:
		convertCStringToPython(s, doLeoTranslations)
		
def go():
	test()

if __name__ == "__main__":
	speedTest(2)</t>
<t tx="T1986">@ c2py converts C or C++ text into python text.  The conversion is not complete.  Nevertheless, c2py eliminates much of the tedious text manipulation that would otherwise be required.

The following is a list of the translations performed by c2py.  These transformations are controlled by convertCodeList().

I.  Prepass

These translations before removing all curly braces.

Suppose we are translating:

	aTypeSpec aClass::aMethod(t1 v1,...,tn vn)
	{
		body
	}

1. Translates the function prototype, i.e., translates:

	aTypeSpec aClass::aMethod(t1 v1,...,tn vn)
to:
	def aMethod(v1,...vn):

As a special case, c2py translates:

	aTypeSpec aClass::aClass(t1 v1,...,tn vn)
to:
	aClass.__init__(t1 v1,...,tn vn)

Yes, I know, aClass.__init__ isn't proper Python, but retaining the class name is useful.

2. Let t denote any member of typeList or classList.

	a) Removes all casts of the form (t) or (t*) or (t**), etc.
	b) Converts t x, t *x, t **x, etc. to x.
	c) Converts x = new t(...) to x = t(...)
	d) For all i in ivarsDict[aClass] converts this -&gt; i to self.i
	e) For all i in ivarsDict[aClass] converts i to self.i

3. Converts &lt; &lt; x &gt; &gt; = to @c.  This Leo-specific translation is not done when translating files.

II.  Main Pass

This pass does the following simple translations everywhere except in comments and strings.

Changes all -&gt; to .
Changes all this.self to self (This corrects problems during the prepass.)
Removes all curly braces
Changes all #if to if
Changes all else if to elif
Changes all #else to else:
Changes all else to else:
Removes all #endif
Changes all &amp;&amp; to and
Changes all || to or
Changes all TRUE to true
Changes all FALSE to false
Changes all NULL to None
Changes all this to self
Changes all @code to @c.  This Leo-specific translation is not done when translating files.

III.  Complex Pass

This pass attempts more complex translations.

Converts if ( x ) to if x:
Converts elif ( x ) to elif x:
Converts while ( x ) to while x:
Converts for ( x ; y ; z ) to for x SEMI y SEMI z:

remove all semicolons.

IV.  Final Pass

This pass completes the translation.

Removes all semicolons.
Removes @c if it starts the text.  This Leo-specific translation is not done when translating files.
Removes all blank lines.
Removes excess whitespace from all lines, leaving leading whitespace unchanged.
Replaces C/C++ comments by Python comments.
Removes trailing whitespace from all lines.
</t>
<t tx="T1987">@ Strategy and Performance

c2py is straightforward.  The speed of c2py is unimportant.  We don't care about the memory used because we translate only small pieces of text at a time.

We can do body[i:j] = x, regardless of len(x).  We can also do del body[i:j] to delete characters.

We scan repeatedly through the text.  Using many passes greatly simplifies the code and does not slow down c2py significantly.

No scans are done within strings or comments.  The idiom to handle such scans is the following:

def someScan(body):
	i = 0
	while i &lt; body(len):
		if isStringOrComment(body,i):
			i = skipStringOrComment(body,i)
		elif &lt;&lt; found what we are looking for ? &gt;&gt; :
			&lt;&lt; convert what we are looking for, setting i &gt;&gt;
		else: i += 1

That's about all there is to it.  The code was remarkably easy to write and seems clear to me.
</t>
<t tx="T1988">@ Please change the following lists so they contain the types and classes used by your program.

c2py removes all type definitions correctly; it converts
	new aType(...)
to
	aType(...)
@c

classList = [
	"vnode", "tnode", "Commands",
	"wxString", "wxTreeCtrl", "wxTextCtrl", "wxSplitterWindow" ]
	
typeList = ["char", "void", "short", "long", "int", "double", "float"]

@ Please change ivarsDict so it represents the instance variables (ivars) used by your program's classes.

ivarsDict is a dictionary used to translate ivar i of class c to self.i.  It also translates this-&gt;i to self.i.
@c
	
ivarsDict = {
	"atFile": [ "mCommands", "mErrors", "mStructureErrors",
		"mTargetFileName", "mOutputFileName", "mOutputStream",
		"mStartSentinelComment", "mEndSentinelComment", "mRoot"],

	"vnode": ["mCommands", "mJoinList", "mIconVal", "mTreeID", "mT", "mStatusBits"],

	"tnode": ["mBodyString", "mBodyRTF", "mJoinHead", "mStatusBits", "mFileIndex",
		"mSelectionStart", "mSelectionLength", "mCloneIndex"],
		
	"LeoFrame": ["mNextFrame", "mPrevFrame", "mCommands"],

	"Commands": [
		# public
		"mCurrentVnode", "mLeoFrame", "mInhibitOnTreeChanged", "mMaxTnodeIndex",
		"mTreeCtrl", "mBodyCtrl", "mFirstWindowAndNeverSaved",
		#private
		"mTabWidth", "mChanged", "mOutlineExpansionLevel", "mUsingClipboard",
		"mFileName", "mMemoryInputStream", "mMemoryOutputStream", "mFileInputStream",
		"mInputFile", "mFileOutputStream", "mFileSize", "mTopVnode", "mTagList",
		"mMaxVnodeTag",
		"mUndoType", "mUndoVnode", "mUndoParent", "mUndoBack", "mUndoN",
		"mUndoDVnodes", "mUndoLastChild", "mUndoablyDeletedVnode" ]}</t>
<t tx="T1989">testData = [ "\n@doc\n\
This is a doc part: format, whilest, {};-&gt;.\n\
&lt;&lt;\
section def&gt;&gt;=\n\
LeoFrame::LeoFrame(vnode *v, char *s, int i)\n\
{\n\
	// test ; {} /* */.\n\
	#if 0 //comment\n\
		if(gLeoFrameList)gLeoFrameList -&gt; mPrevFrame = this ;\n\
		else\n\
			this -&gt; mNextFrame = gLeoFrameList ;\n\
	#else\n\
		\n\
		vnode *v = new vnode(a,b);\n\
		Commands *commander = (Commands) NULL ; // after cast\n\
		this -&gt; mPrevFrame = NULL ;\n\
	#endif\n\
	if (a==b)\n\
		a = 2;\n\
	else if (a ==c)\n\
		a = 3;\n\
	else return; \n\
	/* Block comment test:\n\
		if(2):while(1): end.*/\n\
	for(int i = 1; i &lt; limit; ++i){\n\
		mVisible = FALSE ;\n\
		mOnTop = TRUE ;\n\
	}\n\
	// trailing ws.	 \n\
	mCommands = new Commands(this, mTreeCtrl, mTextCtrl) ;\n\
	gActiveFrame = this ;\n\
}\n\
	", "&lt;&lt;" +
"vnode methods &gt;&gt;=\n\
\n\
void vnode::OnCopyNode(wxCommandEvent&amp; WXUNUSED(event))\n\
{\n\
	mCommands -&gt; copyOutline();\n\
}\n\
\n@doc\n\
another doc part if, then, else, -&gt; \n&lt;&lt;" +
"vnode methods &gt;&gt;=\n\
void vnode::OnPasteNode(wxCommandEvent&amp; WXUNUSED(event))\n\
{\n\
	mCommands -&gt; pasteOutline();\n\
}\n" ]</t>
<t tx="T1990">def speedTest(passes):

	import time
	file = r"c:\prog\LeoPy\LeoPy.leo"
	f=open(file)
	if not f:
		print "not found: ", file
		return
	s=f.read()
	f.close()
	print "file:", file, " size:", len(s), " passes:", passes
	print "speedTest start"
	time1 = time.clock()
	p = passes
	while p &gt; 0:
		n = len(s) ; i = 0 ; lines = 0
		while -1 &lt; i &lt; n:
			if s[i] == '\n':
				lines += 1 ; i += 1
			else:
				i = string.find(s,'\n',i) # _much_ faster than list-based-find.
			continue
			# match is about 9 times slower than simple test.
			if s[i]=='\n': # match(s,i,'\n'): # 
				i += 1
			else:
				i += 1
		p -= 1
	time2 = time.clock()
	print "lines:", lines
	print "speedTest done:"
	print "elapsed time:", time2-time1
	print "time/pass:", (time2-time1)/passes</t>
<t tx="T1991">def leo1to2():

	import leo
	import leoGlobals
	c=leoGlobals.top()
	v=c.currentVnode()
	convertLeo1to2(v,c)
</t>
<t tx="T1992">def convertLeo1to2(v,c):

	after=v.nodeAfterTree()
	while v and v != after:
		s=v.bodyString()
		print "converting:", v.headString()
		s=convertStringLeo1to2(s)
		v.setBodyStringOrPane(s)
		v=v.threadNext()

	c.Repaint() # for backward compatibility
	print "end of leo1to2"</t>
<t tx="T1993">def convertStringLeo1to2 (s):

	# print "convertStringLeo1to2:start\n", s
	codeList = stringToList(s) ; outputList = []
	i = 0
	while i &lt; len(codeList):
		j = skipCodePart(codeList,i)
		if j &gt; i:
			code = codeList[i:j]
			convertCodeList1to2(code)
			i = j
			#print "-----code:", listToString(code)
			for item in code:
				outputList.append(item)
		j = skipDocPart(codeList,i)
		if j &gt; i:
			doc = codeList[i:j]
			convertDocList(doc) # same as in c2py
			#print "-----doc:", listToString(doc)
			i = j
			for item in doc:
				outputList.append(item)
	
	result = listToString(outputList)
	global printFlag
	if printFlag: print "-----:\n", result
	return result</t>
<t tx="T1994">@ We do _not_ replace @root by @file or insert @others as needed.  Inserting @others can be done easily enough by hand, and may take more global knowledge than we can reasonably expect to have.
@c

def convertCodeList1to2(list):

	if 0: # There isn't much reason to do this.
		removeAtRoot(list)
	safeReplace(list, "@code", "@c")
	replaceSectionDefs(list)
	removeLeadingAtCode(list)
</t>
<t tx="T1995">@ We separate the processing into two parts, 1) a leo-aware driver that iterates over @file trees and 2) a text-based part that processes one or more files or strings.
</t>
<t tx="T1996">def convertCurrentTree():

	import leo
	import leoGlobals
	c=leoGlobals.top()
	v = c.currentVnode()
	c2py.convertLeoTree(v,c)</t>
<t tx="T1997">def convertLeoTree(v,c):

	after=v.nodeAfterTree()
	while v and v != after:
		s=v.bodyString()
		print "converting:", v.headString()
		s=convertCStringToPython(s, doLeoTranslations )
		v.setBodyStringOrPane(s)
		v=v.threadNext()
	c.Repaint() # for backward compatibility.
	print "end of c2py"</t>
<t tx="T1998">def convertCFileToPython(file):

	f=open(file, 'r')
	if not f: return
	s = f.read()
	f.close();
	f=open(file + ".py", 'w')
	if not f: return
	s = convertCStringToPython(s, dontDoLeoTranslations )
	f.write(s)
	f.close()</t>
<t tx="T1999">def convertCStringToPython(s, leoFlag):

	# print "convertCStringToPython:start\n", s
	firstPart = true
	codeList = stringToList(s)
	
	if not leoFlag:
		convertCodeList(codeList, firstPart, dontDoLeoTranslations)
		return listToString(codeList)

	outputList = []
	i = 0
	while i &lt; len(codeList):
		j = skipCodePart(codeList,i)
		if j &gt; i:
			code = codeList[i:j]
			convertCodeList(code, firstPart, doLeoTranslations)
			i = j
			#print "-----code:", listToString(code)
			for item in code:
				outputList.append(item)
		firstPart = false # don't remove @c from here on.
		j = skipDocPart(codeList,i)
		if j &gt; i:
			doc = codeList[i:j]
			convertDocList(doc)
			#print "-----doc:", listToString(doc)
			i = j
			for item in doc:
				outputList.append(item)
	
	result = listToString(outputList)
	global printFlag
	if printFlag: print "-----:\n", result
	return result</t>
<t tx="T2000">def convertCodeList(list, firstPart, leoFlag):
	#first
	replace(list, "\r", None)
	convertLeadingBlanks(list)
	if leoFlag:
		replaceSectionDefs(list)
	mungeAllFunctions(list)
	#next
	safeReplace(list, " -&gt; ", '.')
	safeReplace(list, "-&gt;", '.')
	safeReplace(list, " . ", '.')
	safeReplace(list, "this.self", "self")
	safeReplace(list, "{", None)
	safeReplace(list, "}", None)
	safeReplace(list, "#if", "if")
	safeReplace(list, "#else", "else")
	safeReplace(list, "#endif", None)
	safeReplace(list, "else if", "elif")
	safeReplace(list, "else", "else:")
	safeReplace(list, "&amp;&amp;", "and")
	safeReplace(list, "||", "or")
	safeReplace(list, "TRUE", "true")
	safeReplace(list, "FALSE", "false")
	safeReplace(list, "NULL", "None")
	safeReplace(list, "this", "self")
	safeReplace(list, "try", "try:")
	safeReplace(list, "catch", "except:")
	if leoFlag:
		safeReplace(list, "@code", "@c")
	#next
	handleAllKeywords(list)
	# after processing for keywords
	removeSemicolonsAtEndOfLines(list)
	#last
	if firstPart and leoFlag: removeLeadingAtCode(list)
	removeBlankLines(list)
	removeExcessWs(list)
	# your taste may vary: in Python I don't like extra whitespace
	safeReplace(list, " :", ":") 
	safeReplace(list, ", ", ",")
	safeReplace(list, " ,", ",")
	safeReplace(list, " (", "(")
	safeReplace(list, "( ", "(")
	safeReplace(list, " )", ")")
	safeReplace(list, ") ", ")")
	replaceComments(list) # should follow all calls to safeReplace
	removeTrailingWs(list)
	safeReplace(list, "\t ", "\t") # happens when deleting declarations.</t>
<t tx="T2001">def convertDocList(docList):

	# print "convertDocList:", docList
	if matchWord(docList, 0, "@doc"):
		i = skipWs(docList, 4)
		if match(docList, i, "\n"):
			i += 1
		docList[0:i] = list("@ ")</t>
<t tx="T2002">def skipDocPart(list, i):
	
	# print "skipDocPart", i
	while i &lt; len(list):
		if matchWord(list, i, "@code") or matchWord(list, i, "@c"):
			break
		elif isSectionDef(list,i):
			break
		else: i = skipPastLine(list, i)
	return i</t>
<t tx="T2003">def skipCodePart(codeList, i):
	
	# print "skipCodePart", i
	if matchWord(codeList, i, "@doc") or matchWord(codeList, i, "@"):
		return i
	while i &lt; len(codeList):
		if match(codeList, i, "//"):
			i = skipPastLine(codeList,i)
		elif match(codeList, i, "/*"):
			i = skipCBlockComment(codeList,i)
		elif match(codeList, i, '"') or match(codeList, i, "'"):
			i = skipString(codeList,i)
		elif match(codeList, i, "\n"):
			i += 1
			if matchWord(codeList, i, "@doc") or matchWord(codeList, i, "@"):
				break
		else: i += 1
	return i</t>
<t tx="T2004">def convertLeadingBlanks(list):

	global tabWidth
	if tabWidth &lt; 2: return
	i = 0
	while i &lt; len(list):
		n = 0
		while i &lt; len(list) and list[i] == ' ':
			n += 1 ; i += 1
			if n == tabWidth:
				list[i-tabWidth:i] = ['\t']
				i = i - tabWidth + 1
				n = 0
		i = skipPastLine(list, i)</t>
<t tx="T2005">def findInList(list, i, findStringOrList):

	findList = stringToList(findStringOrList)
	
	while i &lt; len(list):
		if match(list, i, findList): return i
		else: i += 1
	return -1</t>
<t tx="T2006">def findInCode(codeList, i, findStringOrList):

	findList = stringToList(findStringOrList)
	
	while i &lt; len(codeList):
		if isStringOrComment(codeList,i):
			i = skipStringOrComment(codeList,i)
		elif match(codeList, i, findList):
			return i
		else: i += 1
	return -1</t>
<t tx="T2007"># We scan for a '{' at the top level that is preceeded by ')'
# @code and &lt; &lt; x &gt; &gt; = have been replaced by @c
def mungeAllFunctions(codeList):

	prevSemi = 0 # Previous semicolon: header contains all previous text
	i = 0
	firstOpen = None
	while i &lt; len(codeList):
		if isStringOrComment(codeList,i):
			i = skipStringOrComment(codeList,i)
			prevSemi = i
		elif match(codeList, i, '('):
			if not firstOpen:
				firstOpen = i
			i += 1
		elif match(codeList, i, '#'):
			i = skipPastLine(codeList, i)
			prevSemi = i
		elif match(codeList, i, ';'):
			i += 1
			prevSemi = i
		elif matchWord(codeList, i, "@code"):
			i += 5
			prevSemi = i # restart the scan
		elif matchWord(codeList, i, "@c"):
			i += 2 ; prevSemi = i # restart the scan
		elif match(codeList, i, "{"):
			i = handlePossibleFunctionHeader(codeList,i,prevSemi,firstOpen)
			prevSemi = i ; firstOpen = None # restart the scan
		else: i += 1</t>
<t tx="T2008"># converts function header lines from c++ format to python format.
# That is, converts
# x1..nn w::y ( t1 z1,..tn zn) {
# to
# def y (z1,..zn): {

def handlePossibleFunctionHeader(codeList, i, prevSemi, firstOpen):

	assert(match(codeList,i,"{"))
	prevSemi = skipWsAndNl(codeList, prevSemi)
	close = prevNonWsOrNlChar(codeList, i)
	if close &lt; 0 or codeList[close] != ')':
		return 1 + skipToMatchingBracket(codeList, i)
	if not firstOpen:
		return 1 + skipToMatchingBracket(codeList, i)
	close2 = skipToMatchingBracket(codeList, firstOpen)
	if close2 != close:
		return 1 + skipToMatchingBracket(codeList, i)
	open = firstOpen
	assert(codeList[open]=='(')
	head = codeList[prevSemi:open]
	# do nothing if the head starts with "if", "for" or "while"
	k = skipWs(head,0)
	if k &gt;= len(head) or not head[k] in string.letters:
		return 1 + skipToMatchingBracket(codeList, i)
	kk = skipPastWord(head,k)
	if kk &gt; k:
		headString = listToString(head[k:kk])
		# C keywords that might be followed by '{'
		# print "headString:", headString
		if headString in [ "class", "do", "for", "if", "struct", "switch", "while"]:
			return 1 + skipToMatchingBracket(codeList, i)
	args = codeList[open:close+1]
	k = 1 + skipToMatchingBracket(codeList,i)
	body = codeList[i:k]
	#print "head:", listToString(head)
	#print "args:", listToString(args)
	#print "body:", listToString(body)
	#print "tot: ", listToString(codeList[prevSemi:k])
	head = massageFunctionHead(head)
	args = massageFunctionArgs(args)
	body = massageFunctionBody(body)
	#print "head2:", listToString(head)
	#print "args2:", listToString(args)
	#print "body2:", listToString(body)
	#print "tot2: ", listToString(codeList[prevSemi:k])
	result = []
	for item in head:
		result.append(item)
	for item in args:
		result.append(item)
	for item in body:
		result.append(item)
	codeList[prevSemi:k] = result
	return k</t>
<t tx="T2009">def massageFunctionArgs(args):
	global gClassName
	assert(args[0]=='(')
	assert(args[-1]==')')

	result = ['('] ; lastWord = []
	if gClassName:
		for item in list("self,"): result.append(item) #can put extra comma

	i = 1
	while i &lt; len(args):
		i = skipWsAndNl(args, i)
		c = args[i]
		if c in string.letters:
			j = skipPastWord(args,i)
			lastWord = args[i:j]
			i = j
		elif c == ',' or c == ')':
			for item in lastWord:
				result.append(item)
			if lastWord != [] and c == ',':
				result.append(',')
			lastWord = []
			i += 1
		else: i += 1
	if result[-1] == ',':
		del result[-1]
	result.append(')')
	result.append(':')
	# print "new args:", listToString(result)
	return result</t>
<t tx="T2010">def massageFunctionHead(head):

	# print "head:", listToString(head)
	result = []
	prevWord = []
	global gClassName ; gClassName = []
	i = 0
	while i &lt; len(head):
		i = skipWsAndNl(head, i)
		if i &lt; len(head) and head[i] in string.letters:
			result = []
			j = skipPastWord(head,i)
			prevWord = head[i:j]
			i = j
			# look for ::word2
			i = skipWs(head,i)
			if match(head,i,"::"):
				# Set the global to the class name.
				gClassName = listToString(prevWord)
				# print "class name:", gClassName
				i = skipWs(head, i+2)
			 	if i &lt; len(head) and (head[i]=='~' or head[i] in string.letters):
					j = skipPastWord(head,i)
					if head[i:j] == prevWord:
						for item in list("__init__"): result.append(item)
					elif head[i]=='~' and head[i+1:j] == prevWord:
						for item in list("__del__"): result.append(item)
					else:
						# for item in "::": result.append(item)
						for item in head[i:j]: result.append(item)
					i = j
			else:
				for item in prevWord:result.append(item)
		else: i += 1
		
	finalResult = list("def ")
	for item in result: finalResult.append(item)
	# print "new head:", listToString(finalResult)
	return finalResult</t>
<t tx="T2011">def massageFunctionBody(body):

	body = massageIvars(body)
	body = removeCasts(body)
	body = removeTypeNames(body)
	return body</t>
<t tx="T2012">def massageIvars(body):

	if gClassName and ivarsDict.has_key(gClassName):
		ivars = ivarsDict [ gClassName ]
	else:
		ivars = []
	# print "key:ivars=", gClassName, ':', `ivars`

	i = 0
	while i &lt; len(body):
		if isStringOrComment(body,i):
			i = skipStringOrComment(body,i)
		elif body[i] in string.letters:
			j = skipPastWord(body,i)
			word = listToString(body[i:j])
			# print "looking up:", word
			if word in ivars:
				# replace word by self.word
				# print "replacing", word, " by self.", word
				word = "self." + word
				word = list(word)
				body[i:j] = word
				delta = len(word)-(j-i)
				i = j + delta
			else: i = j
		else: i += 1
	return body</t>
<t tx="T2013">def removeCasts(body):

	i = 0
	while i &lt; len(body):
		if isStringOrComment(body,i):
			i = skipStringOrComment(body,i)
		elif match(body, i, '('):
			start = i
			i = skipWs(body, i+1)
			if body[i] in string.letters:
				j = skipPastWord(body,i)
				word = listToString(body[i:j])
				i = j
				if word in classList or word in typeList:
					i = skipWs(body, i)
					while match(body,i,'*'):
						i += 1
					i = skipWs(body, i)
					if match(body,i,')'):
						i += 1
						# print "removing cast:", listToString(body[start:i])
						del body[start:i]
						i = start
		else: i += 1
	return body</t>
<t tx="T2014"># Do _not_ remove type names when preceeded by new.

def removeTypeNames(body):

	i = 0
	while i &lt; len(body):
		if isStringOrComment(body,i):
			i = skipStringOrComment(body,i)
		elif matchWord(body, i, "new"):
			i = skipPastWord(body,i)
			i = skipWs(body,i)
			# don't remove what follows new.
			if body[i] in string.letters:
				i = skipPastWord(body,i)
		elif body[i] in string.letters:
			j = skipPastWord(body,i)
			word = listToString(body[i:j])
			if word in classList or word in typeList:
				k = skipWs(body, j)
				while match(body,k,'*'):
					k += 1 ; j = k
				# print "Deleting type name:", listToString(body[i:j])
				del body[i:j]
			else:
				i = j
		else: i += 1
	return body</t>
<t tx="T2015"># converts if ( x ) to if x:
# converts while ( x ) to while x:
def handleAllKeywords(codeList):

	# print "handAllKeywords:", listToString(codeList)
	i = 0
	while i &lt; len(codeList):
		if isStringOrComment(codeList,i):
			i = skipStringOrComment(codeList,i)
		elif ( matchWord(codeList,i,"if") or
			matchWord(codeList,i,"while") or
			matchWord(codeList,i,"for") or
			matchWord(codeList,i,"elif") ):
			i = handleKeyword(codeList,i)
		else:
			i += 1
	# print "handAllKeywords2:", listToString(codeList)</t>
<t tx="T2016">def handleKeyword(codeList,i):

	isFor = false
	if (matchWord(codeList,i,"if")):
		i += 2
	elif (matchWord(codeList,i,"elif")):
		i += 4
	elif (matchWord(codeList,i,"while")):
		i += 5
	elif (matchWord(codeList,i,"for")):
		i += 3
		isFor = true
	else: assert(0)
	# Make sure one space follows the keyword
	k = i
	i = skipWs(codeList,i)
	if k == i:
		c = codeList[i]
		codeList[i:i+1] = [ ' ', c ]
		i += 1
	# Remove '(' and matching ')' and add a ':'
	if codeList[i] == "(":
		j = removeMatchingBrackets(codeList,i)
		if j &gt; i and j &lt; len(codeList):
			c = codeList[j]
			codeList[j:j+1] = [":", " ", c]
			j = j + 2
		return j
	return i</t>
<t tx="T2017">def isWs(c):
	return c == ' ' or c == '\t'
	
def isWsOrNl(c):
	return c == ' ' or c == '\t' or c == '\n'</t>
<t tx="T2018"># returns the ending index if i points to &lt; &lt; x &gt; &gt; =
def isSectionDef(list, i):

	i = skipWs(list,i)
	if not match(list,i,"&lt;&lt;"): return false
	while i &lt; len(list) and list[i] != '\n':
		if match(list,i,"&gt;&gt;="): return i+3
		else: i += 1
	return false</t>
<t tx="T2019">def isStringOrComment(list, i):

	return match(list,i,"'") or match(list,i,'"') or match(list,i,"//") or match(list,i,"/*")</t>
<t tx="T2020"># returns true if findList matches starting at codeList[i]

def match (codeList, i, findStringOrList):

	findList = stringToList(findStringOrList)
	n = len(findList)
	j = 0
	while i+j &lt; len(codeList) and j &lt; len(findList):
		if codeList[i+j] != findList[j]:
			return false
		else:
			j += 1
			if j == n:
				return i+j
	return false</t>
<t tx="T2021">def matchWord (codeList, i, findStringOrList):

	j = match(codeList,i,findStringOrList)
	if not j:
		return false
	elif j &gt;= len(codeList):
		return true
	else:
		c = codeList[j]
		return not (c in string.letters or c in string.digits or c == '_')</t>
<t tx="T2022">def prevNonWsChar(list, i):

	i -= 1
	while i &gt;= 0 and isWs(list[i]):
		i -= 1
	return i

def prevNonWsOrNlChar(list, i):

	i -= 1
	while i &gt;= 0 and isWsOrNl(list[i]):
		i -= 1
	return i</t>
<t tx="T2023">def removeAllCComments(list, delim):

	i = 0
	while i &lt; len(list):
		if match(list,i,"'") or match(list,i,'"'):
			i = skipString(list,i)
		elif match(list,i,"//"):
			j = skipPastLine(list,i)
			print "deleting single line comment:", listToString(list[i:j])
			del list[i:j]
		elif match(list,i,"/*"):
			j = skipCBlockComment(list,i)
			print "deleting block comment:", listToString(list[i:j])
			del list[i:j]
		else:
			i += 1</t>
<t tx="T2024">def removeAllCSentinels(list, delim):

	i = 0
	while i &lt; len(list):
		if match(list,i,"'") or match(list,i,'"'):
			# string starts a line.
			i = skipString(list,i)
			i = skipPastLine(list,i)
		elif match(list,i,"/*"):
			# block comment starts a line
			i = skipCBlockComment(list,i)
			i = skipPastLine(line,i)
		elif match(list,i,"//@"):
			j = skipPastLine(list,i)
			print "deleting sentinel:", listToString(list[i:j])
			del list[i:j]
		else:
			i = skipPastLine(list,i)</t>
<t tx="T2025">def removeAllPythonComments(list, delim):

	i = 0
	while i &lt; len(list):
		if match(list,i,"'") or match(list,i,'"'):
			i = skipString(list,i)
		elif match(list,i,"#"):
			j = skipPastLine(list,i)
			print "deleting comment:", listToString(list[i:j])
			del list[i:j]
		else:
			i += 1</t>
<t tx="T2026">def removeAllPythonSentinels(list, delim):

	i = 0
	while i &lt; len(list):
		if match(list,i,"'") or match(list,i,'"'):
			# string starts a line.
			i = skipString(list,i)
			i = skipPastLine(list,i)
		elif match(list,i,"#@"):
			j = skipPastLine(list,i)
			print "deleting sentinel:", listToString(list[i:j])
			del list[i:j]
		else:
			i = skipPastLine(list,i)</t>
<t tx="T2027">def removeAtRoot (codeList):

	i = skipWs(codeList, 0)
	if matchWord(codeList,i,"@root"):
		j = skipPastLine(codeList,i)
		del codeList[i:j]

	while i &lt; len(codeList):
		if isStringOrComment(codeList,i):
			i = skipStringOrComment(codeList,i)
		elif match(codeList,i,"\n"):
			i = skipWs(codeList, i+1)
			if matchWord (codeList,i,"@root"):
				j = skipPastLine(codeList,i)
				del codeList[i:j]
		else: i += 1
</t>
<t tx="T2028">def removeBlankLines(codeList):

	i = 0
	while i &lt; len(codeList):
		j = i
		while j &lt; len(codeList) and (codeList[j]==" " or codeList[j]=="\t"):
			j += 1
		if j== len(codeList) or codeList[j] == '\n':
			del codeList[i:j+1]
		else:
			oldi = i
			i = skipPastLine(codeList,i)</t>
<t tx="T2029">def removeExcessWs(codeList):

	i = 0
	i = removeExcessWsFromLine(codeList,i)
	while i &lt; len(codeList):
		if isStringOrComment(codeList,i):
			i = skipStringOrComment(codeList,i)
		elif match(codeList,i,'\n'):
			i += 1
			i = removeExcessWsFromLine(codeList,i)
		else: i += 1</t>
<t tx="T2030">def removeExcessWsFromLine(codeList,i):

	assert(i==0 or codeList[i-1] == '\n')
	i = skipWs(codeList,i)
	while i &lt; len(codeList):
		if isStringOrComment(codeList,i): break # safe
		elif match(codeList, i, '\n'): break
		elif match(codeList, i, ' ') or match(codeList, i, '\t'):
			# Replace all whitespace by one blank.
			k = i
			i = skipWs(codeList,i)
			codeList[k:i] = [' ']
			i = k + 1 # make sure we don't go past a newline!
		else: i += 1
	return i</t>
<t tx="T2031">def removeLeadingAtCode(codeList):

	i = skipWsAndNl(codeList,0)
	if matchWord(codeList,i,"@code"):
		i = skipWsAndNl(codeList,5)
		del codeList[0:i]
	elif matchWord(codeList,i,"@c"):
		i = skipWsAndNl(codeList,2)
		del codeList[0:i]</t>
<t tx="T2032">def removeMatchingBrackets(codeList, i):

	j = skipToMatchingBracket(codeList, i)
	if j &gt; i and j &lt; len(codeList):
		# print "del brackets:", listToString(codeList[i:j+1])
		c = codeList[j]
		if c == ')' or c == ']' or c == '}':
			del codeList[j:j+1]
			del codeList[i:i+1]
			# print "returning:", listToString(codeList[i:j])
			return j - 1
		else: return j + 1
	else: return j</t>
<t tx="T2033">def removeSemicolonsAtEndOfLines(list):

	i = 0
	while i &lt; len(list):
		if isStringOrComment(list,i):
			i = skipStringOrComment(list,i)
		elif list[i] == ';':
			j = skipWs(list,i+1)
			if j &gt;= len(list) or match(list,j,'\n') or match(list,j,'#') or match(list,j,"//"):
				del list[i]
			else: i += 1
		else: i += 1</t>
<t tx="T2034">def removeTrailingWs(list):

	i = 0
	while i &lt; len(list):
		if isWs(list[i]):
			j = i
			i = skipWs(list,i)
			assert(j &lt; i)
			if i &gt;= len(list) or list[i] == '\n':
				# print "removing trailing ws:", `i-j`
				del list[j:i]
				i = j
		else: i += 1</t>
<t tx="T2035"># Replaces all occurances of findString by changeString.
# Deletes all occurances if change is None
def replace(codeList, findString, changeString):

	if len(findString)==0: return
	findList = stringToList(findString)
	changeList = stringToList(changeString)

	i = 0
	while i &lt; len(codeList):
		if match(codeList, i, findList):
			codeList[i:i+len(findList)] = changeList
			i += len(changeList)
		else: i += 1</t>
<t tx="T2036"># For Leo we expect few block comments; doc parts are much more common.

def replaceComments(codeList):

	i = 0
	if match(codeList, i, "//"):
		codeList[0:2] = ['#']
	while i &lt; len(codeList):
		if match(codeList, i, "//"):
			codeList[i:i+2] = ['#']
			i = skipPastLine(codeList,i)
		elif match(codeList, i, "/*"):
			j = skipCBlockComment(codeList,i)
			del codeList[j-2:j]
			codeList[i:i+2] = ['#']
			j -= 2 ; k = i ; delta = -1
			while k &lt; j + delta :
				if codeList[k]=='\n':
					codeList[k:k+1] = ['\n', '#', ' ']
					delta += 2 ; k += 3 # progress!
				else: k += 1
			i = j + delta
		elif match(codeList, i, '"') or match(codeList, i, "'"):
			i = skipString(codeList,i)
		else: i += 1</t>
<t tx="T2037"># Replaces &lt; &lt; x &gt; &gt; = by @c (at the start of lines).
def replaceSectionDefs(codeList):

	i = 0
	j = isSectionDef(codeList,i)
	if j &gt; 0: codeList[i:j] = list("@c ")

	while i &lt; len(codeList):
		if isStringOrComment(codeList,i):
			i = skipStringOrComment(codeList,i)
		elif match(codeList,i,"\n"):
			i += 1
			j = isSectionDef(codeList,i)
			if j &gt; i: codeList[i:j] = list("@c ")
		else: i += 1</t>
<t tx="T2038"># Replaces occurances of findString by changeString outside of C comments and strings.
# Deletes all occurances if change is None.
def safeReplace(codeList, findString, changeString):

	if len(findString)==0: return
	findList = stringToList(findString)
	changeList = stringToList(changeString)
	i = 0
	if findList[0] in string.letters: #use matchWord
		while i &lt; len(codeList):
			if isStringOrComment(codeList,i):
				i = skipStringOrComment(codeList,i)
			elif matchWord(codeList, i, findList):
				codeList[i:i+len(findList)] = changeList
				i += len(changeList)
			else: i += 1
	else: #use match
		while i &lt; len(codeList):
			if match(codeList, i, findList):
				codeList[i:i+len(findList)] = changeList
				i += len(changeList)
			else: i += 1</t>
<t tx="T2039">def skipCBlockComment(codeList, i):

	assert(match(codeList, i, "/*"))
	i += 2

	while i &lt; len(codeList):
		if match(codeList, i, "*/"): return i + 2
		else: i += 1
	return i</t>
<t tx="T2040">def skipPastLine(codeList, i):

	while i &lt; len(codeList) and codeList[i] != '\n':
		i += 1
	if i &lt; len(codeList) and codeList[i] == '\n':
		i += 1
	return i</t>
<t tx="T2041">def skipPastWord(list, i):

	assert(list[i] in string.letters or list[i]=='~')
	
	# Kludge: this helps recognize dtors.
	if list[i]=='~':
		i += 1
	
	while i &lt; len(list) and (
		list[i] in string.letters or
		list[i] in string.digits or
		list[i]=='_'):
		i += 1
	return i</t>
<t tx="T2042">def skipString(codeList, i):

	delim = codeList[i] # handle either single or double-quoted strings
	assert(delim == '"' or delim == "'")
	i += 1

	while i &lt; len(codeList):
		if codeList[i] == delim: return i + 1
		elif codeList[i] == '\\': i += 2
		else: i += 1
	return i</t>
<t tx="T2043">def skipStringOrComment(list,i):

	if match(list,i,"'") or match(list,i,'"'):
		return skipString(list,i)
	if match(list, i, "//"):
		return skipPastLine(list,i)
	elif match(list, i, "/*"):
		return skipCBlockComment(list,i)
	else: assert(0)</t>
<t tx="T2044">def skipToMatchingBracket(codeList, i):

	c = codeList[i]
	if   c == '(': delim = ')'
	elif c == '{': delim = '}'
	elif c == '[': delim = ']'
	else: assert(0)

	i += 1
	while i &lt; len(codeList):
		c = codeList[i]
		if isStringOrComment(codeList,i):
			i = skipStringOrComment(codeList,i)
		elif c == delim:
			return i
		elif c == '(' or c == '[' or c == '{':
			i = skipToMatchingBracket(codeList,i)
			i += 1 # skip the closing bracket.
		else: i += 1
	return i</t>
<t tx="T2045">def skipWs(list, i):

	while i &lt; len(list):
		c = list[i]
		if c == ' ' or c == '\t':
			i += 1
		else: break
	return i
	
def skipWsAndNl(list, i):

	while i &lt; len(list):
		c = list[i]
		if c == ' ' or c == '\t' or c == '\n':
			i += 1
		else: break
	return i</t>
<t tx="T2046"># converts a string to a list containing one item per character of the list.
# converts None to the empty string and leaves other types alone.

# list(string) does not work on none.
def stringToList(string):

	if string:
		return list(string)
	else:
		return []</t>
<t tx="T2047">def listToString(list):

	return string.join(list,"")</t>
<t tx="T2048"># routines to gather static statistics about opcodes based on dis module.

import compiler,dis,os,string,sys,types

@others</t>
<t tx="T2049">def go():
	
	dir = "c:/prog/leoCVS/leo/"
	modules = getModules(dir)
	stats = [0] * 256
	try:
		# Importing these might start leo itself and hang idle.
		modules.remove("leo")
		modules.remove("openLeo")
		modules.remove("openEkr")
		modules.remove("setup")
	except: pass
	# print modules
	
	for m in modules:
		try:
			print "module:", m
			exec("import " + m)
			a = eval(m)
			any(a,stats)
		except:
			import traceback
			traceback.print_exc()
			print "----- no matching class in", `m`
			
	print_stats(stats)</t>
<t tx="T2050">def getFiles (dir):

	# Generate the list of modules.
	allFiles = os.listdir(dir)
	files = []
	for f in allFiles:
		head,tail = os.path.split(f)
		root,ext = os.path.splitext(tail)
		if ext==".py":
			files.append(os.path.join(dir,f))
			
	return files</t>
<t tx="T2051">def getModules (dir):
	
	"""Return the list of Python files in dir."""
	
	files = []
	
	try:
		allFiles = os.listdir(dir)
		for f in allFiles:
			head,tail = os.path.split(f)
			fn,ext = os.path.splitext(tail)
			if ext==".py":
				files.append(fn)
	except: pass
			
	return files</t>
<t tx="T2052">def any(x,stats,printName = 0):
	# based on dis.dis()
	"""Gathers statistics for classes, methods, functions, or code."""
	if not x:
		return
	if type(x) is types.InstanceType:
		x = x.__class__
	if hasattr(x, 'im_func'):
		x = x.im_func
	if hasattr(x, 'func_code'):
		x = x.func_code
	if hasattr(x, '__dict__'):
		items = x.__dict__.items()
		items.sort()
		for name, x1 in items:
			if type(x1) in (types.MethodType,
							types.FunctionType,
							types.CodeType):
				if printName: print name
				try:
					any(x1,stats)
				except TypeError, msg:
					print "Sorry:", msg
	elif hasattr(x, 'co_code'):
		code(x,stats)
	else:
		raise TypeError, \
			  "don't know how to disassemble %s objects" % \
			  type(x).__name__</t>
<t tx="T2053">def code (co, stats):
	"""Gather static count statistics for a code object."""

	codeList = co.co_code
	# Count the number of occurances of each opcode.
	i = 0 ;  n = len(codeList)
	while i &lt; n:
		c = codeList[i]
		op = ord(c)
		stats[op] += 1
		i = i+1
		if op &gt;= dis.HAVE_ARGUMENT:
			i = i+2</t>
<t tx="T2054">def print_stats (stats):

	stats2 = [] ; total = 0
	for i in xrange(0,256):
		if stats[i] &gt; 0:
			stats2.append((stats[i],i))
		total += stats[i]

	stats2.sort()
	stats2.reverse()
	for stat,i in stats2:
		print string.rjust(`stat`,6), dis.opname[i]
	print "total", total</t>
<t tx="T2055">@language python

@ This file contains functions for non-interactive searching.  You might find these useful while running other scripts.
@c

import leo, string, re

@others</t>
<t tx="T2056">def changeAll ( commander, findPat, changePat, bodyFlag = 1 ):
	"""
	changeAll	make changes in an entire Leo outline.
	
	commander	Commands object for a Leo outline window.
	findPat		the search string.
	changePat	the replacement string.
	bodyFlag	true: change body text.  false: change headline text.
	"""
	n = len(changePat)
	v = commander.rootVnode()
	pos = 0
	while v != None:
		v, pos = changeNext(v, pos, findPat, changePat, bodyFlag)
		pos = pos + n</t>
<t tx="T2057">def changeNext ( v, pos, findPat, changePat, bodyFlag = 1 ):
	"""
	changeNext:	use string.find() to change text in a Leo outline.
	
	v	 		the vnode to start the search.
	pos			the position within the body text of v to start the search.
	findPat		the search string.
	changePat	the replacement string.
	bodyFlag	true: change body text.  false: change headline text.
	
	returns a tuple (v,pos) showing where the change occured.
	returns (None,0) if no further match in the outline was found.

	Note: if (v,pos) is a tuple returned previously from changeNext,
	changeNext(v,pos+len(findPat),findPat,changePat)
	changes the next matching string.
	"""
	n = len(findPat)
	v, pos = findNext(v, pos, findPat, bodyFlag)
	if v == None:
		return None, 0
	if bodyFlag:
		s = v.bodyString()
		# s[pos:pos+n] = changePat
		s = s[:pos] + changePat + s[pos+n:]
		v.setBodyStringOrPane(s)
	else:
		s = v.headString()
		# s[pos:pos+n] = changePat
		s = s[:pos] + changePat + s[pos+n:]
		v.setHeadStringOrHeadline(s)
		print "setting head string: ", result
	return v, pos</t>
<t tx="T2058">def changePrev ( v, pos, findPat, changePat, bodyFlag = 1 ):
	"""
	changePrev:	use string.rfind() to change text in a Leo outline.
	
	v	 		the vnode to start the search.
	pos			the position within the body text of v to start the search.
	findPat		the search string.
	changePat	the replacement string.
	bodyFlag	true: change body text.  false: change headline text.
	
	returns a tuple (v,pos) showing where the change occured.
	returns (None,0) if no further match in the outline was found.

	Note: if (v,pos) is a tuple returned previously from changePrev,
	changePrev(v,pos-len(findPat),findPat,changePat)
	changes the next matching string.
	"""
	n = len(findPat)
	v, pos = findPrev(v, pos, findPat, bodyFlag)
	if v == None:
		return None, 0
	if bodyFlag:
		s = v.bodyString()
		# s[pos:pos+n] = changePat
		s = s[:pos] + changePat + s[pos+n:]
		v.setBodyStringOrPane(s)
	else:
		s = v.headString()
		#s[pos:pos+n] = changePat
		s = s[:pos] + changePat + s[pos+n:]
		v.setHeadStringOrHeadline(s)
	return v, pos</t>
<t tx="T2059">def findAll ( commander, pattern, bodyFlag = 1 ):
	"""
	findAll		search an entire Leo outline for a pattern.
	
	commander	Commands object for a Leo outline window.
	pattern		the search string.
	bodyFlag	true: search body text.  false: search headline text.
	
	returns a list of tuples (v,pos) showing where matches occured.
	returns [] if no match were found.
	"""
	n = len(pattern)
	result = []
	v = commander.rootVnode()
	pos = 0
	while v != None:
		v, pos = findNext(v, pos, pattern, bodyFlag)
		if v != None:
			result.append ( (v, pos) )
		pos = pos + n
	return result</t>
<t tx="T2060">def findNext ( v, pos, pattern, bodyFlag = 1 ):
	"""
	findNext:	use string.find() to find a pattern in a Leo outline.
	
	v	 		the vnode to start the search.
	pos			the position within the body text of v to start the search.
	pattern		the search string.
	bodyFlag	true: search body text.  false: search headline text.
	
	returns a tuple (v,pos) showing where the match occured.
	returns (None,0) if no further match in the outline was found.

	Note: if (v,pos) is a tuple returned previously from findNext,
	findNext(v,pos+len(pattern),pattern) finds the next match.
	"""
	while v != None:
		if bodyFlag:
			s = v.bodyString()
		else:
			s = v.headString()
		pos = string.find ( s, pattern, pos )
		if pos != -1:
			return v, pos
		v = v.threadNext()
		pos = 0
	return None, 0</t>
<t tx="T2061">def findPrev ( v, pos, pattern, bodyFlag = 1 ):
	"""
	findPrev:	use string.rfind() to find a pattern in a Leo outline.
	
	v	 		the vnode to start the search.
	pos			the position within the body text of v to start the search.
	pattern		the search string
	bodyFlag	true: search body text.  false: search headline text.
	
	returns a tuple (v,pos) showing where the match occured.
	returns (None,0) if no further match in the outline was found.

	Note: if (v,pos) is a tuple returned previously from findPrev,
	findPrev(v,pos-len(pattern),pattern) finds the next match.
	"""
	while v != None:
		if bodyFlag:
			s = v.bodyString()
		else:
			s = v.headString()
		pos = string.rfind ( s, pattern, 0, pos )
		if pos != -1:
			return v, pos
		v  = v.threadBack()
		pos = -1
	return None, 0</t>
<t tx="T2062">def reChangeAll ( commander, findPat, changePat, bodyFlag, reFlags = None ):
	"""
	reChangeAll: make changes in an entire Leo outline using re module.
	
	commander	Commands object for a Leo outline window.
	findPat		the search string.
	changePat	the replacement string.
	bodyFlag	true: change body text.  false: change headline text.
	reFlags		flags argument to re.search().
	"""
	n = len(changePat)
	v = commander.rootVnode()
	pos = 0
	while v != None:
		v, mo, pos = reChangeNext(
			v, pos, findPat, changePat, bodyFlag, reFlags)
		pos = pos + n</t>
<t tx="T2063">def reChangeNext ( v, pos, findPat, changePat, bodyFlag, reFlags = None ):
	"""
	reChangeNext: use re.search() to change text in a Leo outline.
	
	v	 		the vnode to start the search.
	pos			the position within the body text of v to start the search.
	findPat		the search string.
	changePat	the replacement string.
	bodyFlag	true: change body text.  false: change headline text.
	reFlags		flags argument to re.search().
	
	returns a tuple (v,pos) showing where the change occured.
	returns (None,0) if no further match in the outline was found.

	Note: if (v,pos) is a tuple returned previously from reChangeNext,
	reChangeNext(v,pos+len(findPat),findPat,changePat,bodyFlag)
	changes the next matching string.
	"""
	n = len(findPat)
	v, mo, pos = reFindNext(v, pos, findPat, bodyFlag, reFlags)
	if v == None:
		return None, None, 0
	if bodyFlag:
		s = v.bodyString()
		print s, findPat, changePat
		# s[pos:pos+n] = changePat
		s = s[:pos] + changePat + s[pos+n:]
		v.setBodyStringOrPane(s)
	else:
		s = v.headString()
		# s[pos:pos+n] = changePat
		s = s[:pos] + changePat + s[pos+n:]
		v.setHeadStringOrHeadline(s)
	return v, mo, pos</t>
<t tx="T2064">def reChangePrev ( v, pos, findPat, changePat, bodyFlag, reFlags = None ):
	"""
	reChangePrev: use re.search() to change text in a Leo outline.
	
	v	 		the vnode to start the search.
	pos			the position within the body text of v to start the search.
	findPat		the search string.
	changePat	the replacement string.
	bodyFlag	true: change body text.  false: change headline text.
	reFlags		flags argument to re.search().
	
	returns a tuple (v,pos) showing where the change occured.
	returns (None,0) if no further match in the outline was found.

	Note: if (v,pos) is a tuple returned previously from reChangePrev,
	reChangePrev(v,pos-len(findPat),findPat,changePat,bodyFlag)
	changes the next matching string.
	"""
	n = len(findPat)
	v, mo, pos = reFindPrev(v, pos, findPat, bodyFlag, reFlags)
	if v == None:
		return None, None, 0
	if bodyFlag:
		s = v.bodyString()
		# s[pos:pos+n] = changePat
		s = s[:pos] + changePat + s[pos+n:]
		v.setBodyStringOrPane(s)
	else:
		s = v.headString()
		# s[pos:pos+n] = changePat
		s = s[:pos] + changePat + s[pos+n:]
		v.setHeadStringOrHeadline(s)
	return v, mo, pos</t>
<t tx="T2065">def reFindAll ( commander, findPat, bodyFlag, reFlags = None ):
	"""
	reFindAll	search an entire Leo outline using re module.
	
	commander	Commands object for a Leo outline window.
	pattern		the search string.
	bodyFlag	true: search body text.  false: search headline text.
	reFlags		flags argument to re.search().
	
	returns a list of tuples (v,pos) showing where matches occured.
	returns [] if no match were found.
	"""
	n = len(findPat)
	result = []
	v = commander.rootVnode()
	pos = 0
	while v != None:
		v, mo, pos = reFindNext(v, pos, findPat, bodyFlag, reFlags)
		if v != None:
			result.append ( (v,mo,pos) )
		pos = pos + n
	return result</t>
<t tx="T2066">def reFindNext ( v, pos, pattern, bodyFlag, reFlags = None ):
	"""
	reFindNext:	use re.search() to find pattern in a Leo outline.
	
	v	 		the vnode to start the search.
	pos			the position within the body text of v to start the search.
	pattern		the search string
	bodyFlag	true: search body text.  false: search headline text.
	reFlags		the flags argument to re.search()
	
	returns a tuple (v,mo,pos) showing where the match occured.
	returns (None,None,0) if no further match in the outline was found.

	Note: if (v,pos) is a tuple returned previously from reFindNext,
	reFindNext(v,pos+len(pattern),pattern) finds the next match.
	"""
	while v != None:
		if bodyFlag:
			s = v.bodyString()
		else:
			s = v.headString()
		if reFlags == None:
			mo = re.search ( pattern, s[pos:] )
		else:
			mo = re.search ( pattern, s[pos:], reFlags )
		if mo != None:
			return v, mo, pos + mo.start()
		v = v.threadNext()
		pos = 0
	return None, None, 0</t>
<t tx="T2067">def reFindPrev ( v, pos, pattern, bodyFlag, reFlags = None ):
	"""
	reFindPrev:	use re.search() to find pattern in a Leo outline.

	v	 		the vnode to start the search.
	pos			the position within the body text of v to start the search.
	pattern		the search string
	bodyFlag	true: search body text.  false: search headline text.
	reFlags		the flags argument to re.search()
	
	returns a tuple (v,mo,pos) showing where the match occured.
	returns (None,None,0) if no further match in the outline was found.
	
	Note 1: Searches vnodes in reverse (v.threadBack) direction.
	Searches text of vnodes in _forward_ direction.
	
	Note 2: if (v,pos) is a tuple returned previously from reFindPrev,
	reFindPrev(v,pos-len(pattern),pattern) finds the next match.
	"""
	while v != None:
		if bodyFlag:
			s = v.bodyString()
		else:
			s = v.headString()
		# Forward search through text...
		if reFlags == None:
			mo = re.search ( pattern, s[pos:] )
		else:
			mo = re.search ( pattern, s[pos:], reFlags )
		if mo != None:
			return v, mo, pos+mo.start()
		# Reverse search through vnode.
		v = v.threadBack()
		pos = 0
	return None, None, 0</t>
<t tx="T2068">def lineAtPos ( s, pos ):
	"""
	lineAtPos: return the line of a string containing the given index.
	s		a string
	pos		an index into s
	"""
	# find the start of the line containing the match
	if len(s) &lt; 1:
		return ""
	if pos &gt; len(s):
		pos = len(s)-1
		
	while pos &gt; 0:
		if s[pos] == '\n':
			pos = pos + 1
			break
		else:
			pos = pos - 1
	# return the line containing the match
	s = s[pos:]
	list = string.split(s,"\n")
	return list[0]</t>
<t tx="T2069">def printFindList( findList, bodyFlag = 1 ):
	"""
	printFindList:	Print matching lines from the list.
	
	findList:		a list of (v,pos) tuples returned from findAll().
	Only the line containing the match is printed.
	Lines are printed once for each match found on the line.
	"""
	for v,pos in findList:
		if v != None:
			if bodyFlag:
				s = v.bodyString()
			else:
				s = v.headString()
			print lineAtPos(s, pos)</t>
<t tx="T2070">@language python

@ This tiny script is intended to be called from go.bat to open LeoPy.leo.  You could change the file name to be any file you work on a lot...
@c

import leo
leo.leoOpen("c:\prog\leoCVS\leo\LeoPy.leo")</t>
<t tx="T2071">@language python

@ Script for creating and installing distributions of leo.py using Python's distutils package.  setup.py is the conventional name for such scripts.

On Windows, invoke this script using sdist.bat
On Linux do: cd LeoPy ; python setup.py sdist --force-manifest --formats=gztar,zip
@c

from distutils.core import setup
import os

print
print "Update version numbers"
print "Clear Default Tangle Directory"
print "Recreate leoConfig.txt"
print "Distribute both leox-y.zip and leosetup.exe"
print

# Generate the list of modules.
files = os.listdir(os.getcwd())
modules = []
for f in files:
	head,tail = os.path.split(f)
	root,ext = os.path.splitext(tail)
	if tail[0:3]=="leo" and ext==".py":
		modules.append(root)
		
modules.sort()
# print "modules:", modules
&lt;&lt; setup info for setup.py &gt;&gt;</t>
<t tx="T2072">setup( name="leo",
	version="3.9",
	author="Edward K. Ream",
	author_email="edream@tds.net",
	url="http://personalpages.tds.net/~edream/front.html",
	py_modules=modules, # leo*.py also included in manifest
	description = "Leo: Literate Editor with Outlines",
	licence="Python", # [sic], not license
	platforms=["Windows, Linux, Macintosh"],
	long_description =
"""Leo is an outline-oriented editor written in 100% pure Python.
Leo works on any platform that supports Python 2.1 or 2.2 and the Tk toolkit.
This version of Leo was developed with Python 2.2.1 and Tk 8.3.2.

Download Python from http://python.org/
Download tcl/Tk from http://tcl.activestate.com/software/tcltk/

Leo features a multi-window outlining editor with powerful outline commands,
support for literate programming features, syntax colorizing for many common
languages, unlimited Undo/Redo, an integrated Python shell(IDLE) window,
and many user options including user-definable colors and fonts and user-
definable shortcuts for all menu commands.

Leo a unique program editor, outline editor, literate programming tool,
data manager and project manager. Cloned outlines are a key enabling feature
that make possible multiple views of a project within a single Leo outline.
""")</t>
<t tx="T2073">@language python

# Example untangle_done script

def run(root_list):

	print "untangle_done roots:", root_list</t>
<t tx="T2074"># An example of running this script:
#
# import leoImport
# leoImport.importFiles("c:/prog/test", ".py")

def importFiles (dir, type = None, kind = "@file"):
	
	import os

	# Check the params.
	if kind != "@file" and kind != "@root":
		es("kind must be @file or @root: " + `kind`)
		return
	if not os.path.exists(dir):
		es("directory does not exist: " + `dir`)
		return
	
	c = top() # Get the commander.
	
	try:
		files = os.listdir(dir)
		files2 = []
		for f in files:
			path = os.path.join(dir,f)
			if os.path.isfile(path):
				name, ext = os.path.splitext(f)
				if type == None or ext == type:
					files2.append(path)
		if len(files2) &gt; 0:
			c.importCommands.importFilesCommand(files2,kind)
	except:
		es("exception in importFiles script")
		es_exception()</t>
<t tx="T2075">@ignore</t>
<t tx="T2076">@language python

# Dummy file to make this a potential package.</t>
<t tx="T2077"># Entry point for Leo in Python.

@language python
&lt;&lt; Import pychecker &gt;&gt;
from leoGlobals import *
import leoApp,leoFrame
import os,string,sys,Tkinter

@others

if __name__ == "__main__":
	if len(sys.argv) &gt; 1:
		if sys.platform=="win32": # Windows
			fileName = string.join(sys.argv[1:],' ')
		else:
			fileName = sys.argv[1]
		leoOpen(fileName)
	else:
		run()


</t>
<t tx="T2078">@ pychecker is extremely useful, and it sometimes reports problems erroneously.  In particular, the following warnings are invalid:

in leoFrame.py and leoNodes.py: warnings about the event param not being used. pychecker doesn't understand that these routines are Tkinter callbacks.

in leoApp.py and leoGlobals.py: pychecker doesn't seem to handle globals very well.  There are spurious warnings about globals.

several files: pychecker complains about several routines being "too big", i.e., pychecker doesn't understand about literate programming.

@c

if 0: # Set to 1 for lint-like testing.  This can also be done in idle.
	try:
		import pychecker.checker
	except: pass</t>
<t tx="T2079"># This is useful for reloading after a file has been changed.

def go(*args):

	if len(args) &gt; 0 and type(args[0]) == type(("a","b")):
		args = args[0] # Strip the outer tuple.

	run(args)</t>
<t tx="T2080">def init_sherlock (args):
	
	init_trace(args)
	# trace("argv", "sys.argv: " + `sys.argv`)</t>
<t tx="T2081">def profile ():

	import profile, pstats
	
	name = "c:/prog/test/leoProfile.txt"
	profile.run('leo.run()',name)

	p = pstats.Stats(name)
	p.strip_dirs()
	p.sort_stats('cum','file','name')
	p.print_stats()</t>
<t tx="T2082">@language python

from leoGlobals import *
import leo,leoConfig,leoDialog,leoFind
import os,sys,Tkinter

class LeoApp:
	@others</t>
<t tx="T2083">def destroyAllGlobalWindows (self):

	if self.findFrame:
		self.findFrame.top.destroy()</t>
<t tx="T2084"># Called when the gApp global has been defined.

def finishCreate(self):

	&lt;&lt; return false if not v2.1 or above &gt;&gt;
	&lt;&lt; set loadDir &gt;&gt;
	&lt;&lt; set the default Leo icon &gt;&gt;
	self.config = leoConfig.config()
	
	# Create the global windows
	self.findFrame = leoFind.LeoFind()
	self.findFrame.top.withdraw()
	attachLeoIcon(self.findFrame.top)
	return true # all went well.</t>
<t tx="T2085"># Python 2.1 support.

try:
	# 04-SEP-2002 DHEIN: simplify version check
	if not CheckVersion(sys.version, "2.1"):
		d = leoDialog.leoDialog()
		d.askOk("Python version error",
"""
leo.py requires Python 2.1 or higher.

You may download Python 2.1 and Python 2.2 from http://python.org/download/
""",
			text="Exit")
		return false
except:
	print "exception getting version"
	import traceback
	traceback.print_exc()
</t>
<t tx="T2086"># loadDir should be the directory that contains leo.py

try:
	self.loadDir = os.path.dirname(leo.__file__)
except:
	# Emergency defaults.  Hopefully we will never have to use them.
	if sys.platform=="win32": # Windows
		self.loadDir = "c:\\prog\\LeoPy\\"
	else: # Linux, or whatever.
		self.loadDir = "LeoPy"
	print "Setting load directory to:", self.loadDir

# Trace hasn't been enabled yet.
# print self.loadDir</t>
<t tx="T2087">try: # 6/2/02: Try to set the default bitmap.
	bitmap_name = os.path.join(self.loadDir,"Icons","LeoApp.ico")
	bitmap = Tkinter.BitmapImage(bitmap_name)
except:
	print "exception creating bitmap"
	import traceback
	traceback.print_exc()

try:
	version = self.root.getvar("tk_patchLevel")
	# print "tcl version:", version
	&lt;&lt; set v834 if version is 8.3.4 or greater &gt;&gt;
except:
	print "exception getting version"
	import traceback
	traceback.print_exc()
	v834 = None # 6/18/02
	
if v834:
	try:
		if sys.platform=="win32": # Windows
			top.wm_iconbitmap(bitmap,default=1)
		else:
			top.wm_iconbitmap(bitmap)
	except:
		if 0: # Let's ignore this for now until I understand the issues better.
			es("exception setting bitmap")
			es_exception()</t>
<t tx="T2088"># 04-SEP-2002 DHEIN: simplify version check
# 04-SEP-2002 Stephen P. Schaefer: make sure v834 is set
v834 = CheckVersion(version, "8.3.4")
</t>
<t tx="T2089"># Returns the translation of a menu name or an item name.

def getRealMenuName (self,menuName):
	
	cmn = canonicalizeMenuName(menuName)
	return self.realMenuNameDict.get(cmn,menuName)
	
def setRealMenuName (self,untrans,trans):
	
	cmn = canonicalizeMenuName(untrans)
	self.realMenuNameDict[cmn] = trans

def setRealMenuNamesFromTable (self,table):

	for untrans,trans in table:
		self.setRealMenuName(untrans,trans)
</t>
<t tx="T2090">def testDialogs (self):

	import leoDialog
	d = leoDialog.leoDialog()
	d.testDialogs()</t>
<t tx="T2091">@first #line1
@first #line2

@language python

@ Class to read and write @file nodes.

This code uses readline() to get each line rather than reading the entire file into a buffer.  This is more memory efficient and saves us from having to scan for the end of each line.  The result is cleaner and faster code.  This code also accumulates body text line-by-line rather than character-by-character, a much faster way.
@c

from leoGlobals import *
import leoColor,leoNodes
import filecmp,os,os.path,time

class atFile:
	&lt;&lt; atFile constants &gt;&gt;
	@others

@last #last1
@last #last2
</t>
<t tx="T2092"># The kind of at_directives.

noDirective		=  1 # not an at-directive.
delimsDirective =  2 # @delims (not used!)
docDirective	=  3 # @doc.
atDirective		=  4 # @&lt;space&gt; or @&lt;newline&gt;
codeDirective	=  5 # @code
cDirective		=  6 # @c&lt;space&gt; or @c&lt;newline&gt;
othersDirective	=  7 # at-others
miscDirective	=  8 # All other directives
rawDirective = 9 # @raw
endRawDirective = 10 # @end_raw

# The kind of sentinel line.
noSentinel		=  9 # Not a sentinel
endAt			= 10 # @-at
endBody			= 11 # @-body
endDoc			= 12 # @-doc
endLeo			= 13 # @-leo
endNode			= 14 # @-node
endOthers		= 15 # @-others
startAt			= 16 # @+at
startBody		= 17 # @+body
startComment = 18 # @comment 10/16/02
startDelims		= 19 # @delims
startDirective	= 20 # @@
startDoc		= 21 # @+doc
startLeo		= 22 # @+leo
startNode		= 23 # @+node
startOthers		= 24 # @+others
startNewline = 25 # @newline 9/27/02
startNoNewline = 26 # @nonewline 9/27/02
startRef		= 27 # @&lt; &lt; ... &gt; &gt;
startVerbatim	= 28 # @verbatim
startVerbatimAfterRef = 29 # @verbatimAfterRef
</t>
<t tx="T2093">def putCloseNodeSentinel(self,v):

	s = self.nodeSentinelText(v)
	self.putSentinel("@-node:" + s)</t>
<t tx="T2094">@ root is an ancestor of v, or root == v.  We call putCloseSentinel for v up to, but not including, root.
@c
def putCloseSentinels(self,root,v):

	self.putCloseNodeSentinel(v)
	while 1:
		v = v.parent()
		assert(v) # root must be an ancestor of v.
		if  v == root: break
		self.putCloseNodeSentinel(v)</t>
<t tx="T2095">@ This method puts an open node sentinel for node v.
@c
def putOpenNodeSentinel(self,v):

	if v.isAtFileNode() and v != self.root:
		self.writeError("@file not valid in: " + v.headString())
	else:
		s = self.nodeSentinelText(v)
		self.putSentinel("@+node:" + s)</t>
<t tx="T2096">@ root is an ancestor of v, or root == v.  We call putOpenNodeSentinel on all the descendents of root which are the ancestors of v.
@c
def putOpenSentinels(self,root,v):

	last = root
	while last != v:
		# Set node to v or the ancestor of v that is a child of last.
		node = v
		while node and node.parent() != last:
			node = node.parent()
		assert(node)
		self.putOpenNodeSentinel(node)
		last = node</t>
<t tx="T2097">def error(self,message):

	es(message)
	self.errors += 1</t>
<t tx="T2098"># Skip past whitespace equivalent to width spaces.

def skipIndent(self,s,i,width):

	ws = 0 ; n = len(s)
	while i &lt; n and ws &lt; width:
		if   s[i] == '\t': ws += (abs(self.tab_width) - (ws % abs(self.tab_width)))
		elif s[i] == ' ':  ws += 1
		else: break
		i += 1
	return i</t>
<t tx="T2099">def readError(self,message):

	# This is useful now that we don't print the actual messages.
	if self.errors == 0:
		es("----- error reading @file " + self.targetFileName)
		self.error(message) # 9/10/02: we must increment self.errors!

	if 0: # CVS conflicts create too many messages.
		self.error(message)
	
	self.root.setOrphan()
	self.root.setDirty()</t>
<t tx="T2100">@ The new Leo2 computes clone indices differently from the old Leo2:

1. The new Leo2 recomputes clone indices for every write.
2. The new Leo2 forces the clone index of the @file node to be zero.

Also, the read logic ignores the clone index of @file nodes, thereby ensuring that we don't mistakenly join an @file node to another node.
@c
def updateCloneIndices(self,root,next):

	if root.isCloned():
		if 0: # 9/26/02: Silently allow this.  Everything appears to work.
			self.error("ignoring clone mark for " + root.headString())
		root.t.setCloneIndex(0)
	index = 0
	# 12/17/01: increment each cloneIndex at most once.
	v = root
	while v and v != next:
		v.t.cloneIndex = 0
		v = v.threadNext()
	v = root
	while v and v != next:
		vIs = v.isCloned()
		vShould = v.shouldBeClone() #verbose
		if 0: # vIs or vShould:
			es("update:"+`index`+" is:"+`vIs`+" should:"+`vShould`+`v`) ; enl()
		if v.t.cloneIndex == 0 and vIs and vShould:
			index += 1
			v.t.cloneIndex = index
		v = v.threadNext()
	# Make sure the root's clone index is zero.
	root.t.setCloneIndex(0)</t>
<t tx="T2101">def writeError(self,message):

	if self.errors == 0:
		es("errors writing: " + self.targetFileName)
	self.error(message)
	self.root.setOrphan()
	self.root.setDirty()</t>
<t tx="T2102">@ Sections appear in the derived file in reference order, not tree order.  Therefore, when we insert the nth child of the parent there is no guarantee that the previous n-1 children have already been inserted. And it won't work just to insert the nth child as the last child if there aren't n-1 previous siblings.  For example, if we insert the third child followed by the second child followed by the first child the second and third children will be out of order.

To ensure that nodes are placed in the correct location we create "dummy" children as needed as placeholders.  In the example above, we would insert two dummy children when inserting the third child.  When inserting the other two children we replace the previously inserted dummy child with the actual children.

vnode child indices are zero-based.  Here we use 1-based indices.

With the "mirroring" scheme it is a structure error if we ever have to create dummy vnodes.  Such structure errors cause a second pass to be made, with an empty root.  This second pass will generate other structure errors, which are ignored.
@c
def createNthChild(self,n,parent,headline):

	assert(n &gt; 0)

	# Create any needed dummy children.
	dummies = n - parent.numberOfChildren() - 1
	if dummies &gt; 0:
		if 0: # CVS produces to many errors for this to be useful.
			es("dummy created")
		self.structureErrors += 1
	while dummies &gt; 0:
		dummies -= 1
		dummy = parent.insertAsLastChild(leoNodes.tnode())
		# The user should never see this headline.
		dummy.initHeadString("Dummy")

	if n &lt;= parent.numberOfChildren():
		result = parent.nthChild(n-1)
		resulthead = result.headString()
		if string.strip(headline) != string.strip(resulthead):
			if 0: # CVS produces to many errors for this to be useful.
				es("headline mismatch:")
				es("head1:" + `string.strip(headline)`)
				es("head2:" + `string.strip(resulthead)`)
			self.structureErrors += 1
	else:
		# This is using a dummy; we should already have bumped structureErrors.
		result = parent.insertAsLastChild(leoNodes.tnode())
	result.initHeadString(headline)
	
	result.setVisited() # Suppress all other errors for this node.
	return result</t>
<t tx="T2103">@ This function joins all nodes in the two trees which should have the same topology. This code makes no other assumptions about the two trees; some or all of the nodes may already have been joined.

There are several differences between this method and the similar vnode:joinTreeTo method.  First, we can not assert that the two trees have the same topology because the derived file could have been edited outside of Leo.  Second, this method also merges the tnodes of all joined nodes.
@c
def joinTrees(self,tree1,tree2):

	assert(tree1 and tree2)
	# Use a common tnode for both nodes.
	if tree1.t != tree2.t:
		tree1.setT(tree2.t)
	# Join the roots using the vnode class.
	tree1.joinNodeTo(tree2)
	# Recursively join all subtrees.
	child1 = tree1.firstChild()
	child2 = tree2.firstChild()
	while child1 and child2:
		self.joinTrees(child1, child2)
		child1 = child1.next()
		child2 = child2.next()
	if child1 or child2:
		self.readError("cloned nodes have different topologies")</t>
<t tx="T2104">@ This is the entry point to the read code.  The root vnode should be an @file node.  If doErrorRecoveryFlag is false we are doing an update.  In that case it would be very unwise to do any error recovery which might clear clone links.  If doErrorRecoveryFlag is true and there are structure errors during the first pass we delete root's children and its body text, then rescan.  All other errors indicate potentially serious problems with sentinels.

The caller has enclosed this code in beginUpdate/endUpdate.
@c
def read(self,root):

	t1 = getTime()
	c = self.commands
	root.clearVisitedInTree() # Clear the list of nodes for orphans logic.
	if root.isAtFileNode():
		self.targetFileName = root.atFileNodeName()
	else:
		self.targetFileName = root.atRawFileNodeName()
	self.root = root
	self.raw = false
	self.errors = self.structureErrors = 0
	&lt;&lt; open file &gt;&gt;
	if self.errors &gt; 0: return 0
	es("reading: " + root.headString())
	&lt;&lt; Scan the file buffer &gt;&gt;
	&lt;&lt; Bump mStructureErrors if any vnodes are unvisited &gt;&gt;
	next = root.nodeAfterTree()
	if self.structureErrors &gt; 0:
		self.readError("-- Rereading file.  Clone links into this file will be lost.") ;
		self.errors = 0
		root.clearVisitedInTree() # Clear the list of nodes for orphans logic.
		&lt;&lt; Delete root's tree and body text &gt;&gt;
		file.seek(0)
		&lt;&lt; Scan the file buffer &gt;&gt;
	file.close()
	if self.errors == 0:
		next = root.nodeAfterTree()
		if 0: # 9/26/02: No longer used: derived files contain no clone indices.
			root.clearAllVisitedInTree()
			&lt;&lt; Handle clone bits &gt;&gt;
			&lt;&lt; Join cloned trees &gt;&gt;
		&lt;&lt; Handle all status bits &gt;&gt;
	if self.errors &gt; 0:
		# A serious error has occured that has not been corrected.
		self.readError("----- File may have damaged sentinels!")
		root.unjoinTree();
	else: root.clearDirty()
	# esDiffTime("read: exit", t1)
	return self.errors == 0</t>
<t tx="T2105">self.scanAllDirectives(root) # 1/30/02

if not self.targetFileName or len(self.targetFileName) == 0:
	self.readError("Missing file name.  Restoring @file tree from .leo file.")
else:
	# print self.default_directory, self.targetFileName
	fn = os.path.join(self.default_directory, self.targetFileName)
	fn = os.path.normpath(fn)
	try:
		file = open(fn,'r')
		if file:
			&lt;&lt; warn on read-only file &gt;&gt;
	except:
		self.readError("Can not open: " + '"@file ' + fn + '"')</t>
<t tx="T2106"># 8/13/02
try:
	read_only = not os.access(fn,os.W_OK)
	if read_only:
		es("read only: " + fn)
except: pass # os.access() may not exist on all platforms.</t>
<t tx="T2107"># 14-SEP-2002 DTHEIN: firstLines &amp; lastLines logic.
# 18-SEP-2002 EKREAM: all body text set in scanText.

firstLines = self.scanHeader(file)

self.indent = 0 ; out = [] ; implicitChildIndex = 0
lastLines = self.scanText(file,root,out,atFile.endLeo,implicitChildIndex)
# 18-SEP-2002 DTHEIN: update the bodyString directly, because
# out no longer holds body text of node.
if root.t.hasBody:
	bodyLines = root.t.bodyString.split('\n')
	self.completeFirstDirectives(bodyLines,firstLines)
	self.completeLastDirectives(bodyLines,lastLines)
	bodyText = '\n'.join(bodyLines)
	bodyText = bodyText.replace('\r', '')
	root.t.setTnodeText(bodyText)
</t>
<t tx="T2108">@ createNthNode marks all nodes in the derived file as visited.  Any unvisited nodes are either dummies or nodes that don't exist in the derived file.
@c

next = root.nodeAfterTree()
v = root.threadNext()
while v and v != next:
	if not v.isVisited():
		if 0: # CVS produces to many errors for this to be useful.
			es("unvisited node: " + v.headString())
		self.structureErrors += 1
	v = v.threadNext()
</t>
<t tx="T2109">while root.firstChild():
	root.firstChild().doDelete(root)

root.setBodyStringOrPane("")</t>
<t tx="T2110">h = {}
v = root
while v and v != next:
	cloneIndex = v.t.cloneIndex
	# new Leo2: we skip the root node: @file nodes can not be cloned.
	if cloneIndex &gt; 0 and v != root:
		if h.has_key(cloneIndex):
			t = h[cloneIndex]
			# v is a clone: share the previous tnode.
			v.setT(t)
			t.setVisited() # We will mark these clones later.
		else: h[cloneIndex] = v.t
	v = v.threadNext()

# Set clone marks for all visited tnodes.
v = root
while v and v != next:
	if v.t.isVisited():
		if v == root:
			pass
		elif v.shouldBeClone():
			v.initClonedBit(true)
		else:
			# Not a serious error.
			es("clone links cleared for: " + v.headString())
			v.unjoinTree();
			t.setCloneIndex(0) # t is no longer cloned.
	v = v.threadNext()</t>
<t tx="T2111">@ In most cases, this code is not needed, because the outline already has been read and nodes joined.  However, there could be problems on read errors, so we also join nodes here.
@c

h = {}
v = root
while v and v != next:
	cloneIndex = v.t.cloneIndex
	# new Leo2: we skip the root node: @file nodes can not be cloned.
	if cloneIndex &gt; 0 and v != root:
		if h.has_key(cloneIndex):
			clone = h[cloneIndex]
			if v.headString() == clone.headString():
				self.joinTrees(clone,v)
			else:
				# An extremely serious error.  Data may be lost.
				self.readError(
					"Outline corrupted: " +
					"different nodes have same clone index!\n\t" +
					v.headString() + "\n\t" + clone.headString())
		# Enter v so we can join the next clone to it.
		# The next call to lookup will find this v, not the previous.
		h[cloneIndex] = v
	v = v.threadNext()</t>
<t tx="T2112">current = None
v = root
while v and v != next:
	if v.isSelected():
		self.commands.tree.currentVnode = current = v
	if v.isTopBitSet():
		# Just tell the open code we have seen the top vnode.
		self.commands.tree.topVnode = v ;
	v = v.threadNext()

if current:
	# Indicate what the current node will be.
	c.tree.currentVnode = current
</t>
<t tx="T2113">@ This method scans all vnodes, calling read for every @file node found.  v should point to the root of the entire tree on entry.

Bug fix: 9/19/01 This routine clears all orphan status bits, so we must set the dirty bit of orphan @file nodes to force the writing of those nodes on saves.  If we didn't do this, a _second_ save of the .leo file would effectively wipe out bad @file nodes!

10/19/01: With the "new" Leo2 there are no such problems, and setting the dirty bit here is still correct.
@c

def readAll(self,root,partialFlag):

	c = self.commands
	c.endEditing() # Capture the current headline.
	anyRead = false
	self.initIvars()
	v = root
	if partialFlag: after = v.nodeAfterTree()
	else: after = None
	while v and v != after:
		if v.isAtIgnoreNode():
			v = v.nodeAfterTree()
		elif v.isAtFileNode() or v.isAtRawFileNode():
			anyRead = true
			if partialFlag:
				# We are forcing the read.
				self.read(v)
			else:
				# f v is an orphan, we don't expect to see a derived file,
				# and we shall read a derived file if it exists.
				wasOrphan = v.isOrphan()
				ok = self.read(v)
				if wasOrphan and not ok:
					# Remind the user to fix the problem.
					v.setDirty()
					c.setChanged(true)
			v = v.nodeAfterTree()
		else: v = v.threadNext()
	# Clear all orphan bits.
	v = root
	while v:
		v.clearOrphan()
		v = v.threadNext()
		
	if partialFlag and not anyRead:
		es("no @file nodes in the selected tree")</t>
<t tx="T2114"># 14-SEP-2002 DTHEIN: added for use by atFile.read()

# this function scans the lines in the list 'out' for @first directives
# and appends the corresponding line from 'firstLines' to each @first 
# directive found.  NOTE: the @first directives must be the very first
# lines in 'out'.
def completeFirstDirectives(self,out,firstLines):

	tag = "@first"
	foundAtFirstYet = 0
	outRange = range(len(out))
	j = 0
	for k in outRange:
		# skip leading whitespace lines
		if (not foundAtFirstYet) and (len(out[k].strip()) == 0): continue
		# quit if something other than @first directive
		i = 0
		if not match(out[k],i,tag): break;
		foundAtFirstYet = 1
		# quit if no leading lines to apply
		if j &gt;= len(firstLines): break
		# make the new @first directive
		#18-SEP-2002 DTHEIN: remove trailing newlines because they are inserted later
		# 21-SEP-2002 DTHEIN: no trailing whitespace on empty @first directive
		leadingLine = " " + firstLines[j]
		out[k] = tag + leadingLine.rstrip() ; j += 1
</t>
<t tx="T2115"># 14-SEP-2002 DTHEIN: added for use by atFile.read()

# this function scans the lines in the list 'out' for @last directives
# and appends the corresponding line from 'lastLines' to each @last 
# directive found.  NOTE: the @first directives must be the very last
# lines in 'out'.
def completeLastDirectives(self,out,lastLines):

	tag = "@last"
	foundAtLastYet = 0
	outRange = range(-1,-len(out),-1)
	j = -1
	for k in outRange:
		# skip trailing whitespace lines
		if (not foundAtLastYet) and (len(out[k].strip()) == 0): continue
		# quit if something other than @last directive
		i = 0
		if not match(out[k],i,tag): break;
		foundAtLastYet = 1
		# quit if no trailing lines to apply
		if j &lt; -len(lastLines): break
		# make the new @last directive
		#18-SEP-2002 DTHEIN: remove trailing newlines because they are inserted later
		# 21-SEP-2002 DTHEIN: no trailing whitespace on empty @last directive
		trailingLine = " " + lastLines[j]
		out[k] = tag + trailingLine.rstrip() ; j -= 1
</t>
<t tx="T2116">@ This method is the heart of the new read code.  It reads lines from the file until the given ending sentinel is found, and warns if any other ending sentinel is found instead.  It calls itself recursively to handle most nested sentinels.

@c
def scanText (self,file,v,out,endSentinelKind,implicitChildIndex):

	c = self.commands ; config = app().config
	lastLines = [] # 14-SEP-2002 DTHEIN: the last lines, after @-leo
	lineIndent = 0 ; linep = 0 # Changed only for sentinels.
	nextLine = None

	while 1:
		if nextLine:
			s = nextLine ; nextLine = None
		else:
			s = readlineForceUnixNewline(file)
			if len(s) == 0: break
		# trace(`s`)
		&lt;&lt; set kind, nextKind &gt;&gt;
		if kind != atFile.noSentinel:
			&lt;&lt; set lineIndent, linep and leading_ws &gt;&gt;
			i = self.skipSentinelStart(s,0)
		# All cases must appear here so we can set the next line properly below.
		if kind == atFile.noSentinel:
			&lt;&lt; append non-sentinel line &gt;&gt;
		elif kind == atFile.startAt:
			&lt;&lt; scan @+at &gt;&gt;
		elif kind == atFile.startBody:
			&lt;&lt; scan @+body &gt;&gt;
		elif kind == atFile.startDelims:
			&lt;&lt; scan @delims &gt;&gt;
		elif kind == atFile.startDirective:
			&lt;&lt; scan @@ &gt;&gt;
		elif kind == atFile.startDoc:
			&lt;&lt; scan @+doc &gt;&gt;
		elif kind == atFile.startLeo:
			&lt;&lt; scan @+leo &gt;&gt;
		elif kind == atFile.startNode:
			&lt;&lt; scan @+node &gt;&gt;
		elif kind == atFile.startOthers:
			&lt;&lt; scan @+others &gt;&gt;
		elif kind == atFile.startRef:
			&lt;&lt; scan @ref &gt;&gt;
		elif kind == atFile.startVerbatim:
			&lt;&lt; scan @verbatim &gt;&gt;
		elif kind == atFile.startComment:
			&lt;&lt; scan @comment &gt;&gt;
		elif ( kind == atFile.endAt or kind == atFile.endBody or
			kind == atFile.endDoc or kind == atFile.endLeo or
			kind == atFile.endNode or kind == atFile.endOthers ):
			&lt;&lt; handle an ending sentinel &gt;&gt;
		else:
			&lt;&lt; warn about unknown sentinel &gt;&gt;
	&lt;&lt; handle unexpected end of text &gt;&gt;
	assert(len(s)==0 and nextLine==None) # We get here only if readline fails.
	return lastLines # 14-SEP-2002 DTHEIN: shouldn't get here unless problems</t>
<t tx="T2117">@ For non-sentinel lines we look ahead to see whether the next line is a sentinel.  If so, the newline that ends a non-sentinel line belongs to the next sentinel.
@c

assert(nextLine==None)

kind = self.sentinelKind(s)

if kind == atFile.noSentinel:
	nextLine = readlineForceUnixNewline(file)
	nextKind = self.sentinelKind(nextLine)
else:
	nextLine = nextKind = None

# nextLine != None only if we have a non-sentinel line.
# Therefore, nextLine == None whenever scanText returns.</t>
<t tx="T2118">@ lineIndent is the total indentation on a sentinel line.  The first "self.indent" portion of that must be removed when recreating text.  leading_ws is the remainder of the leading whitespace.  linep points to the first "real" character of a line, the character following the "indent" whitespace.
@c

# Point linep past the first self.indent whitespace characters.
if self.raw: # 10/15/02
	linep =0
else:
	linep = self.skipIndent(s,0,self.indent)

# Set lineIndent to the total indentation on the line.
lineIndent = 0 ; i = 0
while i &lt; len(s):
	if s[i] == '\t': lineIndent += (abs(self.tab_width) - (lineIndent % abs(self.tab_width)))
	elif s[i] == ' ': lineIndent += 1
	else: break
	i += 1
# trace("lineIndent:" +`lineIndent` + ", " + `s`)

# Set leading_ws to the additional indentation on the line.
leading_ws = s[linep:i]</t>
<t tx="T2119"># We don't output the trailing newline if the next line is a sentinel.
if self.raw: # 10/15/02
	i = 0
else:
	i = self.skipIndent(s,0,self.indent)

assert(nextLine != None)

if nextKind == atFile.noSentinel:
	line = s[i:]
	out.append(line)
else:
	line = s[i:-1] # don't output the newline
	out.append(line)
</t>
<t tx="T2120">if kind == endSentinelKind:
	if kind == atFile.endLeo:
		# 9/11/02: ignore everything after @-leo.
		# Such lines were presumably written by @last
		while 1:
			s = readlineForceUnixNewline(file)
			if len(s) == 0: break
			# 21-SEP-2002 DTHEIN: capture _all_ the trailing lines, even if empty
			lastLines.append(s) # 14-SEP-2002 DTHEIN: capture the trailing lines
	elif kind == atFile.endBody:
		self.raw = false
	# nextLine != None only if we have a non-sentinel line.
	# Therefore, nextLine == None whenever scanText returns.
	assert(nextLine==None)
	return lastLines # 14-SEP-2002 DTHEIN: return the captured lines after @-leo
else:
	# Tell of the structure error.
	name = self.sentinelName(kind)
	expect = self.sentinelName(endSentinelKind)
	self.readError("Ignoring " + name + " sentinel.  Expecting " + expect)</t>
<t tx="T2121"># Issue the error.
name = self.sentinelName(endSentinelKind)
self.readError("Unexpected end of file. Expecting " + name + "sentinel" )
</t>
<t tx="T2122">assert(match(s,i,"+at"))
self.scanDoc(file,s,i,out,kind)</t>
<t tx="T2123">assert(match(s,i,"+doc"))
self.scanDoc(file,s,i,out,kind)</t>
<t tx="T2124">assert(match(s,i,"+leo"))
self.readError("Ignoring unexpected @+leo sentinel")</t>
<t tx="T2125">assert(match(s,i,"comment"))

# We need do nothing more to ignore the comment line!
</t>
<t tx="T2126">assert(match(s,i,"verbatim"))

# Skip the sentinel.
s = readlineForceUnixNewline(file) 

# Append the next line to the text.
i = self.skipIndent(s,0,self.indent)
out.append(s[i:])
</t>
<t tx="T2127">j = i
i = skip_line(s,i)
line = s[j:i]
self.readError("Unknown sentinel: " + line)</t>
<t tx="T2128"># 14-SEP-2002 DTHEIN
# added for use by putBodyPart()

# This method outputs the directive without the parameter text
def putEmptyDirective(self,s,i):

	assert(i &lt; len(s) and s[i] == '@')
	
	endOfLine = s.find('\n',i)
	# 21-SEP-2002 DTHEIN: if no '\n' then just use line length
	if endOfLine == -1:
		endOfLine = len(s)
	token = s[i:endOfLine].split()
	directive = token[0]
	self.putSentinel("@" + directive)

	i = skip_line(s,i)
	return i</t>
<t tx="T2129">@ This method outputs a doc section terminated by @code or end-of-text.  All other interior directives become part of the doc part.
@c
def putDoc(self,s,i,kind):

	if kind == atFile.atDirective:
		i += 1 ; tag = "at"
	elif kind == atFile.docDirective:
		i += 4 ; tag = "doc"
	else: assert(false)
	# Set j to the end of the doc part.
	n = len(s) ; j = i
	while j &lt; n:
		j = skip_line(s, j)
		kind = self.directiveKind(s, j)
		if kind == atFile.codeDirective or kind == atFile.cDirective:
			break
	self.putSentinel("@+" + tag)
	self.putDocPart(s[i:j])
	self.putSentinel("@-" + tag)
	return j</t>
<t tx="T2130">def checkForLeoCustomize (self,v=None):

	import leoDialog
	d = leoDialog.leoDialog()
	if v:
		if v.atFileNodeName() == "customizeLeo.py":
			d.askOk("Security Alert!",
				"@ignore not in effect for @node customizeLeo.py!")
		return None
	else:
		fn = os.path.basename(self.targetFileName)
		if fn == "customizeLeo.py":
			result = d.askYesNo("Security Alert!",
				"You are about to create or change customizeLeo.py.\n" +
				"Are you sure you trust the code in this file?")
			if result!="yes":
				es("not written: customizeLeo.py")
				return false
		return true</t>
<t tx="T2131">def closeWriteFile (self):
	
	if self.outputFile:
		if self.suppress_newlines and self.newline_pending:
			self.newline_pending = false
			self.onl() # Make sure file ends with a newline.
		self.outputFile.flush()
		self.outputFile.close()
		self.outputFile = None
</t>
<t tx="T2132">def handleWriteException (self,root=None):
	
	es("exception writing:" + self.targetFileName)
	es_exception()
	
	if self.outputFile:
		self.outputFile.flush()
		self.outputFile.close()
		self.outputFile = None
	
	if self.outputFileName != None:
		try: # Just delete the temp file.
			os.remove(self.outputFileName)
		except:
			es("exception deleting:" + self.outputFileName)
			es_exception()

	if root:
		# Make sure we try to rewrite this file.
		root.setOrphan()
		root.setDirty()</t>
<t tx="T2133"># Open files.  Set root.orphan and root.dirty flags and return on errors.

def openWriteFile (self,root):

	try:
		self.scanAllDirectives(root)
		#print `self.startSentinelComment`
		#print `self.endSentinelComment`
		valid = self.errors == 0
	except:
		es("exception in atFile.scanAllDirectives")
		es_exception()
		valid = false
	
	if valid:
		try:
			fn = self.targetFileName
			self.shortFileName = fn # name to use in status messages.
			self.targetFileName = os.path.join(self.default_directory,fn)
			self.targetFileName = os.path.normpath(self.targetFileName)
			path = os.path.dirname(self.targetFileName)
			if path and len(path) &gt; 0:
				valid = os.path.exists(path)
				if not valid:
					self.writeError("path does not exist: " + path)
			else:
				valid = false
		except:
			es("exception creating path:" + fn)
			es_exception()
			valid = false
	
	if valid:
		if os.path.exists(self.targetFileName):
			try:
				read_only = not os.access(self.targetFileName,os.W_OK)
				if read_only:
					es("read only: " + self.targetFileName)
					valid = false
			except: pass # os.access() may not exist on all platforms.
		
	if valid:
		try:
			self.outputFileName = self.targetFileName + ".tmp"
			self.outputFile = open(self.outputFileName, 'wb')
			valid = self.outputFile != None
			if not valid:
				self.writeError("can not open " + self.outputFileName)
		except:
			es("exception opening:" + self.outputFileName)
			es_exception()
			valid = false
	
	if not valid:
		root.setOrphan()
		root.setDirty()
	
	return valid</t>
<t tx="T2134">def replaceTargetFileIfDifferent (self):
	
	assert(self.outputFile == None)
	
	if os.path.exists(self.targetFileName):
		if filecmp.cmp(self.outputFileName, self.targetFileName):
			&lt;&lt; delete the output file &gt;&gt;
		else:
			if self.checkForLeoCustomize() == false:
				return
			&lt;&lt; replace the target file with the output file &gt;&gt;
			
	elif self.checkForLeoCustomize() == false:
		return
	else:
		&lt;&lt; rename the output file to be the target file &gt;&gt;
</t>
<t tx="T2135">try: # Just delete the temp file.
	os.remove(self.outputFileName)
except:
	es("exception deleting:" + self.outputFileName)
	es_exception()

es("unchanged: " + self.shortFileName)</t>
<t tx="T2136">try:
	# 10/6/02: retain the access mode of the previous file,
	# removing any setuid, setgid, and sticky bits.
	mode = (os.stat(self.targetFileName))[0] &amp; 0777
except:
	mode = None

try: # Replace target file with temp file.
	os.remove(self.targetFileName)
	utils_rename(self.outputFileName, self.targetFileName)
	if mode: # 10/3/02: retain the access mode of the previous file.
		os.chmod(self.targetFileName,mode)
	es("writing: " + self.shortFileName)
except:
	self.writeError("exception removing and renaming:" + self.outputFileName +
		" to " + self.targetFileName)
	es_exception()</t>
<t tx="T2137">try:
	# os.rename(self.outputFileName, self.targetFileName)
	utils_rename(self.outputFileName, self.targetFileName)
	es("creating: " + self.targetFileName)

except:
	self.writeError("exception renaming:" + self.outputFileName +
		" to " + self.targetFileName)
	es_exception()</t>
<t tx="T2138">def rawWrite(self,root):

	# trace(`root`)
	c = self.commands ; self.root = root
	self.errors = 0
	c.endEditing() # Capture the current headline.
	try:
		self.targetFileName = root.atRawFileNodeName()
		ok = self.openWriteFile(root)
		if not ok: return
		next = root.nodeAfterTree()
		&lt;&lt; write root's tree &gt;&gt;
		self.closeWriteFile()
		self.replaceTargetFileIfDifferent()
		root.clearOrphan() ; root.clearDirty()
	except:
		self.handleWriteException(root)</t>
<t tx="T2139">next = root.nodeAfterTree()
self.updateCloneIndices(root, next)

&lt;&lt; put all @first lines in root &gt;&gt;
self.putOpenLeoSentinel("@+leo")
&lt;&lt; put optional @comment sentinel lines &gt;&gt;

v = root
while v and v != next:
	&lt;&lt; Write v's node &gt;&gt;
	v = v.threadNext()

self.putSentinel("@-leo")
&lt;&lt; put all @last lines in root &gt;&gt;</t>
<t tx="T2140">@ Write any @first lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines preceding the @+leo sentinel.
@c

s = root.t.bodyString
tag = "@first"
i = 0
while match(s,i,tag):
	i += len(tag)
	i = skip_ws(s,i)
	j = i
	i = skip_to_end_of_line(s,i)
	# 21-SEP-2002 DTHEIN: write @first line, whether empty or not
	line = s[j:i]
	self.os(line) ; self.onl()
	i = skip_nl(s,i)</t>
<t tx="T2141">s2 = app().config.output_initial_comment
if s2:
	lines = string.split(s2,"\\n")
	for line in lines:
		line = string.replace(line,"@date",time.asctime())
		if len(line)&gt; 0:
			self.putSentinel("@comment " + line)
</t>
<t tx="T2142">self.putOpenNodeSentinel(v)
	
s = v.bodyString()
if s and len(s) &gt; 0:
	self.putSentinel("@+body")
	if self.newline_pending:
		self.newline_pending = false
		self.onl()
	self.outputFile.write(s)
	self.putSentinel("@-body")
	
self.putCloseNodeSentinel(v)
</t>
<t tx="T2143">@ Write any @last lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines following the @-leo sentinel.
@c

tag = "@last"
lines = string.split(root.t.bodyString,'\n')
n = len(lines) ; j = k = n - 1
# Don't write an empty last line.
if j &gt;= 0 and len(lines[j])==0:
	j = k = n - 2
# Scan backwards for @last directives.
while j &gt;= 0:
	line = lines[j]
	if match(line,0,tag): j -= 1
	else: break
# Write the @last lines.
for line in lines[j+1:k+1]:
	i = len(tag) ; i = skip_ws(line,i)
	self.os(line[i:]) ; self.onl()</t>
<t tx="T2144">def silentWrite(self,root):

	# trace(`root`)
	c = self.commands ; self.root = root
	self.errors = 0
	c.endEditing() # Capture the current headline.
	try:
		self.targetFileName = root.atSilentFileNodeName()
		ok = self.openWriteFile(root)
		if not ok: return
		next = root.nodeAfterTree()
		v = root
		while v and v != next:
			&lt;&lt; Write v's headline if it starts with @@ &gt;&gt;
			&lt;&lt; Write v's body &gt;&gt;
			v = v.threadNext()
		self.closeWriteFile()
		self.replaceTargetFileIfDifferent()
		root.clearOrphan() ; root.clearDirty()
	except:
		self.handleWriteException(root)</t>
<t tx="T2145">s = v.headString()
if match(s,0,"@@"):
	s = s[2:]
	if s and len(s) &gt; 0:
		self.outputFile.write(s)
</t>
<t tx="T2146">s = v.bodyString()
if s and len(s) &gt; 0:
	self.outputFile.write(s)</t>
<t tx="T2147">def scanAll (self):

	c = self.commands ; v = c.rootVnode()
	while v:
		if v.isAtIgnoreNode():
			v = v.nodeAfterTree()
		elif v.isAtFileNode():
			self.scanFile(v)
			v = v.nodeAfterTree()
		else: v = v.threadNext()</t>
<t tx="T2148">def scanFile(self,root):

	es("scanning: " + root.headString())
	self.targetFileName = root.atFileNodeName()
	self.root = root
	self.errors = self.structureErrors = 0
	&lt;&lt; open file &gt;&gt;
	if self.errors &gt; 0: return 0
	&lt;&lt; Scan the file buffer &gt;&gt;
	if self.structureErrors &gt; 0:
		self.readError(`self.structureErrors` + " errors scanning file")
	return self.errors == 0
</t>
<t tx="T2149">if len(self.targetFileName) == 0:
	self.readError("Missing file name")
else:
	try:
		file = open(self.targetFileName,'r')
	except:
		self.readError("Error reading file")
</t>
<t tx="T2150">self.indent = 0
out = []
self.scanHeader(file)
self.scanText(file,root,out,atFile.endLeo,implicitChildIndex)
s = string.join(out, "")
root.setBodyStringOrPane(s)</t>
<t tx="T2151">@language python

# Syntax coloring routines for Leo.py

from leoGlobals import *
import string,Tkinter,tkColorChooser

&lt;&lt; define colorizer constants &gt;&gt;
&lt;&lt; define colorizer keywords &gt;&gt;
&lt;&lt; define colorizer functions &gt;&gt;
&lt;&lt; define color panel data &gt;&gt;

@others</t>
<t tx="T2152"># These defaults are sure to exist.
default_colors_dict = {
	# tag name      :(     option name,           default color),
	"comment"       :("comment_color",               "red"),
	"cwebName"      :("cweb_section_name_color",     "red"),
	"pp"             :("directive_color",             "blue"),
	"docPart"        :("doc_part_color",              "red"),
	"keyword"        :("keyword_color",               "blue"),
	"leoKeyword"     :("leo_keyword_color",           "blue"),
	"link"           :("section_name_color",          "red"),
	"nameBrackets"   :("section_name_brackets_color", "blue"),
	"string"         :("string_color",                "#00aa00"), # Used by IDLE.
	"name"           :("undefined_section_name_color","red"),
	"latexBackground":("latex_background_color","white") }</t>
<t tx="T2153">def index(i,j):

	if type(i) != type("end"):
		i = `i`
	if type(j) != type("end"):
		j = `j`
	return i + '.' + j
</t>
<t tx="T2154">colorPanelData = (
	#Dialog name,                option name,         default color),
	("Brackets",          "section_name_brackets_color", "blue"),
	("Comments",          "comment_color",               "red"),
	("CWEB section names","cweb_section_name_color",     "red"),
	("Directives",        "directive_color",             "blue"),
	("Doc parts",         "doc_part_color",              "red"),
	("Keywords" ,         "keyword_color",               "blue"),
	("Leo Keywords",      "leo_keyword_color",           "blue"),
	("Section Names",     "section_name_color",          "red"),
	("Strings",           "string_color",   "#00aa00"), # Used by IDLE.
	("Undefined Names",   "undefined_section_name_color","red") )

colorNamesList = (
	"gray60", "gray70", "gray80", "gray85", "gray90", "gray95",
	"snow1", "snow2", "snow3", "snow4", "seashell1", "seashell2",
	"seashell3", "seashell4", "AntiqueWhite1", "AntiqueWhite2", "AntiqueWhite3",
	"AntiqueWhite4", "bisque1", "bisque2", "bisque3", "bisque4", "PeachPuff1",
	"PeachPuff2", "PeachPuff3", "PeachPuff4", "NavajoWhite1", "NavajoWhite2",
	"NavajoWhite3", "NavajoWhite4", "LemonChiffon1", "LemonChiffon2",
	"LemonChiffon3", "LemonChiffon4", "cornsilk1", "cornsilk2", "cornsilk3",
	"cornsilk4", "ivory1", "ivory2", "ivory3", "ivory4", "honeydew1", "honeydew2",
	"honeydew3", "honeydew4", "LavenderBlush1", "LavenderBlush2",
	"LavenderBlush3", "LavenderBlush4", "MistyRose1", "MistyRose2",
	"MistyRose3", "MistyRose4", "azure1", "azure2", "azure3", "azure4",
	"SlateBlue1", "SlateBlue2", "SlateBlue3", "SlateBlue4", "RoyalBlue1",
	"RoyalBlue2", "RoyalBlue3", "RoyalBlue4", "blue1", "blue2", "blue3", "blue4",
	"DodgerBlue1", "DodgerBlue2", "DodgerBlue3", "DodgerBlue4", "SteelBlue1",
	"SteelBlue2", "SteelBlue3", "SteelBlue4", "DeepSkyBlue1", "DeepSkyBlue2",
	"DeepSkyBlue3", "DeepSkyBlue4", "SkyBlue1", "SkyBlue2", "SkyBlue3",
	"SkyBlue4", "LightSkyBlue1", "LightSkyBlue2", "LightSkyBlue3",
	"LightSkyBlue4", "SlateGray1", "SlateGray2", "SlateGray3", "SlateGray4",
	"LightSteelBlue1", "LightSteelBlue2", "LightSteelBlue3",
	"LightSteelBlue4", "LightBlue1", "LightBlue2", "LightBlue3",
	"LightBlue4", "LightCyan1", "LightCyan2", "LightCyan3", "LightCyan4",
	"PaleTurquoise1", "PaleTurquoise2", "PaleTurquoise3", "PaleTurquoise4",
	"CadetBlue1", "CadetBlue2", "CadetBlue3", "CadetBlue4", "turquoise1",
	"turquoise2", "turquoise3", "turquoise4", "cyan1", "cyan2", "cyan3", "cyan4",
	"DarkSlateGray1", "DarkSlateGray2", "DarkSlateGray3",
	"DarkSlateGray4", "aquamarine1", "aquamarine2", "aquamarine3",
	"aquamarine4", "DarkSeaGreen1", "DarkSeaGreen2", "DarkSeaGreen3",
	"DarkSeaGreen4", "SeaGreen1", "SeaGreen2", "SeaGreen3", "SeaGreen4",
	"PaleGreen1", "PaleGreen2", "PaleGreen3", "PaleGreen4", "SpringGreen1",
	"SpringGreen2", "SpringGreen3", "SpringGreen4", "green1", "green2",
	"green3", "green4", "chartreuse1", "chartreuse2", "chartreuse3",
	"chartreuse4", "OliveDrab1", "OliveDrab2", "OliveDrab3", "OliveDrab4",
	"DarkOliveGreen1", "DarkOliveGreen2", "DarkOliveGreen3",
	"DarkOliveGreen4", "khaki1", "khaki2", "khaki3", "khaki4",
	"LightGoldenrod1", "LightGoldenrod2", "LightGoldenrod3",
	"LightGoldenrod4", "LightYellow1", "LightYellow2", "LightYellow3",
	"LightYellow4", "yellow1", "yellow2", "yellow3", "yellow4", "gold1", "gold2",
	"gold3", "gold4", "goldenrod1", "goldenrod2", "goldenrod3", "goldenrod4",
	"DarkGoldenrod1", "DarkGoldenrod2", "DarkGoldenrod3", "DarkGoldenrod4",
	"RosyBrown1", "RosyBrown2", "RosyBrown3", "RosyBrown4", "IndianRed1",
	"IndianRed2", "IndianRed3", "IndianRed4", "sienna1", "sienna2", "sienna3",
	"sienna4", "burlywood1", "burlywood2", "burlywood3", "burlywood4", "wheat1",
	"wheat2", "wheat3", "wheat4", "tan1", "tan2", "tan3", "tan4", "chocolate1",
	"chocolate2", "chocolate3", "chocolate4", "firebrick1", "firebrick2",
	"firebrick3", "firebrick4", "brown1", "brown2", "brown3", "brown4", "salmon1",
	"salmon2", "salmon3", "salmon4", "LightSalmon1", "LightSalmon2",
	"LightSalmon3", "LightSalmon4", "orange1", "orange2", "orange3", "orange4",
	"DarkOrange1", "DarkOrange2", "DarkOrange3", "DarkOrange4", "coral1",
	"coral2", "coral3", "coral4", "tomato1", "tomato2", "tomato3", "tomato4",
	"OrangeRed1", "OrangeRed2", "OrangeRed3", "OrangeRed4", "red1", "red2", "red3",
	"red4", "DeepPink1", "DeepPink2", "DeepPink3", "DeepPink4", "HotPink1",
	"HotPink2", "HotPink3", "HotPink4", "pink1", "pink2", "pink3", "pink4",
	"LightPink1", "LightPink2", "LightPink3", "LightPink4", "PaleVioletRed1",
	"PaleVioletRed2", "PaleVioletRed3", "PaleVioletRed4", "maroon1",
	"maroon2", "maroon3", "maroon4", "VioletRed1", "VioletRed2", "VioletRed3",
	"VioletRed4", "magenta1", "magenta2", "magenta3", "magenta4", "orchid1",
	"orchid2", "orchid3", "orchid4", "plum1", "plum2", "plum3", "plum4",
	"MediumOrchid1", "MediumOrchid2", "MediumOrchid3", "MediumOrchid4",
	"DarkOrchid1", "DarkOrchid2", "DarkOrchid3", "DarkOrchid4", "purple1",
	"purple2", "purple3", "purple4", "MediumPurple1", "MediumPurple2",
	"MediumPurple3", "MediumPurple4", "thistle1", "thistle2", "thistle3",
	"thistle4" )
</t>
<t tx="T2155">class colorizer:
	@others</t>
<t tx="T2156">def disable (self):

	print "disabling all syntax coloring"
	self.enabled=false

def __init__(self, commands):

	self.commands = commands
	self.count = 0 # how many times this has been called.
	self.use_hyperlinks = false # true: use hyperlinks and underline "live" links.
	self.enabled = true # true: syntax coloring enabled
	self.showInvisibles = false # true: show "invisible" characters.
	self.comment_string = None # Set by scanColorDirectives on @comment
	# For incremental coloring.
	self.tags = (
		"blank","comment","cwebName","docPart","keyword","leoKeyword",
		"latexModeBackground","latexModeKeyword",
		"latexBackground","latexKeyword",
		"link","name","nameBrackets","pp","string","tab")
	self.incremental = false
	self.lines = []
	self.states = []
	self.last_language = "unknown"
	&lt;&lt; ivars for communication between colorAllDirectives and its allies &gt;&gt;
	&lt;&lt; define dispatch dicts &gt;&gt;</t>
<t tx="T2157"># Copies of arguments.
self.v = None
self.body = None
self.language = None
self.flag = None
# Others.
self.single_comment_start = None
self.block_comment_start = None
self.block_comment_end = None
self.has_string = None
self.has_pp_directives = None
self.keywords = None
self.lb = None
self.rb = None
self.rootMode = None # None, "code" or "doc"

config = app().config
self.latex_cweb_docs     = config.getBoolColorsPref("color_cweb_doc_parts_with_latex")
self.latex_cweb_comments = config.getBoolColorsPref("color_cweb_comments_with_latex")
# print "docs,comments",`self.latex_cweb_docs`,`self.latex_cweb_comments`</t>
<t tx="T2158">self.state_dict = {
	"blockComment" : self.continueBlockComment,
	"doubleString" : self.continueSingleString,
	"nocolor"      : self.continueNocolor,
	"normal"       : self.doNormalState,
	"singleString" : self.continueDoubleString,
	"string3s"     : self.continueSinglePythonString,
	"string3d"     : self.continueDoublePythonString,
	"doc"          : self.continueDocPart }
	
# Eventually all entries in these dicts will be entered dynamically
# under the control of the XML description of the present language.

if 0: # not ready yet.

	self.dict1 = { # 1-character patterns.
		'"' : self.doString,
		"'" : self.doString,
		'@' : self.doPossibleLeoKeyword,
		' ' : self.doBlank,
		'\t': self.doTab }

	self.dict2 = {} # 2-character patterns
	
	# Searching this list might be very slow!
	mutli_list = [] # Multiple character patterns.
	
	# Enter single-character patterns...
	if self.has_pp_directives:
		dict1 ["#"] = self.doPPDirective
				
	for ch in string.letters:
		dict1 [ch] = self.doPossibleKeyword
	dict1 ['_'] = self.doPossibleKeyword
	
	if self.language == "latex":
		dict1 ['\\'] = self.doPossibleKeyword
		
	if self.language == "php":
		dict1 ['&lt;'] = self.doSpecialPHPKeyword
		dict1 ['?'] = self.doSpecialPHPKeyword
	
	# Enter potentially multi-character patterns.  (or should this be just 2-character patterns)
	if self.language == "cweb":
		dict2 ["@("] = self.doPossibleSectionRefOrDef
	else:
		dict2 ["&lt;&lt;"] = self.doPossibleSectionRefOrDef
		
	if self.single_comment_start:
		n = len(self.single_comment_start)
		if n == 1:
			dict1 [self.single_comment_start] = self.doSingleCommentLine
		elif n == 2:
			dict2 [self.single_comment_start] = self.doSingleCommentLine
		else:
			mutli_list.append((self.single_comment_start,self.doSingleCommentLine),)
	
	if self.block_comment_start:
		n = len(self.block_comment_start)
		if n == 1:
			dict1 [self.block_comment_start] = self.doBlockComment
		elif n == 2:
			ddict2 [self.block_comment_start] = self.doBlockComment
		else:
			mutli_list.append((self.block_comment_start,self.doBlockComment),)</t>
<t tx="T2159">def OnHyperLinkControlClick (self,v):

	pass</t>
<t tx="T2160">def OnHyperLinkEnter (self,v):

	pass # trace(`v` + ", " + `v.tagName`)</t>
<t tx="T2161">def OnHyperLinkLeave (self,v):

	pass # trace(`v`)</t>
<t tx="T2162"># The main colorizer entry point.

def colorize(self,v,body,incremental=false):

	if self.enabled:
		# print "colorize:incremental",incremental
		self.incremental=incremental
		flag,language = self.updateSyntaxColorer(v)
		self.colorizeAnyLanguage(v,body,language,flag)
		
# Called from incremental undo code.
# Colorizes the lines between the leading and trailing lines.
		
def recolor_range(self,v,body,leading,trailing):
	
	if self.enabled:
		# print "recolor_range:leading,trailing",leading,trailing
		self.incremental=true
		flag,language = self.updateSyntaxColorer(v)
		self.colorizeAnyLanguage(
			v,body,language,flag,
			leading=leading,trailing=trailing)
</t>
<t tx="T2163">def schedule(self,v,body,incremental=0):

	if self.enabled:
		self.incremental=incremental
		body.after_idle(self.idle_colorize,v,body)
		
def idle_colorize(self,v,body):

	# trace(`v` + ", " + `body`)
	if v and body and self.enabled:
		self.colorize(v,body,self.incremental)</t>
<t tx="T2164">def getCwebWord (self,s,i):
	
	# trace(get_line(s,i))
	if not match(s,i,"@"):
		return None
	
	ch1 = ch2 = word = None
	if i + 1 &lt; len(s): ch1 = s[i+1]
	if i + 2 &lt; len(s): ch2 = s[i+2]

	if match(s,i,"@**"):
		word = "@**"
	elif not ch1:
		word = "@"
	elif not ch2:
		word = s[i:i+2]
	elif (
		(ch1 in string.letters and not ch2 in string.letters) or # single-letter control code
		ch1 not in string.letters # non-letter control code
	):
		word = s[i:i+2]
		
	# if word: trace(`word`)
		
	return word</t>
<t tx="T2165"># Returns (flag,language)
# flag is true unless an unambiguous @nocolor is seen.

def updateSyntaxColorer (self,v):
	
	# 7/8/02: return a tuple.
	flag = self.useSyntaxColoring(v)
	language = self.scanColorDirectives(v)
	return flag,language
</t>
<t tx="T2166"># Return true if v unless v is unambiguously under the control of @nocolor.

def useSyntaxColoring (self,v):

	first = v ; val = true
	while v:
		s = v.t.bodyString
		dict = get_directives_dict(s)
		no_color = dict.has_key("nocolor")
		color = dict.has_key("color")
		# trace(`dict` + ", " + `v`)
		# A color anywhere in the target enables coloring.
		if color and v == first:
			val = true ; break
		# Otherwise, the @nocolor specification must be unambiguous.
		elif no_color and not color:
			val = false ; break
		elif color and not no_color:
			val = true ; break
		else:
			v = v.parent()
	# trace("useSyntaxColoring",`val`)
	return val</t>
<t tx="T2167">@ These methods are like the corresponding functions in leoGlobals.py except they issue no error messages.
</t>
<t tx="T2168">def setFirstLineState (self):
	
	if self.flag:
		if self.rootMode:
			state = choose(self.rootMode=="code","normal","doc")
		else:
			state = "normal"
	else:
		state = "nocolor"

	return state</t>
<t tx="T2169">def skip_id(self,s,i,chars=None):

	n = len(s)
	while i &lt; n:
		ch = s[i]
		if ch in string.letters or ch in string.digits or ch == '_':
			i += 1
		elif chars and ch in chars:
			i += 1
		else: break
	return i
</t>
<t tx="T2170">def skip_python_string(self,s,i):

	delim = s[i:i+3]
	if delim == "'''" or delim == '"""':
		k = string.find(s,delim,i+3)
		if k == -1:
			return len(s),choose(delim=="'''","string3s","string3d")
		else:
			return k+3, "normal"
	else:
		return self.skip_string(s,i)</t>
<t tx="T2171">def skip_string(self,s,i):

	delim = s[i] ; i += 1
	assert(delim == '"' or delim == "'")
	n = len(s)
	while i &lt; n and s[i] != delim:
		if s[i:] == "\\":
			return n,choose(delim=="'","singleString","doubleString")
		elif s[i] == '\\' :
			i += 2
		else: i += 1

	if i &gt;= n:
		return n, "normal"
	elif s[i] == delim:
		i += 1
	return i,"normal"
</t>
<t tx="T2172">class leoColorNamePanel:
	@others</t>
<t tx="T2173">def __init__ (self, colorPanel, name, color):
	
	self.colorPanel = colorPanel
	self.name = name
	self.color = color
	self.revertColor = color</t>
<t tx="T2174">def getSelection (self):

	box = self.box ; color = None
	
	# Get the family name if possible, or font otherwise.
	items = box.curselection()

	if len(items)&gt; 0:
		try: # This shouldn't fail now.
			items = map(int, items)
			color = box.get(items[0])
		except:
			es("unexpected exception")
			es_exception()

	if not color:
		color = self.color
	return color</t>
<t tx="T2175">def run (self,name,color):
	
	assert(name==self.name)
	assert(color==self.color)
	self.revertColor = color
	
	Tk = Tkinter
	config = app().config

	self.top = top = Tk.Toplevel(app().root)
	top.title("Color names for " + '"' + name + '"')
	top.protocol("WM_DELETE_WINDOW", self.onOk)

	&lt;&lt; create color name panel &gt;&gt;
	self.select(color)
	
	center_dialog(top) # Do this _after_ building the dialog!
	# top.resizable(0,0)
	
	# This must be a modal dialog.
	top.grab_set()
	top.focus_force() # Get all keystrokes.</t>
<t tx="T2176"># Create organizer frames
outer = Tk.Frame(top,bd=2,relief="groove")
outer.pack(fill="both",expand=1)

upper = Tk.Frame(outer)
upper.pack(fill="both",expand=1)

# A kludge to give vertical space to the listbox!
spacer = Tk.Frame(upper) 
spacer.pack(side="right",pady="2i") 

lower = Tk.Frame(outer)
# padx=20 gives more room to the Listbox!
lower.pack(padx=40) # Not expanding centers the buttons.

# Create and populate the listbox.
self.box = box = Tk.Listbox(upper) # height doesn't seem to work.
box.bind("&lt;Double-Button-1&gt;", self.onApply)

if color not in colorNamesList:
	box.insert(0,color)
	
names = list(colorNamesList) # It's actually a tuple.
names.sort()
for name in names:
	box.insert("end",name)

bar = Tk.Scrollbar(box)
bar.pack(side="right", fill="y")
box.pack(padx=2,pady=2,expand=1,fill="both")

bar.config(command=box.yview)
box.config(yscrollcommand=bar.set)
	
# Create the row of buttons.
for text,command in (
	("OK",self.onOk),
	("Cancel",self.onCancel),
	("Revert",self.onRevert),
	("Apply",self.onApply) ):
		
	b = Tk.Button(lower,text=text,command=command)
	b.pack(side="left",pady=6,padx=4)</t>
<t tx="T2177">def onApply (self,event=None):
	self.color = color = self.getSelection()
	self.colorPanel.update(self.name,color)

def onOk (self):
	color = self.getSelection()
	self.colorPanel.update(self.name,color)
	self.top.destroy()
	
def onCancel (self):
	self.onRevert()
	self.top.destroy()
	
def onRevert (self):
	self.color = color = self.revertColor
	self.select(self.color)
	self.colorPanel.update(self.name,color)</t>
<t tx="T2178">def select (self,color):

	# trace(color)

	# The name should be on the list!
	box = self.box
	for i in xrange(0,box.size()):
		item = box.get(i)
		if color == item:
			box.select_clear(0,"end")
			box.select_set(i)
			box.see(i)
			return

	# trace("not found:" + `color`)</t>
<t tx="T2179">@language python

@ This class implements the most basic commands.  Subcommanders contain an ivar that points to an instance of this class.
@c

from leoGlobals import *

# Import the subcommanders.
import leoAtFile,leoFileCommands,leoImport,leoNodes,leoTangle,leoUndo

class Commands:
	@others</t>
<t tx="T2180">def __del__ (self):

	# Can't trace while destroying.
	# print "c.__del__"
	pass</t>
<t tx="T2181">def __repr__ (self):
	
	try:
		return "Commander: " + self.frame.mFileName
	except:
		return "Commander: bad mFileName"
</t>
<t tx="T2182">@ This should be called whenever we need to use preference:
i.e., before reading, writing, tangling, untangling.

7/2/02: We no longer need this now that the Prefs dialog is modal.
@c

def setIvarsFromPrefs (self):

	pass</t>
<t tx="T2183">def beginUpdate(self):

	self.tree.beginUpdate()
	
BeginUpdate = beginUpdate # Compatibility with old scripts</t>
<t tx="T2184">def bringToFront(self):

	self.frame.top.deiconify()

BringToFront = bringToFront # Compatibility with old scripts</t>
<t tx="T2185">def endUpdate(self, flag=true):
	
	self.tree.endUpdate(flag)
	
EndUpdate = endUpdate # Compatibility with old scripts</t>
<t tx="T2186">def recolor(self):

	tree = self.tree
	tree.recolor(tree.currentVnode)</t>
<t tx="T2187">def redraw(self):

	self.tree.redraw()
	
# Compatibility with old scripts
Redraw = redraw 
repaint = redraw
Repaint = redraw</t>
<t tx="T2188">def createLastChildNode (self,parent,headline,body):
	
	c = self
	if body and len(body) &gt; 0:
		body = string.rstrip(body)
	if not body or len(body) == 0:
		body = ""
	v = parent.insertAsLastChild()
	v.initHeadString(headline)
	v.t.setTnodeText(body)
	v.createDependents() # To handle effects of clones.
	v.setDirty()
	c.validateOutline()</t>
<t tx="T2189">def dedentBody (self):

	c = self
	head,lines,tail,oldSel,oldYview = self.getBodyLines()
	result = [] ; changed = false
	for line in lines:
		i, width = skip_leading_ws_with_indent(line,0,c.tab_width)
		s = computeLeadingWhitespace(width-abs(c.tab_width),c.tab_width) + line[i:]
		if s != line: changed = true
		result.append(s)
	if changed:
		result = string.join(result,'\n')
		c.updateBodyPane(head,result,tail,"Undent",oldSel,oldYview)</t>
<t tx="T2190">def extract(self):

	c = self ; current = v = c.currentVnode()
	head,lines,tail,oldSel,oldYview = self.getBodyLines()
	if not lines: return
	headline = lines[0] ; del lines[0]
	junk, ws = skip_leading_ws_with_indent(headline,0,c.tab_width)
	# Create copy for undo.
	v_copy = c.copyTree(v)
	&lt;&lt; Set headline for extract &gt;&gt;
	# Remove leading whitespace from all body lines.
	result = []
	for line in lines:
		# Remove the whitespace on the first line
		line = removeLeadingWhitespace(line,ws,c.tab_width)
		result.append(line)
	# Create a new node from lines.
	body = string.join(result,'\n')
	if head and len(head) &gt; 0:
		head = string.rstrip(head)
	c.beginUpdate()
	c.createLastChildNode(v,headline,body)
	c.updateBodyPane(head,None,tail,"Can't Undo",oldSel,oldYview)
	c.undoer.setUndoParams("Extract",v,select=current,oldTree=v_copy)
	c.endUpdate()</t>
<t tx="T2191">headline = string.strip(headline)
while len(headline) &gt; 0 and headline[0] == '/':
	headline = headline[1:]
headline = string.strip(headline)</t>
<t tx="T2192">def extractSection(self):

	c = self ; current = v = c.currentVnode()
	head,lines,tail,oldSel,oldYview = self.getBodyLines()
	if not lines: return
	headline = lines[0] ; del lines[0]
	junk, ws = skip_leading_ws_with_indent(headline,0,c.tab_width)
	line1 = "\n" + headline
	# Create copy for undo.
	v_copy = c.copyTree(v)
	&lt;&lt; Set headline for extractSection &gt;&gt;
	# Remove leading whitespace from all body lines.
	result = []
	for line in lines:
		# Remove the whitespace on the first line
		line = removeLeadingWhitespace(line,ws,c.tab_width)
		result.append(line)
	# Create a new node from lines.
	body = string.join(result,'\n')
	if head and len(head) &gt; 0:
		head = string.rstrip(head)
	c.beginUpdate()
	c.createLastChildNode(v,headline,body)
	c.updateBodyPane(head,line1,tail,"Can't Undo",oldSel,oldYview)
	c.undoer.setUndoParams("Extract Section",v,select=current,oldTree=v_copy)
	c.endUpdate()
</t>
<t tx="T2193">while len(headline) &gt; 0 and headline[0] == '/':
	headline = headline[1:]
headline = string.strip(headline)

# Make sure we have a @&lt; or &lt;&lt;
if headline[0:2] != '&lt;&lt;' and headline[0:2] != '@&lt;': return</t>
<t tx="T2194">def extractSectionNames(self):

	c = self ; current = v = c.currentVnode()
	head,lines,tail,oldSel,oldYview = self.getBodyLines()
	if not lines: return
	# Save the selection.
	i, j = self.getBodySelection()
	# Create copy for undo.
	v_copy = c.copyTree(v)
	c.beginUpdate()
	for s in lines:
		&lt;&lt; Find the next section name &gt;&gt;
		if name: self.createLastChildNode(v,name,None)
	c.selectVnode(v)
	c.validateOutline()
	c.endUpdate()
	c.undoer.setUndoParams("Extract Names",v,select=current,oldTree=v_copy)
	#c.undoer.clearUndoState()
	# Restore the selection.
	setTextSelection(c.body,i,j)
	c.body.focus_force()</t>
<t tx="T2195">head1 = string.find(s,"&lt;&lt;")
if head1 &gt; -1:
	head2 = string.find(s,"&gt;&gt;",head1)
else:
	head1 = string.find(s,"@&lt;")
	if head1 &gt; -1:
		head2 = string.find(s,"@&gt;",head1)
		
if head1 == -1 or head2 == -1 or head1 &gt; head2:
	name = None
else:
	name = s[head1:head2+2]</t>
<t tx="T2196">def getBodySelection (self):

	c = self
	i, j = getTextSelection(c.body)
	if i and j and c.body.compare(i,"&gt;",j):
		i,j = j,i
	return i, j</t>
<t tx="T2197">def indentBody (self):

	c = self
	head,lines,tail,oldSel,oldYview = self.getBodyLines()
	result = [] ; changed = false
	for line in lines:
		i, width = skip_leading_ws_with_indent(line,0,c.tab_width)
		s = computeLeadingWhitespace(width+abs(c.tab_width),c.tab_width) + line[i:]
		if s != line: changed = true
		result.append(s)
	if changed:
		result = string.join(result,'\n')
		c.updateBodyPane(head,result,tail,"Indent",oldSel,oldYview)</t>
<t tx="T2198">def contractAllHeadlines (self):

	c = self ; current = c.currentVnode()
	v = c.rootVnode()
	c.beginUpdate()
	while v:
		c.contractSubtree(v)
		v = v.next()
	if not current.isVisible():
		c.selectVnode(c.rootVnode())
	c.endUpdate()
	c.expansionLevel = 1 # Reset expansion level.</t>
<t tx="T2199"># Contracts all offspring of the current node.

def contractAllSubheads (self):

	c = self ;v = c.currentVnode()
	if not v: return

	child = v.firstChild()
	c.beginUpdate()
	while child:
		c.contractSubtree(child)
		child = child.next()
	c.endUpdate()
	c.selectVnode(v) # Needed?
	c.expansionLevel = 0</t>
<t tx="T2200">def contractParent (self):
	
	c = self ; v = c.currentVnode()
	parent = v.parent()
	if not parent: return
	
	c.beginUpdate()
	c.selectVnode(parent)
	parent.contract()
	c.endUpdate()</t>
<t tx="T2201">def expandLevel1 (self):

	self.expandToLevel(1)</t>
<t tx="T2202">def expandLevel2 (self):

	self.expandToLevel(2)</t>
<t tx="T2203">def expandLevel3 (self):

	self.expandToLevel(3)</t>
<t tx="T2204">def expandLevel4 (self):

	self.expandToLevel(4)</t>
<t tx="T2205">def expandLevel5 (self):

	self.expandToLevel(5)</t>
<t tx="T2206">def expandLevel6 (self):

	self.expandToLevel(6)</t>
<t tx="T2207">def expandLevel7 (self):

	self.expandToLevel(7)</t>
<t tx="T2208">def expandLevel8 (self):

	self.expandToLevel(8)</t>
<t tx="T2209">def expandLevel9 (self):

	self.expandToLevel(9)</t>
<t tx="T2210">def expandNextLevel (self):

	c = self
	self.expandToLevel(c.expansionLevel + 1)</t>
<t tx="T2211">def expandAllHeadlines(self):

	c = self ; v = root = c.rootVnode()
	c.beginUpdate()
	while v:
		c.expandSubtree(v)
		v = v.next()
	c.selectVnode(root)
	c.endUpdate()
	c.expansionLevel = 0 # Reset expansion level.</t>
<t tx="T2212">def expandAllSubheads (self):

	c = self ; v = c.currentVnode()
	if not v: return

	child = v.firstChild()
	c.beginUpdate()
	c.expandSubtree(v)
	while child:
		c.expandSubtree(child)
		child = child.next()
	c.selectVnode(v)
	c.endUpdate()</t>
<t tx="T2213">def expandSubheads (self):

	c = self ; v = c.currentVnode()
	if not v: return

	child = v.firstChild()
	c.beginUpdate()
	c.expandVnode(v)
	while child:
		c.expandVnode(child)
		child = child.next()
	c.selectVnode(v)
	c.endUpdate()</t>
<t tx="T2214">def contractSubtree (self,v):

	last = v.lastNode()
	while v and v != last:
		v.contract()
		v = v.threadNext()</t>
<t tx="T2215">def contractVnode (self,v):

	v.contract()
	self.tree.redraw()</t>
<t tx="T2216">def expandSubtree (self,v):

	c = self
	last = v.lastNode()
	while v and v != last:
		v.expand()
		v = v.threadNext()
	c.tree.redraw()</t>
<t tx="T2217">def expandToLevel (self,level):

	c = self
	c.beginUpdate()
	# First contract everything.
	c.contractAllHeadlines()
	# Start the recursion.
	v = c.rootVnode()
	while v:
		c.expandTreeToLevelFromLevel(v,level,1)
		v = v.next()
	c.expansionLevel = level
	c.endUpdate()</t>
<t tx="T2218">def expandVnode (self,v):

	v.expand()</t>
<t tx="T2219">def expandTreeToLevelFromLevel (self,v,toLevel,fromLevel):

	if toLevel &lt;= fromLevel: return
	c = self
	while v:
		# Expand this node.
		c.expandVnode(v)
		# Recursively expand lower levels.
		c.expandTreeToLevelFromLevel(v.firstChild(),toLevel,fromLevel + 1)
		v = v.next()</t>
<t tx="T2220"># Compatibility with scripts

def currentVnode (self):

	return self.tree.currentVnode
</t>
<t tx="T2221">def clearAllMarked (self):

	c = self ; v = c.rootVnode()
	while v:
		v.clearMarked()
		v = v.threadNext()</t>
<t tx="T2222">def clearAllVisited (self):

	c = self ; v = c.rootVnode()
	
	c.beginUpdate()
	while v:
		v.clearVisited()
		if v.t:
			v.t.clearVisited()
		v = v.threadNext()
	c.endUpdate(false) # never redraw the tree.</t>
<t tx="T2223"># Compatibility with scripts

def fileName (self):

	return self.frame.mFileName
</t>
<t tx="T2224">def isChanged (self):

	return self.changed</t>
<t tx="T2225"># Compatibility with scripts

def rootVnode (self):

	return self.tree.rootVnode
</t>
<t tx="T2226"># This creates a free-floating copy of v's tree for undo.
# The copied trees must use different tnodes than the original.

def copyTree(self,root):

	c = self
	# Create the root vnode.
	result = v = leoNodes.vnode(c,root.t)
	# Copy the headline and icon values
	v.copyNode(root,v)
	# Copy the rest of tree.
	v.copyTree(root,v)
	# Replace all tnodes in v by copies.
	assert(v.nodeAfterTree() == None)
	while v:
		v.t = leoNodes.tnode(0, v.t.bodyString)
		v = v.threadNext()
	return result</t>
<t tx="T2227">@ This function initializes all clone bits in the entire outline's tree.
@c

def initAllCloneBits (self):

	c=self
	c.clearAllVisited()
	v = self.tree.rootVnode
	c.beginUpdate()
	while v:
		if v.isVisited():
			v = v.threadNext()
			continue
		mark = v.shouldBeClone()
		# Mark all nodes joined to v.
		v2 = v.getJoinList()
		while v2 and v2 != v:
			v2.setVisited()
			# Important speedup: only change the bit if it needs changing.
			if not mark and v2.isCloned():
				v2.clearClonedBit()
			elif mark and not v2.isCloned():
				v2.setClonedBit()
			v2 = v2.getJoinList()
		# Mark v.
		v.setVisited()
		if not mark and v.isCloned():
			v.clearClonedBit()
		elif mark and not v.isCloned():
			v.setClonedBit()
		v = v.threadNext()
	c.endUpdate()</t>
<t tx="T2228"># Initializes all clone bits in the all nodes joined to v.

def initJoinedCloneBits (self,v):

	c = self ; v1 = v

	c.beginUpdate()
	if 1: # update range...
		&lt;&lt; init clone bit for v &gt;&gt;
		v = v.getJoinList()
		while v and v != v1:
			&lt;&lt; init clone bit for v &gt;&gt;
			v = v.getJoinList()
	c.endUpdate()</t>
<t tx="T2229">mark = v.shouldBeClone()
if not mark and v.isCloned():
	v.clearClonedBit()
elif mark and not v.isCloned():
	v.setClonedBit()</t>
<t tx="T2230"># Makes sure all nodes are valid.

def validateOutline (self):

	c = self ; root = c.rootVnode()
	if root:
		return root.validateOutlineWithParent(None)
	else:
		return true</t>
<t tx="T2231">def goToNextDirtyHeadline (self):

	c = self ; current = c.currentVnode()
	if not current: return

	v = current.threadNext()
	while v and not v.isDirty():
		v = v.threadNext()
	if not v:
		v = c.rootVnode()
		while v and not v.isDirty():
			v = v.threadNext()
	if v:
		c.selectVnode(v)</t>
<t tx="T2232">def goToNextMarkedHeadline(self):

	c = self ; current = c.currentVnode()
	if not current: return

	v = current.threadNext()
	while v and not v.isMarked():
		v = v.threadNext()
	if v:
		c.beginUpdate()
		c.endEditing()
		c.selectVnode(v)
		c.endUpdate()</t>
<t tx="T2233">def markChangedHeadlines (self):

	c = self ; v = c.rootVnode()
	c.beginUpdate()
	while v:
		if v.isDirty()and not v.isMarked():
			v.setMarked()
			c.setChanged(true)
		v = v.threadNext()
	c.endUpdate()</t>
<t tx="T2234">def markChangedRoots (self):

	c = self ; v = c.rootVnode()
	c.beginUpdate()
	while v:
		if v.isDirty()and not v.isMarked():
			s = v.bodyString()
			flag, i = is_special(s,0,"@root")
			if flag:
				v.setMarked()
				c.setChanged(true)
		v = v.threadNext()
	c.endUpdate()</t>
<t tx="T2235">def markAllAtFileNodesDirty (self):

	c = self ; v = c.rootVnode()
	c.beginUpdate()
	while v:
		if v.isAtFileNode()and not v.isDirty():
			v.setDirty()
			v = v.nodeAfterTree()
		else: v = v.threadNext()
	c.endUpdate()</t>
<t tx="T2236">def markAtFileNodesDirty (self):

	c = self
	v = c.currentVnode()
	if not v: return
	after = v.nodeAfterTree()
	c.beginUpdate()
	while v and v != after:
		if v.isAtFileNode() and not v.isDirty():
			v.setDirty()
			v = v.nodeAfterTree()
		else: v = v.threadNext()
	c.endUpdate()</t>
<t tx="T2237">def markHeadline (self):

	c = self ; v = c.currentVnode()
	if not v: return

	c.beginUpdate()
	if v.isMarked():
		v.clearMarked()
	else:
		v.setMarked()
		v.setDirty()
		c.setChanged(true)
	c.endUpdate()</t>
<t tx="T2238">def markSubheads(self):

	c = self ; v = c.currentVnode()
	if not v: return

	child = v.firstChild()
	c.beginUpdate()
	while child:
		if not child.isMarked():
			child.setMarked()
			child.setDirty()
			c.setChanged(true)
		child = child.next()
	c.endUpdate()</t>
<t tx="T2239">def unmarkAll(self):

	c = self ; v = c.rootVnode()
	c.beginUpdate()
	while v:
		if v.isMarked():
			v.clearMarked()
			v.setDirty()
			c.setChanged(true)
		v = v.threadNext()
	c.endUpdate()</t>
<t tx="T2240"># Ends the editing in the outline.

def endEditing(self):

	self.tree.endEditLabel()
</t>
<t tx="T2241">def selectThreadBack(self):

	c = self ; current = c.currentVnode()
	if not current: return
	
	v = current.threadBack()
	if v:
		c.beginUpdate()
		c.selectVnode(v)
		c.endUpdate()
</t>
<t tx="T2242">def selectThreadNext(self):

	c = self ; current = c.currentVnode()
	if not current: return

	v = current.threadNext()
	if v:
		c.beginUpdate()
		c.selectVnode(v)
		c.endUpdate()</t>
<t tx="T2243"># This has an up arrow for a control key.

def selectVisBack(self):

	c = self ; current = c.currentVnode()
	if not current: return

	v = current.visBack()
	if v:
		c.beginUpdate()
		c.selectVnode(v)
		c.endUpdate()</t>
<t tx="T2244">def selectVisNext(self):

	c = self ; current = c.currentVnode()
	if not current: return
	
	v = current.visNext()
	if v:
		c.beginUpdate()
		c.selectVnode(v)
		c.endUpdate()
</t>
<t tx="T2245"># Selects the given node and enables editing of the headline if editFlag is true.

def selectVnodeWithEditing(self,v,editFlag):

	c = self
	if editFlag:
		c.editVnode(v)
	else:
		c.selectVnode(v)
</t>
<t tx="T2246">@ These routines provide a convenient interface to the syntax colorer.
</t>
<t tx="T2247">def updateSyntaxColorer(self,v):

	self.tree.colorizer.updateSyntaxColorer(v)
</t>
<t tx="T2248">@language python

# The code for Leo's Compare Panel and the compare class.

from leoGlobals import *
import difflib,filecmp,os,string
import Tkinter,tkFileDialog

@others

if __name__ == "__main__":
	pass</t>
<t tx="T2249">def choose(cond, a, b): # warning: evaluates all arguments

	if cond: return a
	else: return b
</t>
<t tx="T2250">def go ():

	cmp = leoCompare(
		commands = None,
		
		appendOutput = true,

		ignoreBlankLines = true,
		ignoreFirstLine1 = false,
		ignoreFirstLine2 = false,
		ignoreInteriorWhitespace = false,
		ignoreLeadingWhitespace = true,
		ignoreSentinelLines = false,
		
		limitCount = 9, # Zero means don't stop.
		limitToExtension = ".py",  # For directory compares.
		makeWhitespaceVisible = true,
		
		printBothMatches = false,
		printMatches = false,
		printMismatches = true,
		printTrailingMismatches = false,

		outputFileName = None)

	if 1: # Compare all files in Tangle test directories

		path1 = "c:\\prog\\test\\tangleTest\\"
		path2 = "c:\\prog\\test\\tangleTestCB\\"
		cmp.compare_directories(path1,path2)

	else: # Compare two files.

		name1 = "c:\\prog\\test\\compare1.txt"
		name2 = "c:\\prog\\test\\compare2.txt"
		cmp.compare_files(name1,name2)</t>
<t tx="T2251">class leoCompare:
	@others</t>
<t tx="T2252"># All these ivars are known to the leoComparePanel class.

def __init__ (self,

	# Keyword arguments are much convenient and more clear for scripts.
	commands = None,
	
	appendOutput = false,

	ignoreBlankLines = true,
	ignoreFirstLine1 = false,
	ignoreFirstLine2 = false,
	ignoreInteriorWhitespace = false,
	ignoreLeadingWhitespace = true,
	ignoreSentinelLines = false,

	limitCount = 0, # Zero means don't stop.
	limitToExtension = ".py",  # For directory compares.
	makeWhitespaceVisible = true,

	printBothMatches = false,
	printMatches = false,
	printMismatches = true,
	printTrailingMismatches = false,

	outputFileName = None ):
		
	# It is more convenient for the leoComparePanel to set these directly.
	self.commands = commands
	
	self.appendOutput = appendOutput

	self.ignoreBlankLines = ignoreBlankLines
	self.ignoreFirstLine1 = ignoreFirstLine1
	self.ignoreFirstLine2 = ignoreFirstLine2
	self.ignoreInteriorWhitespace = ignoreInteriorWhitespace
	self.ignoreLeadingWhitespace = ignoreLeadingWhitespace
	self.ignoreSentinelLines = ignoreSentinelLines

	self.limitCount = limitCount
	self.limitToExtension = limitToExtension

	self.printBothMatches = printBothMatches
	self.printMatches = printMatches
	self.printMismatches = printMismatches
	self.printTrailingMismatches = printTrailingMismatches
	
	# For communication between methods...
	self.outputFileName = outputFileName
	self.fileName1 = None 
	self.fileName2 = None
	# Open files...
	self.outputFile = None</t>
<t tx="T2253"># We ignore the filename portion of path1 and path2 if it exists.

def compare_directories (self,path1,path2):
	
	# Ignore everything except the directory name.
	dir1 = os.path.dirname(path1)
	dir2 = os.path.dirname(path2)
	dir1 = os.path.normpath(dir1)
	dir2 = os.path.normpath(dir2)
	
	if dir1 == dir2:
		self.show("Directory names are identical.\nPlease pick distinct directories.")
		return
		
	try:
		list1 = os.listdir(dir1)
	except:
		self.show("invalid directory:" + dir1)
		return
	try:
		list2 = os.listdir(dir2)
	except:
		self.show("invalid directory:" + dir2)
		return
		
	if self.outputFileName:
		self.openOutputFile()
	ok = self.outputFileName == None or self.outputFile
	if not ok:
		return

	# Create files and files2, the lists of files to be compared.
	files1 = []
	files2 = []
	for f in list1:
		junk, ext = os.path.splitext(f)
		if self.limitToExtension:
			if ext == self.limitToExtension:
				files1.append(f)
		else:
			files1.append(f)
	for f in list2:
		junk, ext = os.path.splitext(f)
		if self.limitToExtension:
			if ext == self.limitToExtension:
				files2.append(f)
		else:
			files2.append(f)

	# Compare the files and set the yes, no and fail lists.
	yes = [] ; no = [] ; fail = []
	for f1 in files1:
		head,f2 = os.path.split(f1)
		if f2 in files2:
			try:
				name1 = os.path.join(dir1,f1)
				name2 = os.path.join(dir2,f2)
				val = filecmp.cmp(name1,name2,0)
				if val: yes.append(f1)
				else:    no.append(f1)
			except:
				self.show("exception in filecmp.cmp")
				es_exception()
				fail.append(f1)
		else:
			fail.append(f1)
	
	# Print the results.
	for kind, files in (
		("----- matches --------",yes),
		("----- mismatches -----",no),
		("----- not found ------",fail)):
		self.show(kind)
		for f in files:
			self.show(f)
	
	if self.outputFile:
		self.outputFile.close()
		self.outputFile = None</t>
<t tx="T2254">def compare_lines (self,s1,s2):
	
	if self.ignoreLeadingWhitespace:
		s1 = string.lstrip(s1)
		s2 = string.lstrip(s2)

	if self.ignoreInteriorWhitespace:
		k1 = skip_ws(s1,0)
		k2 = skip_ws(s2,0)
		ws1 = s1[:k1]
		ws2 = s2[:k2]
		tail1 = s1[k1:]
		tail2 = s2[k2:]
		tail1 = string.replace(tail1," ","")
		tail1 = string.replace(tail1,"\t","")
		tail2 = string.replace(tail2," ","")
		tail2 = string.replace(tail2,"\t","")
		s1 = ws1 + tail1
		s2 = ws2 + tail2

	return s1 == s2</t>
<t tx="T2255">def compare_open_files (self, f1, f2, name1, name2):

	# self.show("compare_open_files")
	lines1 = 0 ; lines2 = 0 ; mismatches = 0 ; printTrailing = true
	sentinelComment1 = sentinelComment2 = None
	if self.openOutputFile():
		self.show("1: " + name1)
		self.show("2: " + name2)
		self.show("")
	s1 = s2 = None
	&lt;&lt; handle opening lines &gt;&gt;
	while 1:
		if s1 == None:
			s1 = readlineForceUnixNewline(f1) ; lines1 += 1
		if s2 == None:
			s2 = readlineForceUnixNewline(f2) ; lines2 += 1
		&lt;&lt; ignore blank lines and/or sentinels &gt;&gt;
		n1 = len(s1) ; n2 = len(s2)
		if n1==0 and n2 != 0: self.show("1.eof***:")
		if n2==0 and n1 != 0: self.show("2.eof***:")
		if n1==0 or n2==0: break
		match = self.compare_lines(s1,s2)
		if not match: mismatches += 1
		&lt;&lt; print matches and/or mismatches &gt;&gt;
		&lt;&lt; warn if mismatch limit reached &gt;&gt;
		s1 = s2 = None # force a read of both lines.
	&lt;&lt; handle reporting after at least one eof is seen &gt;&gt;</t>
<t tx="T2256">if self.ignoreSentinelLines:
	
	s1 = readlineForceUnixNewline(f1) ; lines1 += 1
	s2 = readlineForceUnixNewline(f2) ; lines2 += 1
	# Note: isLeoHeader may return None.
	sentinelComment1 = self.isLeoHeader(s1)
	sentinelComment2 = self.isLeoHeader(s2)
	if not sentinelComment1: self.show("no @+leo line for " + name1)
	if not sentinelComment2: self.show("no @+leo line for " + name2)
		
if self.ignoreFirstLine1:
	if s1 == None:
		readlineForceUnixNewline(f1) ; lines1 += 1
	s1 = None

if self.ignoreFirstLine2:
	if s2 == None:
		readlineForceUnixNewline(f2) ; lines2 += 1
	s2 = None</t>
<t tx="T2257"># Completely empty strings denotes end-of-file.
if s1 and len(s1) &gt; 0:
	if self.ignoreBlankLines and len(string.strip(s1)) == 0:
		s1 = None ; continue
		
	if self.ignoreSentinelLines and sentinelComment1 and self.isSentinel(s1,sentinelComment1):
		s1 = None ; continue

if s2 and len(s2) &gt; 0:
	if self.ignoreBlankLines and len(string.strip(s2)) == 0:
		s2 = None ; continue

	if self.ignoreSentinelLines and sentinelComment2 and self.isSentinel(s2,sentinelComment2):
		s2 = None ; continue
</t>
<t tx="T2258">if self.limitCount == 0 or mismatches &lt;= self.limitCount:

	if match and self.printMatches:
		
		if self.printBothMatches:
			self.dump(string.rjust("1." + `lines1`,6) + ' :',s1)
			self.dump(string.rjust("2." + `lines2`,6) + ' :',s2)
		else:
			self.dump(string.rjust(       `lines1`,6) + ' :',s1)
	
	if not match and self.printMismatches:
		
		self.dump(string.rjust("1." + `lines1`,6) + '*:',s1)
		self.dump(string.rjust("2." + `lines2`,6) + '*:',s2)</t>
<t tx="T2259">if self.limitCount &gt; 0 and mismatches &gt;= self.limitCount:
	
	if printTrailing:
		self.show("")
		self.show("limit count reached")
		self.show("")
		printTrailing = false</t>
<t tx="T2260">if n1 &gt; 0: 
	lines1 += self.dumpToEndOfFile("1.",f1,s1,lines1,printTrailing)
	
if n2 &gt; 0:
	lines2 += self.dumpToEndOfFile("2.",f2,s2,lines2,printTrailing)

self.show("")
self.show("lines1:" + `lines1`)
self.show("lines2:" + `lines2`)
self.show("mismatches:" + `mismatches`)</t>
<t tx="T2261">def filecmp (self,f1,f2):

	val = filecmp.cmp(f1,f2)
	if 1:
		if val: self.show("equal")
		else:   self.show("*** not equal")
	else:
		self.show("filecmp.cmp returns:")
		if val: self.show(`val` + " (equal)")
		else:   self.show(`val` + " (not equal)")
	return val</t>
<t tx="T2262">def doOpen (self,name):

	try:
		f = open(name,'r')
		return f
	except:
		self.show("can not open:" + '"' + name + '"')
		return None</t>
<t tx="T2263">def dump (self,tag,s):

	out = tag

	for ch in s[:-1]: # don't print the newline
	
		if self.makeWhitespaceVisible:
			if ch == '\t':
				out += "[" ; out += "t" ; out += "]"
			elif ch == ' ':
				out += "[" ; out += " " ; out += "]"
			else: out += ch
		else:
			if 1:
				out += ch
			else: # I don't know why I thought this was a good idea ;-)
				if ch == '\t' or ch == ' ':
					out += ' '
				else:
					out += ch

	self.show(out)</t>
<t tx="T2264">def dumpToEndOfFile (self,tag,f,s,line,printTrailing):

	trailingLines = 0
	while 1:
		if not s:
			s = readlineForceUnixNewline(f)
		if len(s) == 0: break
		trailingLines += 1
		if self.printTrailingMismatches and printTrailing:
			tag2 = string.rjust(tag + `line`,6) + "+:"
			self.dump(tag2,s)
		s = None

	self.show(tag + `trailingLines` + " trailing lines")
	return trailingLines</t>
<t tx="T2265">@ These methods are based on atFile.scanHeader().  They are simpler because we only care about the starting sentinel comment: any line starting with the starting sentinel comment is presumed to be a sentinel line.
@c

def isLeoHeader (self,s):

	tag = "@+leo"
	j = string.find(s,tag)
	if j &gt; 0:
		i = skip_ws(s,0)
		if i &lt; j: return s[i:j]
		else: return None
	else: return None
		
def isSentinel (self,s,sentinelComment):

	i = skip_ws(s,0)
	return match(s,i,sentinelComment)</t>
<t tx="T2266">def show (self,s):
	
	# print s
	if self.outputFile:
		self.outputFile.write(s + '\n')
	elif self.commands:
		es(s)
	else:
		print s
		print</t>
<t tx="T2267">def showIvars (self):
	
	self.show("fileName1:"        + `self.fileName1`)
	self.show("fileName2:"        + `self.fileName2`)
	self.show("outputFileName:"   + `self.outputFileName`)
	self.show("limitToExtension:" + `self.limitToExtension`)
	self.show("")

	self.show("ignoreBlankLines:"         + `self.ignoreBlankLines`)
	self.show("ignoreFirstLine1:"         + `self.ignoreFirstLine1`)
	self.show("ignoreFirstLine2:"         + `self.ignoreFirstLine2`)
	self.show("ignoreInteriorWhitespace:" + `self.ignoreInteriorWhitespace`)
	self.show("ignoreLeadingWhitespace:"  + `self.ignoreLeadingWhitespace`)
	self.show("ignoreSentinelLines:"      + `self.ignoreSentinelLines`)
	self.show("")
	
	self.show("limitCount:"              + `self.limitCount`)
	self.show("printMatches:"            + `self.printMatches`)
	self.show("printMismatches:"         + `self.printMismatches`)
	self.show("printTrailingMismatches:" + `self.printTrailingMismatches`)</t>
<t tx="T2268">class leoComparePanel:
	@others</t>
<t tx="T2269">def browser (self,n):
	
	types = [
		("C/C++ files","*.c"),
		("C/C++ files","*.cpp"),
		("C/C++ files","*.h"),
		("C/C++ files","*.hpp"),
		("Java files","*.java"),
		("Pascal files","*.pas"),
		("Python files","*.py"),
		("Text files","*.txt"),
		("All files","*") ]

	fileName = tkFileDialog.askopenfilename(
		title="Choose compare file" + n,
		filetypes=types,
		defaultextension=".txt")
		
	if fileName and len(fileName) &gt; 0:
		# The dialog also warns about this, so this may never happen.
		if not os.path.exists(fileName):
			self.show("not found: " + fileName)
			fileName = None
	else: fileName = None
		
	return fileName</t>
<t tx="T2270">def __init__ (self,c,cmp):

	Tk = Tkinter
	self.commands = c
	self.cmp = cmp
	
	# Ivars pointing to Tk elements.
	self.browseEntries = []
	self.extensionEntry = None
	self.countEntry = None
	self.printButtons = []
	
	# No corresponding cmp ivar.
	self.useOutputFileVar = Tk.IntVar()
	
	# These all correspond to ivars in leoCompare.
	self.appendOutputVar             = Tk.IntVar()

	self.ignoreBlankLinesVar         = Tk.IntVar()
	self.ignoreFirstLine1Var         = Tk.IntVar()
	self.ignoreFirstLine2Var         = Tk.IntVar()
	self.ignoreInteriorWhitespaceVar = Tk.IntVar()
	self.ignoreLeadingWhitespaceVar  = Tk.IntVar()
	self.ignoreSentinelLinesVar      = Tk.IntVar()

	self.limitToExtensionVar         = Tk.IntVar()
	self.makeWhitespaceVisibleVar    = Tk.IntVar()
	
	self.printBothMatchesVar         = Tk.IntVar()
	self.printMatchesVar             = Tk.IntVar()
	self.printMismatchesVar          = Tk.IntVar()
	self.printTrailingMismatchesVar  = Tk.IntVar()
	self.stopAfterMismatchVar        = Tk.IntVar()
	
	# These ivars are set from Entry widgets.
	self.limitCount = 0
	self.limitToExtension = None 
	if 0: # we just use the cmp ivars.
		self.pathName1 = None
		self.pathName2 = None
		self.outputFileName = None
	
	# The default file name in the "output file name" browsers.
	self.defaultOutputFileName = "CompareResults.txt"</t>
<t tx="T2271">def run (self):

	import leoApp, leoCommands

	c = self.commands ; cmp = self.cmp ; Tk = Tkinter
	self.top = top = Tk.Toplevel(app().root)
	top.title("Compare files and directories (" + shortFileName(c.frame.title) + ")")
	top.protocol("WM_DELETE_WINDOW", self.onClose)
	&lt;&lt; create the organizer frames &gt;&gt;
	&lt;&lt; create the browser rows &gt;&gt;
	&lt;&lt; create the extension row &gt;&gt;
	&lt;&lt; create the whitespace options frame &gt;&gt;
	&lt;&lt; create the print options frame &gt;&gt;
	&lt;&lt; create the compare buttons &gt;&gt;
	center_dialog(top) # Do this _after_ building the dialog!
	top.resizable(0,0)
	self.finishCreate()</t>
<t tx="T2272">outer = Tk.Frame(top, bd=2,relief="groove")
outer.pack(pady=4)

row1 = Tk.Frame(outer)
row1.pack(pady=4)

row2 = Tk.Frame(outer)
row2.pack(pady=4)

row3 = Tk.Frame(outer)
row3.pack(pady=4)

row4 = Tk.Frame(outer)
row4.pack(pady=4,expand=1,fill="x") # for left justification.

options = Tk.Frame(outer)
options.pack(pady=4)

ws = Tk.Frame(options)
ws.pack(side="left",padx=4)

pr = Tk.Frame(options)
pr.pack(side="right",padx=4)

lower = Tk.Frame(outer)
lower.pack(pady=6)</t>
<t tx="T2273">for row,text,text2,command,var in (
	(row1,"Compare path 1:","Ignore first line",self.onBrowse1,self.ignoreFirstLine1Var),
	(row2,"Compare path 2:","Ignore first line",self.onBrowse2,self.ignoreFirstLine2Var),
	(row3,"Output file:",   "Use output file",  self.onBrowse3,self.useOutputFileVar) ):

	lab = Tk.Label(row,anchor="e",text=text,width=13)
	lab.pack(side="left",padx=4)
	
	e = Tk.Entry(row)
	e.pack(side="left",padx=2)
	self.browseEntries.append(e)
	
	b = Tk.Button(row,text="browse...",command=command)
	b.pack(side="left",padx=6)

	b = Tk.Checkbutton(row,text=text2,anchor="w",variable=var,width=15)
	b.pack(side="left")</t>
<t tx="T2274">b = Tk.Checkbutton(row4,anchor="w",var=self.limitToExtensionVar,
	text="Limit directory compares to type:")
b.pack(side="left",padx=4)

self.extensionEntry = e = Tk.Entry(row4,width=6)
e.pack(side="left",padx=2)

b = Tk.Checkbutton(row4,anchor="w",var=self.appendOutputVar,
	text="Append output to output file")
b.pack(side="left",padx=4)</t>
<t tx="T2275">w,f = create_labeled_frame(ws,caption="Whitespace options",relief="groove")
	
for text,var in (
	("Ignore Leo sentinel lines", self.ignoreSentinelLinesVar),
	("Ignore blank lines",        self.ignoreBlankLinesVar),
	("Ignore leading whitespace", self.ignoreLeadingWhitespaceVar),
	("Ignore interior whitespace",self.ignoreInteriorWhitespaceVar),
	("Make whitespace visible",   self.makeWhitespaceVisibleVar) ):
	
	b = Tk.Checkbutton(f,text=text,variable=var)
	b.pack(side="top",anchor="w")
	
spacer = Tk.Frame(f)
spacer.pack(padx="1i")</t>
<t tx="T2276">w,f = create_labeled_frame(pr,caption="Print options",relief="groove")

row = Tk.Frame(f)
row.pack(expand=1,fill="x")

b = Tk.Checkbutton(row,text="Stop after",variable=self.stopAfterMismatchVar)
b.pack(side="left",anchor="w")

self.countEntry = e = Tk.Entry(row,width=4)
e.pack(side="left",padx=2)
e.insert(01,"1")

lab = Tk.Label(row,text="mismatches")
lab.pack(side="left",padx=2)

for padx,text,var in (    
	(0,  "Print matched lines",           self.printMatchesVar),
	(20, "Show both matching lines",      self.printBothMatchesVar),
	(0,  "Print mismatched lines",        self.printMismatchesVar),
	(0,  "Print unmatched trailing lines",self.printTrailingMismatchesVar) ):
	
	b = Tk.Checkbutton(f,text=text,variable=var)
	b.pack(side="top",anchor="w",padx=padx)
	self.printButtons.append(b)
	
# To enable or disable the "Print both matching lines" button.
b = self.printButtons[0]
b.configure(command=self.onPrintMatchedLines)

spacer = Tk.Frame(f)
spacer.pack(padx="1i")</t>
<t tx="T2277">for text,command in (
	("Compare files",      self.onCompareFiles),
	("Compare directories",self.onCompareDirectories) ):
	
	b = Tk.Button(lower,text=text,command=command,width=18)
	b.pack(side="left",padx=6)</t>
<t tx="T2278">def show (self,s):
	
	self.cmp.show(s)</t>
<t tx="T2279">def onBrowse1 (self):
	
	fileName = self.browser("1")
	if fileName:
		e = self.browseEntries[0]
		e.delete(0,"end")
		e.insert(0,fileName)
	self.top.deiconify()
	
def onBrowse2 (self):
	
	fileName = self.browser("2")
	if fileName:
		e = self.browseEntries[1]
		e.delete(0,"end")
		e.insert(0,fileName)
	self.top.deiconify()
	
def onBrowse3 (self): # Get the name of the output file.

	fileName = tkFileDialog.asksaveasfilename(
		initialfile = self.defaultOutputFileName,
		title="Set output file",
		filetypes=[("Text files", "*.txt")],
		defaultextension=".txt")
		
	if fileName and len(fileName) &gt; 0:
		self.defaultOutputFileName = fileName
		self.useOutputFileVar.set(1) # The user will expect this.
		e = self.browseEntries[2]
		e.delete(0,"end")
		e.insert(0,fileName)</t>
<t tx="T2280">def onClose (self):
	
	self.top.withdraw()</t>
<t tx="T2281">def onCompareDirectories (self):

	cmp = self.cmp
	self.setIvarsFromWidgets()
	cmp.compare_directories(cmp.fileName1,cmp.fileName2)

def onCompareFiles (self):

	cmp = self.cmp
	self.setIvarsFromWidgets()
	cmp.compare_files(cmp.fileName1,cmp.fileName2)</t>
<t tx="T2282">def onPrintMatchedLines (self):
	
	v = self.printMatchesVar.get()
	b = self.printButtons[1]
	state = choose(v,"normal","disabled")
	b.configure(state=state)</t>
<t tx="T2283">@language python

from leoGlobals import *
import leoFind
import ConfigParser,exceptions,os,string,sys,tkFont

class config:
	&lt;&lt; define defaultsDict &gt;&gt;
	@others</t>
<t tx="T2284">@ This contains only the "interesting" defaults.
Ints and bools default to 0, floats to 0.0 and strings to "".
@c

defaultBodyFontSize = choose(sys.platform=="win32",9,12)

defaultsDict = {
	# compare options...
	"ignore_blank_lines" : 1,
	"limit_count" : 9,
	"print_mismatching_lines" : 1,
	"print_trailing_lines" : 1,
	# find/change options...
	"search_body" : 1,
	"whole_word" : 1,
	# Prefs panel.
	"default_target_language" : "Python",
	"tab_width" : 4,
	"page_width" : 132,
	"output_doc_chunks" : 1,
	"tangle_outputs_header" : 1,
	# Syntax coloring options...
	# Defaults for colors are handled by leoColor.py.
	"color_directives_in_plain_text" : 1,
	"underline_undefined_section_names" : 1,
	# Window options...
	"body_pane_wraps" : 1,
	"body_text_font_family" : "Courier",
	"body_text_font_size" : defaultBodyFontSize,
	"body_text_font_slant" : "roman",
	"body_text_font_weight" : "normal",
	"headline_text_font_size" : 12,
	"headline_text_font_slant" : "roman",
	"headline_text_font_weight" : "normal",
	"log_text_font_size" : 12,
	"log_text_font_slant" : "roman",
	"log_text_font_weight" : "normal",
	"initial_window_height" : 20, # In grid units.  These are just a guess.
	"initial_window_width" :  60,
	"initial_window_left" : 10,
	"initial_window_top" : 10,
	"initial_splitter_orientation" : "vertical",
	"initial_vertical_ratio" : 0.5,
	"initial_horizontal_ratio" : 0.3,
	"initial_horizontal_secondary_ratio" : 0.5,
	"initial_vertical_secondary_ratio" : 0.7,
	"outline_pane_scrolls_horizontally" : 0,
	"split_bar_color" : "LightSteelBlue2",
	"split_bar_relief" : "groove",
	"split_bar_width" : 7 }</t>
<t tx="T2285">def getBoolFromDict (self,name,dict):
	val = self.getIntFromDict(name,dict)
	if val and val != None and val != 0: val = 1
	return val

def getFloatFromDict (self,name,dict):
	val = self.getFromDict(name,dict)
	if val:
		try: val = float(val)
		except: val = None
	return val

def getFromDict (self,name,dict):
	val = dict.get(name)
	if val == "ignore":
		val = None
	elif val == None:
		val = self.defaultsDict.get(name)
	return val

def getIntFromDict (self,name,dict):
	val = self.getFromDict(name,dict)
	if val:
		try: val = int(val)
		except: val = None
	return val

def setDict (self,name,val,dict):
	dict [name] = val
		
getStringFromDict = getFromDict
</t>
<t tx="T2286">def getBoolColorsPref (self,name):
	return self.getBoolFromDict(name,self.colorsDict)
	
# Basic getters and setters.

def getColorsPref (self,name):
	return self.getFromDict(name,self.colorsDict)

def setColorsPref (self,name,val):
	self.setDict(name,val,self.colorsDict)
	
getStringColorsPref = getColorsPref</t>
<t tx="T2287">def getBoolComparePref (self,name):
	return self.getBoolFromDict(name,self.compareDict)
	
def getIntComparePref (self,name):
	return self.getIntFromDict(name,self.compareDict)

# Basic getters and setters.

def getComparePref (self,name):
	return self.getFromDict(name,self.compareDict)

def setComparePref (self,name,val):
	self.setDict(name,val,self.compareDict)
	
getStringComparePref = getComparePref</t>
<t tx="T2288">def getBoolFindPref (self,name):
	return self.getBoolFromDict(name,self.findDict)

# Basic getters and setters.

def getFindPref (self,name):
	return self.getFromDict(name,self.findDict)

def setFindPref (self,name,val):
	self.setDict(name,val,self.findDict)
	
getStringFindPref = getFindPref</t>
<t tx="T2289">def getBoolPref (self,name):
	return self.getBoolFromDict(name,self.prefsDict)

def getIntPref (self,name):
	return self.getIntFromDict(name,self.prefsDict)
	
# Basic getters and setters.

def getPref (self,name):
	return self.getFromDict(name,self.prefsDict)

def setPref (self,name,val):
	self.setDict(name,val,self.prefsDict)
	
getStringPref = getPref</t>
<t tx="T2290">def getRecentFiles (self):
	
	return self.recentFiles

def setRecentFiles (self,files):
	
	self.recentFiles = files
</t>
<t tx="T2291">def getBoolWindowPref (self,name):
	return self.getBoolFromDict(name,self.windowDict)
	
def getFloatWindowPref (self,name):
	return self.getFloatFromDict(name,self.windowDict)
	
def getIntWindowPref (self,name):
	return self.getIntFromDict(name,self.windowDict)
	
# Basic getters and setters.

def getWindowPref (self,name):
	return self.getFromDict(name,self.windowDict)

def setWindowPref (self,name,val):
	self.setDict(name,val,self.windowDict)
	
getStringWindowPref = getWindowPref</t>
<t tx="T2292">def getShortcut (self,name):
	
	val = self.keysDict.get(name)
	if val == "None":
		return None
	else:
		return val</t>
<t tx="T2293">def initConfigParam (self,name,defaultVal):
	try:
		val = self.config.get(self.configSection,name)
	except:
		val = defaultVal
	return val

def initBooleanConfigParam (self,name,defaultVal):
	try:
		val = self.config.getboolean(self.configSection,name)
	except:
		val = defaultVal
	return val
</t>
<t tx="T2294"># Sets ivars of c that can be overridden by leoConfig.txt

def setCommandsIvars (self,c):

	config = self ; a = app()
	&lt;&lt; set prefs ivars &gt;&gt;</t>
<t tx="T2295">val = config.getIntPref("tab_width")
if val:
	c.tab_width = val
	if 0: # 9/20/02: don't actually redraw.
		c.frame.setTabWidth(c.tab_width)

val = config.getIntPref("page_width")
if val: c.page_width = val

val = config.getIntPref("run_tangle_done.py")
if val: c.tangle_batch_flag = val

val = config.getIntPref("run_untangle_done.py")
if val: c.untangle_batch_flag = val

val = config.getIntPref("output_doc_chunks")
if val: c.output_doc_flag = val

val = config.getIntPref("tangle_outputs_header")
if val: c.use_header_flag = val

val = config.getPref("default_tangle_directory")
if val: c.tangle_directory = val

val = config.getPref("find_string")
if val: c.tangle_directory = val

c.target_language = "python" # default
val = config.getPref("default_target_language")
if val:
	try:
		val = string.lower(val)
		if 1: # new
			val = string.replace(val,"/","")
			if a.language_delims_dict.get(val):
				c.target_language = val
		else: #old
			for language,name in self.languageNameDict.items():
				# print language, name
				if string.lower(name) == val:
					c.target_language = language
	except: pass</t>
<t tx="T2296"># Sets config ivars from c.

def setConfigIvars (self,c):
	
	a = app()
	
	if 1: # new 
		if c.target_language and a.language_delims_dict.get(c.target_language):
			language = c.target_language
		else:
			language = "plain"
	else: # old ???? what does this do ???????
		if c.target_language and c.target_language in self.languageNameDict.keys():
			language = self.languageNameDict[c.target_language]
		else:
			language = "Plain"

	self.setPref("default_tangle_directory",c.tangle_directory)
	self.setPref("default_target_language",language)
	self.setPref("output_doc_chunks",`c.output_doc_flag`)
	self.setPref("page_width",`c.page_width`)
	self.setPref("run_tangle_done.py",`c.tangle_batch_flag`)
	self.setPref("run_untangle_done.py",`c.untangle_batch_flag`)
	self.setPref("tab_width",`c.tab_width`)
	self.setPref("tangle_outputs_header",`c.use_header_flag`)
	
	self.setFindPref("batch",`c.batch_flag`)
	self.setFindPref("ignore_case",`c.ignore_case_flag`)
	self.setFindPref("mark_changes",`c.mark_changes_flag`)
	self.setFindPref("mark_finds",`c.mark_finds_flag`)
	self.setFindPref("pattern_match",`c.pattern_match_flag`)
	self.setFindPref("reverse",`c.reverse_flag`)
	self.setFindPref("search_body",`c.search_body_flag`)
	self.setFindPref("search_headline",`c.search_headline_flag`)
	self.setFindPref("suboutline_only",`c.suboutline_only_flag`)
	self.setFindPref("wrap",`c.wrap_flag`)
	self.setFindPref("whole_word",`c.whole_word_flag`)
	
	self.setFindPref("change_string",c.change_text)
	self.setFindPref("find_string",c.find_text)</t>
<t tx="T2297">def open (self):
	
	config = ConfigParser.ConfigParser()
	self.config = config
	try:
		cf = open(self.configFileName)
		config.readfp(cf)
		&lt;&lt; get config options &gt;&gt;
		&lt;&lt; get recent files &gt;&gt;
		for section, dict in self.sectionInfo:
			if dict != None:
				try:
					for opt in config.options(section):
						dict[string.lower(opt)]=config.get(section,opt)
				except: pass
		&lt;&lt; print options &gt;&gt;
		cf.close()
		self.configsExist = true
	except exceptions.IOError:
		pass
	except:
		es("Exception opening " + self.configFileName)
		es_exception()
		pass
	self.config = None</t>
<t tx="T2298">@ Rewritten 10/11/02 as follows:

1. We call initConfigParam and initBooleanConfigParam to get the values.

The general purpose code will enter all these values into configDict.  This allows update() to write the configuration section without special case code.  configDict is not accessible by the user.  Rather, for greater speed the user access these values via the ivars of this class.

2. We pass the ivars themselves as params so that default initialization is done in the ctor, as would normally be expected.
@c

self.at_root_bodies_start_in_doc_mode = self.initBooleanConfigParam(
	"at_root_bodies_start_in_doc_mode",
	self.at_root_bodies_start_in_doc_mode)

self.output_initial_comment = self.initConfigParam(
	"output_initial_comment",
	self.output_initial_comment)

self.output_newline = self.initConfigParam(
	"output_newline",self.output_newline)

self.create_nonexistent_directories = self.initBooleanConfigParam(
	"create_nonexistent_directories",
	self.create_nonexistent_directories)

self.read_only = self.initBooleanConfigParam(
	"read_only",self.read_only)

self.relative_path_base_directory = self.initConfigParam(
	"relative_path_base_directory",
	self.relative_path_base_directory)

self.save_clears_undo_buffer = self.initBooleanConfigParam(
	"save_clears_undo_buffer",
	self.save_clears_undo_buffer)
	
self.stylesheet = self.initConfigParam(
	"stylesheet",
	self.stylesheet)

self.xml_version_string = self.initConfigParam(
	"xml_version_string",
	self.xml_version_string)

self.use_relative_node_indices = self.initBooleanConfigParam(
	"use_relative_node_indices",
	self.use_relative_node_indices)

self.remove_sentinels_extension = self.initConfigParam(
	"remove_sentinels_extension",
	self.remove_sentinels_extension)
	
self.use_customizeLeo_dot_py = self.initBooleanConfigParam(
	"use_customizeLeo_dot_py",
	self.use_customizeLeo_dot_py)

self.write_clone_indices = self.initBooleanConfigParam(
	"write_clone_indices",
	self.write_clone_indices)</t>
<t tx="T2299">section = self.recentFilesSection

if 0: # elegant, but may be a security hole.
	self.recentFiles = eval(config.get(section, "recentFiles"))
else: # easier to read in the config file.
	try:
		for i in xrange(10):
			self.recentFiles.append(config.get(section, "file" + `i`))
	except: pass</t>
<t tx="T2300">if 0:
	print "\n\ncolorsDict:\n" ,self.colorsDict
	print "\n\ncompareDict:\n",self.compareDict
	print "\n\nfindDict:\n"   ,self.findDict
	print "\n\nprefsDict:\n"  ,self.prefsDict
	print "\n\nwindowDict:\n" ,self.windowDict
if 0:
	print "\n\nkeysDict:\n\n"
	for i in self.keysDict.items():
		print i
if 0:
	print "\n\nwindowDict:\n\n"
	for i in self.windowDict.keys():
		print i</t>
<t tx="T2301">def update_section (self,config,section,dict):
	
	if config.has_section(section):
		config.remove_section(section)
	config.add_section(section)
	
	keys = dict.keys()
	keys.sort() # Not effective.
	for name in keys:
		val = dict [name]
		config.set(section,name,val)</t>
<t tx="T2302">@language python

from leoGlobals import *
import string,Tkinter

class leoDialog:
	@others</t>
<t tx="T2303">def __init__(self):

	self.answer = ""
	self.number = -1
	self.top = None
	self.email = None
	self.url = None
	self.text = None</t>
<t tx="T2304">def askOk(self, title, message, text="OK"):

	Tk = Tkinter ; root = app().root
	self.answer="ok"
	self.top = top = Tk.Toplevel(root)
	attachLeoIcon(self.top)
	top.title(title)
	top.resizable(0,0) # neither height or width is resizable.
	frame = Tk.Frame(top)
	if text=="OK":
		self.top.bind("&lt;Key&gt;", self.OnOkCancelKey)
	frame.pack(padx=6,pady=4)
	label = Tk.Label(frame, text=message)
	label.pack(pady=10)
	center = Tk.Frame(frame)
	center.pack()
	underline = choose(text=="OK",0,-1) # Underline character 0 if "OK", else no underlining.
	ok = Tk.Button(center,width=6,text=text,bd=4, # default button
		underline=underline,command=self.okButton)
	ok.pack(side="left",padx=5,pady=10)
	self.center() # Do this after packing.
	top.grab_set() # Make the dialog a modal dialog.
	top.focus_force() # Get all keystrokes.
	root.wait_window(top)</t>
<t tx="T2305">def askOkCancel(self, title, message):

	Tk = Tkinter ; root = app().root
	self.answer="ok"
	self.top = top = Tk.Toplevel(root)
	attachLeoIcon(self.top)
	top.title(title)
	top.resizable(0,0) # neither height or width is resizable.
	frame = Tk.Frame(top)
	self.top.bind("&lt;Key&gt;", self.OnOkCancelKey)
	frame.pack(padx=6,pady=4)
	label = Tk.Label(frame, text=message)
	label.pack(pady=10)
	center = Tk.Frame(frame)
	center.pack()
	ok = Tk.Button(center,width=6,text="OK",bd=4, # default button
		underline=0,command=self.okButton)
	cancel = Tk.Button(center,width=6,text="Cancel",
		underline=0,command=self.cancelButton)
	ok.pack(side="left",padx=5,pady=10)
	cancel.pack(side="left",padx=5,pady=10)
	self.center() # Do this after packing.
	top.grab_set() # Make the dialog a modal dialog.
	top.focus_force() # Get all keystrokes.
	root.wait_window(top)
	return self.answer</t>
<t tx="T2306">def askOkCancelNumber(self,title,message):

	Tk = Tkinter ; root = app().root
	self.number=-1
	self.top = top = Tk.Toplevel(root)
	attachLeoIcon(self.top)
	top.title(title)
	top.resizable(0,0) # neither height or width is resizable.
	frame = Tk.Frame(top)
	self.top.bind("&lt;Key&gt;", self.OnOkCancelKey)
	frame.pack(padx=6,pady=4)
	label = Tk.Label(frame,text=message)
	label.pack(pady=10,side="left")
	self.number_text = txt = Tk.Text(frame,height=1,width=10)
	txt.pack(side="left")

	center = Tk.Frame(top)
	center.pack(side="top",padx=30)
	ok = Tk.Button(center,width=6,text="OK",bd=4, # default button
		underline=0,command=self.okNumberButton)
	cancel = Tk.Button(center,width=6,text="Cancel",
		underline=0,command=self.cancelButton)
	ok.pack(side="left",padx=5,pady=10)
	cancel.pack(side="left",padx=5,pady=10)
	self.center() # Do this after packing.
	top.grab_set() # Make the dialog a modal dialog.
	top.focus_force() # Get all keystrokes.
	root.wait_window(top)
	return self.number</t>
<t tx="T2307">def askYesNo(self, title, message):

	Tk = Tkinter ; root = app().root
	self.answer="No"
	self.top = top = Tk.Toplevel(root)
	attachLeoIcon(self.top)
	top.title(title)
	top.resizable(0,0) # neither height or width is resizable.
	frame = Tk.Frame(top)
	self.top.bind("&lt;Key&gt;", self.OnYesNoKey)
	frame.pack(padx=6,pady=4)
	label = Tk.Label(frame, text=message)
	label.pack(pady=10)
	center = Tk.Frame(frame)
	center.pack()
	yes = Tk.Button(center,width=6,text="Yes",bd=4, # default button
		underline=0,command=self.yesButton)
	no = Tk.Button(center,width=6,text="No",
		underline=0,command=self.noButton)
	yes.pack(side="left",padx=5,pady=10)
	no.pack(side="left",padx=5,pady=10)
	self.center() # Do this after packing.
	top.grab_set() # Make the dialog a modal dialog.
	top.focus_force() # Get all keystrokes.
	root.wait_window(top)
	return self.answer</t>
<t tx="T2308">def askYesNoCancel(self, title, message):

	Tk = Tkinter ; root = app().root
	self.answer="cancel"
	self.top = top = Tk.Toplevel(root)
	attachLeoIcon(self.top)
	top.title(title)
	top.resizable(0,0) # neither height or width is resizable.
	frame = Tk.Frame(top)
	self.top.bind("&lt;Key&gt;", self.OnYesNoCancelKey)
	frame.pack(padx=6,pady=4)
	label = Tk.Label(frame, text=message)
	label.pack(pady=10)
	center = Tk.Frame(frame)
	center.pack()
	yes = Tk.Button(center,width=6,text="Yes",bd=4, # default button
		underline=0,command=self.yesButton)
	no = Tk.Button(center,width=6,text="No",
		underline=0,command=self.noButton)
	cancel = Tk.Button(center,width=6,text="Cancel",
		underline=0,command=self.cancelButton)
	yes.pack(side="left",padx=5,pady=10)
	no.pack(side="left",padx=5,pady=10)
	cancel.pack(side="left",padx=5,pady=10)
	self.center() # Do this after packing.
	top.grab_set() # Make the dialog a modal dialog.
	top.focus_force() # Get all keystrokes.
	root.wait_window(top)
	return self.answer</t>
<t tx="T2309">def center(self):
	
	center_dialog(self.top)
	return</t>
<t tx="T2310">
</t>
<t tx="T2311"># Command handlers.

def cancelButton(self):
	self.answer="cancel"
	self.top.destroy() # terminates wait_window
	
def noButton(self):
	self.answer="no"
	self.top.destroy() # terminates wait_window
	
def okButton(self):
	self.answer="ok"
	self.top.destroy() # terminates wait_window

def yesButton(self):
	self.answer="yes"
	self.top.destroy() # terminates wait_window</t>
<t tx="T2312">def OnOkCancelKey(self,event):
	ch=string.lower(event.char)
	if ch=='\n' or ch=='\r': self.okButton() # The default
	elif ch=='c': self.cancelButton()
	elif ch=='o': self.okButton()
	return "break"

def OnYesNoKey(self,event):
	ch=string.lower(event.char)
	if ch=='\n' or ch=='\r': self.yesButton() # The default
	elif ch=='n': self.noButton()
	elif ch=='y': self.yesButton()
	return "break"
	
def OnYesNoCancelKey(self,event):
	ch=string.lower(event.char)
	if ch=='\n' or ch=='\r': self.yesButton() # The default
	elif ch=='c': self.cancelButton()
	elif ch=='n': self.noButton()
	elif ch=='y': self.yesButton()
	return "break"</t>
<t tx="T2313">def setArrowCursor (self,event=None):
	
	if self.text:
		self.text.configure(cursor="arrow")
	
def setDefaultCursor (self,event=None):
	
	if self.text:
		self.text.configure(cursor="xterm")</t>
<t tx="T2314">def okNumberButton(self):

	t = self.number_text.get("1.0","end")
	try:
		self.number=int(t)
	except:
		es("invalid line number:" + t)
		self.number=-1
	self.top.destroy() # terminates wait_window
	
def cancelButton(self):
	self.number=-1
	self.top.destroy() # terminates wait_window</t>
<t tx="T2315">@language python

from leoGlobals import *
import leoDialog,leoNodes
import os,os.path,time

@ The list of language names that are written differently from the names in language_delims_dict in leoGlobals.py.  This is needed for compatibility with the borland version of Leo.

We convert from names in xml_language_names to names in language_delims_dict by converting the name to lowercase and by removing slashes.
@c

xml_language_names = (
	"CWEB","C","HTML","Java","LaTeX",
	"Pascal","PerlPod","Perl","Plain","Python","tcl/tk")

class BadLeoFile:
	def __init__(self, message):
		self.message = message
	def __str__(self):
		return "Bad Leo File:" + self.message

class fileCommands:
	@others</t>
<t tx="T2316">def __init__(self,commands):

	# trace("__init__", "fileCommands.__init__")
	self.commands = commands
	self.frame = commands.frame
	self.initIvars()

def initIvars(self):

	# General
	self.maxTnodeIndex = 0
	self.numberOfTnodes = 0
	self.topVnode = None
	self.mFileName = ""
	self.fileDate = -1
	# For reading
	self.fileFormatNumber = 0
	self.ratio = 0.5
	self.tnodesDict = {}
	self.fileBuffer = None ; self.fileIndex = 0
	self.dummy_v = None
	self.dummy_t = None
	# For writing
	self.read_only = false
	self.outputFile = None # File for normal writing
	self.outputString = None # String for pasting
	self.openDirectory = None
	self.usingClipboard = false</t>
<t tx="T2317">def assignFileIndices (self):

	c=self.commands ; v = c.rootVnode()
	while v:
		t = v.t
		# 8/28/99.  Write shared tnodes even if they are empty.
		if t.hasBody() or v.getJoinList():
			if t.fileIndex == 0:
				self.maxTnodeIndex += 1
				t.setFileIndex(self.maxTnodeIndex)
		else:
			t.setFileIndex(0)
		v = v.threadNext()</t>
<t tx="T2318">def compactFileIndices (self):

	c = self.commands ; v = c.rootVnode()
	self.maxTnodeIndex = 0
	while v: # Clear all indices.
		v.t.setFileIndex(0)
		v = v.threadNext()
	v = c.rootVnode()
	while v: # Set indices for all tnodes that will be written.
		t = v.t
		if t.hasBody() or v.getJoinList(): # 8/28/99. Write shared tnodes even if they are empty.
			if t.fileIndex == 0:
				self.maxTnodeIndex += 1
				t.setFileIndex(self.maxTnodeIndex)
		v = v.threadNext()</t>
<t tx="T2319">@ This method sets policy for when we should compact a file before doing a Save Command.
@c

def shouldCompactOnSave (self):

	c=self.commands
	# Count the number of tnodes used
	c.clearAllVisited()
	v = c.rootVnode() ; tnodesUsed = 0
	while v:
		t = v.t
		if t and not t.isVisited():
			tnodesUsed += 1
			t.setVisited()
		v = v.threadNext()
	tnodesUnused = self.maxTnodeIndex - tnodesUsed
	return tnodesUnused &gt; 100</t>
<t tx="T2320">def putClipboardHeader (self):

	tnodes = 0
	&lt;&lt; count the number of tnodes &gt;&gt;
	self.put('&lt;leo_header file_format="1" tnodes=')
	self.put_in_dquotes(`tnodes`)
	self.put(" max_tnode_index=")
	self.put_in_dquotes(`tnodes`)
	self.put("/&gt;") ; self.put_nl()</t>
<t tx="T2321">c=self.commands
c.clearAllVisited()

# Count the vnode and tnodes.
v = c.currentVnode()
after = v.nodeAfterTree()
while v and v != after:
	t = v.t
	if t and not t.isVisited() and (t.hasBody() or v.getJoinList()):
		t.setVisited()
		tnodes += 1
	v = v.threadNext()</t>
<t tx="T2322">@ Surprisingly, the call to xmlEscape here is _much_ faster than calling put for each characters of s.
@c

def putEscapedString (self,s):

	if s and len(s) &gt; 0:
		self.put(self.xmlEscape(s))</t>
<t tx="T2323">def putGlobals (self):

	c=self.commands
	self.put("&lt;globals")
	&lt;&lt; put the body/outline ratio &gt;&gt;
	self.put("&gt;") ; self.put_nl()
	&lt;&lt; put the position of this frame &gt;&gt;
	&lt;&lt; put the position of the log window &gt;&gt;
	self.put("&lt;/globals&gt;") ; self.put_nl()</t>
<t tx="T2324"># Puts an innumerate number of digits

self.put(" body_outline_ratio=") ; self.put_in_dquotes(`c.frame.ratio`)</t>
<t tx="T2325">width,height,left,top = get_window_info(self.frame.top)
# print ("t,l,h,w:" + `top` + ":" + `left` + ":" + `height` + ":" + `width`)

self.put_tab()
self.put("&lt;global_window_position")
self.put(" top=") ; self.put_in_dquotes(`top`)
self.put(" left=") ; self.put_in_dquotes(`left`)
self.put(" height=") ; self.put_in_dquotes(`height`)
self.put(" width=") ; self.put_in_dquotes(`width`)
self.put("/&gt;") ; self.put_nl()</t>
<t tx="T2326">top = left = height = width = 0 # no longer used
self.put_tab()
self.put("&lt;global_log_window_position")
self.put(" top=") ; self.put_in_dquotes(`top`)
self.put(" left=") ; self.put_in_dquotes(`left`)
self.put(" height=") ; self.put_in_dquotes(`height`)
self.put(" width=") ; self.put_in_dquotes(`width`)
self.put("/&gt;") ; self.put_nl()</t>
<t tx="T2327">def putHeader (self):

	tnodes = 0 ; clone_windows = 0 # Always zero in Leo2.

	self.put("&lt;leo_header")
	self.put(" file_format=") ; self.put_in_dquotes("2")
	self.put(" tnodes=") ; self.put_in_dquotes(`tnodes`)
	self.put(" max_tnode_index=") ; self.put_in_dquotes(`self.maxTnodeIndex`)
	self.put(" clone_windows=") ; self.put_in_dquotes(`clone_windows`)
	self.put("/&gt;") ; self.put_nl()</t>
<t tx="T2328"># Writes a Leo outline to s in a format suitable for pasting to the clipboard.

def putLeoOutline (self):

	self.outputString = "" ; self.outputFile = None
	self.usingClipboard = true
	# self.assignFileIndices() // The caller does this.
	self.putProlog()
	self.putClipboardHeader()
	self.putVnodes()
	self.putTnodes()
	self.putPostlog()
	s = self.outputString
	self.outputString = None
	self.usingClipboard = false
	return s</t>
<t tx="T2329">def putPostlog (self):

	self.put("&lt;/leo_file&gt;") ; self.put_nl()</t>
<t tx="T2330">@ This method puts all tnodes in index order.  All tnode indices must have been assigned at this point.
@c
def putTnodes (self):

	c=self.commands
	tnodes = {}
	if self.usingClipboard: # write the current tree.
		v = c.currentVnode() ; after = v.nodeAfterTree()
	else: # write everything
		v = c.rootVnode() ; after = None
	# Populate tnodes
	while v and v != after:
		index = v.t.fileIndex
		if index &gt; 0 and not tnodes.has_key(index):
			tnodes[index] = v.t
		v = v.threadNext()
	# Put all tnodes in index order.
	self.put("&lt;tnodes&gt;") ; self.put_nl()
	#
	keys = tnodes.keys() ; keys.sort()
	for index in keys:
		t = tnodes[index]
		assert(t)
		# New for Leo2: write only those tnodes whose vnodes were written.
		if t.isVisited(): self.putTnode(t)
	#
	self.put("&lt;/tnodes&gt;") ; self.put_nl()</t>
<t tx="T2331">def putTnode (self,t):

	self.put("&lt;t tx=") ; self.put_in_dquotes("T" + `t.fileIndex`)
	self.put("&gt;")
	if t and t.bodyString and len(t.bodyString) &gt; 0:
		self.putEscapedString(t.bodyString)
	self.put("&lt;/t&gt;") ; self.put_nl()</t>
<t tx="T2332">@ This method puts all vnodes by starting the recursion.  putVnode will write all vnodes in the order in which they appear in the outline.
@c
def putVnodes (self):

	c=self.commands
	c.clearAllVisited()

	self.put("&lt;vnodes&gt;") ; self.put_nl()
	if self.usingClipboard:
		self.putVnode(
			c.currentVnode(), # Write only current tree.
			None) # Don't write top vnode status bit.
	else: 
		v = c.rootVnode()
		while v:
			self.putVnode(
				v, # Write the next top-level node.
				c.tree.topVnode) # Write the top-vnode status bit.
			v = v.next()
	self.put("&lt;/vnodes&gt;") ; self.put_nl()</t>
<t tx="T2333">@ This writes full headline and body text for all vnodes, even orphan and @ignored nodes.  This allows all Leo outlines to be used as backup files.
@c

def putVnode (self,v,topVnode):

	c = self.commands
	self.put("&lt;v")
	&lt;&lt; Put tnode index if this vnode has body text &gt;&gt;
	&lt;&lt; Put attribute bits &gt;&gt;
	self.put("&gt;")
	&lt;&lt; write the head text &gt;&gt;
	child = v.firstChild()
	if child:
		self.put_nl()
		while child:
			self.putVnode(child,topVnode)
			child = child.next()
	self.put("&lt;/v&gt;") ; self.put_nl()</t>
<t tx="T2334">t = v.t
if t and (t.hasBody() or v.getJoinList()):
	if t.fileIndex &gt; 0:
		self.put(" t=") ; self.put_in_dquotes("T" + `t.fileIndex`)
		v.t.setVisited() # Indicate we wrote the body text.
	else:
		es("error writing file(bad vnode)!")
		es("try using the Save To command")</t>
<t tx="T2335"># Dummy vnodes carry all attributes.
current = c.currentVnode()
top = topVnode
if ( v.isCloned() or v.isExpanded() or v.isMarked() or
	v == current or v == top ):
	self.put(" a=") ; self.put_dquote()
	if v.isCloned(): self.put("C")
	if v.isExpanded(): self.put("E")
	if v.isMarked(): self.put("M")
	if v.isOrphan(): self.put("O")
	if v == top: self.put("T")
	if v == current: self.put("V")
	self.put_dquote()</t>
<t tx="T2336">headString = v.headString()
if len(headString) &gt; 0:
	self.put("&lt;vh&gt;")
	self.putEscapedString(headString)
	self.put("&lt;/vh&gt;")</t>
<t tx="T2337">def save(self,fileName):

	c=self.commands
	c.beginUpdate()
	if 1: # within update...
		c.endEditing()# Set the current headline text.
		self.compactFileIndices() # 1/14/02: always recompute file indices
		&lt;&lt; Set the default directory for new files &gt;&gt;
		if self.write_LEO_file(fileName,false): # outlineOnlyFlag
			c.setChanged(false) # Clears all dirty bits.
			es("saved: " + shortFileName(fileName))
			if app().config.save_clears_undo_buffer:
				es("clearing undo")
				c.undoer.clearUndoState()
	c.endUpdate()</t>
<t tx="T2338"># 8/13/02: Set c.openDirectory for new files for the benefit of leoAtFile.scanAllDirectives.

if not c.openDirectory or len(c.openDirectory) == 0:
	dir = os.path.dirname(fileName) 
	if len(dir) &gt; 0 and os.path.isabs(fileName) and os.path.exists(fileName):
		c.openDirectory = dir</t>
<t tx="T2339">def saveAs(self,fileName):

	c=self.commands
	c.beginUpdate()
	if 1: # within update...
		c.endEditing() # Set the current headline text.
		self.compactFileIndices()
		if self.write_LEO_file(fileName,false): # outlineOnlyFlag
			c.setChanged(false) # Clears all dirty bits.
			es("saved: " + shortFileName(fileName))
	c.endUpdate()</t>
<t tx="T2340">def saveTo (self,fileName):

	c=self.commands
	c.beginUpdate()
	if 1: # within update...
		c.endEditing()# Set the current headline text.
		self.compactFileIndices()
		if self.write_LEO_file(fileName,false): # outlineOnlyFlag
			es("saved: " + shortFileName(fileName))
	c.endUpdate()</t>
<t tx="T2341"># Surprisingly, this is a time critical routine.

def xmlEscape(self,s):

	assert(s and len(s) &gt; 0) # check is made in putEscapedString
	s = string.replace(s, '\r', '')
	s = string.replace(s, '&amp;', "&amp;amp;")
	s = string.replace(s, '&lt;', "&amp;lt;")
	s = string.replace(s, '&gt;', "&amp;gt;")
	return s</t>
<t tx="T2342">def writeAtFileNodes (self):

	c = self.commands ; v = c.currentVnode()
	if v:
		at = c.atFileCommands
		at.writeAll(v,true) # partialFlag</t>
<t tx="T2343">def writeOutlineOnly (self):

	c=self.commands
	c.endEditing()
	self.compactFileIndices()
	self.write_LEO_file(self.mFileName,true) # outlineOnlyFlag</t>
<t tx="T2344">@language python

&lt;&lt; Theory of operation of find/change &gt;&gt;

from leoGlobals import *
import Tkinter,types

# Abbreviations
set_undo_params = true ; dont_set_undo_params = false
all = true

#define is_word(c)(isalnum(c)or(c)== '_')

# The names of the actual ivars have "_flag" appended to these.
# Note: batch_flag now records the "context" checkbox.
ivars = [
	"batch", "wrap", "whole_word", "ignore_case", "node_only",
	"pattern_match", "search_headline", "search_body",
	"suboutline_only", "mark_changes", "mark_finds", "reverse" ]

class LeoFind:
	@others</t>
<t tx="T2345">def OnCloseFindEvent(self):

	self.top.withdraw()</t>
<t tx="T2346">@language python

from leoGlobals import *
import exceptions,sys,string,Tkinter,tkFont

class leoFontPanel:
	@others</t>
<t tx="T2347">def __init__ (self,c):
	
	Tk = Tkinter
	self.commands = c
	self.frame = c.frame
	self.default_font = "Courier"
	self.last_selected_font = None
	self.setRevertVars()
	# Variables to track values of style checkboxes.
	self.sizeVar = Tk.IntVar()
	self.boldVar = Tk.IntVar()
	self.italVar = Tk.IntVar()
	# Variables to track values of pane checkboxes.
	self.bodyVar = Tk.IntVar()
	self.logVar = Tk.IntVar()
	self.treeVar = Tk.IntVar()
	# Slots for callbacks
	self.listBoxIndex = 0
	self.family_list_box = None
	self.size_entry = None
	self.example_entry = None
	self.outer = None</t>
<t tx="T2348">def create_outer(self):

	Tk = Tkinter
	top = self.top
	&lt;&lt; Create the organizer frames &gt;&gt;
	&lt;&lt; create the font pane &gt;&gt;
	&lt;&lt; create the checkboxes &gt;&gt;
	&lt;&lt; create Ok, Cancel and Revert buttons &gt;&gt;</t>
<t tx="T2349">self.outer = outer = Tk.Frame(top,bd=2,relief="groove",width="8i")
outer.pack(padx=2,pady=2,expand=1,fill="both")

upper = Tk.Frame(outer)
upper.pack(fill="both",expand=1)

lt = Tk.Frame(upper)
lt.pack(side="left",fill="both",expand=1)

rt = Tk.Frame(upper)
rt.pack(side="right",anchor="n",padx=4) # Not filling or expanding centers contents.

# Not filling or expanding centers contents.
# padx=20 gives more room to the Listbox in the lt frame!
lower = Tk.Frame(outer)
lower.pack(side="top",anchor="w",padx=20)</t>
<t tx="T2350"># Create the list box and its scrollbar.
self.family_list_box = box = Tk.Listbox(lt,height=7)

# Fill the listbox to set the width.
names = tkFont.families()
names = list(names)
names.sort()
for name in names:
	box.insert("end", name)

box.pack(padx=4,pady=4,fill="both",expand=1)
box.bind("&lt;Double-Button-1&gt;", self.update)

bar = Tk.Scrollbar(box)
bar.pack(side="right", fill="y")

bar.config(command=box.yview)
box.config(yscrollcommand=bar.set)</t>
<t tx="T2351"># Create the style checkboxes.
for text,var in (
	("Bold",self.boldVar),
	("Italic",self.italVar)):

	b = Tk.Checkbutton(rt,text=text,variable=var,command=self.update)
	b.pack(side="top",anchor="w")

# Create the size label and entry widget.
row = Tk.Frame(rt)
row.pack(side="top")

lab = Tk.Label(row,text="Size:")
lab.pack(side="left")

self.size_entry = e = Tk.Entry(row,width=4)
e.pack(side="left")
e.bind("&lt;Key&gt;",self.onSizeEntryKey)

# Create the pane checkboxes.
for text,var,command in (
	("Body",self.bodyVar,self.onBodyBoxChanged),
	("Outline",self.treeVar,self.onTreeBoxChanged),
	("Log",self.logVar,self.onLogBoxChanged)):
		
	b = Tk.Checkbutton(rt,text=text,variable=var,command=command)
	b.pack(side="top",anchor="w")</t>
<t tx="T2352">for name,command in (
	("OK",self.onOk),
	("Cancel",self.onCancel),
	("Revert",self.onRevert)):
		
	b = Tk.Button(lower,width=7,text=name,command=command)
	b.pack(side="left",anchor="w",pady=6,padx=4,expand=0) #,fill="y")</t>
<t tx="T2353">def finishCreate (self):
	
	# These do not get changed when reverted.
	self.bodyVar.set(1)
	self.logVar.set(0)
	self.treeVar.set(0)
	
	# All other vars do change when reverted.
	self.revertIvars()
	self.update()
</t>
<t tx="T2354">@ Returns a font corresponding to present visual state of the font panel.  As a benign side effect, this routine selects the font in the list box.

Alas, the selection in the list box may have been cleared.  In that case, we must figure out what it should be. We recreate the family name (and only the family name!) from self.last_selected_font, or in an emergency the font returned from getImpliedFont().
@c

def getActiveFont (self):

	box = self.family_list_box
	family = font = None

	# Get the family name if possible, or font otherwise.
	items = box.curselection()
	if len(items) == 0:
		# Nothing selected.
		if self.last_selected_font:
			font =self.last_selected_font
		else:
			font = self.getImpliedFont()
	else:
		try: # This shouldn't fail now.
			items = map(int, items)
			family = box.get(items[0])
		except:
			es("unexpected exception")
			es_exception()
			font = self.getImpliedFont()
	# At this point we either have family or font.
	assert(font or family)
	if not family:
		# Extract the family from the computed font.
		family,junk,junk,junk = self.getFontSettings(font)
	# At last we have a valid family name!
	# Get all other font settings from the font panel.
	bold = self.boldVar.get()
	ital = self.italVar.get()
	size = self.sizeVar.get()
	# trace(`size`)
	slant=choose(ital,"italic","roman")
	weight=choose(bold,"bold","normal")
	# Compute the font from all the settings.
	font = tkFont.Font(family=family,size=size,slant=slant,weight=weight)
	self.selectFont(font)
	return font</t>
<t tx="T2355">def getFontSettings (self, font):

	name   = font.cget("family")
	size   = font.cget("size")
	slant  = font.cget("slant")
	weight = font.cget("weight")

	return name, size, slant, weight</t>
<t tx="T2356"># If a single pane's checkbox is checked, select that pane's present font.
# Otherwise, select the present font of some checked pane, it doesn't much matter which.
# If none are check, select the body pane's present font.

def getImpliedFont (self):

	c = self.commands

	body = self.bodyVar.get()
	log  = self.logVar.get()
	tree = self.treeVar.get()
	
	fn = c.body.cget("font")
	bodyFont = tkFont.Font(font=fn)
	fn = c.log.cget("font")
	logFont = tkFont.Font(font=fn)
	treeFont = c.tree.getFont()
	
	if log and not body and not tree:
		font = logFont
	elif tree and not body and not log:
		font = treeFont
	elif body: font = bodyFont
	elif tree: font = treeFont
	elif log:  font = logFont # Exercise for the reader: prove this case will never happen.
	else:      font = bodyFont
	return font</t>
<t tx="T2357">@ We define these routines so that changing one pane box affects only that pane.

When we turn a box on, we expect that the present font will instantly apply to the new pane, and when we turn a box off we call implied font to see which font should be highlighted and we revert the pane's font. It is crucial that unchecking a box be equivalent to a "small revert".  This is the _only_ scheme that isn't confusing to the user.

Note: if we just called update instead of these routines we could do something unexpected after after a revert.  For example, suppose all three pane boxes are checked and we do a revert.  If we then uncheck a box, we expect only that pane to change, but if we call update the other two panes might also change...
@c
def onBodyBoxChanged(self):
	font = choose(self.bodyVar.get(),
		self.getActiveFont(),self.revertBodyFont)
	self.commands.body.configure(font=font)

def onLogBoxChanged(self):
	font = choose(self.logVar.get(),
		self.getActiveFont(),self.revertLogFont)
	self.commands.log.configure(font=font)
		
def onTreeBoxChanged(self):
	c = self.commands
	font = choose(self.treeVar.get(),
		self.getActiveFont(),self.revertTreeFont)
	c.tree.setFont(font=font)
	c.redraw()</t>
<t tx="T2358">def onSizeEntryKey (self,event=None):
	
	self.size_entry.after_idle(self.idle_entry_key)
	
def idle_entry_key (self):
	
	size = self.size_entry.get() # Doesn't work until idle time.
	try:
		size = int(size)
	except: # This just means the user didn't type a valid number.
		return
	# trace(`size`)
	self.sizeVar.set(size)
	if 0 &lt; size &lt; 100: # Choosing very small or large fonts drives Tk crazy.
		self.update()</t>
<t tx="T2359">def revertIvars (self):
	
	c = self.commands
	# Revert the fonts themselves in the various panes.
	font = self.revertBodyFont
	c.body.configure(font=font)
	font = self.revertLogFont
	c.log.configure(font=font)
	font = self.revertTreeFont
	c.tree.setFont(font=font)
	# Revert the setting of the items in the font panel
	self.last_selected_font = None # Use the font for the selected panes.
	font = self.getImpliedFont()
	self.selectFont(font)
	try:
		name, size, slant, weight = self.getFontSettings(font)
		size=int(size)
	except: pass
	self.sizeVar.set(size)
	self.boldVar.set(choose(weight=="bold",1,0))
	self.italVar.set(choose(slant=="italic",1,0))
	
	e = self.size_entry
	e.delete(0,"end")
	e.insert(0,`size`)</t>
<t tx="T2360">def run (self):
	
	Tk = Tkinter ; c = self.commands
	self.top = top = Tk.Toplevel(app().root)
	attachLeoIcon(top)
	top.title("Fonts for " + shortFileName(c.frame.title))
	top.protocol("WM_DELETE_WINDOW", self.onOk)
	self.create_outer()
	
	# This must be done _after_ the dialog has been built!
	w,h,x,y = center_dialog(top)
	top.wm_minsize(height=h,width=w)
	
	# Finish up after the dialog is frozen.
	self.outer.after_idle(self.finishCreate)

	if 0: # The pane now looks decent when resized!
		top.resizable(0,0)

	# Bring up the dialog.
	if 0: # It need not be modal: it will go away if the owning window closes!
		top.grab_set()
		top.focus_force() # Get all keystrokes.</t>
<t tx="T2361">def selectFont (self,font):
	
	box = self.family_list_box
	
	# All selections come here.
	self.last_selected_font = font

	# The name should be on the list!
	name, size, slant, weight = self.getFontSettings(font)
	for i in xrange(0,box.size()):
		item = box.get(i)
		if name == item:
			box.select_clear(0,"end")
			box.select_set(i)
			box.see(i)
			self.last_selected_font = font
			# trace(name)
			return
	# print "not found:" + name</t>
<t tx="T2362">def setRevertVars (self):
	
	c = self.commands
	
	# Variables for revert.
	fn = c.body.cget("font")
	self.revertBodyFont = tkFont.Font(font=fn)
	
	fn = c.log.cget("font")
	self.revertLogFont = tkFont.Font(font=fn)
	
	self.revertTreeFont = c.tree.getFont()</t>
<t tx="T2363"># Write all settings to the log panel.
# Note that just after a revert all three setting may be different.

def showSettings (self):
	c = self.commands
	es("---------------")
	# Body pane.
	fn = c.body.cget("font")
	font = tkFont.Font(font=fn)
	name,size,slant,weight = self.getFontSettings(font)
	es("body font:" + name + "," + `size` + "," + slant + "," + weight)
	# Log pane.
	fn = c.log.cget("font")
	font = tkFont.Font(font=fn)
	name,size,slant,weight = self.getFontSettings(font)
	es("log font:" + name + "," + `size` + "," + slant + "," + weight)
	# Tree pane.
	font = c.tree.getFont()
	name,size,slant,weight = self.getFontSettings(font)
	es("headline font:" + name + "," + `size` + "," + slant + "," + weight)</t>
<t tx="T2364"># Updates size box and example box when something changes.

def update (self,event=None):
	
	c = self.commands
	size = self.sizeVar.get()
	
	# Insert the new text in the size box.
	e = self.size_entry
	e.delete(0,"end")
	e.insert(0,`size`)
	
	font = self.getActiveFont()
	
	if not self.bodyVar.get() and not self.logVar.get() and not self.treeVar.get():
		es("no pane selected")

	f = choose(self.bodyVar.get(),font,self.revertBodyFont)
	self.commands.body.configure(font=f)
	
	f = choose(self.logVar.get(),font,self.revertLogFont)
	self.commands.log.configure(font=f)
	
	f = choose(self.treeVar.get(),font,self.revertTreeFont)
	c.tree.setFont(font=f)
	c.redraw()</t>
<t tx="T2365"># To do: Use config params for window height, width and bar color, relief and width.

@language python

__pychecker__ = 'argumentsused=0' # Pychecker param.

from leoGlobals import *
import leoColor,leoCommands,leoCompare,leoDialog,leoFontPanel,leoNodes,leoPrefs,leoTree
import os,string,sys,Tkinter,tkFileDialog,tkFont

class LeoFrame:
	@others</t>
<t tx="T2366">def __repr__ (self):

	return "leoFrame: " + self.title
</t>
<t tx="T2367">def configureBar (self, bar, verticalFlag):
	
	config = app().config

	# Get configuration settings.
	w = config.getWindowPref("split_bar_width")
	if not w or w &lt; 1: w = 7
	relief = config.getWindowPref("split_bar_relief")
	if not relief: relief = "flat"
	color = config.getWindowPref("split_bar_color")
	if not color: color = "LightSteelBlue2"

	try:
		if verticalFlag:
			# Panes arranged vertically; horizontal splitter bar
			bar.configure(relief=relief,height=w,bg=color,cursor="sb_v_double_arrow")
		else:
			# Panes arranged horizontally; vertical splitter bar
			bar.configure(relief=relief,width=w,bg=color,cursor="sb_h_double_arrow")
	except: # Could be a user error. Use all defaults
		es("exception in user configuration for splitbar")
		es_exception()
		if verticalFlag:
			# Panes arranged vertically; horizontal splitter bar
			bar.configure(height=7,cursor="sb_v_double_arrow")
		else:
			# Panes arranged horizontally; vertical splitter bar
			bar.configure(width=7,cursor="sb_h_double_arrow")</t>
<t tx="T2368">def setTreeColorsFromConfig (self):
	
	config = app().config ; tree = self.tree

	bg = config.getWindowPref("outline_pane_background_color")
	if bg:
		try: self.canvas.configure(bg=bg)
		except: pass
</t>
<t tx="T2369">def reconfigurePanes (self):
	
	border = app().config.getIntWindowPref('additional_body_text_border')
	if border == None: border = 0
	
	# The body pane needs a _much_ bigger border when tiling horizontally.
	border = choose(self.splitVerticalFlag,2+border,6+border)
	self.body.configure(bd=border)
	
	# The log pane needs a slightly bigger border when tiling vertically.
	border = choose(self.splitVerticalFlag,4,2) 
	self.log.configure(bd=border)</t>
<t tx="T2370">def longFileName (self):
	return self.mFileName
	
def shortFileName (self):
	return shortFileName(self.mFileName)</t>
<t tx="T2371"># Returns the frame that has focus, or body if None.

def getFocus(self):

	f = self.top.focus_displayof()
	if f:
		return f
	else:
		return self.body</t>
<t tx="T2372">def notYet(self,name):

	es(name + " not ready yet")
</t>
<t tx="T2373"># Global constants, variables and utility functions used throughout Leo.

@language python
import exceptions,os,re,string,sys,time,types,Tkinter

&lt;&lt; define general constants &gt;&gt;

@others</t>
<t tx="T2374">body_newline = '\n'
body_ignored_newline = '\r'

try:
	true = True
	false = False
except:
	# print "True and False not defined"
	true = 1
	false = 0 # Better than None

assert(false!=None)</t>
<t tx="T2375"># WARNING: Call this routine _after_ creating a dialog.
# (This routine inhibits the grid and pack geometry managers.)

def get_window_info (top):
	
	top.update_idletasks() # Required to get proper info.

	# Get the information about top and the screen.
	geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
	dim,x,y = string.split(geom,'+')
	w,h = string.split(dim,'x')
	w,h,x,y = int(w),int(h),int(x),int(y)
	
	return w,h,x,y</t>
<t tx="T2376"># Center the dialog on the screen.
# WARNING: Call this routine _after_ creating a dialog.
# (This routine inhibits the grid and pack geometry managers.)

def center_dialog(top):

	sw = top.winfo_screenwidth()
	sh = top.winfo_screenheight()
	w,h,x,y = get_window_info(top)
	
	# Set the new window coordinates, leaving w and h unchanged.
	x = (sw - w)/2
	y = (sh - h)/2
	top.geometry("%dx%d%+d%+d" % (w,h,x,y))
	
	return w,h,x,y</t>
<t tx="T2377">@ Returns (delim1, delim2, delim2), the delims following the @comment directive.

This code can be called from @languge logic, in which case s can point at @comment
@c

def set_delims_from_string(s):
	
	# trace(`s`)

	# Skip an optional @comment
	tag = "@comment"
	i = 0
	if match_word(s,i,tag):
		i += len(tag)
		
	count = 0 ; delims = [None, None, None]
	while count &lt; 3 and i &lt; len(s):
		i = j = skip_ws(s,i)
		while i &lt; len(s) and not is_ws(s[i]) and not is_nl(s,i):
			i += 1
		if j == i: break
		delims[count] = s[j:i]
		count += 1
		
	# 'rr 09/25/02
	if count == 2: # delims[0] is always the single-line delim.
		delims[2] = delims[1]
		delims[1] = delims[0]
		delims[0] = None

	# 7/8/02: The "REM hack": replace underscores by blanks.
	# 9/25/02: The "perlpod hack": replace double underscores by newlines.
	for i in xrange(0,3):
		if delims[i]:
			delims[i] = string.replace(delims[i],"__",'\n') 
			delims[i] = string.replace(delims[i],'_',' ')

	return delims[0], delims[1], delims[2]</t>
<t tx="T2378">@ We search the descendents of v looking for the definition node matching name.
There should be exactly one such node (descendents of other definition nodes are not searched).
@c

def findReference(name,root):

	after = root.nodeAfterTree()
	v = root.firstChild()
	while v and v != after:
		if v.matchHeadline(name) and not v.isAtIgnoreNode():
			return v
		v = v.threadNext()
	return None
</t>
<t tx="T2379">@ sequence is a sequence of items, each of which is a sequence containing at least n elements.
returns a list of the the items sorted on the n'th element of each tuple.
@c

def sortSequence (sequence, n):

	keys = [] ; links = {}
	for item in sequence:
		key = item[n]
		links[key] = item
		keys.append(key)
	keys.sort() ; sorted = []
	for key in keys:
		sorted.append(links[key])
	return sorted
	
@ The sort() method takes an optional argument specifying a comparison function of two arguments (list items) which should return -1, 0 or 1 depending on whether the first argument is considered smaller than, equal to, or larger than the second argument.

Note that this slows the sorting process down considerably; e.g. to sort a list in reverse order it is much faster to use calls to the methods sort() and reverse() than to use the built-in function sort() with a comparison function that reverses the ordering of the elements.

So a "clever" solution wouldn't be so clever after all.
@c
</t>
<t tx="T2380">def alert(message):

	es(message)

	import tkMessageBox
	tkMessageBox.showwarning("Alert", message)
</t>
<t tx="T2381"># Returns &lt; &lt; s &gt; &gt;

def angleBrackets(s):

	return ( "&lt;&lt;" + s +
		"&gt;&gt;") # must be on a separate line.

virtual_event_name = angleBrackets</t>
<t tx="T2382">def dump(s):
	
	out = ""
	for i in s:
		out += `ord(i)` + ","
	return out
		
def oldDump(s):

	out = ""
	for i in s:
		if i=='\n':
			out += "[" ; out += "n" ; out += "]"
		if i=='\t':
			out += "[" ; out += "t" ; out += "]"
		elif i==' ':
			out += "[" ; out += " " ; out += "]"
		else: out += i
	return out</t>
<t tx="T2383">def es_exception (full=false):

	import traceback
	typ,val,tb = sys.exc_info()
	if full:
		errList = traceback.format_exception(typ,val,tb)
	else:
		errList = traceback.format_exception_only(typ,val)
	for i in errList:
		es(i)
	traceback.print_exc()</t>
<t tx="T2384"># Very useful for tracing.

def get_line (s,i):

	nl = ""
	if is_nl(s,i):
		i = skip_nl(s,i)
		nl = "[nl]"
	j = find_line_start(s,i)
	k = skip_to_end_of_line(s,i)
	return nl + s[j:k]
	
def get_line_after (s,i):
	
	nl = ""
	if is_nl(s,i):
		i = skip_nl(s,i)
		nl = "[nl]"
	k = skip_to_end_of_line(s,i)
	return nl + s[i:k]
</t>
<t tx="T2385">def print_bindings (name,window):

	bindings = window.bind()
	print
	print "Bindings for", name
	for b in bindings:
		print b</t>
<t tx="T2386">def printGlobals(message=None):
	
	# Get the list of globals.
	globs = list(globals())
	globs.sort()
	
	# Print the list.
	if message:
		leader = "-" * 10
		print leader, ' ', message, ' ', leader
	for glob in globs:
		print glob</t>
<t tx="T2387">def printLeoModules(message=None):
	
	# Create the list.
	mods = []
	for name in sys.modules.keys():
		if name and name[0:3] == "leo":
			mods.append(name)

	# Print the list.
	if message:
		leader = "-" * 10
		print leader, ' ', message, ' ', leader
	mods.sort()
	for m in mods:
		print m,
	print</t>
<t tx="T2388">@ Starting with this release, you will see trace statements throughout the code.  The trace function is defined in leoGlobals.py; trace implements much of the functionality of my Sherlock tracing package.  Traces are more convenient than print statements for two reasons: 1) you don't need explicit trace names and 2) you can disable them without recompiling.

In the following examples, suppose that the call to trace appears in function f.

trace(string) prints string if tracing for f has been enabled.  For example, the following statment prints from s[i] to the end of the line if tracing for f has been enabled.

	j = skip_line(s,i) ; trace(s[i:j])

trace(function) exectutes the function if tracing for f has been enabled.  For example,

	trace(self.f2)

You enable and disable tracing by calling init_trace(args).  Examples:

	init_trace("+*")         # enable all traces
	init_trace("+a","+b")    # enable traces for a and b
	init_trace(("+a","+b"))  # enable traces for a and b
	init_trace("-a")         # disable tracing for a
	traces = init_trace("?") # return the list of enabled traces

If two arguments are supplied to trace, the first argument is the "tracepoint name" and the second argument is the "tracepoint action" as shown in the examples above.  If tracing for the tracepoint name is enabled, the tracepoint action is printed (if it is a string) or exectuted (if it is a function name).

"*" will not match an explicit tracepoint name that starts with a minus sign.  For example,

	trace("-nocolor", self.disable_color)
</t>
<t tx="T2389">@ It no args are given we attempt to get them from the "SherlockArgs" file.  If there are still no arguments we trace everything.  This default makes tracing much more useful in Python.
@c

def get_Sherlock_args (args):

	if not args or len(args)==0:
		try:
			f = open(os.path.join(app().loadDir,"SherlockArgs"))
			args = f.readlines()
			f.close()
		except: pass
	elif type(args[0]) == type(("1","2")):
		args = args[0] # strip away the outer tuple.

	# No args means trace everything.
	if not args or len(args)==0: args = ["+*"] 
	# print "get_Sherlock_args:", args
	return args</t>
<t tx="T2390">def init_trace(args):

	t = app().trace_list
	args = get_Sherlock_args(args)

	for arg in args:
		if arg[0] in string.letters: prefix = '+'
		else: prefix = arg[0] ; arg = arg[1:]
		
		if prefix == '?':
			print "trace list:", t
		elif prefix == '+' and not arg in t:
			t.append(string.lower(arg))
			# print "enabling:", arg
		elif prefix == '-' and arg in t:
			t.remove(string.lower(arg))
			# print "disabling:", arg
		else:
			print "ignoring:", prefix + arg</t>
<t tx="T2391">def trace (s1=None,s2=None):

	if s1 and s2:
		name = s1 ; message = s2
	else: # use the funtion name as the tracepoint name.
		message = s1 # may be None
		try: # get the function name from the call stack.
			f1 = sys._getframe(1) # The stack frame, one level up.
			code1 = f1.f_code # The code object
			name = code1.co_name # The code name
		except: name = ""
		
	t = app().trace_list
	# tracepoint names starting with '-' must match exactly.
	minus = len(name) &gt; 0 and name[0] == '-'
	if minus: name = name[1:]
	if (not minus and '*' in t) or string.lower(name) in t:
		if not message: message = ""
		if type(message) == type("a"):
			s = name + ": " + message
			if 1: print s
			else: es(s)
		else: # assume we have a method and try to execute it.
			# print type(message)
			message()</t>
<t tx="T2392">@ pychecker bug: pychecker complains that there is no attribute time.clock
@c

def getTime():
	return time.clock()
	
def esDiffTime(message, start):
	es(message + ("%6.3f" % (time.clock()-start)))
	return time.clock()</t>
<t tx="T2393"># Returns a temporary file name.

def create_temp_name ():

	import tempfile
	temp = tempfile.mktemp()
	# trace(`temp`)
	return temp</t>
<t tx="T2394">def ensure_extension (name, ext):

	file, old_ext = os.path.splitext(name)
	if len(name) == 0:
		return name # don't add to an empty name.
	elif old_ext and old_ext == ext:
		return name
	else:
		return file + ext</t>
<t tx="T2395">@ Stephen P. Schaefer 9/7/2002

The Unix readline() routine delivers "\r\n" line end strings verbatim, while the windows versions force the string to use the Unix convention of using only "\n".  This routine causes the Unix readline to do the same.
@c

def readlineForceUnixNewline(f):

	s = f.readline()
	if len(s) &gt;= 2 and s[-2] == "\r" and s[-1] == "\n":
		s = s[0:-2] + "\n"
	return s
</t>
<t tx="T2396">def shortFileName (fileName):
	
	return os.path.basename(fileName)</t>
<t tx="T2397">def appendToList(out, s):

	for i in s:
		out.append(i)</t>
<t tx="T2398">def flattenList (theList):

	result = []
	for item in theList:
		if type(item) == types.ListType:
			result.extend(flattenList(item))
		else:
			result.append(item)
	return result</t>
<t tx="T2399">def listToString(theList):

	if list:
		theList = flattenList(theList)
		return string.join(theList,"")
	else:
		return ""</t>
<t tx="T2400"># These are guaranteed always to exist for scripts.</t>
<t tx="T2401"># *** Note *** the global statement makes sense only within functions!

gApp = None # Not needed, and keeps Pychecker happy.

def app():
	global gApp
	return gApp

def setApp(app):
	global gApp
	gApp = app</t>
<t tx="T2402">def choose(cond, a, b): # warning: evaluates all arguments

	if cond: return a
	else: return b</t>
<t tx="T2403">def windows():
	return app().windowList</t>
<t tx="T2404">@ It seems dubious to bump the Tangle error count here.  OTOH, it really doesn't hurt.
@c

def scanError(s):

	# Bump the error count in the tangle command.
	top().tangleCommands.errors += 1

	es(s)</t>
<t tx="T2405">@ These scanners all call scanError() directly or indirectly, so they will call es() if they find an error.  scanError() also bumps commands.tangleCommands.errors, which is harmless if we aren't tangling, and useful if we are.

These routines are called by the Import routines and the Tangle routines.
</t>
<t tx="T2406"># Scans past a block comment (an old_style C comment).

def skip_block_comment (s,i):

	assert(match(s,i,"/*"))
	j = i ; i += 2 ; n = len(s)
	
	k = string.find(s,"*/",i)
	if k == -1:
		scanError("Run on block comment: " + s[j:i])
		return n
	else: return k + 2</t>
<t tx="T2407">@ 08-SEP-2002 DTHEIN: Added for PHP import support
Skips from the opening to the matching . If no matching is found i is set to len(s).

This code is called only from the import logic, and only for PHP imports.
@c

def skip_php_braces(s,i):

	start = get_line(s,i)
	assert(match(s,i,'{'))
	level = 0 ; n = len(s)
	while i &lt; n:
		c = s[i]
		if c == '{':
			level += 1 ; i += 1
		elif c == '}':
			level -= 1
			if level &lt;= 0: return i + 1
			i += 1
		elif c == '\'' or c == '"': i = skip_string(s,i)
		elif match(s,i,"&lt;&lt;&lt;"): i = skip_heredoc_string(s,i)
		elif match(s,i,'//') or match(s,i,'#'): i = skip_to_end_of_line(s,i)
		elif match(s,i,'/*'): i = skip_block_comment(s,i)
		else: i += 1
	return i
</t>
<t tx="T2408">@ Skips from the opening ( to the matching ) . If no matching is found i is set to len(s)
@c

def skip_parens(s,i):
	level = 0 ; n = len(s)
	assert(match(s,i,'('))
	while i &lt; n:
		c = s[i]
		if c == '(':
			level += 1 ; i += 1
		elif c == ')':
			level -= 1
			if level &lt;= 0:  return i
			i += 1
		elif c == '\'' or c == '"': i = skip_string(s,i)
		elif match(s,i,"//"): i = skip_to_end_of_line(s,i)
		elif match(s,i,"/*"): i = skip_block_comment(s,i)
		else: i += 1
	return i</t>
<t tx="T2409">@ Skips from begin to matching end.
If found, i points to the end. Otherwise, i &gt;= len(s)
The end keyword matches begin, case, class, record, and try.
@c

def skip_pascal_begin_end(s,i):

	assert(match_c_word(s,i,"begin"))
	i1 = i # for traces
	level = 1 ; i = skip_c_id(s,i) # Skip the opening begin.
	while i &lt; len(s):
		ch = s[i]
		if ch =='{' : i = skip_pascal_braces(s,i)
		elif ch =='"' or ch == '\'': i = skip_pascal_string(s,i)
		elif match(s,i,"//"): i = skip_line(s,i)
		elif match(s,i,"(*"): i = skip_pascal_block_comment(s,i)
		elif match_c_word(s,i,"end"):
			level -= 1 ;
			if level == 0:
				# lines = s[i1:i+3] ; trace('\n' + lines + '\n')
				return i
			else: i = skip_c_id(s,i)
		elif is_c_id(ch):
			j = i ; i = skip_c_id(s,i) ; name = s[j:i]
			if name in ["begin", "case", "class", "record", "try"]:
				level += 1
		else: i += 1
	# trace(`s[i1:i]`)
	return i</t>
<t tx="T2410"># Scans past a pascal comment delimited by (* and *).

def skip_pascal_block_comment(s,i):
	
	j = i
	assert(match(s,i,"(*"))
	i = string.find(s,"*)",i)
	if i &gt; -1: return i + 2
	else:
		scanError("Run on comment" + s[j:i])
		return len(s)

#	n = len(s)
#	while i &lt; n:
#		if match(s,i,"*)"): return i + 2
#		i += 1
#	scanError("Run on comment" + s[j:i])
#	return i</t>
<t tx="T2411">def skip_pascal_string(s,i):

	j = i ; delim = s[i] ; i += 1
	assert(delim == '"' or delim == '\'')

	while i &lt; len(s):
		if s[i] == delim:
			return i + 1
		else: i += 1

	scanError("Run on string: " + s[j:i])
	return i</t>
<t tx="T2412">@ 08-SEP-2002 DTHEIN:  added function skip_heredoc_string
A heredoc string in PHP looks like:

	&lt;&lt;&lt;EOS
	This is my string.
	It is mine. I own it.
	No one else has it.
	EOS

It begins with &lt;&lt;&lt; plus a token (naming same as PHP variable names).
It ends with the token on a line by itself (must start in first position.

@c
def skip_heredoc_string(s,i):
	
	import re
	
	j = i
	assert(match(s,i,"&lt;&lt;&lt;"))
	m = re.match("\&lt;\&lt;\&lt;([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)", s[i:])
	if (None == m):
		i += 3
		return i

	# 14-SEP-2002 DTHEIN: needed to add \n to find word, not just string
	delim = m.group(1) + '\n' 
	
	i = skip_line(s,i) # 14-SEP-2002 DTHEIN: look after \n, not before
	n = len(s)
	while i &lt; n and not match(s,i,delim):
		i = skip_line(s,i) # 14-SEP-2002 DTHEIN: move past \n
		
	if i &gt;= n:
		scanError("Run on string: " + s[j:i])
	elif match(s,i,delim):
		i += len(delim)
	return i
</t>
<t tx="T2413"># Now handles continuation lines and block comments.

def skip_pp_directive(s,i):

	while i &lt; len(s):
		if is_nl(s,i):
			if escaped(s,i): i = skip_nl(s,i)
			else: break
		elif match(s,i,"//"): i = skip_to_end_of_line(s,i)
		elif match(s,i,"/*"): i = skip_block_comment(s,i)
		else: i += 1
	return i</t>
<t tx="T2414"># Skips an entire if or if def statement, including any nested statements.

def skip_pp_if(s,i):
	
	start_line = get_line(s,i) # used for error messages.
	# trace(start_line)

	assert(
		match_word(s,i,"#if") or
		match_word(s,i,"#ifdef") or
		match_word(s,i,"#ifndef"))

	i = skip_line(s,i)
	i,delta1 = skip_pp_part(s,i)
	i = skip_ws(s,i)
	if match_word(s,i,"#else"):
		i = skip_line(s,i)
		i = skip_ws(s,i)
		i,delta2 = skip_pp_part(s,i)
		if delta1 != delta2:
			es("#if and #else parts have different braces: " + start_line)
	i = skip_ws(s,i)
	if match_word(s,i,"#endif"):
		i = skip_line(s,i)
	else:
		es("no matching #endif: " + start_line)
		
	# trace(`delta1` + ":" + start_line)
	return i,delta1
</t>
<t tx="T2415"># Skip to an #else or #endif.  The caller has eaten the #if, #ifdef, #ifndef or #else

def skip_pp_part(s,i):
		
	start_line = get_line(s,i) # used for error messages.
	# trace(start_line)
	
	delta = 0
	while i &lt; len(s):
		c = s[i]
		if 0:
			if c == '\n':
				trace(`delta` + ":" + get_line(s,i))
		if match_word(s,i,"#if") or match_word(s,i,"#ifdef") or match_word(s,i,"#ifndef"):
			i,delta1 = skip_pp_if(s,i)
			delta += delta1
		elif match_word(s,i,"#else") or match_word(s,i,"#endif"):
			return i,delta
		elif c == '\'' or c == '"': i = skip_string(s,i)
		elif c == '{':
			delta += 1 ; i += 1
		elif c == '}':
			delta -= 1 ; i += 1
		elif match(s,i,"//"): i = skip_line(s,i)
		elif match(s,i,"/*"): i = skip_block_comment(s,i)
		else: i += 1
	return i,delta</t>
<t tx="T2416">def skip_python_string(s,i):

	if match(s,i,"'''") or match(s,i,'"""'):
		j = i ; delim = s[i]*3 ; i += 3
		k = string.find(s,delim,i)
		if k &gt; -1: return k+3
		scanError("Run on triple quoted string: " + s[j:i])
		return len(s)
	else:
		return skip_string(s,i)</t>
<t tx="T2417">def skip_string(s,i):
	
	j = i ; delim = s[i] ; i += 1
	assert(delim == '"' or delim == '\'')
	n = len(s)
	while i &lt; n and s[i] != delim:
		if s[i] == '\\' : i += 2
		else: i += 1

	if i &gt;= n:
		scanError("Run on string: " + s[j:i])
	elif s[i] == delim:
		i += 1
	return i</t>
<t tx="T2418"># Skips to the next semicolon that is not in a comment or a string.

def skip_to_semicolon(s,i):

	n = len(s)
	while i &lt; n:
		c = s[i]
		if c == ';': return i
		elif c == '\'' or c == '"' : i = skip_string(s,i)
		elif match(s,i,"//"): i = skip_to_end_of_line(s,i)
		elif match(s,i,"/*"): i = skip_block_comment(s,i)
		else: i += 1
	return i</t>
<t tx="T2419">def skip_typedef(s,i):

	n = len(s)
	while i &lt; n and is_c_id(s[i]):
		i = skip_c_id(s,i)
		i = skip_ws_and_nl(s,i)
	if match(s,i,'{'):
		i = skip_braces(s,i)
		i = skip_to_semicolon(s,i)
	return i</t>
<t tx="T2420"># Returns true if s[i] is preceded by an odd number of backslashes.

def escaped(s,i):

	count = 0
	while i-1 &gt;= 0 and s[i-1] == '\\':
		count += 1
		i -= 1
	return (count%2) == 1</t>
<t tx="T2421">def find_on_line(s,i,pattern):

	# j = skip_line(s,i) ; trace(`s[i:j]`)
	j = string.find(s,'\n',i)
	if j == -1: j = len(s)
	k = string.find(s,pattern,i,j)
	if k &gt; -1: return k
	else: return None</t>
<t tx="T2422">def is_c_id(ch):

	return ch in string.letters or ch in string.digits or ch == '_'</t>
<t tx="T2423">def is_nl(s,i):

	return i &lt; len(s) and (s[i] == '\n' or s[i] == '\r')</t>
<t tx="T2424">@ Return true if the body text contains the @ directive.

We no longer require that the directive appear befor any @c directive or section definition.
@c

def is_special(s,i,directive):

	# j = skip_line(s,i) ; trace(`s[i:j]` + " : " + `directive`)
	assert (directive and directive [0] == '@' )

	# 10/23/02: all directives except @others must start the line.
	skip_flag = directive == "@others"
	while i &lt; len(s):
		if match_word(s,i,directive):
			return true, i
		else:
			i = skip_line(s,i)
			if skip_flag:
				i = skip_ws(s,i)
	return false, -1</t>
<t tx="T2425">def is_ws(c):

	return c == '\t' or c == ' '
	
def is_ws_or_nl(s,i):

	return is_nl(s,i) or (i &lt; len(s) and is_ws(s[i]))</t>
<t tx="T2426"># Warning: this code makes no assumptions about what follows pattern.

def match(s,i,pattern):

	return s and pattern and string.find(s,pattern,i,i+len(pattern)) == i</t>
<t tx="T2427">def match_c_word (s,i,name):

	if name == None: return false
	n = len(name)
	if n == 0: return false
	return name == s[i:i+n] and (i+n == len(s) or not is_c_id(s[i+n]))</t>
<t tx="T2428">def match_ignoring_case(s1,s2):

	if s1 == None or s2 == None: return false
	return string.lower(s1) == string.lower(s2)</t>
<t tx="T2429">def match_word(s,i,pattern):

	if pattern == None: return false
	j = len(pattern)
	if j == 0: return false
	if string.find(s,pattern,i,i+j) != i:
		return false
	if i+j &gt;= len(s):
		return true
	c = s[i+j]
	return not (c in string.letters or c in string.digits or c == '_')</t>
<t tx="T2430">def skip_blank_lines(s,i):

	while i &lt; len(s):
		if is_nl(s,i) :
			i = skip_nl(s,i)
		elif is_ws(s[i]):
			j = skip_ws(s,i)
			if is_nl(s,j):
				i = j
			else: break
		else: break
	return i</t>
<t tx="T2431">def skip_c_id(s,i):

	n = len(s)
	while i &lt; n:
		c = s[i]
		if c in string.letters or c in string.digits or c == '_':
			i += 1
		else: break
	return i</t>
<t tx="T2432">@ These methods skip to the next newline, regardless of whether the newline may be preceeded by a backslash. Consequently, they should be used only when we know that we are not in a preprocessor directive or string.
@c

def skip_line (s,i):

	i = string.find(s,'\n',i)
	if i == -1: return len(s)
	else: return i + 1
		
def skip_to_end_of_line (s,i):

	i = string.find(s,'\n',i)
	if i == -1: return len(s)
	else: return i</t>
<t tx="T2433"># returns (i, val) or (i, None) if s[i] does not point at a number.

def skip_long(s,i):

	digits = string.digits
	val = 0
	i = skip_ws(s,i)
	n = len(s)
	if i &gt;= n or s[i] not in "+-" + digits:
		return i, None
	# Rewritten: 7/18/02.
	j = i
	if s[i] in '+-':    # whr allow sign if first digit
		i +=1
	while i &lt; n and s[i] in digits:
		i += 1
	val = int(s[j:i])
	return i, val</t>
<t tx="T2434">def skip_matching_delims(s,i,delim1,delim2):
	
	assert(match(s,i,delim1))

	i += len(delim1)
	k = string.find(s,delim2,i)
	if k == -1:
		return len(s)
	else:
		return k + len(delim2)</t>
<t tx="T2435">@ This function skips a single "logical" end-of-line character.  We need this function because different systems have different end-of-line conventions.
@c

def skip_nl (s,i):

	if match(s,i,"\r\n"): return i + 2
	elif match(s,i,'\n') or match(s,i,'\r'): return i + 1
	else: return i</t>
<t tx="T2436"># Skips from the opening { to the matching }.

def skip_pascal_braces(s,i):

	# No constructs are recognized inside Pascal block comments!
	k = string.find(s,'}',i)
	if i == -1: return len(s)
	else: return k</t>
<t tx="T2437">def skip_ws(s,i):

	n = len(s)
	while i &lt; n and is_ws(s[i]):
		i += 1
	return i
	
def skip_ws_and_nl(s,i):

	n = len(s)
	while i &lt; n and (is_ws(s[i]) or is_nl(s,i)):
		i += 1
	return i</t>
<t tx="T2438">@
CheckVersion() is a generic version checker.  Assumes a
version string of up to four parts, or tokens, with
leftmost token being most significant and each token
becoming less signficant in sequence to the right.

RETURN VALUE

1 if comparison is true
0 if comparison is false

PARAMETERS

version: the version string to be tested
againstVersion: the reference version string to be
                compared against
condition: can be any of "==", "!=", "&gt;=", "&lt;=", "&gt;", or "&lt;"
stringCompare: whether to test a token using only the
               leading integer of the token, or using the
			   entire token string.  For example, a value
			   of "0.0.1.0" means that we use the integer
			   value of the first, second, and fourth
			   tokens, but we use a string compare for the
			   third version token.
delimiter: the character that separates the tokens in the
           version strings.

The comparison uses the precision of the version string
with the least number of tokens.  For example a test of
"8.4" against "8.3.3" would just compare the first two
tokens.

The version strings are limited to a maximum of 4 tokens.
@c

def CheckVersion( version, againstVersion, condition="&gt;=", stringCompare="0.0.0.0", delimiter='.' ):
	import sre  # Unicode-aware regular expressions
	#
	# tokenize the stringCompare flags
	compareFlag = string.split( stringCompare, '.' )
	#
	# tokenize the version strings
	testVersion = string.split( version, delimiter )
	testAgainst = string.split( againstVersion, delimiter )
	#
	# find the 'precision' of the comparison
	tokenCount = 4
	if tokenCount &gt; len(testAgainst):
		tokenCount = len(testAgainst)
	if tokenCount &gt; len(testVersion):
		tokenCount = len(testVersion)
	#
	# Apply the stringCompare flags
	justInteger = sre.compile("^[0-9]+")
	for i in range(tokenCount):
		if "0" == compareFlag[i]:
			m = justInteger.match( testVersion[i] )
			testVersion[i] = m.group()
			m = justInteger.match( testAgainst[i] )
			testAgainst[i] = m.group()
		elif "1" != compareFlag[i]:
			errMsg = "stringCompare argument must be of " +\
				 "the form \"x.x.x.x\" where each " +\
				 "'x' is either '0' or '1'."
			raise EnvironmentError,errMsg
	#
	# Compare the versions
	if condition == "&gt;=":
		for i in range(tokenCount):
			if testVersion[i] &lt; testAgainst[i]:
				return 0
			if testVersion[i] &gt; testAgainst[i]:
				return 1 # it was greater than
		return 1 # it was equal
	if condition == "&gt;":
		for i in range(tokenCount):
			if testVersion[i] &lt; testAgainst[i]:
				return 0
			if testVersion[i] &gt; testAgainst[i]:
				return 1 # it was greater than
		return 0 # it was equal
	if condition == "==":
		for i in range(tokenCount):
			if testVersion[i] != testAgainst[i]:
				return 0 # any token was not equal
		return 1 # every token was equal
	if condition == "!=":
		for i in range(tokenCount):
			if testVersion[i] != testAgainst[i]:
				return 1 # any token was not equal
		return 0 # every token was equal
	if condition == "&lt;":
		for i in range(tokenCount):
			if testVersion[i] &gt;= testAgainst[i]:
				return 0
			if testVersion[i] &lt; testAgainst[i]:
				return 1 # it was less than
		return 0 # it was equal
	if condition == "&lt;=":
		for i in range(tokenCount):
			if testVersion[i] &gt; testAgainst[i]:
				return 0
			if testVersion[i] &lt; testAgainst[i]:
				return 1 # it was less than
		return 1 # it was equal
	#
	# didn't find a condition that we expected.
	raise EnvironmentError,"condition must be one of '&gt;=', '&gt;', '==', '!=', '&lt;', or '&lt;='."
</t>
<t tx="T2439">@ Unloads all of Leo's modules.  Based on code from the Python Cookbook.

It would be very confusing to call this reloadAll.  In fact, this routine does no reloading at all.  You must understand that modules are reloaded _only_ as the result of a later call to import.

Actually, the more I think about it, the less useful this routine appears.  It is easy enought to save LeoPy.leo and then reload it, and trying to do this kind of processing looks like asking for trouble...
@c

def unloadAll():

	try:
		import sys
		a = app()
		modules = []
		for name in sys.modules.keys():
			if name and name[0:3]=="leo":
				del (sys.modules[name])
				modules.append(name)
		# Restore gApp.  This must be done first.
		setApp(a)
		print "unloaded",str(len(modules)),"modules"
	except:
		es_exception()
</t>
<t tx="T2440">@language python

from leoGlobals import *

&lt;&lt; scripts &gt;&gt;

class leoImportCommands:
	@others</t>
<t tx="T2441">def __init__ (self,commands):

	self.commands = commands
	
	# Set by ImportFilesFommand.
	self.treeType = "@file" # "@root" or "@file"
	# Set by ImportWebCommand.
	self.webType = "@noweb" # "cweb" or "noweb"

	# Set by create_outline.
	self.fileName = None # The original file name, say x.cpp
	self.methodName = None # x, as in &lt; &lt; x methods &gt; &gt; =
	self.fileType = None # ".py", ".c", etc.
	self.rootLine = "" # Empty or @root + self.fileName

	# Support of output_newline option
	self.output_newline = getOutputNewline()
	
	# Used by Importers.
	self.web_st = []
</t>
<t tx="T2442">@others</t>
<t tx="T2443">def createOutline (self,fileName,parent):

	c = self.commands ; current = c.currentVnode()
	junk, self.fileName = os.path.split(fileName) # junk/fileName
	self.methodName, type = os.path.splitext(self.fileName) # methodName.fileType
	self.fileType = type
	# trace(`self.fileName`) ; trace(`self.fileType`)
	# All file types except the following just get copied to the parent node.
	# 08-SEP-2002 DTHEIN: Added php
	# 9/9/02: E.K.Ream.  Allow upper case, add cxx.
	# Note: we should _not_ import header files using this code.
	appendFileFlag = string.lower(type) not in [".c", ".cpp", ".cxx", ".java", ".pas", ".py", ".php"]
	&lt;&lt; Read file into s &gt;&gt;
	# Create the top-level headline.
	v = parent.insertAsLastChild()
	c.undoer.setUndoParams("Import",v,select=current)
	if self.treeType == "@file":
		v.initHeadString("@file " + self.fileName)
	else:
		v.initHeadString(self.fileName)
		
	self.rootLine = choose(self.treeType=="@file","","@root "+self.fileName+'\n')

	if appendFileFlag:
		v.setBodyStringOrPane("@ignore\n" + self.rootLine + s)
	elif type == ".c" or type == ".cpp":
		self.scanCText(s,v)
	elif type == ".java":
		self.scanJavaText(s,v,true) #outer level
	elif type == ".pas":
		self.scanPascalText(s,v)
	elif type == ".py":
		self.scanPythonText(s,v)
	elif type == ".php":
		self.scanPHPText(s,v) # 08-SEP-2002 DTHEIN
	else:
		es("createOutline: can't happen")
	return v</t>
<t tx="T2444">try:
	file = open(fileName)
	s = file.read()
	file.close()
except:
	es("can not read " + fileName)
	return None</t>
<t tx="T2445">def importFilesCommand (self,files,treeType):

	c = self.commands
	if c == None: return
	v = current = c.currentVnode()
	if current == None: return
	if len(files) &lt; 1: return
	self.treeType = treeType
	c.beginUpdate()
	if 1: # range of update...
		if len(files) == 2:
			&lt;&lt; Create a parent for two files having a common prefix &gt;&gt;
		for i in xrange(len(files)):
			fileName = files[i]
			v = self.createOutline(fileName,current)
			if v: # 8/11/02: createOutline may fail.
				es("imported " + fileName)
				c.contractVnode(v)
				v.setDirty()
				c.setChanged(true)
		c.validateOutline()
		c.expandVnode(current)
	c.endUpdate()
	c.selectVnode(current)</t>
<t tx="T2446">@ The two filenames have a common prefix everything before the last period is the same.  For example, x.h and x.cpp.
@c

name0 = files[0]
name1 = files[1]
prefix0, junk = os.path.splitext(name0)
prefix1, junk = os.path.splitext(name1)
if len(prefix0) &gt; 0 and prefix0 == prefix1:
	current = current.insertAsLastChild()
	junk, nameExt = os.path.split(prefix1)
	name,ext = os.path.splitext(prefix1)
	current.initHeadString(name)</t>
<t tx="T2447"># Used by paste logic.

def convertMoreStringToOutlineAfter (self,s,firstVnode):
	s = string.replace(s,"\r","")
	strings = string.split(s,"\n")
	return self.convertMoreStringsToOutlineAfter(strings,firstVnode)

# Almost all the time spent in this command is spent here.

def convertMoreStringsToOutlineAfter (self,strings,firstVnode):

	c = self.commands
	if len(strings) == 0: return None
	if not self.stringsAreValidMoreFile(strings): return None
	c.beginUpdate()
	firstLevel, junk = self.moreHeadlineLevel(strings[0])
	lastLevel = -1 ; theRoot = lastVnode = None
	index = 0
	while index &lt; len(strings):
		progress = index
		s = strings[index]
		level, newFlag = self.moreHeadlineLevel(s)
		level -= firstLevel
		if level &gt;= 0:
			&lt;&lt; Link a new vnode v into the outline &gt;&gt;
			&lt;&lt; Set the headline string, skipping over the leader &gt;&gt;
			&lt;&lt; Count the number of following body lines &gt;&gt;
			&lt;&lt; Add the lines to the body text of v &gt;&gt;
			v.setDirty()
		else: index += 1
		assert progress &lt; index
	if theRoot:
		theRoot.setDirty()
		c.setChanged(true)
	c.endUpdate()
	return theRoot</t>
<t tx="T2448">assert(level &gt;= 0)
if not lastVnode:
	theRoot = v = firstVnode.insertAfter()
elif level == lastLevel:
	v = lastVnode.insertAfter()
elif level == lastLevel + 1:
	v = lastVnode.insertAsNthChild(0)
else:
	assert(level &lt; lastLevel)
	while level &lt; lastLevel:
		lastLevel -= 1
		lastVnode = lastVnode.parent()
		assert(lastVnode)
		assert(lastLevel &gt;= 0)
	v = lastVnode.insertAfter()
lastVnode = v
lastLevel = level</t>
<t tx="T2449">j = 0
while match(s,j,'\t'):
	j += 1
if match(s,j,"+ ") or match(s,j,"- "):
	j += 2

v.initHeadString(s[j:])</t>
<t tx="T2450">bodyLines = 0
index += 1 # Skip the headline.
while index &lt; len(strings):
	s = strings[index]
	level, junk = self.moreHeadlineLevel(s)
	level -= firstLevel
	if level &gt;= 0:
		break
	# Remove first backslash of the body line.
	if match(s,0,'\\'):
		strings[index] = s[1:]
	bodyLines += 1
	index += 1</t>
<t tx="T2451">if bodyLines &gt; 0:
	body = ""
	n = index - bodyLines
	while n &lt; index:
		body += strings[n]
		if n != index - 1:
			body += "\n"
		n += 1
	v.t.setTnodeText(body)</t>
<t tx="T2452"># On entry,files contains at most one file to convert.
def importFlattenedOutline (self,files):

	c = self.commands ; current = c.currentVnode()
	if current == None: return
	if len(files) &lt; 1: return
	fileName = files[0]
	&lt;&lt; Read the file into array &gt;&gt;
	# Convert the string to an outline and insert it after the current node.
	newVnode = self.convertMoreStringsToOutlineAfter(array,current)
	if newVnode:
		c.undoer.setUndoParams("Import",newVnode,select=current)
		c.endEditing()
		c.validateOutline()
		c.editVnode(newVnode)
		newVnode.setDirty()
		c.setChanged(true)
	else:
		es(fileName + " is not a valid MORE file.")</t>
<t tx="T2453">try:
	file = open(fileName)
	s = file.read()
	s = string.replace(s,"\r","")
	array = string.split(s,"\n")
	file.close()
except: array = []</t>
<t tx="T2454"># return the headline level of s,or -1 if the string is not a MORE headline.
def moreHeadlineLevel (self,s):

	level = 0 ; i = 0
	while match(s,i,'\t'):
		level += 1
		i += 1
	plusFlag = choose(match(s,i,"+"),true,false)
	if match(s,i,"+ ") or match(s,i,"- "):
		return level, plusFlag
	else:
		return -1, plusFlag</t>
<t tx="T2455"># Used by paste logic.

def stringIsValidMoreFile (self,s):
	
	s = string.replace(s,"\r","")
	strings = string.split(s,"\n")
	return self.stringsAreValidMoreFile(strings)

def stringsAreValidMoreFile (self,strings):

	if len(strings) &lt; 1: return false
	level1, plusFlag = self.moreHeadlineLevel(strings[0])
	if level1 == -1: return false
	# Check the level of all headlines.
	i = 0 ; 	lastLevel = level1
	while i &lt; len(strings):
		s = strings[i] ; i += 1
		level, newFlag = self.moreHeadlineLevel(s)
		if level &gt; 0:
			if level &lt; level1 or level &gt; lastLevel + 1:
				return false # improper level.
			elif level &gt; lastLevel and plusFlag == false:
				return false # parent of this node has no children.
			elif level == lastLevel and plusFlag == true:
				return false # last node has missing child.
			else:
				lastLevel = level
				plusFlag = newFlag
	return true</t>
<t tx="T2456">def createOutlineFromWeb (self,path,parent):

	c = self.commands ; current = c.currentVnode()
	junk, fileName = os.path.split(path)
	# Create the top-level headline.
	v = parent.insertAsLastChild()
	c.undoer.setUndoParams("Import",v,select=current)
	v.initHeadString(fileName)
	if self.webType=="cweb":
		v.setBodyStringOrPane("@ignore\n" + self.rootLine + "@language cweb")

	# Scan the file,creating one section for each function definition.
	self.scanWebFile(path,v)
	return v</t>
<t tx="T2457">def importWebCommand (self,files,webType):

	c = self.commands ; current = c.currentVnode()
	if current == None: return
	if len(files) &lt; 1: return
	self.webType = webType
	c.beginUpdate()
	for i in xrange(len(files)):
		fileName = files[i]
		v = self.createOutlineFromWeb(fileName,current)
		c.contractVnode(v)
		v.setDirty()
		c.setChanged(true)
	c.selectVnode(current)
	c.endUpdate()</t>
<t tx="T2458">def findFunctionDef (self,s,i):
	
	# Look at the next non-blank line for a function name.
	i = skip_ws_and_nl(s,i)
	k = skip_line(s,i)
	name = None
	while i &lt; k:
		if is_c_id(s[i]):
			j = i ; i = skip_c_id(s,i) ; name = s[j:i]
		elif s[i] == '(':
			if name: return name
			else: break
		else: i += 1
	return None</t>
<t tx="T2459">@ This method returns the proper headline text.

1. If s contains a section def, return the section ref.
2. cweb only: if s contains @c, return the function name following the @c.
3. cweb only: if s contains @d name, returns @d name.
4. Otherwise, returns "@"
@c

def scanBodyForHeadline (self,s):
	
	if self.webType == "cweb":
		&lt;&lt; scan cweb body for headline &gt;&gt;
	else:
		&lt;&lt; scan noweb body for headline &gt;&gt;
	return "@" # default.</t>
<t tx="T2460">i = 0
while i &lt; len(s):
	i = skip_ws_and_nl(s,i)
	# line = get_line(s,i) ; trace(`line`)
	# Allow constructs such as @ @c, or @ @&lt;.
	if self.isDocStart(s,i):
		i += 2 ; i = skip_ws(s,i)
	if match(s,i,"@d") or match(s,i,"@f"):
		# Look for a macro name.
		directive = s[i:i+2]
		i = skip_ws(s,i+2) # skip the @d or @f
		if i &lt; len(s) and is_c_id(s[i]):
			j = i ; skip_c_id(s,i) ; return s[j:i]
		else: return directive
	elif match(s,i,"@c") or match(s,i,"@p"):
		# Look for a function def.
		name = self.findFunctionDef(s,i+2)
		return choose(name,name,"outer function")
	elif match(s,i,"@&lt;"):
		# Look for a section def.
		# A small bug: the section def must end on this line.
		j = i ; k = find_on_line(s,i,"@&gt;")
		if k &gt; -1 and (match(s,k+2,"+=") or match(s,k+2,"=")):
			return s[j:k+2] # return the section ref.
	i = skip_line(s,i)</t>
<t tx="T2461">i = 0
while i &lt; len(s):
	i = skip_ws_and_nl(s,i)
	# line = get_line(s,i) ; trace(`line`)
	if match(s,i,"&lt;&lt;"):
		k = find_on_line(s,i,"&gt;&gt;=")
		if k &gt; -1:
			ref = s[i:k+2]
			name = string.strip(s[i+2:k])
			if name != "@others":
				return ref
	else:
		name = self.findFunctionDef(s,i)
		if name:
			return name
	i = skip_line(s,i)</t>
<t tx="T2462">def scanWebFile (self,fileName,parent):

	type = self.webType
	lb = choose(type=="cweb","@&lt;","&lt;&lt;")
	rb = choose(type=="cweb","@&gt;","&gt;&gt;")

	try: # Read the file into s.
		f = open(fileName)
		s = f.read()
	except: s = None

	&lt;&lt; Create a symbol table of all section names &gt;&gt;
	&lt;&lt; Create nodes for limbo text and the root section &gt;&gt;
	while i &lt; len(s):
		progress = i
		&lt;&lt; Create a node for the next module &gt;&gt;
		assert(progress &lt; i)</t>
<t tx="T2463">i = 0 ; 	self.web_st = []
while i &lt; len(s):
	i = skip_ws_and_nl(s,i)
	# line = get_line(s,i) ; trace(`line`)
	if self.isDocStart(s,i):
		if type == "cweb": i += 2
		else: i = skip_line(s,i)
	elif type == "cweb" and match(s,i,"@@"):
		i += 2
	elif match(s,i,lb):
		i += 2 ; j = i ; k = find_on_line(s,j,rb)
		if k &gt; -1: self.cstEnter(s[j:k])
	else: i += 1

# trace(self.cstDump())</t>
<t tx="T2464">i = 0
while i &lt; len(s):
	i = skip_ws_and_nl(s,i)
	if self.isModuleStart(s,i) or match(s,i,lb):
		break
	else: i = skip_line(s,i)
	
j = skip_ws(s,0)
if j &lt; i:
	self.createHeadline(parent,"@ " + s[j:i],"Limbo")

j = i
if match(s,i,lb):
	while i &lt; len(s):
		i = skip_ws_and_nl(s,i)
		if self.isModuleStart(s,i):
			break
		else: i = skip_line(s,i)
	self.createHeadline(parent,s[j:i],angleBrackets(" @ "))
	
# trace(`get_line(s,i)`)</t>
<t tx="T2465">if type=="cweb":
	assert(self.isModuleStart(s,i))
	start = i
	if self.isDocStart(s,i):
		i += 2
		while i &lt; len(s):
			i = skip_ws_and_nl(s,i)
			if self.isModuleStart(s,i): break
			else: i = skip_line(s,i)
	&lt;&lt; Handle cweb @d, @f, @c and @p directives &gt;&gt;
else:
	assert(self.isDocStart(s,i)) # isModuleStart == isDocStart for noweb.
	start = i ; i = skip_line(s,i)
	while i &lt; len(s):
		i = skip_ws_and_nl(s,i)
		if self.isDocStart(s,i): break
		else: i = skip_line(s,i)
	
body = s[start:i]
body = self.massageWebBody(body)
headline = self.scanBodyForHeadline(body)
self.createHeadline(parent,body,headline)</t>
<t tx="T2466">if match(s,i,"@d") or match(s,i,"@f"):
	i += 2 ; i = skip_line(s,i)
	# Place all @d and @f directives in the same node.
	while i &lt; len(s):
		i = skip_ws_and_nl(s,i)
		if match(s,i,"@d") or match(s,i,"@f"): i = skip_line(s,i)
		else: break
	i = skip_ws_and_nl(s,i)
	
while i &lt; len(s) and not self.isModuleStart(s,i):
	i = skip_line(s,i)
	i = skip_ws_and_nl(s,i)

if match(s,i,"@c") or match(s,i,"@p"):
	i += 2 ; 
	while i &lt; len(s):
		i = skip_line(s,i)
		i = skip_ws_and_nl(s,i)
		if self.isModuleStart(s,i):
			break</t>
<t tx="T2467">@ We canonicalize strings before looking them up, but strings are entered in the form they are first encountered.
@c

def cstCanonicalize (self,s,lower=true):
	
	if lower:
		s = string.lower(s)
	s = string.replace(s,"\t"," ")
	s = string.replace(s,"\r","")
	s = string.replace(s,"\n"," ")
	s = string.replace(s,"  "," ")
	s = string.strip(s)
	return s</t>
<t tx="T2468">def cstDump (self):

	self.web_st.sort()
	s = "Web Symbol Table...\n\n"
	for name in self.web_st:
		s += name + "\n"
	return s</t>
<t tx="T2469"># We only enter the section name into the symbol table if the ... convention is not used.

def cstEnter (self,s):

	# Don't enter names that end in "..."
	s = string.rstrip(s)
	if s.endswith("..."): return
	
	# Put the section name in the symbol table, retaining capitalization.
	lower = self.cstCanonicalize(s,true)  # do lower
	upper = self.cstCanonicalize(s,false) # don't lower.
	for name in self.web_st:
		if string.lower(name) == lower:
			return
	self.web_st.append(upper)</t>
<t tx="T2470"># This method returns a string if the indicated string is a prefix of an entry in the web_st.

def cstLookup (self,target):
	
	# Do nothing if the ... convention is not used.
	target = string.strip(target)
	if not target.endswith("..."): return target
	# Canonicalize the target name, and remove the trailing "..."
	ctarget = target[:-3]
	ctarget = self.cstCanonicalize(ctarget)
	ctarget = string.strip(ctarget)
	found = false ; result = target
	for s in self.web_st:
		cs = self.cstCanonicalize(s)
		if cs[:len(ctarget)] == ctarget:
			if found:
				es("****** " + target + ": is also a prefix of: " + s)
			else:
				found = true ; result = s
				# es("replacing: " + target + " with: " + s)
	return result</t>
<t tx="T2471">@ Creates a child node c of parent for the class, and children of c for each def in the class.
@c

def scanPythonClass (self,s,i,start,parent):

	# line = get_line(s,i) ; trace(`line`)
	classIndent = self.getLeadingIndent(s,i)
	&lt;&lt; set classname and headline, or return i &gt;&gt;
	i = skip_line(s,i) # Skip the class line.
	&lt;&lt; create class_vnode &gt;&gt;
	savedMethodName = self.methodName
	self.methodName = headline
	# Create a node for leading declarations of the class.
	i = self.scanPythonDecls(s,i,class_vnode,indent_parent_ref_flag=true)
	&lt;&lt; create nodes for all defs of the class &gt;&gt;
	self.methodName = savedMethodName
	return i</t>
<t tx="T2472"># Skip to the class name.
i = skip_ws(s,i)
i = skip_c_id(s,i) # skip "class"
i = skip_ws_and_nl(s,i)
if i &lt; len(s) and is_c_id(s[i]):
	j = i ; i = skip_c_id(s,i)
	classname = s[j:i]
	headline = "class " + classname
else:
	return i</t>
<t tx="T2473"># Create the section name using the old value of self.methodName.
if  self.treeType == "@file":
	prefix = ""
else:
	prefix = angleBrackets(" " + self.methodName + " methods ") + "=\n\n"

# i points just after the class line.
body = s[start:i]
body = self.undentBody(body)
class_vnode = self.createHeadline(parent,prefix + body,headline)
</t>
<t tx="T2474">@ Creates a node of parent for the def.
@c

def scanPythonDef (self,s,i,start,parent):

	# line = get_line(s,i) ; trace(`line`)
	&lt;&lt; set headline or return i &gt;&gt;
	&lt;&lt; skip the Python def &gt;&gt;
	# Create the def node.
	savedMethodName = self.methodName
	self.methodName = headline
	&lt;&lt; Create def node &gt;&gt;
	self.methodName = savedMethodName
	return i</t>
<t tx="T2475">i = skip_ws(s,i)
i = skip_c_id(s,i) # Skip the "def"
i = skip_ws_and_nl(s,i)
if i &lt; len(s) and is_c_id(s[i]):
	j = i ; i = skip_c_id(s,i)
	headline = s[j:i]
	# trace("headline:" + `headline`)
else: return i</t>
<t tx="T2476"># Set defIndent to the indentation of the def line.
defIndent = self.getLeadingIndent(s,start)
i = skip_line(s,i) # Skip the def line.
indent = self.getLeadingIndent(s,i)
while i &lt; len(s) and indent &gt; defIndent:
	progress = i
	ch = s[i]
	if is_nl(s,i):
		i = skip_nl(s,i)
		indent = self.getLeadingIndent(s,i)
		if indent &lt;= defIndent:
			break
	elif ch == '#':
		i = skip_to_end_of_line(s,i) # 7/29/02
	elif ch == '"' or ch == '\'':
		i = skip_python_string(s,i)
	else: i += 1
	assert(progress &lt; i)</t>
<t tx="T2477"># Create the prefix line for @root trees.
if self.treeType == "@file":
	prefix = ""
else:
	prefix = angleBrackets(" " + savedMethodName + " methods ") + "=\n\n"

# Create body.
start = skip_blank_lines(s,start)
body = s[start:i]
body = self.undentBody(body)

# Create the node.
self.createHeadline(parent,prefix + body,headline)</t>
<t tx="T2478">def scanPythonDecls (self,s,i,parent,indent_parent_ref_flag=true):
	
	done = false ; start = i
	while not done and i &lt; len(s):
		progress = i
		# line = get_line(s,i) ; trace(`line`)
		ch = s[i]
		if ch == '\n': i = skip_nl(s,i)
		elif ch == '#': i = skip_to_end_of_line(s,i)
		elif ch == '"' or ch == '\'':
			i = skip_python_string(s,i)
		elif is_c_id(ch):
			&lt;&lt; break on def or class &gt;&gt;
		else: i += 1
		assert(progress &lt; i)
	j = skip_blank_lines(s,start)
	if is_nl(s,j): j = skip_nl(s,j)
	if j &lt; i:
		&lt;&lt; Create a child node for declarations &gt;&gt;
	return i</t>
<t tx="T2479">if match_c_word(s,i,"def") or match_c_word(s,i,"class"):
	i = find_line_start(s,i)
	done = true
	break
else:
	i = skip_c_id(s,i)</t>
<t tx="T2480">headline = ref = angleBrackets(" " + self.methodName + " declarations ")
leading_tab = choose(indent_parent_ref_flag,"\t","")

# Append the reference to the parent's body.
parent.appendStringToBody(leading_tab + ref + "\n") # 7/6/02

# Create the node for the decls.
body = self.undentBody(s[j:i])
if self.treeType == "@root":
	body = "@code\n\n" + body
self.createHeadline(parent,body,headline)</t>
<t tx="T2481">@ This code creates a child of parent for each Python function definition seen.  See the comments for scanCText for what the text looks like.
@c

def scanPythonText (self,s,parent):

	decls_seen = false ; start = i = 0
	while i &lt; len(s):
		progress = i
		# line = get_line(s,i) ; trace(`line`)
		ch = s[i]
		if ch == '\n' or ch == '\r': i = skip_nl(s,i)
		elif ch == '#': i = skip_to_end_of_line(s,i)
		elif ch == '"' or ch == '\'': i = skip_python_string(s,i)
		elif is_c_id(ch):
			&lt;&lt; handle possible Python function or class &gt;&gt;
		else: i += 1
		assert(progress &lt; i)
	&lt;&lt; Append a reference to the methods of this file &gt;&gt;
	&lt;&lt; Append any unused python text to the parent's body text &gt;&gt;</t>
<t tx="T2482">if match_c_word(s,i,"def") or match_word(s,i,"class"):
	isDef = match_c_word(s,i,"def")
	if not decls_seen:
		parent.appendStringToBody("@ignore\n" + self.rootLine + "@language python\n")
		i = start = self.scanPythonDecls(s,start,parent,indent_parent_ref_flag=false)
		decls_seen = true
		if self.treeType == "@file": # 7/29/02
			parent.appendStringToBody("@others\n") # 7/29/02
	if isDef:
		i = start = self.scanPythonDef(s,i,start,parent)
	else:
		i = start = self.scanPythonClass(s,i,start,parent)
else:
	i = skip_c_id(s,i)</t>
<t tx="T2483">if self.treeType == "@file":
	pass
else:
	parent.appendStringToBody(
		angleBrackets(" " + self.methodName + " methods ") + "\n\n")</t>
<t tx="T2484"># Do nothing if only whitespace is left.
i = start ; i = skip_ws_and_nl(s,i)
if i &lt; len(s):
	parent.appendStringToBody(s[start:])</t>
<t tx="T2485">@  08-SEP-2002 DTHEIN: Added for PHP import support
Creates a child of parent for each class and function definition seen.

PHP uses both # and // as line comments, and /* */ as block comments
@c
def scanPHPText (self,s,parent):
	import re
	&lt;&lt; Append file if not pure PHP &gt;&gt;

	&lt;&lt; define scanPHPText vars &gt;&gt;
	# 14-SEP-2002 DTHEIN: Make leading &lt;?php use the @first directive
	parent.appendStringToBody("@first ")	
	parent.appendStringToBody(s[:startOfCode])
	scan_start = i = startOfCode
	while i &lt; endOfCode:
		# line = get_line(s,i) ; trace(`line`)
		ch = s[i]
		# These cases skip tokens.
		if ch == '/' or ch == '#':
			&lt;&lt; handle possible PHP comments &gt;&gt;
		elif ch == '&lt;':
			&lt;&lt; handle possible heredoc string &gt;&gt;
		elif ch == '"' or ch == '\'':
			i = skip_string(s,i)
		# These cases help determine where functions start.
		# FIXME: probably want to capture 'var's as class member data
		elif ch == 'f' or ch =='c':
			&lt;&lt; handle possible class or function &gt;&gt;
		elif class_start and (ch == '}'):
			&lt;&lt; handle end of class &gt;&gt;
		else: i += 1
	&lt;&lt; Append any unused text to the parent's body text &gt;&gt;
	# 14-SEP-2002 DTHEIN: Make leading &lt;?php use the @first directive
	parent.appendStringToBody("@last ")	
	parent.appendStringToBody(s[endOfCode:])</t>
<t tx="T2486"># If the file does not begin with &lt;?php or end with ?&gt; then
# it is simply appended like a generic import would do.
s.strip() #remove inadvertent whitespace
if not s.startswith("&lt;?php") \
or not (s.endswith("?&gt;") or s.endswith("?&gt;\n") or s.endswith("?&gt;\r\n")):
	es("File seems to be mixed HTML and PHP; importing as plain text file.")
	parent.setBodyStringOrPane("@ignore\n" + self.rootLine + s)
	return</t>
<t tx="T2487">scan_start = 0
class_start = 0
function_start = 0
c = self.commands
i = 0
class_body = ""
class_node = ""
phpClassName = re.compile("class\s+([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)")
phpFunctionName = re.compile("function\s+([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)")

# 14-SEP-2002 DTHEIN: added these 2 variables to allow use of @first/last
startOfCode = s.find("\n") + 1 # this should be the line containing the initial &lt;?php
endOfCode = s.rfind("?&gt;") # this should be the line containing the last ?&gt;
</t>
<t tx="T2488">if match(s,i,"&lt;&lt;&lt;"):
	i = skip_heredoc_string(s,i)
else:
	i += 1
</t>
<t tx="T2489">if match(s,i,"//"):
	i = skip_line(s,i)
elif match(s,i,"#"):
	i = skip_line(s,i)
elif match(s,i,"/*"):
	i = skip_block_comment(s,i)
else:
	i += 1</t>
<t tx="T2490">@ In PHP, all functions are typeless and start with the keyword "function;  all classes start with the keyword class.

Functions can be nested, but we don't handle that right now (I don't think it is a common practice anyway).
@c
if match(s,i,"function "):
	#we want to make the function a subnode of either the @file node or a class node
	# 1. get the function name
	# 2. make a reference in the parent
	# 3. create the child node, and dump the function in it.
	function_start = i
	m = phpFunctionName.match(s[i:])
	if (None == m): # function keyword without function name
		i += len("function ")
	else:
		headline = angleBrackets(" function " + m.group(1) + " ")
		# find the end of the function
		openingBrace = s.find('{',i)
		function_end = skip_php_braces(s,openingBrace)
		function_end = skip_to_end_of_line(s,function_end - 1) + 1 # include the line end
		# Insert skipped text into parent's body.
		if class_start:
			class_body += s[scan_start:function_start]
		else:
			parent.appendStringToBody(s[scan_start:function_start])
		# Append the headline to the parent's body.
		if class_start:
			class_body += (headline + "\n")
		else:
			parent.appendStringToBody(headline + "\n")
		# Backup to capture leading whitespace (for undent purposes)
		while (function_start &gt; 0) and (s[function_start - 1] in [" ", "\t"]):
			function_start -= 1
		# Get the body and undent it
		function_body = s[function_start:function_end]
		function_body = self.undentBody(function_body)
		if self.treeType != "@file":
			function_body = "@code\n\n" + function_body
		# Create the new node
		if class_start:
			self.createHeadline(class_node,function_body,headline)
		else:
			self.createHeadline(parent,function_body,headline)
		i = function_end
		scan_start = i
		function_end = 0
		function_start = 0 #done with this function
		function_body = ""
		
elif match(s,i,"class "):
	# we want to make the class a subnode of the @file node
	# 1. get the class name
	# 2. make a reference in the parent
	# 3. create the child node and dump the function in it
	class_start = i
	class_body = ""
	m = phpClassName.match(s[i:])
	if (None == m): # class keyword without class name
		i += len("class ")
	else:
		# Insert skipped text into parent's body.
		parent.appendStringToBody(s[scan_start:class_start])
		# create the headline name
		headline = angleBrackets(" class " + m.group(1) + " ")
		# find the place to start looking for methods (functions)
		openingBrace = s.find('{',i)
		# find the end of the class
		class_end = skip_php_braces(s,openingBrace)
		class_end = skip_to_end_of_line(s,class_end - 1) + 1 # include the line end
		# Append the headline to the parent's body.
		parent.appendStringToBody(headline + "\n")
		# Backup to capture leading whitespace (for undent purposes)
		while (class_start &gt; 0) and (s[class_start - 1] in [" ", "\t"]):
			class_start -= 1
		scan_start = class_start
		# Create the new node
		class_node = self.createHeadline(parent,"",headline)
		i = openingBrace
	
else:
	i += 1</t>
<t tx="T2491"># Capture the rest of the body
class_body += s[scan_start:class_end]
# insert the class node's body
if self.treeType != "@file":
	class_body = "@code\n\n" + class_body
class_body = self.undentBody(class_body)
class_node.appendStringToBody(class_body)
# reset the indices
i = class_end
scan_start = i
class_end = 0
class_start = 0 #done with this class
class_body=""
</t>
<t tx="T2492">parent.appendStringToBody(s[scan_start:endOfCode])
</t>
<t tx="T2493"># Creates a child of parent for each Pascal function definition seen.

def scanPascalText (self,s,parent):

	method_seen = false ; methodKind = "methods"
	scan_start = function_start = i = 0
	name = None
	while i &lt; len(s):
		# line = get_line(s,i) ; trace(`line`)
		ch = s[i]
		if ch == '{': i = skip_pascal_braces(s,i)
		elif ch == '"' or ch == '\'': i = skip_pascal_string(s,i)
		elif match(s,i,"//"): i = skip_to_end_of_line(s,i)
		elif match(s,i,"(*"): i = skip_pascal_block_comment(s,i)
		elif is_c_id(s[i]):
			&lt;&lt; handle possible Pascal function &gt;&gt;
		else: i += 1
	&lt;&lt; Append any unused text to the parent's body text &gt;&gt;</t>
<t tx="T2494">if match_c_word(s,i,"begin"):
	i = skip_pascal_begin_end(s,i)
	if match_c_word(s,i,"end"):
		i = skip_c_id(s,i)
elif (match_c_word(s,i,"function")  or match_c_word(s,i,"procedure") or
	match_c_word(s,i,"constructor") or match_c_word(s,i,"destructor")):

	# line = get_line(s,i) ; trace(`line`)
	
	start = i
	i = skip_c_id(s,i)
	i = skip_ws_and_nl(s,i)
	&lt;&lt; remember the function name, or continue &gt;&gt;
	&lt;&lt; skip the function definition, or continue &gt;&gt;
	if not method_seen:
		method_seen = true
		&lt;&lt; create a child node for leading declarations &gt;&gt;
		&lt;&lt; append noweb method reference to the parent node &gt;&gt;
		function_start = start
	else: function_start = scan_start
	&lt;&lt; create a child node for the function &gt;&gt;
else: i = skip_c_id(s,i)</t>
<t tx="T2495">save_ip = i
i = scan_start
while i &lt; start and is_ws_or_nl(s,i):
	i += 1
if i &lt; start:
	parent.appendStringToBody("@ignore\n" + self.rootLine + "@language pascal\n")
	headline = angleBrackets(self.methodName + " declarations ")
	# Append the headline to the parent's body.
	parent.appendStringToBody(headline + "\n")
	if self.treeType == "@file":
		body = s[scan_start:start]
	else:
		body = "@code\n\n" + s[scan_start:start]
	body = self.undentBody(body)
	self.createHeadline(parent,body,headline)
i = save_ip
scan_start = i</t>
<t tx="T2496"># Point i _after_ the last character of the function.
i = skip_ws(s,i)
if is_nl(s,i):
	i = skip_nl(s,i)
function_end = i
headline = name
body = s[function_start:function_end]
body = self.massageBody(body,methodKind)
self.createHeadline(parent,body,headline)
scan_start = i</t>
<t tx="T2497">if i &lt; len(s) and is_c_id(s[i]):
	j = i ; i = skip_c_id(s,i)
	while i + 1 &lt; len(s) and s[i] == '.' and is_c_id(s[i+1]):
		i += 1 ; j = i
		i = skip_c_id(s,i)
	name = s[j:i]
else: continue</t>
<t tx="T2498">&lt;&lt; skip past the semicolon &gt;&gt;

if not match_c_word(s,i,"begin"):
	continue
# Skip to the matching end.
i = skip_pascal_begin_end(s,i)
if match_c_word(s,i,"end"):
	i = skip_c_id(s,i)
	i = skip_ws_and_nl(s,i)
	if match(s,i,';'):
		i += 1
	i = skip_ws(s,i)
	if is_nl(s,i):
		i = skip_nl(s,i)
else: continue</t>
<t tx="T2499">while i &lt; len(s) and s[i] != ';':
	# The paremeter list may contain "inner" semicolons.
	if s[i] == '(':
		i = skip_parens(s,i)
		if match(s,i,')'):
			i += 1
		else: break
	else: i += 1
if match(s,i,';'):
	i += 1
i = skip_ws_and_nl(s,i)

if match_c_word(s,i,"var"):
	# Skip to the next begin.
	i = skip_c_id(s,i)
	done = false
	while i &lt; len(s) and not done:
		ch = s[i]
		if ch == '{': i = skip_pascal_braces(s,i)
		elif match(s,i,"//"): i = skip_to_end_of_line(s,i)
		elif match(s,i,"(*"): i = skip_pascal_block_comment(s,i)
		elif is_c_id(ch):
			if match_c_word(s,i,"begin"): done = true
			else: i = skip_c_id(s,i)
		elif ch == '"' or ch == '\'': i = skip_pascal_string(s,i)
		else: i += 1</t>
<t tx="T2500"># Append the headline to the parent's body.
if self.treeType == "@file":
	parent.appendStringToBody("@others\n")
else:
	parent.appendStringToBody(
		angleBrackets(" " + self.methodName + " methods ") + "\n")</t>
<t tx="T2501">def createHeadline (self,parent,body,headline):

	# trace("parent,headline:" + `parent` + ":" + `headline`)
	# Create the vnode.
	v = parent.insertAsLastChild()
	v.initHeadString(headline)
	# Set the body.
	if len(body) &gt; 0:
		v.setBodyStringOrPane(body)
	return v</t>
<t tx="T2502">def error (self,s): es(s)</t>
<t tx="T2503">@ This code returns the leading whitespace of a line, ignoring blank and comment lines.
@c

def getLeadingIndent (self,s,i):

	c = self.commands
	i = find_line_start(s,i)
	while i &lt; len(s):
		# trace(`get_line(s,i)`)
		if is_nl(s,i) or match(s,i,"#"):
			i = skip_line(s,i) # ignore blank lines and comments.
		else:
			i, width = skip_leading_ws_with_indent(s,i,c.tab_width)
			# trace("returns:" + `width`)
			return width
	# trace("returns:0")
	return 0</t>
<t tx="T2504"># The start of a document part or module in a noweb or cweb file.
# Exporters may have to test for @doc as well.

def isDocStart (self,s,i):
	
	if not match(s,i,"@"):
		return false

	j = skip_ws(s,i+1)
	if match(s,j,"%defs"):
		return false
	elif self.webType == "cweb" and match(s,i,"@*"):
		return true
	else:
		return match(s,i,"@ ") or match(s,i,"@\t") or match(s,i,"@\n")

def isModuleStart (self,s,i):

	if self.isDocStart(s,i):
		return true
	else:
		return self.webType == "cweb" and (
			match(s,i,"@c") or match(s,i,"@p") or
			match(s,i,"@d") or match(s,i,"@f"))
</t>
<t tx="T2505">def massageBody (self,s,methodKind):
	
	# trace(`s`)
	# trace(`get_line(s,0)`)
	c = self.commands
	if self.treeType == "@file":
		if self.fileType == ".py": # 7/31/02: was "py"
			return self.undentBody(s)
		else:
			newBody, comment = self.skipLeadingComments(s)
			newBody = self.undentBody(newBody)
			newLine = choose(is_nl(newBody,0),"\n","\n\n")
			if len(comment) &gt; 0:
				return comment + "\n@c" + newLine + newBody
			else:
				return newBody
	else:
		# Inserts &lt; &lt; self.methodName methodKind &gt; &gt; =
		cweb = self.fileType == "c" and not c.use_noweb_flag
		lb = choose(cweb,"@&lt;","&lt;&lt;")
		rb = choose(cweb,"@&gt;=","&gt;&gt;=")
		intro = lb + " " + self.methodName + " " + methodKind + " " + rb
		if self.fileType == ".py": # 7/31/02: was "py"
			newBody = self.undentBody(s)
			newLine = choose(is_nl(newBody,0),"\n","\n\n")
			return intro + newLine + newBody
		else:
			newBody, comment = self.skipLeadingComments(s)
			newBody = self.undentBody(newBody)
			newLine = choose(is_nl(newBody,0),"\n","\n\n")
			if len(comment) &gt; 0:
				return comment + "\n" + intro + newLine + newBody
			else:
				return intro + newLine + newBody</t>
<t tx="T2506">@ Returns s with all runs of whitespace and newlines converted to a single blank.  It also removes leading and trailing whitespace.
@c

def massageComment (self,s):

	# trace(`get_line(s,0)`)
	s = string.strip(s)
	s = string.replace(s,"\n"," ")
	s = string.replace(s,"\r"," ")
	s = string.replace(s,"\t"," ")
	s = string.replace(s,"  "," ")
	s = string.strip(s)
	return s</t>
<t tx="T2507">def massageWebBody (self,s):

	type = self.webType
	lb = choose(type=="cweb","@&lt;","&lt;&lt;")
	rb = choose(type=="cweb","@&gt;","&gt;&gt;")
	&lt;&lt; Remove most newlines from @space and @* sections &gt;&gt;
	&lt;&lt; Replace abbreviated names with full names &gt;&gt;
	s = string.rstrip(s)
	return s</t>
<t tx="T2508">i = 0
while i &lt; len(s):
	i = skip_ws_and_nl(s,i)
	if self.isDocStart(s,i):
		# Scan to end of the doc part.
		if match(s,i,"@ %def"):
			# Don't remove the newline following %def
			i = skip_line(s,i) ; start = end = i
		else:
			start = end = i ; i += 2
		while i &lt; len(s):
			i = skip_ws_and_nl(s,i)
			if self.isModuleStart(s,i) or match(s,i,lb):
				end = i ; break
			elif type == "cweb": i += 1
			else: i = skip_to_end_of_line(s,i)
		# Remove newlines from start to end.
		doc = s[start:end]
		doc = string.replace(doc,"\n"," ")
		doc = string.replace(doc,"\r","")
		doc = string.strip(doc)
		if doc and len(doc) &gt; 0:
			if doc == "@":
				doc = choose(self.webType=="cweb", "@ ","@\n")
			else:
				doc += "\n\n"
			# trace("new doc:" + `doc`)
			s = s[:start] + doc + s[end:]
			i = start + len(doc)
	else: i = skip_line(s,i)</t>
<t tx="T2509">i = 0
while i &lt; len(s):
	# trace(`get_line(s,i)`)
	if match(s,i,lb):
		i += 2 ; j = i ; k = find_on_line(s,j,rb)
		if k &gt; -1:
			name = s[j:k]
			name2 = self.cstLookup(name)
			if name != name2:
				# Replace name by name2 in s.
				# trace("replacing:" + `name` + ", by:" + `name2`)
				s = s[:j] + name2 + s[k:]
				i = j + len(name2)
	i = skip_line(s,i)</t>
<t tx="T2510">@ This skips all leading comments in s, returning the remaining body text and the massaged comment text.
Returns (body, comment)
@c

def skipLeadingComments (self,s):

	# trace(`get_line(s,0)`)
	s_original = s
	s = string.lstrip(s)
	i = 0 ; comment = ""
	if self.fileType in [".c", ".cpp"]: # 11/2/02: don't mess with java comments.
		&lt;&lt; scan for C-style comments &gt;&gt;
	elif self.fileType == ".pas":
		&lt;&lt; scan for Pascal comments &gt;&gt;
	elif self.fileType == ".py":
		&lt;&lt; scan for Python comments &gt;&gt;
	comment = string.strip(comment)
	if len(comment) == 0:
		return s_original, "" # Bug fix: 11/2/02: don't skip leading whitespace!
	elif self.treeType == "@file":
		return s[i:], "@ " + comment
	else:
		return s[i:], "@ " + comment + "\n"</t>
<t tx="T2511">while i &lt; len(s):
	if match(s,i,"//"): # Handle a C++ comment.
		while match(s,i,'/'):
			i += 1
		j = i ; i = skip_line(s,i)
		comment = comment + self.massageComment(s[j:i]) + "\n"
		# 8/2/02: Preserve leading whitespace for undentBody
		i = skip_ws(s,i)
		i = skip_blank_lines(s,i)
	elif match(s,i,"/*"): # Handle a block C comment.
		j = i + 2 ; i = skip_block_comment (s,i)
		k = choose(match(s,i-2,"*/"),i-2,i)
		if self.fileType == ".java":
			# 8/2/02: a hack: add leading whitespace then remove it.
			comment = self.undentBody(comment)
			comment2 = ' ' * 2 + s[j:k]
			comment2 = self.undentBody(comment2)
			comment = comment + comment2 + "\n"
		else:
			comment = comment + self.massageComment(s[j:k]) + "\n"
		# 8/2/02: Preserve leading whitespace for undentBody
		i = skip_ws(s,i)
		i = skip_blank_lines(s,i)
	else: break</t>
<t tx="T2512">while i &lt; len(s):
	if match(s,i,"//"): # Handle a Pascal line comment.
		while match(s,i,'/'):
			i += 1
		j = i ; i = skip_line(s,i)
		comment = comment + self.massageComment(s[j:i]) + "\n"
		# 8/2/02: Preserve leading whitespace for undentBody
		i = skip_ws(s,i)
		i = skip_blank_lines(s,i)
	elif match(s,i,'(*'):
		j = i + 1 ; i = skip_pascal_block_comment(s,i)
		comment = comment + self.massageComment(s[j:i]) + "\n"
		# 8/2/02: Preserve leading whitespace for undentBody
		i = skip_ws(s,i)
		i = skip_blank_lines(s,i)
	else: break</t>
<t tx="T2513">while i &lt; len(s) and match(s,i,'#'):
	j = i + 1 ; i = skip_line(s,i)
	comment = self.undentBody(comment)
	comment = comment + self.massageComment(s[j:i]) + "\n"
	# 8/2/02: Preserve leading whitespace for undentBody
	i = skip_ws(s,i)
	i = skip_blank_lines(s,i)</t>
<t tx="T2514">@ Removes extra leading indentation from all lines.  We look at the first line to determine how much leading whitespace to delete.
@c

def undentBody (self,s):

	# trace(`s`)
	c = self.commands
	i = 0 ; result = ""
	# Copy an @code line as is.
	if match(s,i,"@code"):
		j = i ; i = skip_line(s,i) # don't use get_line: it is only for dumping.
		result += s[j:i]
	# Calculate the amount to be removed from each line.
	undent = self.getLeadingIndent(s,i)
	if undent == 0: return s
	while i &lt; len(s):
		j = i ; i = skip_line(s,i) # don't use get_line: it is only for dumping.
		line = s[j:i]
		# trace(`line`)
		line = removeLeadingWhitespace(line,undent,c.tab_width)
		result += line
	return result</t>
<t tx="T2515">@language python

&lt;&lt; About the vnode and tnode classes &gt;&gt;
&lt;&lt; About clones &gt;&gt;

from leoGlobals import *
import types

@others</t>
<t tx="T2516">class tnode:
	&lt;&lt; tnode constants &gt;&gt;
	@others</t>
<t tx="T2517">dirtyBit =		0x01
richTextBit =	0x02 # Determines whether we use &lt;bt&gt; or &lt;btr&gt; tags.
visitedBit =	0x04</t>
<t tx="T2518">def __del__ (self):

	# Can't trace while destroying.
	# print "t.__del__"
	pass</t>
<t tx="T2519">def destroy (self):

	self.joinHead = None</t>
<t tx="T2520">def hasBody (self):

	return self.bodyString and len(self.bodyString) &gt; 0</t>
<t tx="T2521">def isDirty (self):

	return (self.statusBits &amp; self.dirtyBit) != 0</t>
<t tx="T2522">def isRichTextBit (self):

	return (self.statusBits &amp; self.richTextBit) != 0</t>
<t tx="T2523">def isVisited (self):

	return (self.statusBits &amp; self.visitedBit) != 0</t>
<t tx="T2524">def clearDirty (self):

	self.statusBits &amp;= ~ self.dirtyBit</t>
<t tx="T2525">def clearRichTextBit (self):

	self.statusBits &amp;= ~ self.richTextBit</t>
<t tx="T2526">def clearVisited (self):

	self.statusBits &amp;= ~ self.visitedBit</t>
<t tx="T2527">def setDirty (self):

	self.statusBits |= self.dirtyBit</t>
<t tx="T2528">def setRichTextBit (self):

	self.statusBits |= self.richTextBit</t>
<t tx="T2529">def setVisited (self):

	self.statusBits |= self.visitedBit</t>
<t tx="T2530">def setCloneIndex (self, index):

	self.cloneIndex = index</t>
<t tx="T2531">def setFileIndex (self, index):

	self.fileIndex = index</t>
<t tx="T2532">def setJoinHead (self, v):

	self.joinHead = v</t>
<t tx="T2533">class vnode:
	&lt;&lt; vnode constants &gt;&gt;
	@others</t>
<t tx="T2534"># Define the meaning of vnode status bits.

# Archived...
clonedBit	 = 0x01 # true: vnode has clone mark.
# not used	 = 0x02
expandedBit  = 0x04 # true: vnode is expanded.
markedBit	 = 0x08 # true: vnode is marked
orphanBit	 = 0x10 # true: vnode saved in .leo file, not derived file.
selectedBit  = 0x20 # true: vnode is current vnode.
topBit		 = 0x40 # true: vnode was top vnode when saved.

# Not archived
visitedBit	 = 0x80</t>
<t tx="T2535">def __del__ (self):

	# Can't trace while destroying.
	# print "v.__del__" + self
	try:
		self.icon_id = None
	except: pass</t>
<t tx="T2536">def __repr__ (self):

	return "v: " + `self.mHeadString`</t>
<t tx="T2537">if 0: # not used
	def __cmp__(self,other):
		
		trace(`self` + "," + `other`)
		return not (self is other) # Must return 0, 1 or -1</t>
<t tx="T2538">@ These callbacks are vnode methods so we can pass the vnode back to the tree class.
</t>
<t tx="T2539"># Called when the box is clicked.

def OnBoxClick(self,event=None):

	self.commands.tree.OnBoxClick(self)
	
# Called when the icon is double-clicked.
	
def OnIconDoubleClick(self,event=None):

	self.commands.tree.OnIconDoubleClick(self)</t>
<t tx="T2540">def OnDrag(self,event=None):
	
	self.commands.tree.OnDrag(self,event)
</t>
<t tx="T2541">def OnEndDrag(self,event=None):
	
	self.commands.tree.OnEndDrag(self,event)
</t>
<t tx="T2542">def OnHeadlineKey (self,event):

	self.commands.tree.OnHeadlineKey(self,event)</t>
<t tx="T2543">def OnHyperLinkControlClick (self,event):

	c = self.commands ; v = self
	c.beginUpdate()
	c.selectVnode(v)
	c.endUpdate()
	c.body.mark_set("insert","1.0")</t>
<t tx="T2544">def OnHyperLinkEnter (self,event):

	if 0: # This works, and isn't very useful.
		c = self.commands ; v = self
		c.body.tag_config(v.tagName,background="green")</t>
<t tx="T2545">def OnHyperLinkLeave (self,event):

	if 0: # This works, and isn't very useful.
		c = self.commands ; v = self
		c.body.tag_config(v.tagName,background="white")</t>
<t tx="T2546">def OnIconClick(self,event=None):
	
	self.commands.tree.OnIconClick(self,event)
</t>
<t tx="T2547"># Converts the outline to a string in "MORE" format

def convertTreeToString (self):

	v = self
	level1 = v.level()
	after = v.nodeAfterTree()
	s = ""
	while v and v != after:
		s += v.moreHead(level1) + "\n"
		body = v.moreBody()
		if len(body) &gt; 0:
			s += body + "\n"
		v = v.threadNext()
	return s</t>
<t tx="T2548"># Returns the headline string in MORE format.

def moreHead (self, firstLevel):

	v = self
	level = self.level() - firstLevel
	if level &gt; 0: s = "\t" * level
	else: s = ""
	s += choose(v.hasChildren(), "+ ", "- ")
	s += v.headString()
	return s</t>
<t tx="T2549">@ Returns the body string in MORE format.  It inserts a backslash before any leading plus, minus or backslash.

+ test line
- test line
\ test line
test line +
test line -
test line \

More lines...
@c

def moreBody (self):

	v = self ; list = []
	
	if 1: # new code: only escape the first non-blank character of the line.
		s =  v.t.bodyString ; result = []
		lines = string.split(s,'\n')
		for s in lines:
			i = skip_ws(s,0)
			if i &lt; len(s):
				ch = s[i]
				if ch == '+' or ch == '-' or ch == '\\':
					s = s[:i] + '\\' + s[i:]
			result.append(s)
		return string.join(result,'\n')

	else: # pre 3.1 code.
		for ch in v.t.bodyString:
			if ch == '+' or ch == '-' or ch == '\\':
				list.append('\\')
			list.append(ch)
		return string.join(list,'')</t>
<t tx="T2550"># Compatibility routine for scripts

def bodyString (self):

	return self.t.bodyString</t>
<t tx="T2551"># childIndex and nthChild are zero-based.

def childIndex (self):

	parent=self.parent()
	if not parent: return 0

	child = parent.firstChild()
	n = 0
	while child:
		if child == self: return n
		n += 1 ; child = child.next()
	assert(false)</t>
<t tx="T2552"># Compatibility routine for scripts

def firstChild (self):

	return self.mFirstChild</t>
<t tx="T2553">def hasChildren (self):

	return self.firstChild() != None</t>
<t tx="T2554"># Compatibility routine for scripts

def lastChild (self):

	child = self.firstChild()
	while child and child.next():
		child = child.next()
	return child</t>
<t tx="T2555"># childIndex and nthChild are zero-based.

def nthChild (self, n):

	child = self.firstChild()
	if not child: return None
	while n &gt; 0 and child:
		n -= 1
		child = child.next()
	return child</t>
<t tx="T2556">def numberOfChildren (self):

	n = 0
	child = self.firstChild()
	while child:
		n += 1
		child = child.next()
	return n</t>
<t tx="T2557"># Compatibility routine for scripts

def currentVnode (self):

	return self.commands.tree.currentVnode</t>
<t tx="T2558"># Compatibility routine for scripts

def findRoot (self):

	return self.commands.tree.rootVnode
</t>
<t tx="T2559">def getJoinList (self):

	return self.joinList</t>
<t tx="T2560"># Compatibility routine for scripts

def headString (self):

	return self.mHeadString

</t>
<t tx="T2561">def isAncestorOf (self, v):

	if not v:
		return false
	v = v.parent()
	while v:
		if v == self:
			return true
		v = v.parent()
	return false</t>
<t tx="T2562">def isRoot (self):

	return not self.parent() and not self.back()</t>
<t tx="T2563">def isCloned (self):

	return ( self.statusBits &amp; vnode.clonedBit ) != 0</t>
<t tx="T2564">def isDirty (self):

	return self.t.isDirty()</t>
<t tx="T2565">def isExpanded (self):

	return ( self.statusBits &amp; self.expandedBit ) != 0</t>
<t tx="T2566">def isMarked (self):

	return ( self.statusBits &amp; vnode.markedBit ) != 0</t>
<t tx="T2567">def isOrphan (self):

	return ( self.statusBits &amp; vnode.orphanBit ) != 0</t>
<t tx="T2568">def isSelected (self):

	return ( self.statusBits &amp; vnode.selectedBit ) != 0</t>
<t tx="T2569">def isTopBitSet (self):

	return ( self.statusBits &amp; self.topBit ) != 0</t>
<t tx="T2570"># Returns true if all parents are expanded.

def isVisible (self):

	v = self.parent()
	while v:
		if not v.isExpanded():
			return false
		v = v.parent()
	return true</t>
<t tx="T2571">def isVisited (self):

	return ( self.statusBits &amp; vnode.visitedBit ) != 0</t>
<t tx="T2572">def status (self):

	return self.statusBits</t>
<t tx="T2573"># Compatibility routine for scripts

def back (self):

	return self.mBack</t>
<t tx="T2574">def lastNode (self):

	v = self
	level = self.level()
	result = None

	while v:
		result = v
		v = v.threadNext()
		if not v or v.level() &lt;= level:
			break

	return result</t>
<t tx="T2575">@ This function returns the indentation level of the receiver. The root nodes have level 0, their children have level 1, and so on.
@c

def level (self):

	level = 0 ; parent = self.parent()
	while parent:
		level += 1
		parent = parent.parent()
	return level</t>
<t tx="T2576"># Compatibility routine for scripts

def next (self):

	return self.mNext</t>
<t tx="T2577"># Returns the vnode following the tree whose root is the receiver.

def nodeAfterTree (self):

	next = self.next()
	p = self.parent()

	while not next and p:
		next = p.next()
		p = p.parent()

	return next</t>
<t tx="T2578"># Compatibility routine for scripts

def parent (self):

	return self.mParent</t>
<t tx="T2579"># Returns the previous element of the outline, or None if at the start of the outline.

def threadBack (self):

	back = self.back()
	if back:
		lastChild = back.lastChild()
		if lastChild:
			return lastChild.lastNode()
		else:
			return back
	else:
		return self.parent()</t>
<t tx="T2580">def threadNext (self):

	"""Returns node following the receiver in "threadNext" order.
	This should be called whenever v's links change"""
	
	v = self
	
	if v.firstChild():
		return v.firstChild()
	elif v.next():
		return v.next()
	else:
		p = v.parent()
		while p:
			if p.next():
				return p.next()
			p = p.parent()
		return None</t>
<t tx="T2581">def visBack (self):

	v = self.threadBack()
	while v and not v.isVisible():
		v = v.threadBack()
	return v</t>
<t tx="T2582">def visNext (self):

	v = self.threadNext()
	while v and not v.isVisible():
		v = v.threadNext()
	return v</t>
<t tx="T2583">def appendStringToBody (self, s):

	if len(s) == 0: return
	body = self.t.bodyString + s
	self.setBodyStringOrPane(body)</t>
<t tx="T2584"># Compatibility routine for scripts

def setHeadStringOrHeadline (self, s):

	c = self.commands
	c.endEditing()
	self.setHeadString(s)</t>
<t tx="T2585">def computeIcon (self):

	val = 0 ; v = self
	if v.t.hasBody(): val += 1
	if v.isMarked(): val += 2
	if v.isCloned(): val += 4
	if v.isDirty(): val += 8
	return val
	
def setIcon (self):

	pass # Compatibility routine for old scripts</t>
<t tx="T2586"># Compatibility routine for scripts

def clearAllVisited (self):
	
	self.commands.clearAllVisited()
</t>
<t tx="T2587">def clearAllVisitedInTree (self):

	v = self ; c = v.commands
	after = v.nodeAfterTree()
	
	c.beginUpdate()
	while v and v != after:
		v.clearVisited()
		v.t.clearVisited()
		v = v.threadNext()
	c.endUpdate()
</t>
<t tx="T2588">def clearClonedBit (self):

	self.statusBits &amp;= ~ self.clonedBit</t>
<t tx="T2589">def clearDirty (self):

	v = self
	v.t.clearDirty()

def clearDirtyJoined (self):

	v = self ; c = v.commands
	c.beginUpdate()
	if 1: # update range
		v.t.clearDirty()
		v2 = v.getJoinList()
		while v2 and v2 != self:
			v2.t.clearDirty()
			v2 = v2.getJoinList()
	c.endUpdate() # recomputes all icons</t>
<t tx="T2590">def clearMarked (self):

	self.statusBits &amp;= ~ self.markedBit</t>
<t tx="T2591">def clearOrphan (self):

	self.statusBits &amp;= ~ self.orphanBit</t>
<t tx="T2592">def clearVisited (self):

	self.statusBits &amp;= ~ self.visitedBit</t>
<t tx="T2593">def clearVisitedInTree (self):

	after = self.nodeAfterTree()
	v = self
	while v and v != after:
		v.clearVisited()
		v = v.threadNext()</t>
<t tx="T2594">def contract(self):

	self.statusBits &amp;= ~ self.expandedBit

def expand(self):

	self.statusBits |= self.expandedBit

def initExpandedBit (self):

    self.statusBits |= self.expandedBit</t>
<t tx="T2595">def initStatus (self, status):

	self.statusBits = status</t>
<t tx="T2596">def setClonedBit (self):

	self.statusBits |= self.clonedBit

def initClonedBit (self, val):

	if val:
		self.statusBits |= self.clonedBit
	else:
		self.statusBits &amp;= ~ self.clonedBit</t>
<t tx="T2597">def setMarked (self):

	self.statusBits |= self.markedBit

def initMarkedBit (self):

	self.statusBits |= self.markedBit</t>
<t tx="T2598">def setOrphan (self):

	self.statusBits |= self.orphanBit</t>
<t tx="T2599"># This only sets the selected bit.

def setSelected (self):

	self.statusBits |= self.selectedBit</t>
<t tx="T2600"># Compatibility routine for scripts

def setVisited (self):

	self.statusBits |= self.visitedBit</t>
<t tx="T2601">def setJoinList (self, v):

	assert(not self.joinList)
	self.joinList = v</t>
<t tx="T2602">def setSelection (self, start, length):

	self.t.setSelection ( start, length )</t>
<t tx="T2603">def setT (self, t):

	if t != self:
		del self.t
		self.t = t</t>
<t tx="T2604">@ This trims trailing blank lines from a node.  It is surprising difficult to do this during Untangle.
@c

def trimTrailingLines (self):

	v = self
	body = v.bodyString()
	# trace(`body`)
	lines = string.split(body,'\n')
	i = len(lines) - 1 ; changed = false
	while i &gt;= 0:
		line = lines[i]
		j = skip_ws(line,0)
		if j + 1 == len(line):
			del lines[i]
			i -= 1 ; changed = true
		else: break
	if changed:
		body = string.join(body,'') + '\n' # Add back one last newline.
		# trace(`body`)
		v.setBodyStringOrPane(body)
		# Don't set the dirty bit: it would just be annoying.</t>
<t tx="T2605">@ This is the main delete routine.  It deletes the receiver's entire tree from the screen.  Because of the undo command we never actually delete vnodes or tnodes.
@c

def doDelete (self, newVnode):

	"""Unlinks the receiver, but does not destroy it. May be undone"""

	v = self ; c = v.commands
	v.setDirty() # 1/30/02: mark @file nodes dirty!
	v.destroyDependents()
	v.unjoinTree()
	v.unlink()
	# Bug fix: 1/18/99: we must set the currentVnode here!
	c.selectVnode(newVnode)
	# Update all clone bits.
	c.initAllCloneBits()
	return self # We no longer need dvnodes: vnodes contain all needed info.</t>
<t tx="T2606">def insertAfter (self, t = None):

	"""Inserts a new vnode after the receiver"""

	if not t: t = tnode()
	v = vnode(self.commands,t)
	v.mHeadString = "NewHeadline"
	v.iconVal = 0
	v.linkAfter(self)
	return v</t>
<t tx="T2607">def insertAsLastChild (self,t = None):

	"""Inserts a new vnode as the last child of the receiver"""

	n = self.numberOfChildren()
	if not t:
		t = tnode()
	return self.insertAsNthChild(n,t)</t>
<t tx="T2608">def insertAsNthChild (self, n, t=None):

	"""Inserts a new node as the the nth child of the receiver.
	The receiver must have at least n-1 children"""

	# trace(`n` + `self`)
	if not t: t = tnode()
	v = vnode(self.commands,t)
	v.mHeadString = "NewHeadline"
	v.iconVal = 0
	v.linkAsNthChild(self,n)
	return v</t>
<t tx="T2609"># Used by scripts

def moveAfter (self,a):

	"""Moves the receiver after a"""

	v = self ; c = self.commands
	# trace(`v`)
	v.destroyDependents()
	v.unlink()
	v.linkAfter(a)
	v.createDependents()
	
	# 5/27/02: Moving a node after another node can create a new root node.
	if not a.parent() and not a.back():
		c.tree.rootVnode = a</t>
<t tx="T2610">def moveToRoot (self, oldRoot = None):

	"""Moves the receiver to the root position"""

	v = self
	# trace(`v`)
	v.destroyDependents()
	v.unlink()
	v.linkAsRoot(oldRoot)
	v.createDependents()</t>
<t tx="T2611"># Restores (relinks) the dv tree in the position described by back and parent.

def restoreOutlineFromDVnodes (self, dv, parent, back):

	if back:
		dv.linkAfter(back)
	elif parent:
		dv.linkAsNthChild(parent, 0)
	else:
		dv.linkAsRoot()
	return dv</t>
<t tx="T2612"># 7/5/02: New for undo.
# On entry, linked is linked into a tree and unlinked is not.
# On exit,  unlinked is linked into a tree and linked is not.

# Warning: caller is responsible for hanling join links properly.

def swap_links (self,unlinked,linked):

	assert(unlinked and linked)
	assert(unlinked.mParent == None)
	assert(unlinked.mBack == None)
	assert(unlinked.mNext == None)
	assert(unlinked.joinList == None)
	#print "swap_links:unlinked.last,linked.last",unlinked.lastChild(),linked.lastChild()

	# Copy links to unlinked.
	unlinked.mParent = linked.mParent
	unlinked.mBack = linked.mBack
	unlinked.mNext = linked.mNext
	# Caller is responsible for handling join links.
	unlinked.joinList = None 
	
	# Change links to linked from other nodes.
	if linked.mParent and linked.mParent.mFirstChild == linked:
		linked.mParent.mFirstChild = unlinked
	if linked.mBack:
		linked.mBack.mNext = unlinked
	if linked.mNext:
		linked.mNext.mBack = unlinked
		
	# Clear links in linked.
	linked.mParent = linked.mBack = linked.mNext = linked.joinList = None</t>
<t tx="T2613">@ This method copies all subtrees of oldRoot to the subtrees of newRoot.  The caller is responsible for copying the headline text from oldRoot to newRoot.

This method must be given the new root as well as the old:  the wxWindows classes do not allow us to create an unattached outline.
@c

def copyTree (self, oldTree, newTree):

	old_v = oldTree.firstChild()
	if not old_v: return
	# Copy the first child of oldTree to the first child of newTree.
	new_v = newTree.insertAsNthChild (0, old_v.t)
	self.copyNode(old_v, new_v)
	# Copy all other children of oldTree after the first child of newTree.
	old_v = old_v.next()
	while old_v:
		new_v = new_v.insertAfter(old_v.t)
		self.copyNode(old_v, new_v)
		old_v = old_v.next()
	# Recursively copy all descendents of oldTree.
	new_v = newTree.firstChild()
	old_v = oldTree.firstChild()
	while old_v:
		assert(new_v)
		self.copyTree(old_v, new_v)
		old_v = old_v.next()
		new_v = new_v.next()
	assert(new_v == None)</t>
<t tx="T2614">@ This function joins all nodes in the receiver and tree2.  This code makes no assumptions about the two trees, and some or all of the nodes may already have been joined.  The assert's guarantee that both trees have the same topology.
@c

def joinTreeTo (self, tree2):

	tree1 = self
	assert(tree2)
	# Join the roots.
	tree1.joinNodeTo ( tree2 )
	# Recursively join all subtrees.
	child1 = tree1.firstChild()
	child2 = tree2.firstChild()
	while child1:
		assert(child2)
		child1.joinTreeTo(child2)
		child1 = child1.next()
		child2 = child2.next()
	assert(child2 == None)</t>
<t tx="T2615">@ This function returns true if the receiver should be a clone.  This can be done quickly using the receiver's join list.

The receiver is a clone if and only it is structurally _dissimilar_ to a node joined to it.  Structurally _similar_ joined nodes have non-null, distinct and joined parents, and have the same child indices.

9/16/99 We now return the node that proves that the receiver should be a clone.  This allows us to dispense with the old "survivor" logic in commands::deleteHeadline.
@c

def shouldBeClone (self,verbose=0):

	p = self.parent()
	n = self.childIndex()
	if verbose:
		v = self.joinList
		es("shouldBeClone: self,self.parent():"+`self`+","+`self.parent()`)
		es("shouldBeClone: joinlist of self:")
		while v and v != self:
			es("v,v.parent():"+`v`+","+`v.parent()`)
			v=v.joinList

	v = self.joinList
	while v and v != self:
		vp = v.parent()
		if 0: # verbose:
			es("shouldBeClone:" + `v`)
			es("shouldBeClone: p,vp:" + `p` + "," + `vp`)
			es("shouldBeClone: join:" + `p.isJoinedTo(vp)`)
			es("shouldBeClone: indices:" + `n` + "," + `v.childIndex()`)
		if ( # self and v are sturcturally dissimilar if...
			(not p or not vp) or  # they are at the top level, or
			vp == p or  # have the same parent, or
			not p.isJoinedTo(vp) or  # have unjoined parents, or
			(v.childIndex() != n)): # have different child indices.
			if verbose: es("shouldBeClone returns true")
			return true
		v = v.joinList

	# The receiver is structurally similar to all nodes joined to it.
	if verbose: es("shouldBeClone returns false")
	return false</t>
<t tx="T2616"># This routine checks the structure of the receiver's tree.

def validateOutlineWithParent (self, p):

	result = true # optimists get only unpleasant surprises.
	parent = self.parent()
	childIndex = self.childIndex()
	&lt;&lt; validate parent ivar &gt;&gt;
	&lt;&lt; validate childIndex ivar &gt;&gt;
	&lt;&lt; validate x ivar &gt;&gt;

	# Recursively validate all the children.
	child = self.firstChild()
	while child:
		r = child.validateOutlineWithParent ( self )
		if not r: result = false
		child = child.next()
	return result</t>
<t tx="T2617">if parent != p:
	self.invalidOutline ( "Invalid parent link: " + parent.description() )</t>
<t tx="T2618">if p:
	if childIndex &lt; 0:
		self.invalidOutline ( "missing childIndex" + childIndex )
	elif childIndex &gt;= p.numberOfChildren():
		self.invalidOutline ( "missing children entry for index: " + childIndex )
elif childIndex &lt; 0:
	self.invalidOutline ( "negative childIndex" + childIndex )</t>
<t tx="T2619">if not self.t and p:
	self.invalidOutline ( "Empty t" )</t>
<t tx="T2620"># This method creates a cloned tree after oldTree.

def cloneTree (self, oldTree):
	# Create a new tree following oldTree.
	newTree = self.insertAfter(oldTree.t)
	newTree.initHeadString (oldTree.mHeadString)
	self.copyTree(oldTree, newTree)
	# Join the trees and copy clone bits.
	oldTree.joinTreeTo(newTree)
	oldTree.copyCloneBitsTo(newTree)
	return newTree</t>
<t tx="T2621"># This methods propagates clone bits from the receiver's tree to tree2.

def copyCloneBitsTo (self, tree2):

	tree1 = self
	assert(tree2)
	# Set the bit in the root.
	if tree1.isCloned():
		tree2.setClonedBit()
	else:
		tree2.clearClonedBit()
	# Recursively set the bits in all subtrees.
	child1 = tree1.firstChild()
	child2 = tree2.firstChild()
	while child1:
		assert(child2)
		if child1.isCloned():
			child2.setClonedBit()
		else:
			child2.clearClonedBit()
		child1 = child1.next()
		child2 = child2.next()
	assert(child2 == None)</t>
<t tx="T2622">def copyNode (self, old_node, new_node):

	new_node.mHeadString = old_node.mHeadString
	new_node.iconVal = old_node.iconVal</t>
<t tx="T2623"># This method creates all nodes that depend on the receiver.
def createDependents (self):

	v = self ; t = v.t ; parent = v.parent()
	if not parent: return
	# Copy v as the nth child of all nodes joined to parent.
	n = v.childIndex()
	# trace(`n` + ", " + `v`)
	p = parent.joinList
	while p and p != parent:
		copy = p.insertAsNthChild(n, t)
		copy.mHeadString = v.mHeadString
		copy.iconWithVal = v.iconVal
		self.copyTree(v, copy)
		v.joinTreeTo(copy)
		p = p.joinList</t>
<t tx="T2624"># Destroys all dependent vnodes and tree nodes associated with the receiver.

def destroyDependents (self):

	parent = self.parent()
	if not parent: return
	# Destroy the nth child of all nodes joined to the receiver's parent.
	n = self.childIndex()
	join = parent.joinList
	# trace(`n` + ", " + `self`)
	while join and join != parent:
		child = join.nthChild(n)
		if child:
			child.unjoinTree()
			child.unlink()
			child.destroyTree()
		join = join.joinList</t>
<t tx="T2625">@ This method destroys (irrevocably deletes) a vnode tree.

This code should be called only when it is no longer possible to undo a previous delete.  It is always valid to destroy dependent trees.
@c

def destroyTree (self):

	pass</t>
<t tx="T2626">def invalidOutline (self, message):

	s = "invalid outline: " + message + "\n"
	parent = self.parent()

	if parent:
		s += `parent`
	else:
		s += `self`

	alert ( s )</t>
<t tx="T2627">def isJoinedTo (self, v):

	return v and self.t == v.t</t>
<t tx="T2628"># Returns true if the nodes v1 and v2 are on the same join list.
def isOnJoinListOf (self, v2):

	v1 = self
	assert(v2 and v1.t and v2.t)
	
	# v1 and v2 must share the same tnode.
	if v1.t != v2.t: return false
	
	# v1 and v2 must have join lists.
	if not v1.joinList or not v2.joinList: return false
	
	# Return true if v2 is on v1's join list.
	v = v1.joinList
	while v and v != v1:
		if v == v2: return true
		v = v.joinList

	return false</t>
<t tx="T2629">@ This method joins the receiver to v2 if the two nodes have not already been joined. Joining involves placing each vnode on the others join list.
@c

def joinNodeTo (self, v2):

	v1 = self
	if v1.isOnJoinListOf(v2): return # 12/17/01: fix same bug as in LeoCB

	j1 = v1.joinList
	j2 = v2.joinList
	if j1 and j2:
		# Swapping pointers joins the two cycles.
		v1.joinList = j2  # Neither join list is None.
		v2.joinList = j1
	elif j1:
		v2.joinList = j1  # Link v2 after v1.
		v1.joinList = v2
	elif j2:
		v1.joinList = j2  # Link v1 after v2.
		v2.joinList = v1
	else:
		v1.joinList = v2  # point v1 and v2 at each other.
		v2.joinList = v1
	assert(v1.joinList and v2.joinList)</t>
<t tx="T2630"># Links the receiver after v.

def linkAfter (self, v):

	# trace(`v`)
	self.mParent = v.mParent
	self.mBack = v
	self.mNext = v.mNext
	v.mNext = self
	if self.mNext:
		self.mNext.mBack = self</t>
<t tx="T2631">def linkAsNthChild (self, p, n):

	"""Links the receiver as the n'th child of p"""

	v = self
	# trace(`v` + ", " + `p` + ", " + `n`)
	v.mParent = p
	if n == 0:
		v.mBack = None
		v.mNext = p.mFirstChild
		if p.mFirstChild:
			p.mFirstChild.mBack = v
		p.mFirstChild = v
	else:
		prev = p.nthChild(n-1) # zero based
		assert(prev)
		v.mBack = prev
		v.mNext = prev.mNext
		prev.mNext = v
		if v.mNext:
			v.mNext.mBack = v</t>
<t tx="T2632">@ Bug fix: 5/27/02.  We link in the rest of the tree only when oldRoot != None.  Otherwise, we are calling this routine from init code and we want to start with a pristine tree.
@c
def linkAsRoot(self, oldRoot = None):

	v = self ; c = v.commands ; tree = c.tree
	# trace(`v`)
	# Bug fix 3/16/02:
	# Clear all links except the child link.
	# This allows a node with children to be moved up properly to the root position.
	# v.mFirstChild = None
	v.mParent = None
	v.mBack = None
	# 5/27/02
	if oldRoot: oldRoot.mBack = v
	v.mNext = oldRoot
	tree.rootVnode = v
</t>
<t tx="T2633">def unlink (self):

	"""Unlinks the receiver from the tree before moving or deleting."""
	v = self ; c = v.commands ; tree = c.tree
	
	# trace(`v.mParent`+", child:"+`v.mFirstChild`+", back:"+`v.mBack`+", next:"+`v.mNext`)
	
	# Special case the root
	if v == tree.rootVnode:
		if not v.mNext: return # Should never happen.
		tree.rootVnode = v.mNext

	# Clear the links in other nodes
	if v.mBack:
		v.mBack.mNext = v.mNext
	if v.mNext:
		v.mNext.mBack = v.mBack
	if v.mParent and v == v.mParent.mFirstChild:
		v.mParent.mFirstChild = v.mNext

	# Clear the links in this node
	v.mParent = v.mNext = v.mBack = None</t>
<t tx="T2634">@ This code carefully unlinks the receiver from its join list.  We can not assume that all such links will eventually be cleared.
@c

def unjoinNode (self):

	next = self.joinList
	if not next: return

	if next.joinList == self:
		# The list contains only two elements.
		next.joinList = None
		self.joinList = None
	else:
		prev = None
		&lt;&lt; Set prev to the node that points to self &gt;&gt;
		# Remove self from the join list.
		prev.joinList = next
		self.joinList = None</t>
<t tx="T2635">@ We guard against any cycles in the join list, which would cause self loop to hang.  It's much better to cause an assert to fail.
@c

self.commands.clearAllVisited()

prev = next
while prev and prev.joinList != self:
	assert(not prev.isVisited())
	prev.setVisited()
	prev = prev.joinList</t>
<t tx="T2636"># This function unjoins all nodes of the receiver's tree.

def unjoinTree (self):

	v = self
	after = self.nodeAfterTree()
	while v and v != after:
		v.unjoinNode()
		v = v.threadNext()</t>
<t tx="T2637">@language python

from leoGlobals import *
import string,Tkinter

# Public constants used for defaults when leoConfig.txt can not be read.
default_page_width = 132
default_tab_width = 4
default_target_language = "python"
default_default_directory = None

ivars = [
	"tangle_batch_flag", "untangle_batch_flag",
	"use_header_flag", "output_doc_flag",
	"tangle_directory", "page_width", "tab_width",
	"target_language" ]

class LeoPrefs:
	@others</t>
<t tx="T2638">def __init__ (self,c):

	Tk = Tkinter
	&lt;&lt; set ivars &gt;&gt;
	self.commands = c
	self.top = top = Tk.Toplevel()
	c.frame.prefsPanel = self
	head,tail = os.path.split(c.frame.title)
	self.top.title("Prefs for " + tail)
	
	# Create the outer frame
	outer = Tk.Frame(top,bd=2,relief="groove")
	outer.pack(fill="both",expand=1,padx=2,pady=2)
	&lt;&lt; Create the Global Options frame &gt;&gt;
	&lt;&lt; Create the Tangle Options frame &gt;&gt;
	&lt;&lt; Create the Target Language frame &gt;&gt;
	&lt;&lt; Create the Ok, Cancel &amp; Revert buttons &gt;&gt;
	center_dialog(top) # Do this _after_ building the dialog!
	top.resizable(0,0) # neither height or width is resizable.
	self.top.protocol("WM_DELETE_WINDOW", self.OnClosePrefsFrame)
	self.init(c)
	# es("Prefs.__init__")</t>
<t tx="T2639"># These ivars have the same names as the corresponding ivars in commands class.

# Global options
self.page_width = default_page_width
self.tab_width = default_tab_width
self.tangle_batch_flag = 0
self.untangle_batch_flag = 0

self.tangle_batch_var = Tk.IntVar()
self.untangle_batch_var = Tk.IntVar()

# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = 0
self.output_doc_flag = 0

self.use_header_var = Tk.IntVar()
self.output_doc_var = Tk.IntVar()

# Default Target Language
self.target_language = default_target_language
self.lang_var = Tk.StringVar()</t>
<t tx="T2640"># Frame and title
w,glob = create_labeled_frame (outer,caption="Global Options")
w.pack(padx=2,pady=2,expand=1,fill="x")

# Page width &amp; page width
f = Tk.Frame(glob)
f.pack(anchor="w", pady="1m", expand=1, fill="x")

lab = Tk.Label(f, anchor="w", padx="1m", text="Page width:")
self.pageWidthText = txt = Tk.Text(f, height=1, width=4)
lab.pack(side="left")
txt.pack(side="left")
txt.bind("&lt;Key&gt;", self.idle_set_ivars)

lab2 = Tk.Label(f, padx="1m", text="Tab width:")
self.tabWidthText = txt2 = Tk.Text(f, height=1, width=4)
lab2.pack(side="left")
txt2.pack(side="left")
txt2.bind("&lt;Key&gt;", self.idle_set_ivars)

# Batch Checkbuttons...
# Can't easily use a list becasue we use different variables.
self.doneBox = doneBox = Tk.Checkbutton(glob,anchor="w",
	text="Run tangle_done.py after Tangle",
	variable=self.tangle_batch_var,command=self.idle_set_ivars)
self.unBox = unBox = Tk.Checkbutton(glob,anchor="w",
	text="Run untangle_done.py after Untangle",
	variable=self.untangle_batch_var,command=self.idle_set_ivars)
doneBox.pack(fill="x")
unBox.pack(fill="x")</t>
<t tx="T2641"># Frame and title
w,tangle = create_labeled_frame (outer,caption="Default Options")
w.pack(padx=2,pady=2,expand=1,fill="x")

# Label and text
lab3 = Tk.Label(tangle, anchor="w", text="Default tangle directory")
self.tangleDirectoryText = txt3 = Tk.Text(tangle, height=1, width=30)
txt3.bind("&lt;Key&gt;", self.idle_set_ivars) # Capture the change immediately
lab3.pack(            padx="1m", pady="1m", fill="x")
txt3.pack(anchor="w", padx="1m", pady="1m", fill="x")

# Checkbuttons
self.headerBox = header = Tk.Checkbutton(tangle,anchor="w",
	text="Tangle outputs header line",
	variable=self.use_header_var,command=self.idle_set_ivars)
self.docBox = doc = Tk.Checkbutton(tangle,anchor="w",
	text="Tangle outputs document chunks",
	variable=self.output_doc_var,command=self.idle_set_ivars)
header.pack(fill="x")
doc.pack(fill="x")</t>
<t tx="T2642">buttons = Tk.Frame(outer)
buttons.pack(padx=2,pady=2,expand=1,fill="x")

okButton = Tk.Button(buttons,text="OK",width=7,command=self.onOK)
cancelButton = Tk.Button(buttons,text="Cancel",width=7,command=self.onCancel)
revertButton = Tk.Button(buttons,text="Revert",width=7,command=self.onRevert)

okButton.pack(side="left",pady=7,expand=1)
cancelButton.pack(side="left",pady=7,expand=0)
revertButton.pack(side="left",pady=7,expand=1)</t>
<t tx="T2643"># This event handler gets executed when the user choose a new default language.

def set_lang (self):
	
	c = top() ; v = c.currentVnode()
	language = self.lang_var.get()
	c.target_language = self.target_language = language
	c.tree.recolor(v)
	# print "set_lang",language</t>
<t tx="T2644">@language python

# Tangle and Untangle.

from leoGlobals import *
import os,string

&lt;&lt; about Tangle and Untangle &gt;&gt;
&lt;&lt; constants &amp; synonyms &gt;&gt;

@others</t>
<t tx="T2645">class tst_node:
	@others</t>
<t tx="T2646">def __init__ (self,name,root_flag):

	# trace("tst_node.__init__" + `name`)
	self.name = name
	self.is_root = root_flag
	self.referenced = false
	self.parts = []</t>
<t tx="T2647">def __repr__ (self):

	return "tst_node:" + self.name</t>
<t tx="T2648">class part_node:
	@others</t>
<t tx="T2649">def __init__ (self,name,code,doc,is_root,is_dirty):

	# trace("part_node.__init__" + `name`)
	self.name = name # Section or file name.
	self.code = code # The code text.
	self.doc = doc # The doc text.
	self.is_dirty = is_dirty # true: vnode for body text is dirty.
	self.is_root = is_root # true: name is a root name.</t>
<t tx="T2650">def __repr__ (self):

	return "part_node:" + self.name</t>
<t tx="T2651">class ust_node:
	@others</t>
<t tx="T2652">@ The text has been masssaged so that 1) it contains no leading indentation and 2) all code arising from section references have been replaced by the reference line itself.  Text for all copies of the same part can differ only in non-critical white space.
@c

def __init__ (self,name,code,part,of,nl_flag,update_flag):

	# trace("ust_node.__init__", `name` +":"+ `part`)
	self.name = name # section name
	self.parts = {} # parts dict
	self.code = code # code text
	self.part = part # n in "(part n of m)" or zero.
	self.of = of  # m in "(part n of m)" or zero.
	self.nl_flag = nl_flag  # true: section starts with a newline.
	self.update_flag = update_flag # true: section corresponds to a section in the outline.</t>
<t tx="T2653">def __repr__ (self):

	return "ust_node:" + self.name</t>
<t tx="T2654">class def_node:
	@others</t>
<t tx="T2655">@ The text has been masssaged so that 1) it contains no leading indentation and 2) all code arising from section references have been replaced by the reference line itself.  Text for all copies of the same part can differ only in non-critical white space.
@c

def __init__ (self,name,indent,part,of,nl_flag,code):

	if 0:
		trace("def_node.__init__",
			"name:" + name + ", part:" + `part` + ", of:" + `of` + ", indent:" + `indent`)
	self.name = name
	self.indent = indent
	self.code = code
	if self.code == None: self.code = ""
	self.part = part
	self.of = of
	self.nl_flag = nl_flag</t>
<t tx="T2656">def __repr__ (self):

	return "def_node:" + self.name</t>
<t tx="T2657">@doc Stephen P. Schaefer, 9/2/2002
Collect the root node specific attributes in an
easy-to-use container.
@code
class root_attributes:
	@others</t>
<t tx="T2658">@ Stephen P. Schaefer, 9/2/2002
Keep track of the attributes of a root node
@c

def __init__ (self, tangle_state):

	if 0:
		&lt;&lt; trace the state &gt;&gt;
	self.language = tangle_state.language
	self.single_comment_string = tangle_state.single_comment_string
	self.start_comment_string = tangle_state.start_comment_string
	self.end_comment_string = tangle_state.end_comment_string
	self.use_header_flag = tangle_state.use_header_flag
	self.print_mode = tangle_state.print_mode
	
	# of all the state variables, this one isn't set in tangleCommands.__init__
	# peculiar
	try:
		self.path = tangle_state.path
	except AttributeError:
		self.path = None
	
	self.page_width = tangle_state.page_width
	self.tab_width = tangle_state.tab_width
	self.first_lines = tangle_state.first_lines # Stephen P. Schaefer 9/13/2002</t>
<t tx="T2659">try:
	if tangle_state.path: pass
except AttributeError:
	tangle_state.path = None
	
trace("def_root_attribute.__init__",
	"language:" + tangle_state.language +
	", single_comment_string: " + tangle_state.single_comment_string +
	", start_comment_string: " + tangle_state.start_comment_string +
	", end_comment_string: " + tangle_state.end_comment_string +
	", use_header_flag: " + choose(tangle_state.use_header_flag, "true", "false") +
	", print_mode: " + tangle_state.print_mode +
	", path: " + choose(tangle_state.path, tangle_state.path, "") +
	", page_width: " + tangle_state.page_width +
	", tab_width: " + tangle_state.tab_width +
	# Stephen P. Schaefer 9/13/2002
	", first_lines: " + tangle_state.first_lines)</t>
<t tx="T2660">def __repr__ (self):

	return ("root_attributes: language: " + self.language +
        ", single_comment_string: " + self.single_comment_string +
		", start_comment_string: " +	self.start_comment_string +
		", end_comment_string: " +	self.end_comment_string +
		", use_header_flag: " + choose(self.use_header_flag, "true", "false") +
		", print_mode: " + self.print_mode +
		", path: " + self.path +
		", page_width: " + self.page_width +
		", tab_width: " + self.tab_width +
		# Stephen P. Schaefer 9/13/2002
		", first_lines: " + self.first_lines)
</t>
<t tx="T2661">class tangleCommands:
	@others</t>
<t tx="T2662">def __init__ (self,commands):

	self.commands = commands
	self.init_ivars()</t>
<t tx="T2663"># Called by __init__

def init_ivars(self):

	c = self.commands
	&lt;&lt; init tangle ivars &gt;&gt;
	&lt;&lt; init untangle ivars &gt;&gt;
	
# Called by scanAllDirectives

def init_directive_ivars (self):

	c = self.commands
	&lt;&lt; init directive ivars &gt;&gt;</t>
<t tx="T2664"># Various flags and counts...

self.errors = 0 # The number of errors seen.
self.tangling = true # true if tangling, false if untangling.
self.path_warning_given = false # true: suppress duplicate warnings.
self.tangle_indent = 0 # Level of indentation during pass 2, in spaces.
self.file_name = c.frame.mFileName # The file name (was a bridge function)
self.v = None # vnode being processed.
self.output_file = None # The file descriptor of the output file.
self.start_mode = "doc" # "code" or "doc".  Use "doc" for compatibility.
self.tangle_default_directory = None # Default directory set by scanAllDirectives.

@ Symbol tables: the TST (Tangle Symbol Table) contains all section names in the outline. The UST (Untangle Symbol Table) contains all sections defined in the derived file.
@c
self.tst = {}
self.ust = {}

# The section stack for Tangle and the definition stack for Untangle.
self.section_stack = []
self.def_stack = []

@ The list of all roots. The symbol table routines add roots to self list during pass 1. Pass 2 uses self list to generate code for all roots.
@c
self.root_list = []

# The delimiters for comments created by the @comment directive.
self.single_comment_string = "//"  # present comment delimiters.
self.start_comment_string = "/*"
self.end_comment_string = "*/"
self.sentinel = None

# The filename following @root in a headline.
# The code that checks for &lt; &lt; * &gt; &gt; = uses these globals.
self.root = None
self.root_name = None

# Formerly the "tangle private globals"
# These save state during tangling and untangling.
# It is possible that these will be removed...
if 1:
	self.head_root = None
	self.code = None
	self.doc = None
	self.header_name = None
	self.header = None
	self.section_name = None

@ The following records whether we have seen an @code directive in a body text.
If so, an @code represents &lt; &lt; header name &gt; &gt; = and it is valid to continue a section definition.
@c
self.code_seen = false # true if @code seen in body text.

# Support of output_newline option
self.output_newline = getOutputNewline()</t>
<t tx="T2665">@ Untangle vars used while comparing.
@c
self.line_comment = self.comment = self.comment_end = None
self.comment2 = self.comment2_end = None
self.string1 = self.string2 = self.verbatim = None
self.message = None # forgiving compare message.</t>
<t tx="T2666">@ Only top-level drivers initialize ivars.
</t>
<t tx="T2667">def initTangleCommand (self):

	c = self.commands
	c.endEditing()
	
	es("Tangling...")
	c.setIvarsFromPrefs()
	self.init_ivars()
	self.tangling = true</t>
<t tx="T2668">def initUntangleCommand (self):

	c = self.commands
	c.endEditing()
	
	es("Untangling...")
	c.setIvarsFromPrefs()
	self.init_ivars()
	self.tangling = false</t>
<t tx="T2669">def tangle(self):

	c = self.commands ; v = c.currentVnode()
	self.initTangleCommand()
	self.tangleTree(v,report_errors)
	es("Tangle complete")</t>
<t tx="T2670">def tangleAll(self):

	c = self.commands ; v = c.rootVnode()
	self.initTangleCommand()
	has_roots = false

	while v:
		ok = self.tangleTree(v,dont_report_errors)
		if ok: has_roots = true
		if self.path_warning_given:
			break # Fatal error.
		v = v.next()

	if not has_roots:
		es("----- The outline contains no roots")
	elif self.errors &gt; 0 and not self.path_warning_given:
		es("----- Tangle halted because of errors")
	else:
		es("Tangle complete")</t>
<t tx="T2671">def tangleMarked(self):

	c = self.commands ; v = c.rootVnode()
	c.clearAllVisited() # No roots have been tangled yet.
	self.initTangleCommand()
	any_marked = false

	while v:
		is_ignore, i = is_special(v.bodyString(),0,"@ignore")
		# Only tangle marked and unvisited nodes.
		if is_ignore:
			v = v.nodeAfterTree()
		elif v.isMarked():
			ok = self.tangleTree(v,dont_report_errors)
			if ok: any_marked = true
			if self.path_warning_given:
				break # Fatal error.
			v = v.nodeAfterTree()
		else: v = v.threadNext()

	if not any_marked:
		es("----- The outline contains no marked roots")
	elif self.errors &gt; 0 and not self.path_warning_given:
		es("----- Tangle halted because of errors")
	else:
		es("Tangle complete")</t>
<t tx="T2672">@ This is the main routine of pass 1. It traverses the tree whose root is given, handling each headline and associated body text.
@c

def tanglePass1(self,v):

	next = v.nodeAfterTree()
	
	while v and v != next:
		self.v = v
		self.setRootFromHeadline(v)
		dict = get_directives_dict(v.bodyString(),[self.head_root])
		is_ignore = dict.has_key("ignore")
		if is_ignore:
			v = v.nodeAfterTree()
			continue
		# This must be called after root_name has been set.
		if self.tangling:
			self.scanAllDirectives(v,require_path,report_errors) # calls init_directive_ivars.
		# Scan the headline and body text.
		self.skip_headline(v)
		self.skip_body(v)
		v = v.threadNext()
		if self.errors &gt;= max_errors:
			es("----- Halting Tangle: too many errors")
			break

	if self.tangling:
		self.st_check()
		# trace(self.st_dump(verbose_flag=true))</t>
<t tx="T2673"># At this point v is the root of the tree that has been tangled.

def tanglePass2(self):

	self.v = None # self.v is not valid in pass 2.

	if self.errors &gt; 0:
		es("----- No file written because of errors")
	elif self.root_list == None:
		es("----- The outline contains no roots")
	else:
		self.put_all_roots() # pass 2 top level function.</t>
<t tx="T2674">@ This funtion tangles all nodes in the tree whose root is v. It reports on its results if report_flag is true.

This function is called only from the top level, so there is no need to initialize globals.
@c

def tangleTree(self,v,report_flag):

	assert(v)
	any_root_flag = false
	next = v.nodeAfterTree()
	self.path_warning_given = false

	while v and v != next:
		self.setRootFromHeadline(v)
		dict = get_directives_dict(v.bodyString(),[self.head_root])
		is_ignore = dict.has_key("ignore")
		is_root = dict.has_key("root")
		is_unit = dict.has_key("unit")
		if is_ignore:
			v = v.nodeAfterTree()
		elif not is_root and not is_unit:
			v = v.threadNext()
		else:
			self.tanglePass1(v) # sets self.v
			if self.root_list and self.tangling:
				any_root_flag = true
				self.tanglePass2() # self.v invalid in pass 2.
			self.cleanup()
			v = v.nodeAfterTree()
			if self.path_warning_given: break # Fatal error.

	if self.tangling and report_flag and not any_root_flag:
		# This is done by Untangle if we are untangling.
		es("----- The outline contains no roots")
	return any_root_flag</t>
<t tx="T2675">def untangle(self):

	c = self.commands ; v = c.currentVnode()
	self.initUntangleCommand()
	
	c.beginUpdate()
	self.untangleTree(v,report_errors)
	c.endUpdate()
	es("Untangle complete")</t>
<t tx="T2676">def untangleAll(self):

	c = self.commands ; v = c.rootVnode()
	self.initUntangleCommand()
	has_roots = false

	c.beginUpdate()
	while v:
		ok = self.untangleTree(v,false)
		if ok: has_roots = true
		v = v.next()
	c.endUpdate()
	
	if not has_roots:
		es("----- The outline contains no roots")
	elif self.errors &gt; 0:
		es("----- Untangle command halted because of errors")
	else:
		es("Untangle complete")</t>
<t tx="T2677">def untangleMarked(self):

	c = self.commands ; v = c.rootVnode()
	self.initUntangleCommand()
	marked_flag = false

	c.beginUpdate()
	while v:
		if v.isMarked():
			ok = self.untangleTree(v,dont_report_errors)
			if ok: marked_flag = true
			if self.errors &gt; 0: break
			v = v.nodeAfterTree()
		else: v = v.threadNext()
	c.endUpdate()

	if not marked_flag:
		es("----- The outline contains no marked roots")
	elif self.errors &gt; 0:
		es("----- Untangle command halted because of errors")
	else:
		es("Untangle complete")</t>
<t tx="T2678">@ This method untangles the derived files in a vnode known to contain at least one @root directive. The work is done in two passes. The first pass creates the UST by scanning the derived file. The second pass updates the outline using the UST and a TST that is created during the pass.

We assume that all sections from root to end are contained in the derived file, and we attempt to update all such sections. The begin/end params indicate the range of nodes to be scanned when building the TST.
@c

def untangleRoot(self,root,begin,end):

	# trace("root,begin,end:" + `root` + `begin` + `end`)
	&lt;&lt; Set path &amp; root_name to the file specified in the @root directive &gt;&gt;
	&lt;&lt; return if @silent or unknown language &gt;&gt;
	&lt;&lt; Read the file into file_buf &gt;&gt;
	es("@root " + path)
	# Pass 1: Scan the C file, creating the UST
	self.scan_derived_file(file_buf)
	# trace(self.ust_dump())
	if self.errors == 0:
		&lt;&lt; Pass 2: Untangle the outline using the UST and a newly-created TST &gt;&gt;
	self.cleanup()</t>
<t tx="T2679">if self.language == "unknown":
	es("**Unknown language for " + path)
	return

if self.print_mode in ("quiet","silent"):
	es("@" + self.print_mode +  " inhibits untangle for " + path)
	return
</t>
<t tx="T2680">s = root.bodyString()
i = 0
while i &lt; len(s):
	code, junk = self.token_type(s,i,report_errors)
	if code == at_root:
		# token_type sets root_name unless there is a syntax error.
		if self.root_name: path = self.root_name
		break
	else: i = skip_line(s,i)
	
if not self.root_name:
	# A bad @root command.  token_type has already given an error.
	self.cleanup()
	return</t>
<t tx="T2681">f = None
try:
	path = os.path.join(self.tangle_directory,path)
	f = open(path)
	if f:
		file_buf = f.read()
		file_buf = string.replace(file_buf,body_ignored_newline,'')
except:
	if f: f.close()
	es("error reading: " + path)
	es_exception()
	self.cleanup()
	return</t>
<t tx="T2682">@ This code untangles the root and all its siblings. We don't call tangleTree here because we must handle all siblings.  tanglePass1 handles an entire tree.  It also handles @ignore.
@c

v = begin
while v and v != end:
	self.tanglePass1(v)
	if self.errors != 0:
		break
	v = v.nodeAfterTree()

self.ust_warn_about_orphans()</t>
<t tx="T2683"># This funtion is called when the user selects any "Untangle" command.

def untangleTree(self,v,report_flag):

	# trace(`v`)
	c = self.commands
	any_root_flag = false
	afterEntireTree = v.nodeAfterTree()
	# Initialize these globals here: they can't be cleared later.
	self.head_root = None
	self.errors = 0
	c.clearAllVisited() # Used by untangle code.

	while v and v != afterEntireTree and self.errors == 0:
		self.setRootFromHeadline(v)
		dict = get_directives_dict(v.bodyString(),[self.head_root])
		ignore = dict.has_key("ignore")
		root = dict.has_key("root")
		unit = dict.has_key("unit")
		if ignore:
			v = v.nodeAfterTree()
		elif unit:
			# Expand the context to the @unit directive.
			unitNode = v   # 9/27/99
			afterUnit = v.nodeAfterTree()
			v = v.threadNext()
			while v and v != afterUnit and self.errors == 0:
				self.setRootFromHeadline(v)
				dict = get_directives_dict(v.bodyString(),[self.head_root])
				root = dict.has_key("root")
				if root:
					any_root_flag = true
					end = None
					&lt;&lt; set end to the next root in the unit &gt;&gt;
					# trace("end:" + `end`)
					self.scanAllDirectives(v,require_path,report_errors)
					self.untangleRoot(v,unitNode,afterUnit)
					v = end
				else: v = v.threadNext()
		elif root:
			# Limit the range of the @root to its own tree.
			afterRoot = v.nodeAfterTree()
			any_root_flag = true
			self.scanAllDirectives(v,require_path,report_errors)
			self.untangleRoot(v,v,afterRoot) # 9/27/99
			v = afterRoot
		else:
			v = v.threadNext()
	if report_flag:
		if not any_root_flag:
			es("----- The outline contains no roots")
		elif self.errors &gt; 0:
			es("----- Untangle command halted because of errors")
	return any_root_flag</t>
<t tx="T2684">@ The untangle_root function will untangle an entire tree by calling untangleTree, so the following code ensures that the next @root node will not be an offspring of v.
@c

end = v.threadNext()
while end and end != afterUnit:
	flag, i = is_special(end.bodyString(),0,"@root")
	if flag and not v.isAncestorOf(end):
		break
	end = end.threadNext()
</t>
<t tx="T2685">@ This function sets ivars that keep track of the indentation level. We also remember where the next line starts because it is assumed to be the first line of a documentation section.

A headline can contain a leading section name.  If it does, we substitute the section name if we see an @c directive in the body text.
@c

def skip_headline(self,v):

	# trace(`v`)
	self.header = s = v.headString()
	# Set self.header_name.
	j = i = skip_ws(s,0)
	i, kind, end = self.is_section_name(s,i)
	if kind == bad_section_name:
		self.header_name = None
	else:
		self.header_name = s[j:end]</t>
<t tx="T2686"># This method outputs a doc section within a block comment.

def put_doc(self,s):

	# trace(`get_line(s,0)`)
	width = self.page_width
	words = 0 ; word_width = 0 ; line_width = 0
	# 8/1/02: can't use choose here!
	if self.single_comment_string == None: single_w = 0
	else: single_w = len(self.single_comment_string)
	# Make sure we put at least 20 characters on a line.
	if width - max(0,self.tangle_indent) &lt; 20:
		width = max(0,self.tangle_indent) + 20
	# Skip Initial white space in the doc part.
	i = skip_ws_and_nl(s,0)
	if i &lt; len(s) and (self.print_mode == "verbose" or self.print_mode == "quiet"):
		use_block_comment = self.start_comment_string and self.end_comment_string
		use_single_comment = not use_block_comment and self.single_comment_string
		# javadoc_comment = use_block_comment and self.start_comment_string == "/**"
		if use_block_comment or use_single_comment:
			if 0: # The section name ends in an self.onl().
				self.onl()
			self.put_leading_ws(self.tangle_indent)
			if use_block_comment:
				self.os(self.start_comment_string)
			&lt;&lt; put the doc part &gt;&gt;
			self.onl()
			self.put_leading_ws(self.tangle_indent)
			if use_block_comment:
				self.os(self.end_comment_string)
			self.onl()
		else: self.onl()</t>
<t tx="T2687">@ This code fills and outputs each line of a doc part. It keeps track of whether the next word will fit on a line,and starts a new line if needed.
@c

if use_single_comment:
	# New code: 5/31/00
	self.os(self.single_comment_string) ; self.otab()
	line_width =(single_w / abs(self.tab_width) + 1) * abs(self.tab_width)
else:
	line_width = abs(self.tab_width)
	self.onl() ; self.otab()
self.put_leading_ws(self.tangle_indent)
line_width += max(0,self.tangle_indent)
words = 0 ; word_width = 0
while i &lt; len(s):
	&lt;&lt;output or skip whitespace or newlines&gt;&gt;
	if i &gt;= len(s):
		break
	&lt;&lt;compute the width of the next word&gt;&gt;
	if words == 0 or line_width + word_width &lt; width:
		words += 1
		&lt;&lt;output next word&gt;&gt;
		line_width += word_width
	else:
		# 11-SEP-2002 DTHEIN: Fixed linewrapping bug in
		# tab-then-comment sequencing
		self.onl()
		if use_single_comment:
			self.os(self.single_comment_string) ; self.otab()
			line_width = (single_w / abs(self.tab_width) + 1) * abs(self.tab_width)
		else:
			self.otab()
			line_width = abs(self.tab_width)
		words = 0
		self.put_leading_ws(self.tangle_indent)
 		# tangle_indent is in spaces.
		line_width += max(0,self.tangle_indent)
</t>
<t tx="T2688">@ This outputs whitespace if it fits, and ignores it otherwise, and starts a new line if a newline is seen. The effect of self code is that we never start a line with whitespace that was originally at the end of a line.
@c

while is_ws_or_nl(s,i):
	ch = s[i]
	if ch == '\t':
		pad = abs(self.tab_width) - (line_width % abs(self.tab_width))
		line_width += pad
		if line_width &lt; width: self.otab()
		i += 1
	elif ch == ' ':
		line_width += 1
		if line_width &lt; width: self.os(ch)
		i += 1
	else:
		assert(is_nl(s,i))
		self.onl()
		if use_single_comment:
			# New code: 5/31/00
			self.os(self.single_comment_string) ; self.otab()
			line_width = (single_w / abs(self.tab_width) + 1) * abs(self.tab_width)
		else:
			self.otab()
			line_width = abs(self.tab_width)
		i = skip_nl(s,i)
		words = 0
		self.put_leading_ws(self.tangle_indent)
 		# tangle_indent is in spaces.
		line_width += max(0,self.tangle_indent)
</t>
<t tx="T2689">j = i ; word_width = 0
while j &lt; len(s) and not is_ws_or_nl(s,j):
	word_width += 1
	j += 1</t>
<t tx="T2690">while i &lt; len(s) and not is_ws_or_nl(s,i):
	self.os(s[i])
	i += 1</t>
<t tx="T2691"># This method outputs one part of a section definition.

def put_part_node(self,part,no_first_lws_flag):

	if 0:
		if part: name = part.name # can't use choose.
		else: name = "&lt;NULL part&gt;"
		trace(`name`)

	if part.doc and self.output_doc_flag and self.print_mode != "silent" and part.doc:
		self.put_doc(part.doc)

	if part.code:
		self.put_code(part.code,no_first_lws_flag)</t>
<t tx="T2692">@ We can not allow a section to be defined in terms of itself, either directly or indirectly.

We push an entry on the section stack whenever beginning to expand a section and pop the section stack at the end of each section.  This method checks whether the given name appears in the stack. If so, the section is defined in terms of itself.
@c

def section_check (self,name):

	if name in self.section_stack:
		s = "Invalid recursive reference of " + name + "\n"
		for n in self.section_stack:
			s += "called from: " + n + "\n"
		self.error(s)
		return false
	return true</t>
<t tx="T2693"># Dumps the given symbol table in a readable format.

def st_dump(self,verbose_flag=true):
	
	s = "\ndump of symbol table...\n"
	keys = self.tst.keys()
	keys.sort()
	for name in keys:
		section = self.tst[name]
		if verbose_flag:
			s += self.st_dump_node(section)
		else:
			type = choose(len(section.parts)&gt;0,"  ","un")
			s += ("\n" + type + "defined:[" + section.name + "]")
	return s</t>
<t tx="T2694"># Dumps each part of a section's definition.

def st_dump_node(self,section):

	s = ("\nsection: " + section.name +
		", referenced:" + `section.referenced` +
		", is root:" + `section.is_root`)
	
	if len(section.parts) &gt; 0:
		s += "\n----- parts of " + angleBrackets(section.name)
		n = 1 # part list is in numeric order
		for part in section.parts:
			s += "\n----- Part " + `n`
			n += 1
			s += "\ndoc:  [" + `part.doc`  + "]"
			s += "\ncode: [" + `part.code` + "]"
		s += "\n----- end of partList\n"
	return s</t>
<t tx="T2695">@ Enters names and their associated code and doc parts into the given symbol table.
`is_dirty` is used only when entering root names.
@c

def st_enter(self,name,code,doc,multiple_parts_flag,is_root_flag):
	
	# trace(`name`)
	section = self.st_lookup(name,is_root_flag)
	assert(section)
	if doc:
		doc = string.rstrip(doc) # remove trailing lines.
	if code:
		if self.print_mode != "silent": # @silent supresses newline processing.
			i = skip_blank_lines(code,0) # remove leading lines.
			if i &gt; 0: code = code[i:] 
			if code and len(code) &gt; 0: code = string.rstrip(code) # remove trailing lines.
		if len(code) == 0: code = None
	if code:
		&lt;&lt; check for duplicate code definitions &gt;&gt;
	if code or doc:
		part = part_node(name,code,doc,is_root_flag,false) # not dirty
		section.parts.append(part)
	else: # A reference
		section.referenced = true
	if is_root_flag:
		self.root_list.append(section)
		section.referenced = true # Mark the root as referenced.
		&lt;&lt;remember root node attributes&gt;&gt;
	# Stephen Schaefer, 9/2/02
	return len(section.parts) # part number
</t>
<t tx="T2696">for part in section.parts:

	if part.code and multiple_parts_flag == disallow_multiple_parts:
		# Give the message only for non-empty parts.
		self.error("Multiple parts not allowed for " + name)
	  	return 0 # part number

	if self.tangling and code and code == part.code:
		es("Warning: possible duplicate definition of: &lt;&lt;" +
			section.name + "&gt;&gt;")</t>
<t tx="T2697"># Stephen Schaefer, 9/2/02
# remember the language and comment characteristics
section.root_attributes = root_attributes(self)</t>
<t tx="T2698"># Enters a root name into the given symbol table.

def st_enter_root_name(self,name,code,doc):
	
	# assert(code)
	if name: # User errors can result in an empty @root name.
		self.st_enter(name,code,doc,disallow_multiple_parts,is_root_name)</t>
<t tx="T2699">@ This function enters a section name into the given symbol table.
The code and doc pointers are None for references.
@c

def st_enter_section_name(self,name,code,doc,multiple_parts_flag):
	
	return self.st_enter(name,code,doc,multiple_parts_flag,not_root_name)</t>
<t tx="T2700">@ This function looks up name in the symbol table and creates a tst_node for it if it does not exist.
@c

def st_lookup(self,name,is_root_flag):

	if is_root_flag:
		key = name
	else:
		key = self.standardize_name(name)

	if self.tst.has_key(key):
		section = self.tst[key]
		# trace("found:" + key)
		return section
	else:
		# trace("not found:" + key)
		section = tst_node(key,is_root_flag)
		self.tst [key] = section
		return section</t>
<t tx="T2701">def ust_dump (self):

	s = "\n---------- Untangle Symbol Table ----------"
	keys = self.ust.keys()
	keys.sort()
	for name in keys:
		section = self.ust[name]
		s += "\n\n" + section.name
		for part in section.parts.values():
			assert(part.of == section.of)
			s += "\n----- part " + `part.part` + " of " + `part.of` + " -----\n"
			s += `get_line(part.code,0)`
	s += "\n--------------------"
	return s</t>
<t tx="T2702">@ This routine enters names and their code parts into the given table. The 'part' and 'of' parameters are taken from the "(part n of m)" portion of the line that introduces the section definition in the C code.

If no part numbers are given the caller should set the 'part' and 'of' parameters to zero.  The caller is reponsible for checking for duplicate parts.

This function handles names scanned from a source file; the corresponding st_enter routine handles names scanned from outlines.
@c

def ust_enter (self,name,part,of,code,nl_flag,is_root_flag):

	if not is_root_flag:
		name = self.standardize_name(name)
	&lt;&lt; remove blank lines from the start and end of the text &gt;&gt;
	u = ust_node(name,code,part,of,nl_flag,false) # update_flag
	if not self.ust.has_key(name):
		self.ust[name] = u
	section = self.ust[name]
	section.parts[part]=u # Parts may be defined in any order.
	# trace("section name: [" + name + "](" + `part` + " of " + `of` + ")..."+`get_line(code,0)`)</t>
<t tx="T2703">i = skip_blank_lines(code,0)
if i &gt; 0:
	code = code[i:]
	code = string.rstrip(code)
</t>
<t tx="T2704"># Searches the given table for a part matching the name and part number.

def ust_lookup (self,name,part_number,is_root_flag,update_flag):
	
	# trace(`name` + ":" + `part_number`)
	
	if not is_root_flag:
		name = self.standardize_name(name)

	if part_number == 0: part_number = 1 # A hack: zero indicates the first part.
	if self.ust.has_key(name):
		section = self.ust[name]
		if section.parts.has_key(part_number):
			part = section.parts[part_number]
			if update_flag: part.update_flag = true
			# trace("found:" + name + " (" + `part_number` + ")...\n" + `get_line(part.code,0)`)
			return part, true

	# trace("not found:" + name + " (" + `part_number` + ")...\n")
	return None, false</t>
<t tx="T2705">@ This function is called to massage an @doc part in the ust. We call this routine only after a mismatch in @doc parts is found between the ust and tst. On entry, the parameters point to the inside of a block C comment: the opening and closing delimiters are not part of the text handled by self routine.

This code removes newlines that may have been inserted by the Tangle command in a block comment. Tangle may break lines differently in different expansions, but line breaks are ignored by forgiving_compare() and doc_compare() within block C comments.

We count the leading whitespace from the first non-blank line and remove this much whitespace from all lines. We also remove singleton newlines and replace sequences of two or more newlines by a single newline.
@c

def massage_block_comment (self,s):

	c = self.commands
	newlines = 0  # Consecutive newlines seen.
	i = skip_blank_lines(s,0)
	# Copy the first line and set n
	i, n = skip_leading_ws_with_indent(s,i,c.tab_width)
	j = i ; i = skip_to_end_of_line(s,i)
	result = s[j:i]
	while i &lt; len(s):
		assert(is_nl(s,i))
		newlines += 1
		# Replace the first newline with a blank.
		result += ' ' ; i += 1
		while i &lt; len(s) and is_nl(s,i):
			i += 1 # skip the newline.
		j = i ; i = skip_ws(s,i)
		if is_nl(s,i)and newlines &gt; 1:
			# Skip blank lines.
			while is_nl(s,i):
				i += 1
		else:
			# Skip the leading whitespace.
			i = j # back track
			i = skip_leading_ws(s,i,n,c.tab_width)
			newlines = 0
			# Copy the rest of the line.
			j = i ; i = skip_to_end_of_line(s,i)
			result += s[j:i]
	return result
</t>
<t tx="T2706">def mismatch (self,message):

	self.message = message</t>
<t tx="T2707">@ This function scans an entire derived file in s, discovering section or part definitions.

This is the easiest place to delete leading whitespace from each line: we simply don't copy it.  We also ignore leading blank lines and trailing blank lines.  The resulting definition must compare equal using the "forgiving" compare to any other definitions of that section or part.

We use a stack to handle nested expansions.  The outermost level of expansion corresponds to the @root directive that created the file.  When the stack is popped, the indent variable is restored.

self.root_name is the name of the file mentioned in the @root directive.

The caller has deleted all body_ignored_newlines from the text.
@c

def scan_derived_file (self,s):

	c = self.commands
	self.def_stack = []
	&lt;&lt; set the private global matching vars &gt;&gt;
	line_indent = 0  # The indentation to use if we see a section reference.
	# indent is the leading whitespace to be deleted.
	i, indent = skip_leading_ws_with_indent(s,0,self.tab_width)
	&lt;&lt; Skip the header line output by tangle &gt;&gt;
	# The top level of the stack represents the root.
	self.push_new_def_node(self.root_name,indent,1,1,true)
	while i &lt; len(s):
		ch = s[i]
		if ch == body_ignored_newline:
			i += 1 # ignore
		elif ch == body_newline:
			&lt;&lt; handle the start of a new line &gt;&gt;
		elif match(s,i,self.sentinel) and self.is_sentinel_line(s,i):
			&lt;&lt; handle a sentinel line  &gt;&gt;
		elif match(s,i,self.line_comment) or match(s,i,self.verbatim):
			&lt;&lt; copy the entire line &gt;&gt;
		elif match(s,i,self.comment):
			&lt;&lt; copy a multi-line comment &gt;&gt;
		elif match(s,i,self.comment2):
			&lt;&lt; copy an alternate multi-line comment &gt;&gt;
		elif match(s,i,self.string1) or match(s,i,self.string2):
			&lt;&lt; copy a string &gt;&gt;
		else:
			self.copy(ch) ; i += 1
	&lt;&lt; end all open sections &gt;&gt;</t>
<t tx="T2708"># Set defaults from the public globals set by the @comment command.
if self.single_comment_string:
	self.sentinel = self.single_comment_string
	self.sentinel_end = None
elif self.end_comment_string:
	self.sentinel = self.start_comment_string
	self.sentinel_end = self.end_comment_string
else:
	self.sentinel = self.sentinel_end = None
	
if 0:
	trace("single,start,end,sentinel:"+
		`self.single_comment_string` +":"+ `self.start_comment_string` +":"+
		`self.end_comment_string` +":"+ `self.sentinel`)

# Set defaults.  See set_delims_from_langauge.
self.line_comment = self.single_comment_string
self.comment = self.start_comment_string
self.comment_end = self.end_comment_string
self.comment2 = self.comment2_end = None
self.string1 = "\""
self.string2 = "'"
self.verbatim = None

# Set special cases.
if self.language == "plain":
	self.string1 = self.string2 = None # This is debatable.
	self.line_comment = None
if self.language == "pascal":
	self.comment2 = "(*" ; self.comment2_end = "*)"</t>
<t tx="T2709">if self.sentinel or self.comment:
	line = choose(self.sentinel,self.sentinel,self.comment) + " Created by Leo from" 
	if match(s,i,line):
		# Even a block comment will end on the first line.
		i = skip_to_end_of_line(s,i)</t>
<t tx="T2710">self.copy(ch) ; i += 1 # This works because we have one-character newlines.

# Set line_indent, used only if we see a section reference.
junk, line_indent = skip_leading_ws_with_indent(s,i,c.tab_width)
i = skip_leading_ws(s,i,indent,c.tab_width) # skip indent leading white space.</t>
<t tx="T2711">@ This is the place to eliminate the proper amount of whitespace from the start of each line. We do this by setting the 'indent' variable to the leading whitespace of the first _non-blank_ line following the opening sentinel.

Tangle increases the indentation by one tab if the section reference is not the first non-whitespace item on the line,so self code must do the same.
@c

# trace(`get_line(s,i)`)
result,junk,kind,name,part,of,end,nl_flag = self.is_sentinel_line_with_data(s,i)
assert(result==true)
&lt;&lt; terminate the previous part of this section if it exists &gt;&gt;

if kind == start_sentinel_line:
	indent = line_indent
	# Increase line_indent by one tab width if the
	# the section reference does not start the line.
	j = i - 1
	while j &gt;= 0:
		if is_nl(s,j):
			break
		elif not is_ws(s[j]):
			indent += abs(self.tab_width) ; break
		j -= 1
	# copy the section reference to the _present_ section,
	# but only if this is the first part of the section.
	if part &lt; 2: self.copy(name)
	# Skip to the first character of the new section definition.
	i = skip_to_end_of_line(s,i)
	# Start the new section.
	self.push_new_def_node(name,indent,part,of,nl_flag)
else:
	assert(kind == end_sentinel_line)
	# Skip the sentinel line.
	i = skip_to_end_of_line(s,i)
	# Skip a newline only if it was added after(!newline)
	if not nl_flag:
		i = skip_ws(s,i)
		i = skip_nl(s,i)
		i = skip_ws(s,i)
		# Copy any whitespace following the (!newline)
		while end and is_ws(s[end]):
			self.copy(s[end])
			end += 1
	# Restore the old indentation level.
	if len(self.def_stack) &gt; 0:
		indent = self.def_stack[-1].indent</t>
<t tx="T2712">@ We have just seen a sentinel line. Any kind of sentinel line will terminate a previous part of the present definition. For end sentinel lines, the present section name must match the name on the top of the stack.
@c

if len(self.def_stack) &gt; 0:
	dn = self.def_stack[-1]
	if self.compare_section_names(name,dn.name):
		dn = self.def_stack.pop()
		if len(dn.code) &gt; 0:
			thePart, found = self.ust_lookup(name,dn.part,false,false) # not root, not update
			# Check for incompatible previous definition.
			if found and not self.forgiving_compare(name,dn.part,dn.code,thePart.code):
				self.error("Incompatible definitions of " + name)
			elif not found:
				self.ust_enter(name,dn.part,dn.of,dn.code,dn.nl_flag,false) # not root
	elif kind == end_sentinel_line:
		self.error("Missing sentinel line for: " + name)</t>
<t tx="T2713">j = i ; i = skip_to_end_of_line(s,i)
self.copy(s[j:i])
</t>
<t tx="T2714">j = i
if self.language == "pascal":
	i = skip_pascal_string(s,i)
else:
	i = skip_string(s,i)
self.copy(s[j:i])</t>
<t tx="T2715">assert(self.comment_end)

# Scan for the ending delimiter.
j = i ; i += len(self.comment)
while i &lt; len(s) and not match(s,i,self.comment_end):
	i += 1
if match(s,i,self.comment_end):
	i += len(self.comment_end)
self.copy(s[j:i])</t>
<t tx="T2716">assert(self.comment2_end)
j = i
# Scan for the ending delimiter.
i += len(self.comment2)
while i &lt; len(s) and not match(s,i,self.comment2_end):
	i += 1
if match(s,i,self.comment2_end):
	i += len(self.comment2)
self.copy(s[j:i])</t>
<t tx="T2717">dn= None
while len(self.def_stack) &gt; 0:
	dn = self.def_stack.pop()
	if len(self.def_stack) &gt; 0:
		self.error("Unterminated section: " + dn.name)
if dn:
	# Terminate the root setcion.
	i = len(s)
	if dn.code and len(dn.code) &gt; 0:
		self.ust_enter(dn.name,dn.part,dn.of,dn.code,dn.nl_flag,true) # is_root_flag
	else:
		self.error("Missing root part")
else:
	self.error("Missing root section")</t>
<t tx="T2718">@ This function handles the actual updating of section definitions in the web.  Only code parts are updated, never doc parts.

During pass 2 of Untangle, skip_body() calls this routine when it discovers the definition of a section in the outline.  We look up the name in the ust. If an entry exists, we compare the code (the code part of an outline node) with the code part in the ust. We update the code part if necessary.

We use the forgiving_compare() to compare code parts. It's not possible to change only trivial whitespace using Untangle because forgiving_compare() ignores trivial whitespace.
@c

# Major change: 2/23/01: Untangle never updates doc parts.

def update_def (self,name,part_number,head,code,tail,is_root_flag): # Doc parts are never updated!

	# trace(`name` + ":" + `part_number` + ":" + `code`)
	v = self.v ; body = v.bodyString()
	if not head: head = ""
	if not tail: tail = ""
	if not code: code = ""
	false_ret = head + code + tail, len(head) + len(code), false
	part, found = self.ust_lookup(name,part_number,is_root_flag,true) # Set update
	if not found:
		return false_ret  # Not an error.
	ucode = part.code
	&lt;&lt; Remove leading blank lines and comments from ucode &gt;&gt;
	# trace(`ucode`)
	if not ucode or len(ucode) == 0:
		return false_ret # Not an error.
	if code and self.forgiving_compare(name,part,code,ucode):
		return false_ret # Not an error.
	# Update the body.
	es("***Updating: " + v.headString())
	i = skip_blank_lines(ucode,0)
	ucode = ucode[i:]
	ucode = string.rstrip(ucode)
	# Add the trailing whitespace of code to ucode.
	code2 = string.rstrip(code)
	trail_ws = code[len(code2):]
	ucode = ucode + trail_ws
	body = head + ucode + tail
	self.update_current_vnode(body)
	if 0:
		trace("head:" + `head`)
		trace("ucode:" + `ucode`)
		trace("tail:" + `tail`)
	return body, len(head) + len(ucode),true
</t>
<t tx="T2719">@ We assume that any leading comments came from an @doc part.  This isn't always valid and this code will eliminate such leading comments.  This is a defect in Untangle; it can hardly be avoided.
@c

i = skip_blank_lines(ucode,0)
j = skip_ws(ucode,i)
# trace("comment,end,single:"+`self.comment`+":"+`self.comment_end`+":"+`self.line_comment`)

if self.comment and self.comment_end:
	if ucode and match(ucode,j,self.comment):
		# Skip to the end of the block comment.
		i = j + len(self.comment)
		i = string.find(ucode,self.comment_end,i)
		if i == -1: ucode = None # An unreported problem in the user code.
		else:
			i += len(self.comment_end)
			i = skip_blank_lines(ucode,i)
elif self.line_comment:
	while ucode and match(ucode,j,self.line_comment):
		i = skip_line(ucode,i)
		i = skip_blank_lines(ucode,i)
		j = skip_ws(ucode,i)
# Only the value of ucode matters here.
if ucode: ucode = ucode[i:]</t>
<t tx="T2720">@ This function is called from within the Untangle logic to update the body text of self.v.
@c

def update_current_vnode (self,s):

	c = self.commands ; v = self.v
	assert(self.v)
	v.setBodyStringOrPane(s)

	c.beginUpdate()
	c.setChanged(true)
	v.setDirty()
	v.setMarked()
	c.endUpdate()</t>
<t tx="T2721">@ These utilities deal with tangle ivars, so they should be methods.
</t>
<t tx="T2722">def copy (self, s):

	assert(len(self.def_stack) &gt; 0)
	dn = self.def_stack[-1] # Add the code at the top of the stack.
	dn.code += s</t>
<t tx="T2723">def error (self,s):
	self.errors += 1
	es(s)
	
def pathError (self,s):
	if not self.path_warning_given:
		self.path_warning_given = true
		self.error(s)
	
def warning (self,s):
	es(s)
</t>
<t tx="T2724"># This function returns true if we are at the end of preprocessor directive.

def is_end_of_directive (self,s,i):

	return is_nl(s,i) and not self.is_escaped(s,i)</t>
<t tx="T2725">def is_end_of_string (self,s,i,delim):

	return i &lt; len(s) and s[i] == delim and not self.is_escaped(s,i)</t>
<t tx="T2726"># This function returns true if the s[i] is preceded by an odd number of back slashes.

def is_escaped (self,s,i):

	back_slashes = 0 ; i -= 1
	while i &gt;= 0 and s[i] == '\\':
		back_slashes += 1
		i -= 1
	return (back_slashes &amp; 1) == 1
</t>
<t tx="T2727"># This function pushes a new def_node on the top of the section stack.

def push_new_def_node (self,name,indent,part,of,nl_flag):
		
	# trace(`name` + ":" + `part`)
	node = def_node(name,indent,part,of,nl_flag,None)
	self.def_stack.append(node)</t>
<t tx="T2728"># This function scans a positive integer.
# returns (i,val), where val == -1 if there is an error.

def scan_short_val (self,s,i):

	if i &gt;= len(s) or s[i] not in string.digits:
		return i, -1

	j = i
	while i &lt; len(s) and s[i] in string.digits:
		i += 1

	val = int(s[j:i])
	# trace(s[j:i] + ":" + `val`)
	return i, val</t>
<t tx="T2729">@ This function skips past a section name that starts with @&lt; and ends with @&gt;. This code also skips any = following the section name.

Returns (i, kind, end), where kind is:

	bad_section_name:  @ &lt; with no matching @ &gt;
	section_ref: @ &lt; name @ &gt;
	section_def: @ &lt; name @ &gt; =

Unlike noweb, bad section names generate errors.
@c

def skip_cweb_section_name(self,s,i):
	
	j = i # Used for error message.
	kind = bad_section_name ; end = -1
	runon = false ; empty_name = true
	assert(s[i:i+2]=="@&lt;")
	i += 2
	while i &lt; len(s):
		if match(s,i,"@&gt;="):
			i += 3 ; end = i-1 ; kind = section_def ; break
		elif match(s,i,"@&gt;"):
			i += 2 ; end = i ; kind = section_ref ; break
		elif match(s,i,"@&lt;"):
			runon = true ; break
		elif match(s,i,"@@"): i += 2
		elif is_ws_or_nl(s,i): i += 1
		else:
			i += 1 ; empty_name = false

	if empty_name:
		scanError("empty CWEB section name: " + s[j:i])
		return i, bad_section_name, -1
	elif i &gt;= len(s) or runon:
		scanError("Run on CWEB section name: " + s[j:i])
		return i, bad_section_name, -1
	else:
		return i, kind, end</t>
<t tx="T2730">@ This function skips past a section name that starts with &lt; &lt; and might end with &gt; &gt; or &gt; &gt; =. The entire section name must appear on the same line.

Note: this code no longer supports extended noweb mode.

Returns (i, kind, end),
	end indicates the end of the section name itself (not counting the =).
	kind is one of:
		bad_section_name: "no matching "&gt;&gt;" or "&gt;&gt;"  This is _not_ a user error!
		section_ref: &lt; &lt; name &gt; &gt;
		section_def: &lt; &lt; name &gt; &gt; =
		at_root:     &lt; &lt; * &gt; &gt; =
@c
def skip_noweb_section_name(self,s,i):
	
	assert(match(s,i,"&lt;&lt;"))
	i += 2
	j = i # Return this value if no section name found.
	kind = bad_section_name ; end = -1 ; empty_name = true

	# Scan for the end of the section name.
	while i &lt; len(s) and not is_nl(s,i):
		if match(s,i,"&gt;&gt;="):
			i += 3 ; end = i - 1 ; kind = section_def ; break
		elif match(s,i,"&gt;&gt;"):
			i += 2 ; end = i ; kind = section_ref ; break
		elif is_ws_or_nl(s,i):
			i += 1
		elif empty_name and s[i] == '*':
			empty_name = false
			i = skip_ws(s,i+1) # skip the '*'
			if match(s,i,"&gt;&gt;="):
				i += 3 ; end = i - 1 ; kind = at_root ; break
		else:
			i += 1 ; empty_name = false

	if empty_name:
		kind = bad_section_name
	if kind == bad_section_name:
		i = j
	return i, kind, end</t>
<t tx="T2731">@ This code removes leading and trailing brackets, converts white space to a single blank and converts to lower case.
@c

def standardize_name (self,name):

	# Convert to lowercase.
	name = string.lower(name)
	# Convert whitespace to a single space.
	name = string.replace(name,'\t',' ')
	name = string.replace(name,'  ',' ')
	# Remove leading '&lt;'
	i = 0 ; n = len(name)
	while i &lt; n and name[i] == '&lt;':
		i += 1
	j = i
	# Find the first '&gt;'
	while i &lt; n and name [i] != '&gt;':
		i += 1
	name = string.strip(name[j:i])
	# trace(`name`)
	return name</t>
<t tx="T2732">@language python

@ This class implements a tree control similar to Windows explorer.  The draw code is based on code found in Python's IDLE program.  Thank you Guido van Rossum!

The tree class knows about vnodes.  The vnode class could be split into a base class (say a treeItem class) containing the ivars known to the tree class, and a derived class containing everything else, including, e.g., the bodyString ivar.  I haven't chosen to split the vnode class this way because nothing would be gained in Leo.
@c

from leoGlobals import *
import leoColor
import os,string,Tkinter,tkFont,types

&lt;&lt; about drawing and events &gt;&gt;
&lt;&lt; drawing constants &gt;&gt;

class leoTree:
	@others</t>
<t tx="T2733">def __del__ (self):

	# Can't trace while destroying.
	# print "tree.__del__"
	self.deleteBindings()
	pass</t>
<t tx="T2734"># Called on click in box and double-click in headline.

def OnBoxClick (self,v):

	if v.isExpanded():
		v.contract()
	else:
		v.expand()

	self.active = true
	self.select(v)
	self.canvas.focus_set() # This is safe.
	self.redraw()</t>
<t tx="T2735">def OnDeactivate (self, event=None):

	self.endEditLabel()
	self.dimEditLabel()
	self.active = false</t>
<t tx="T2736">@language python

# Undo manager for leo.py.

&lt;&lt; How Leo implements unlimited undo &gt;&gt;
&lt;&lt; Define optionl ivars &gt;&gt;
from leoGlobals import *
import types

class undoer:
	@others</t>
<t tx="T2737">optionalIvars = (
	"lastChild",
	"parent","oldParent",
	"back","oldBack",
	"n","oldN","oldV",
	"oldText","newText",
	"oldSel","newSel",
	"sort","select",
	"oldTree",
	"yview",
	# For incremental undo typing...
	"leading","trailing",
	"oldMiddleLines","newMiddleLines",
	"oldNewlines","newNewlines")</t>
<t tx="T2738">def findSharedVnode (self,target):

	c = self.commands ; v = c.rootVnode()
	while v:
		if v != target and v.t == target.t:
			return v
		v = v.threadNext()
	return None</t>
<t tx="T2739">@ This routine implements undo by properly replacing v's tree by the oldv tree.  For redo, just call this routine with these two variables interchanged.

This routine shows how to implement undo for any kind of operation, no matter how complex.  Just do:

	v_copy = c.copyTree(v)
	&lt; &lt; make arbitrary changes to v's tree &gt; &gt;
	c.undoer.setUndoParams("Op Name",v,select=current,oldTree=v_copy)

This way is far more elegant than calling v.destroyDependents and v.createDependents.  This is the way it is written in "The Book." Yes, entire trees are copied, but in the most general case that is necessary.
@c

def undoReplace (self,v,oldv):

	assert(v)
	assert(oldv)
	u = self ; c = u.commands
	j = v.joinList
	copies = []

	# For each node joined to v, swap in a copy of oldv.
	while j and j != v:
		nextj = j.joinList
		copy = c.copyTree(oldv)
		copies.append(copy)
		j.swap_links(copy,j)
		j = nextj

	# Swap v and oldv.
	v.swap_links(oldv,v)
	v = oldv
	
	# Join v to all copies.
	for copy in copies:
		v.joinTreeTo(copy)
		
	# Restore all clone bits.
	if v.shouldBeClone():
		v.setClonedBit()
	c.initAllCloneBits()</t>
<t tx="T2740">def undoSortChildren (self):

	u = self ; c = u.commands ; v = u.v
	assert(v)
	c.beginUpdate()
	if 1: # inside update...
		c.endEditing()
		index = 0
		for child in u.sort:
			child.moveToNthChildOf(v,index)
			index += 1
		v.setDirty()
		c.setChanged(true)
	c.endUpdate()</t>
<t tx="T2741">def undoSortSiblings (self):
	
	u = self ; c = u.commands ; v = u.v
	parent = v.parent()
	assert(v and parent)
	c.beginUpdate()
	if 1: # inside update...
		c.endEditing()
		index = 0
		for sib in u.sort:
			sib.moveToNthChildOf(parent,index)
			index += 1
		parent.setDirty()
		c.setChanged(true)
	c.endUpdate()</t>
<t tx="T2742">@language python

# Example tangle_done.py file.
# Leo catches all exceptions thrown here; there is no need for try:except blocks.

@others</t>
<t tx="T2743"># Leo calls this routine if "Run tangle-done.py after Tangle" is checked in the Prefs panel.

def run (root_list):

	print "tangle_done roots:"
	for root in root_list:
		print root
	
	if 0: # Run code contributed by Paul Paterson.
		convertRSTfilesToHTML(root_list)</t>
<t tx="T2744">@ This routine creates .html files from all .rst files in root_list, the list of files that have just been tangled.

Adapted from code by Paul Paterson.
@c

def convertRSTfilesToHTML(root_list):

	# Leo will report the execption if docutils is not installed.
	from docutils.core import Publisher 
	from docutils.io import FileInput,StringOutput,StringInput 
	import os
	
	for root in root_list: 
		base,fullname = os.path.split(root)
		name,ext = os.path.splitext(fullname)
		if ext == ".rst":
			file = os.path.join(base,name+".html")
			&lt;&lt; Convert root to corresponding .html file &gt;&gt;
</t>
<t tx="T2745"># Read .rst file into s.
f = open(root,"r")
s = f.read()
f.close()

# Restucture s into output.
pub = Publisher() 
pub.source = StringInput(pub.settings,source=s) 
pub.destination = StringOutput(pub.settings,encoding="utf-8") 
pub.set_reader('standalone',None,'restructuredtext') 
pub.set_writer('html') 
output = pub.publish()

# Write the corresponding html file.
f = open(file,"w")
f.write(output)
f.close()</t>
</tnodes>
</leo_file>
