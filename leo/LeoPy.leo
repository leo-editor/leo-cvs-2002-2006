<?xml version="1.0" encoding="UTF-8"?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="1551" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="10" left="10" height="624" width="768"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences allow_rich_text="0" tab_width="4" page_width="132" tangle_bat="0" untangle_bat="0" output_doc_chunks="1" defaultTargetLanguage="Python" use_header_flag="1">
	<defaultDirectory>c:\prog\LeoPy</defaultDirectory>
</preferences>
<find_panel_settings whole_word="1" search_body="1">
	<find_string>test</find_string>
	<change_string></change_string>
</find_panel_settings>
<vnodes>
<v t="T1"><vh>Diary</vh>
<v><vh>Feb 2002</vh>
<v><vh>02/10 1.0 released</vh>
<v t="T2"><vh>Added Contract Parent (Alt-0)</vh></v>
<v t="T3"><vh>Fixed bugs in Prefs panel</vh></v>
</v>
<v><vh>02/09 Preparing for release</vh>
<v t="T4"><vh>02/09 Got clean import of leoImport.py</vh></v>
<v t="T5"><vh>02/09 Created do-nothing leoUndo.py</vh></v>
<v t="T6"><vh>02/09 Updated current language properly in Prefs panel</vh></v>
<v t="T7"><vh>02/09 Re-marked @file nodes dirty on write errors</vh></v>
<v t="T8"><vh>02/09 Prefs Panel stick to current window</vh></v>
<v><vh>02/09 Tangle passes full regression test</vh></v>
<v t="T9"><vh>02/09 Added Sort Siblings</vh></v>
</v>
<v><vh>02/08 Regression testing</vh>
<v t="T10"><vh>02/08 Found Tangle problem</vh></v>
<v><vh>02/08 Cleaned up leoCompare.py</vh></v>
<v t="T11"><vh>02/08 @c in Tangled files</vh></v>
<v t="T12"><vh>02/08 Testing wiped out files!</vh></v>
</v>
<v><vh>02/07 New commands and bug fixes</vh>
<v t="T13"><vh>02/07 Possible reversion</vh></v>
<v><vh>02/07 Converted Import Files code</vh></v>
<v t="T14"><vh>02/07 Search suboutline only now applies to Search/ChangeAll</vh></v>
<v t="T15"><vh>02/07 Fixed bug in search()</vh></v>
<v><vh>02/07 Fixed bug: @others wasn't colored unless at left margin.</vh></v>
<v><vh>02/07 * Added indent and undent commands</vh></v>
<v t="T16"><vh>02/07 * Improved idle_body_key</vh></v>
</v>
<v><vh>02/06 Finished commands</vh>
<v t="T17"><vh>02/06 Rewrote and tested all Edit Body commands</vh></v>
<v t="T18"><vh>02/06 Rewrote and tested Convert Blanks command</vh></v>
<v t="T19"><vh>02/06 Removed Print and Page Setup commands</vh></v>
<v t="T20"><vh>02/06 * Implemented View All Characters</vh></v>
<v t="T21"><vh>02/06 Got the arrow binding right</vh></v>
<v><vh>02/06 finished Delete command</vh></v>
<v t="T22"><vh>02/06 created tree.onBodyChanged</vh></v>
<v><vh>02/06 rewrote and tested Revert</vh></v>
<v><vh>02/06 created leoDialog.yesNo</vh></v>
</v>
<v><vh>2/05 More bug fixes</vh>
<v t="T23"><vh>02/05 * Extended Sherlock</vh></v>
<v t="T24"><vh>02/05 * Properly enabled and disabled all menu items</vh></v>
<v t="T25"><vh>02/05 Got special accelerator keys working</vh></v>
<v><vh>02/05 GoTo commands now working</vh></v>
<v t="T26"><vh>02/05 Got Alt-keys working</vh></v>
<v t="T27"><vh>02/05 Made es and trace safer during quit</vh></v>
<v t="T28"><vh>02/05 Fixed bugs in Search Headline and Find, Then Change</vh></v>
<v t="T29"><vh>02/05 Do not eliminate begin/endUpdate!</vh></v>
</v>
<v><vh>02/04 Many bug fixes &amp; some big improvements</vh>
<v t="T30"><vh>02/04 Fixed Change command in headline</vh></v>
<v t="T31"><vh>02/04 A kludgy way to cut &amp; paste between Leo &amp; Leo.py</vh></v>
<v t="T32"><vh>02/04 Ended all event handlers with return "break"</vh></v>
<v><vh>02/04 Changed Insert Node accelerator from Control-K to Control-I</vh></v>
<v t="T33"><vh>02/04 Implemented Toggle Active Pane</vh></v>
<v t="T34"><vh>02/04 ** Overrode default text keys</vh></v>
<v><vh>02/04 Documented control characters used in the body pane.</vh></v>
<v t="T35"><vh>02/04 ** Breakthrough regarding events and accelerators</vh></v>
<v t="T36"><vh>02/04 Implemented Select All command</vh></v>
<v t="T37"><vh>02/04 created OnBodyDoubleClick and allies</vh></v>
<v><vh>02/04 create setTextSelelection utility</vh></v>
<v t="T38"><vh>02/04 Created Sort command</vh></v>
<v t="T39"><vh>02/04 Fixed Tangle Marked and Tangle All commands</vh></v>
</v>
<v t="T40"><vh>02/03 Created shortcuts for opening LeoPy.leo</vh></v>
<v><vh>02/03 Released 0.08</vh></v>
<v><vh>02/02 Fixing Bugs</vh>
<v t="T41"><vh>02/02 Fixed bugs in outline-only and whole-word searches &amp; is_c_id</vh></v>
<v t="T42"><vh>02/02 ** Drawing breakthroughs</vh></v>
<v t="T43"><vh>02/02 Fixed control-d bug</vh></v>
<v t="T44"><vh>02/02 ** About redrawing</vh></v>
</v>
<v><vh>02/01 Fixing bugs</vh>
<v t="T45"><vh>02/01 Test tangle path errors</vh></v>
<v t="T46"><vh>02/01 ** started tree.makeVisible &amp; tree.scrollTo</vh></v>
<v t="T47"><vh>02/01 ** used distutils</vh></v>
</v>
</v>
<v><vh>Jan 2002</vh>
<v><vh>01/31 Preparing for release...</vh>
<v t="T48"><vh>** 01/31 leo.py now tangles better than LeoCB</vh></v>
<v t="T49"><vh>01/31 Created open script in leo.py</vh></v>
<v t="T50"><vh>01/31 Fixed suboutline only logic</vh></v>
<v t="T51"><vh>01/31 Tested directory logic</vh></v>
<v t="T52"><vh>01/31 replaced frame.defaultDirectory by c.tangle_directory</vh></v>
</v>
<v><vh>01/30 Major improvements...</vh>
<v t="T53"><vh>01/30 ** May have solved the load path problem</vh></v>
<v t="T54"><vh>01/30 ** Rewrote path logic: removed all calls to os.chdir</vh></v>
<v t="T55"><vh>01/30 ** Fixed major bug causing @file read errors</vh></v>
<v t="T56"><vh>01/30 ** Changed how directories are handled</vh></v>
</v>
<v t="T57"><vh>01/29 Improved Paste Node command</vh></v>
<v t="T58"><vh>01/28 Generalized trace to allow function args</vh></v>
<v t="T59"><vh>01/28 Found source of Find performance bug</vh></v>
<v t="T60"><vh>01/25 Found one source of misreads</vh></v>
<v><vh>01/24 Implemented Sherlock: init_trace and trace</vh></v>
<v t="T61"><vh>01/22 More work on leoTangle.py</vh></v>
<v><vh>01/21 Started workon leoTangle.py</vh></v>
<v><vh>01/20</vh>
<v t="T62"><vh>01/20 Lost clones into leoColor.py</vh></v>
<v t="T63"><vh>01/20 Implemented hyperlinks</vh></v>
</v>
<v><vh>01/18 Completed Change all command</vh></v>
<v><vh>01/17</vh>
<v t="T64"><vh>01/17 Breakthrough: tree.redraw_now</vh></v>
<v t="T65"><vh>01/17 much work on Find class</vh></v>
<v t="T66"><vh>01/17 v.edit_text defined only if v is visible</vh></v>
</v>
<v><vh>01/16</vh>
<v t="T67"><vh>01/16 Fixed idle_headline logic</vh></v>
<v t="T68"><vh>01/16 Lost data in outline (not derived files)</vh></v>
<v><vh>01/16 Fixed minor find/change bugs and removed bach checkbox</vh></v>
<v t="T69"><vh>01/16 Breakthrough re event handlers!</vh></v>
</v>
<v><vh>01/15</vh>
<v t="T70"><vh>01/15 Completed find/change commands</vh></v>
<v t="T71"><vh>01/15 Converted headline from Tk.Entry to Tk.Text</vh></v>
</v>
<v><vh>01/14</vh>
<v t="T72"><vh>01/14 Fixed bug: cancelling dialog wrote .leo</vh></v>
<v t="T73"><vh>01/14 Got basic Find commands to work</vh></v>
<v t="T74"><vh>01/14 Fixed Save To bug</vh></v>
<v><vh>01/14 Added log messages for saves</vh></v>
<v><vh>01/14 Always recompute file indices on saves</vh></v>
<v t="T75"><vh>01/14 Reduced width of log window</vh></v>
</v>
<v><vh>01/13</vh>
<v t="T76"><vh>01/13 exec statement simplifies code</vh></v>
<v t="T77"><vh>01/13 Prefs/Find settings now functional</vh></v>
</v>
<v><vh>01/11</vh>
<v t="T78"><vh>01/11 Replaced globals with app() ivars</vh></v>
<v t="T79"><vh>01/11 New memory management: created c/v/tree/frame destroy routines</vh></v>
<v t="T80"><vh>01/11 About destroy routines: eliminating circular references</vh></v>
<v t="T81"><vh>01/11 disabled c.setChanged while loading</vh></v>
<v t="T82"><vh>01/11 Eliminated ?? error message on exit</vh></v>
<v t="T83"><vh>01/11 created leoFrame.__del__</vh></v>
</v>
<v><vh>01/10</vh>
<v t="T84"><vh>01/10 Worked on Quit error messages</vh></v>
<v><vh>01/10 Released v 0.07</vh></v>
<v t="T85"><vh>01/10 Tested c2py on Borland</vh></v>
</v>
<v><vh>01/09</vh>
<v t="T86"><vh>01/09 Wrote and debugged leo1to2 scripts !</vh></v>
<v t="T87"><vh>01/09 Made Python window functional !</vh></v>
<v><vh>01/09 Added auto indent</vh></v>
</v>
<v><vh>01/08</vh>
<v t="T88"><vh>01/08 bodyKeepsFocus logic</vh></v>
<v t="T89"><vh>01/08 Fixed bug: no doesn't abort a Quit command</vh></v>
<v t="T90"><vh>01/08 Fixed bug: changing clones didn't mark joined dirty.</vh></v>
<v t="T91"><vh>01/08 Got cut/copy/paste working</vh></v>
<v t="T92"><vh>01/08 Fixed reooloring problem</vh></v>
<v><vh>01/08 Added Help-Leo Documentation command</vh></v>
<v><vh>01/08 Save commands now ensure .leo extension</vh></v>
<v t="T93"><vh>01/08 Still no joy with canvas border</vh></v>
<v t="T94"><vh>01/08 Expermented with window icons</vh></v>
<v t="T95"><vh>01/08 Increased size of open windows</vh></v>
<v t="T96"><vh>01/08 Improved look of prefs panel</vh></v>
<v t="T97"><vh>01/08 Made progress towards "Show invisibles"</vh></v>
<v t="T98"><vh>01/08 @ignore now colored properly</vh></v>
<v><vh>01/08 @color and @nocolor are now inherited</vh></v>
</v>
<v><vh>01/07</vh>
<v t="T99"><vh>01/07 Fixed some bugs in Move Up and Move Down commands</vh></v>
<v t="T100"><vh>01/07 Fixed loss-of-data on insert command</vh></v>
<v t="T101"><vh>01/07 tab width</vh></v>
</v>
<v><vh>01/06</vh>
<v t="T102"><vh>01/06 borders again</vh></v>
<v t="T103"><vh>01/06 editing and selecting</vh></v>
</v>
</v>
<v><vh>2001</vh>
<v><vh>Dec 2001</vh>
<v t="T104"><vh>12/20/01 Fixed Linux problems</vh></v>
<v t="T105"><vh>12/19/01 Improved LeoDocs.leo</vh></v>
<v t="T106"><vh>12/18/01 Improved Leo2 documentation</vh></v>
<v t="T107"><vh>12/17/01 ** Leo 0.05 released</vh></v>
<v t="T108"><vh>12/16/01 Found the source of the file mismatches</vh></v>
<v t="T109"><vh>12/16/01 Created directory compare routines</vh></v>
<v><vh>12/15/01 Leo is operational</vh></v>
<v t="T110"><vh>12/15/01 Fixed bug in scanText</vh></v>
<v t="T111"><vh>12/15/01 Fixed bug in putBodyPart</vh></v>
<v t="T112"><vh>12/15/01 Fixed lookahead code in scanText, scanDoc</vh></v>
<v t="T113"><vh>12/14/01 Created leoCompare.py</vh></v>
<v t="T114"><vh>12/14/01 Create leoDialog.py</vh></v>
<v t="T115"><vh>12/14/01 Fixed minor problems</vh></v>
<v t="T116"><vh>12/13/01 Fixed several clone bugs</vh></v>
<v t="T117"><vh>12/13/01 Aha: we can eliminate v.setIcon !</vh></v>
<v t="T118"><vh>12/13/01 ** Fixed bottleneck with endupdate(flag)</vh></v>
<v t="T119"><vh>12/13/01 ** Syntax coloring now works</vh></v>
<v t="T120"><vh>12/12/01 Cut/copy/paste of nodes now done using internal clipboard</vh></v>
<v t="T121"><vh>12/12/01 Fixed insert, move, clone and delete commands</vh></v>
<v t="T122"><vh>12/12/01 Looked into Tk &amp; Python clipboard commands</vh></v>
<v t="T123"><vh>12/11/01 Menu accelerators</vh></v>
<v t="T124"><vh>12/11/01 Properly initialized the file in getLeoFile</vh></v>
<v t="T125"><vh>12/10/01 Got accellerators working</vh></v>
<v t="T126"><vh>12/10/01 Simplified icon handling, tree.redraw</vh></v>
<v t="T127"><vh>12/10/01 Used idle-time handler to work around event problems</vh></v>
<v t="T128"><vh>12/09/01 Problems with canvas border</vh></v>
<v><vh>12/09/01 Tree now drawn properly</vh></v>
<v t="T129"><vh>12/08/01 Progress with selection</vh></v>
<v t="T130"><vh>12/07/01 Small improvements</vh></v>
<v><vh>12/07/01 Tree now contains labels for editing</vh></v>
<v t="T131"><vh>12/06/01 Open/Close events now handled properly</vh></v>
<v t="T132"><vh>12/06/01 Tree drawn correctly, slowly</vh></v>
<v t="T133"><vh>12/04/01 Create .gif icons</vh></v>
<v t="T134"><vh>12/04/01 replaced dvnodes with vnodes!</vh></v>
<v t="T135"><vh>12/04/01 read code is now fast enough!</vh></v>
<v t="T136"><vh>12/04/01 tree starts to work</vh></v>
<v t="T137"><vh>12/01/01</vh></v>
</v>
<v><vh>Nov 2001</vh>
<v t="T138"><vh>11/15/01 Created do-nothing tk app using Tkinter</vh></v>
<v t="T139"><vh>11/15/01 added -padx to log window</vh></v>
<v t="T140"><vh>11/13/01 Speeding up reads</vh></v>
<v t="T141"><vh>11/11/01 Design of tree class</vh></v>
<v t="T142"><vh>11/10/01 began conversion to tk</vh></v>
<v t="T143"><vh>11/10/01 es outputs newline</vh></v>
<v t="T144"><vh>11/10/01 fixed bug in putDocPart</vh></v>
<v t="T145"><vh>11/10/01 added code for @delims</vh></v>
<v t="T146"><vh>11/10/01 got @first working</vh></v>
<v t="T147"><vh>11/09/01 moved all globals into class</vh></v>
<v t="T148"><vh>11/09/01 fixed bugs in write logic</vh></v>
<v t="T149"><vh>11/09/01 fixed bugs read logic</vh></v>
<v t="T150"><vh>11/06/01 created Leo window using Tk</vh></v>
</v>
<v><vh>Oct 2001</vh>
<v t="T151"><vh>11/01/01 Write code works except for comments</vh></v>
<v><vh>10/31/01 Added Read/write submenu</vh></v>
<v t="T152"><vh>10/31/01 Fixed write code</vh></v>
<v t="T153"><vh>10/26/01 Read code is slow</vh></v>
<v t="T154"><vh>10/26/01 Read/write code now works</vh></v>
<v t="T155"><vh>10/11/01 Outline commands now work</vh></v>
<v t="T156"><vh>10/11/01 Removed redundant getters</vh></v>
<v t="T157"><vh>10/10/01 Debugged Commands, nodes, fileCommands</vh></v>
<v t="T158"><vh>10/08/01 design of leoFileCommands</vh></v>
<v t="T159"><vh>10/07/01 removed info and tagList classes</vh></v>
<v t="T160"><vh>10/05/01 c2py fixes, speedTest</vh></v>
<v t="T161"><vh>10/02/01 through 1/10/4</vh></v>
<v t="T162"><vh>10/01/01 fxed bugs in c2py</vh></v>
<v t="T163"><vh>10/01/01 c2py in leo</vh></v>
</v>
<v><vh>Sept 2001</vh>
<v t="T164"><vh>9/30/01 documented c2py</vh></v>
<v t="T165"><vh>9/29/01 c2py.py</vh></v>
<v t="T166"><vh>9/25/01 Idle has trees &amp; syntax coloring</vh></v>
<v t="T167"><vh>9/14/01</vh></v>
</v>
</v>
</v>
<v t="T168"><vh>Notes</vh>
<v t="T169"><vh>about sys.settrace</vh></v>
<v><vh>Milestones</vh>
<v><vh>02/03/02 Leo 0.08 released</vh></v>
<v><vh>12/17/01 ** Leo 0.05 released</vh></v>
<v t="T170"><vh>12/16/01 Leo becomes functional</vh></v>
<v t="T171"><vh>12/13/01 Syntax coloring works</vh></v>
<v><vh>12/09/01 Tree now drawn properly</vh></v>
<v><vh>12/05/01 Tree works with Tkinter</vh></v>
<v t="T172"><vh>11/10/01 ** began conversion to tk</vh></v>
<v><vh>10/26/01 First successful read of .leo file w/ @file nodes</vh></v>
<v t="T173"><vh>9/29/01 c2py: Totally in love with Python</vh></v>
<v t="T174"><vh>ca. 9/1/01 began work on wxPython version of Leo</vh></v>
</v>
<v><vh>Problems</vh>
<v t="T175"><vh>Linux problems</vh></v>
</v>
<v t="T176"><vh>Schedule</vh></v>
<v t="T177"><vh>Scripting compatibility</vh>
<v t="T178"><vh>Functions (done with stub topCommand)</vh></v>
<v t="T179"><vh>Commands (menu commands &amp; enablers not ready yet)</vh>
<v t="T180"><vh>menu commands (not ready yet)</vh></v>
<v t="T181"><vh>command enablers (not ready yet)</vh></v>
</v>
<v t="T182"><vh>Prefs (not ready yet)</vh></v>
<v t="T183"><vh>vnodes (done except for minor routines)</vh></v>
</v>
<v t="T184"><vh>Selection notes</vh></v>
<v t="T185"><vh>Tk notes &amp; url's</vh>
<v t="T186" a="E"><vh>Standard names for all accelerator keys</vh>
<v t="T187"><vh>Useful for "show invisibles"</vh></v>
<v t="T188"><vh>Other characters</vh></v>
</v>
</v>
<v t="T189"><vh>Unused code</vh>
<v t="T190"><vh>tk prototype code</vh>
<v t="T191"><vh>tree</vh>
<v t="T192"><vh>createTree</vh></v>
<v><vh>expand/contract</vh>
<v t="T193"><vh>flip</vh></v>
<v t="T194"><vh>expand</vh></v>
<v t="T195"><vh>collapse</vh></v>
</v>
<v><vh>drawing</vh>
<v t="T196"><vh>geticonimage</vh></v>
<v t="T197"><vh>view</vh></v>
<v t="T198"><vh>lastvisiblechild</vh></v>
<v t="T199"><vh>update</vh></v>
<v t="T200"><vh>drawicon</vh></v>
<v t="T201"><vh>draw (draws the tree!)</vh>
<v t="T202"><vh>&lt;&lt; append TreeNodes to children &gt;&gt;</vh></v>
<v t="T203"><vh>&lt;&lt; draw the horizontal line to the child &gt;&gt;</vh></v>
<v t="T204"><vh>&lt;&lt; draw the plus or minus icon &gt;&gt;</vh></v>
<v t="T205"><vh>&lt;&lt; Add bindings for plus or minus icon &gt;&gt;</vh></v>
<v t="T206"><vh>&lt;&lt; draw the vertical line to the left of all children &gt;&gt;</vh></v>
</v>
<v t="T207"><vh>drawtext</vh></v>
</v>
<v><vh>edit or select</vh>
<v t="T208"><vh>edit</vh></v>
<v t="T209"><vh>edit_finish</vh></v>
<v t="T210"><vh>edit_cancel</vh></v>
<v t="T211"><vh>select</vh></v>
<v t="T212"><vh>select_or_edit</vh></v>
<v t="T213"><vh>deselect</vh></v>
<v t="T214"><vh>deselectall</vh></v>
<v t="T215"><vh>deselecttree</vh></v>
</v>
</v>
<v t="T216"><vh>widget.tcl (The Tk demo)</vh>
<v t="T217"><vh>&lt;&lt; Create the main window &gt;&gt;</vh>
<v t="T218"><vh>&lt;&lt; Create the menu bar &gt;&gt;</vh></v>
<v t="T219"><vh>&lt;&lt; Create the status bar &gt;&gt;</vh></v>
<v t="T220"><vh>&lt;&lt; Create the text frame &gt;&gt;</vh></v>
<v t="T221"><vh>&lt;&lt; Create tags for the text widget &gt;&gt;</vh></v>
</v>
<v t="T222"><vh>&lt;&lt; Create the text for the text widget &gt;&gt;</vh></v>
<v t="T223"><vh>AboutBox</vh></v>
<v t="T224"><vh>invoke</vh></v>
<v t="T225"><vh>positionWindow</vh></v>
<v t="T226"><vh>showCode</vh></v>
<v t="T227"><vh>showStatus</vh></v>
<v t="T228"><vh>showVars</vh></v>
</v>
<v t="T229"><vh>@file c:/prog/test/leoSplitter.tcl</vh>
<v t="T230"><vh>go</vh></v>
<v t="T231"><vh>createLeo</vh></v>
<v t="T232"><vh>createMenus</vh></v>
<v><vh>createSplitter</vh>
<v t="T233"><vh>createSplitter</vh></v>
<v t="T234"><vh>onGrabSplitterBar</vh></v>
<v t="T235"><vh>onDropSplitterBar</vh></v>
<v t="T236"><vh>onDragSplitterBar</vh></v>
<v t="T237"><vh>divideSplitter</vh></v>
</v>
<v t="T238"><vh>createFindPanel</vh>
<v t="T239"><vh>&lt;&lt; Create the Find and Change panes &gt;&gt;</vh></v>
<v t="T240"><vh>&lt;&lt; Create two columns of checkboxes &gt;&gt;</vh></v>
<v t="T241"><vh>&lt;&lt; Create two rows of buttons &gt;&gt;</vh></v>
</v>
<v t="T242"><vh>createPrefsPanel</vh>
<v t="T243"><vh>&lt;&lt; Create the Global Options frame &gt;&gt;</vh></v>
<v t="T244"><vh>&lt;&lt; Create the Tangle Options frame &gt;&gt;</vh></v>
<v t="T245"><vh>&lt;&lt; Create the Target Language frame &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T246"><vh>Untangle (old and unused code)</vh>
<v t="T247"><vh>&lt;&lt; Untangle types &amp; private data &gt;&gt; </vh></v>
<v t="T248"><vh>ust_standardize_name (replaced by standardize)</vh>
<v t="T249"><vh>&lt;&lt; Remove &lt; characters &gt;&gt;</vh></v>
<v t="T250"><vh>&lt;&lt; Remove @&lt; &gt;&gt;</vh></v>
</v>
<v t="T251"><vh>update_def (pass 2)(original)</vh>
<v t="T252"><vh>&lt;&lt; Define update_def vars &gt;&gt;</vh></v>
<v t="T253"><vh>&lt;&lt; Initialize update_def vars &gt;&gt;</vh></v>
<v t="T254"><vh>&lt;&lt; Set udoc_ip pointers and adjust ucode_ip pointers &gt;&gt; (test)</vh></v>
<v t="T255"><vh>&lt;&lt; Adjust ucode_ip pointers &gt;&gt;</vh></v>
<v t="T256"><vh>&lt;&lt; Set ust_doc and ust_code flags &gt;&gt;</vh></v>
<v t="T257"><vh>&lt;&lt; Set tst_doc and tst_code flags &gt;&gt;</vh></v>
<v t="T258"><vh>&lt;&lt; Set match_code and match_doc flags &gt;&gt;</vh></v>
<v t="T259"><vh>&lt;&lt; Adjust pointers after updating the doc part &gt;&gt;</vh></v>
<v t="T260"><vh>&lt;&lt; Replace the code part &gt;&gt;</vh>
<v t="T261"><vh>&lt;&lt; Skip opening newlines in the new code part &gt;&gt;</vh></v>
<v t="T262"><vh>&lt;&lt; Skip trailing whitespace in the new code part &gt;&gt;</vh></v>
</v>
<v t="T263"><vh>&lt;&lt; Replace the doc part &gt;&gt;</vh>
<v t="T264"><vh>&lt;&lt; Scan past trailing blank lines in the old doc part &gt;&gt;</vh></v>
</v>
<v t="T265"><vh>&lt;&lt; Report what happened &gt;&gt;</vh></v>
</v>
</v>
<v t="T266"><vh>massageExtractedBody</vh></v>
<v t="T267"><vh>getConvertVars (not used)</vh></v>
</v>
<v><vh>White papers</vh>
<v t="T268"><vh>Mac status report</vh></v>
<v t="T269"><vh>tk is the future of Leo</vh></v>
<v t="T270"><vh>Why I like Python</vh></v>
</v>
</v>
<v t="T271"><vh>To do</vh>
<v t="T272"><vh>Calls to notYet</vh></v>
<v a="E"><vh>2.0 release</vh>
<v><vh>support Show Invisibles in plain text mode</vh></v>
<v a="M"><vh>Untangle</vh></v>
<v t="T273" a="M"><vh>Import</vh></v>
<v t="T274"><vh>Fix @ space bug</vh></v>
</v>
<v t="T275"><vh>Borland release (after repair clones)</vh></v>
<v t="T276"><vh>2.1 release</vh>
<v><vh>cut and paste between apps directly</vh></v>
<v t="T277" a="M"><vh>Recover from @read errors: repair clone links</vh></v>
<v><vh>read CVS file/write CVS file in Import/Export menu</vh></v>
<v t="T278"><vh>Add hooks to python scripts on entry</vh></v>
<v t="T279"><vh>Create alert on read problems</vh></v>
<v><vh>Undo</vh></v>
<v t="T280"><vh>Drag and drop</vh></v>
<v t="T281"><vh>don't destroy .leo file if write fails</vh></v>
</v>
<v t="T282"><vh>3.0 Release</vh>
<v><vh>Finish all syntax colorers</vh></v>
<v t="T283"><vh>Finish Toggle Splitter Direction</vh></v>
<v><vh>Open leo.py when double-click .leo files</vh></v>
<v><vh>Update file association to Leo.py</vh></v>
<v><vh>Automatic "tab nanny" and syntax checking of Python code</vh></v>
<v><vh>Add mutex so only one copy of Leo will run</vh></v>
</v>
<v t="T284"><vh>3.1 Release</vh>
<v t="T285"><vh>Syntax Coloring Options Window</vh></v>
<v t="T286"><vh>Compare Window</vh></v>
<v t="T287"><vh>Font Window</vh></v>
<v t="T288"><vh>Unlimited Undo</vh></v>
</v>
<v><vh>Writing</vh>
<v t="T289"><vh>Update web site</vh></v>
<v t="T290"><vh>Announcements to comp.prog.lit</vh></v>
<v><vh>Finish Leo Article: post it to SourceForge.</vh></v>
<v t="T291"><vh>Leo Article</vh>
<v t="T292"><vh>Summary</vh></v>
<v t="T293"><vh>Limitations</vh></v>
<v t="T294"><vh>IDLE-dev posting</vh></v>
</v>
</v>
<v><vh>New scripts</vh>
<v t="T295"><vh>removeSentinelLines</vh></v>
<v t="T296"><vh>python2c</vh></v>
<v><vh>pyLint</vh></v>
</v>
<v><vh>Bugs &amp; intractable problems</vh>
<v t="T297"><vh>Tree problems</vh></v>
<v t="T298"><vh>Window icons are Tk icon, not Leo icon</vh></v>
</v>
</v>
<v t="T299"><vh>(Projects)</vh>
<v><vh>Commands &amp; utilities</vh>
<v><vh>(Cut &amp; Paste between apps)</vh>
<v t="T300" a="C"><vh>OnSelectAll</vh></v>
<v t="T301" a="C"><vh>frame.__init__</vh>
<v t="T302"><vh>&lt;&lt; set the LeoFrame ivars &gt;&gt;</vh></v>
<v t="T303"><vh>&lt;&lt; create the Leo frame &gt;&gt;</vh></v>
<v t="T304"><vh>&lt;&lt; create the first tree node &gt;&gt;</vh></v>
</v>
<v t="T305" a="C"><vh>frame.OnPaste, OnPasteNode, OnPasteFromMenu</vh></v>
<v t="T306" a="C"><vh>frame.OnCopy, OnCopyFromMenu</vh></v>
<v t="T307" a="C"><vh>frame.OnCut, OnCutFrom Menu</vh></v>
<v t="T308" a="C"><vh>canPasteOutline</vh></v>
<v t="T309" a="C"><vh>Cut &amp; Paste Outlines</vh>
<v t="T310"><vh>cutOutline</vh></v>
<v t="T311"><vh>copyOutline</vh></v>
<v t="T312"><vh>pasteOutline</vh></v>
</v>
</v>
<v><vh>(Delete &amp; Revert)</vh>
<v t="T313" a="C"><vh>canRevert</vh></v>
<v t="T314" a="C"><vh>OnRevert (rewrite)</vh></v>
<v t="T315" a="C"><vh>OnDelete</vh></v>
</v>
<v><vh>(Edit Body Commands)</vh>
<v t="T316" a="C"><vh>Tk.Text selection</vh>
<v t="T317"><vh>getTextSelection</vh></v>
<v t="T318"><vh>getSelectedText</vh></v>
<v t="T319" a="C"><vh>setTextSelection</vh></v>
</v>
<v t="T320" a="C"><vh>Leading whitespace...</vh>
<v t="T321"><vh>computeLeadingWhitespace</vh></v>
<v t="T322"><vh>removeLeadingWhitespace</vh></v>
<v t="T323"><vh>optimizeLeadingWhitespace</vh></v>
<v t="T324"><vh>skip_leading_ws_with_indent</vh></v>
</v>
<v t="T325" a="C"><vh>canExtract, canExtractSection &amp; canExtractSectionNames</vh></v>
<v t="T326" a="C"><vh>Edit Body Text</vh>
<v t="T327"><vh>convertBlanks</vh></v>
<v t="T328"><vh>createLastChildNode</vh></v>
<v t="T329"><vh>dedentBody</vh></v>
<v t="T330"><vh>extract</vh>
<v t="T331"><vh>&lt;&lt; Set headline for extract &gt;&gt;</vh></v>
</v>
<v t="T332"><vh>extractSection</vh>
<v t="T333"><vh>&lt;&lt; Set headline for extractSection &gt;&gt;</vh></v>
</v>
<v t="T334"><vh>extractSectionNames</vh>
<v t="T335"><vh>&lt;&lt; Find the next section name &gt;&gt;</vh></v>
</v>
<v t="T336"><vh>getBodyLines</vh></v>
<v t="T337"><vh>getBodySelection</vh></v>
<v t="T338"><vh>indentBody</vh></v>
<v t="T339"><vh>updateBodyPane</vh></v>
</v>
</v>
<v><vh>(find)</vh>
<v t="T340" a="C"><vh>tree.OnHeadlineKey</vh></v>
<v t="T341" a="C"><vh>tree.redraw , force_redraw, redraw_now</vh></v>
<v t="T342" a="C"><vh>tree.set...LabelState</vh></v>
<v t="T343" a="C"><vh>&lt;&lt; Theory of operation &gt;&gt;</vh></v>
<v t="T344" a="C"><vh>find.__init__</vh>
<v t="T345"><vh>&lt;&lt; Initialize the leoFind ivars &gt;&gt;</vh></v>
<v t="T346"><vh>&lt;&lt; Create the Find and Change panes &gt;&gt;</vh></v>
<v t="T347"><vh>&lt;&lt; Create two columns of checkboxes &gt;&gt;</vh></v>
<v t="T348"><vh>&lt;&lt; Create two rows of buttons &gt;&gt;</vh></v>
</v>
<v t="T349" a="C"><vh>find.init</vh>
<v t="T350"><vh>&lt;&lt; set widgets &gt;&gt;</vh></v>
</v>
<v t="T351" a="C"><vh>resetWrap</vh></v>
<v t="T352" a="C"><vh>Top Level Commands</vh>
<v t="T353"><vh>changeButton</vh></v>
<v t="T354"><vh>changeAllButton</vh></v>
<v t="T355"><vh>changeThenFindButton</vh></v>
<v t="T356"><vh>findButton</vh></v>
<v t="T357"><vh>findAllButton</vh></v>
<v t="T358"><vh>changeCommand </vh></v>
<v t="T359"><vh>changeThenFindCommandd</vh></v>
<v t="T360"><vh>findNextCommand</vh></v>
<v t="T361"><vh>fndPreviousCommand</vh></v>
<v t="T362"><vh>setup_button</vh></v>
<v t="T363"><vh>setup_command</vh></v>
</v>
<v t="T364" a="C"><vh>Utilities</vh>
<v t="T365"><vh>batchChange</vh></v>
<v t="T366"><vh>change</vh></v>
<v t="T367"><vh>changeAll</vh></v>
<v t="T368"><vh>changeSelection</vh></v>
<v t="T369"><vh>changeThenFind</vh></v>
<v t="T370"><vh>findAll</vh></v>
<v t="T371"><vh>findNext</vh></v>
<v t="T372"><vh>findNextMatch</vh></v>
<v t="T373"><vh>selectNextVnode</vh></v>
<v t="T374"><vh>search</vh>
<v t="T375"><vh>&lt;&lt; return if we are passed the wrap point &gt;&gt;</vh></v>
<v t="T376"><vh>&lt;&lt; test for whole word match &gt;&gt;</vh></v>
</v>
<v t="T377"><vh>Initializing &amp; finalizing &amp; selecting</vh>
<v t="T378"><vh>checkArgs</vh></v>
<v t="T379"><vh>initBatchCommands</vh></v>
<v t="T380"><vh>initBatchText &amp; initNextText</vh></v>
<v t="T381"><vh>initInHeadline</vh></v>
<v t="T382"><vh>initInteractiveCommands</vh></v>
<v t="T383"><vh>printLine</vh></v>
<v t="T384"><vh>restore</vh></v>
<v t="T385"><vh>save</vh></v>
<v t="T386" a="C"><vh>showSuccess</vh></v>
</v>
</v>
</v>
<v t="T387"><vh>(Go To Commands)</vh>
<v t="T388" a="C"><vh>canSelectThreadBack</vh></v>
<v t="T389" a="C"><vh>canSelectThreadNext</vh></v>
<v t="T390" a="C"><vh>canSelectVisBack</vh></v>
<v t="T391" a="C"><vh>canSelectVisNext</vh></v>
<v t="T392" a="C"><vh>selectThreadBack</vh></v>
<v t="T393" a="C"><vh>selectThreadNext</vh></v>
<v t="T394" a="C"><vh>selectVisBack</vh></v>
<v t="T395" a="C"><vh>selectVisNext</vh></v>
</v>
<v><vh>(leo_done.bat)</vh>
<v t="T396" a="C"><vh>cleanup</vh></v>
</v>
<v><vh>(Quit safe log and trace)</vh>
<v t="T397" a="C"><vh>tree.destroy</vh></v>
<v t="T398" a="C"><vh>v.destroy</vh></v>
<v t="T399" a="C"><vh>c.destroy</vh></v>
<v t="T400" a="C"><vh>frame.destroy</vh></v>
<v t="T401" a="C"><vh>frame.OnCloseLeoEvent</vh>
<v t="T402"><vh>&lt;&lt; Prompt for change.  Set veto if the user cancels &gt;&gt;</vh>
<v t="T403"><vh>&lt;&lt; Put up a file save dialog; set veto if the user cancels &gt;&gt;</vh></v>
</v>
</v>
<v t="T404" a="C"><vh>frame.OnQuit</vh></v>
<v t="T405" a="C"><vh>app.quit</vh></v>
<v t="T406" a="C"><vh>frame.put, putnl</vh></v>
</v>
<v t="T407"><vh>(remarking bad @file nodes dirty)</vh>
<v t="T408" a="C"><vh>atFile.write</vh>
<v t="T409"><vh>&lt;&lt; Open files.  Set orphan and dirty flags and return on errors &gt;&gt;</vh></v>
<v t="T410"><vh>&lt;&lt; put all @first lines in root &gt;&gt;</vh></v>
<v t="T411"><vh>&lt;&lt; Warn about @ignored and orphans  &gt;&gt;</vh></v>
<v t="T412"><vh>&lt;&lt; Replace the target with the temp file if different &gt;&gt;</vh></v>
</v>
</v>
<v t="T413"><vh>(scanAllDirectives)</vh>
<v t="T414"><vh>from args.c</vh></v>
<v t="T415"><vh>old code from tangle.scanAllDirectives &lt;&lt; try to set path... &gt;&gt;</vh></v>
<v t="T416" a="C"><vh>scanColorDirectives</vh>
<v t="T417"><vh>&lt;&lt; Test for @comment or @language &gt;&gt;</vh></v>
</v>
<v t="T418" a="C"><vh>atFile.scanAllDirectives (calls writeError on errors) </vh>
<v t="T419"><vh>&lt;&lt; Set delims to default values &gt;&gt;</vh></v>
<v t="T420"><vh>&lt;&lt; Set path from @file node &gt;&gt;</vh></v>
<v t="T421"><vh>&lt;&lt; Test for @comment or @language &gt;&gt;</vh></v>
<v t="T422"><vh>&lt;&lt; Test for @path &gt;&gt;</vh></v>
<v t="T423"><vh>&lt;&lt; Test for @pagewidth and @tabwidth &gt;&gt;</vh></v>
<v t="T424"><vh>&lt;&lt; Set current directory &gt;&gt;</vh></v>
<v t="T425"><vh>&lt;&lt; Set comment Strings from delims &gt;&gt;</vh></v>
</v>
<v t="T426" a="C"><vh>tangle.scanAllDirectives</vh>
<v t="T427"><vh>&lt;&lt; Test for @comment or @language &gt;&gt;</vh></v>
<v t="T428"><vh>&lt;&lt; Test for @verbose, @terse or @silent &gt;&gt;</vh></v>
<v t="T429"><vh>&lt;&lt; Test for @path, @pagewidth and @tabwidth &gt;&gt;</vh>
<v t="T430"><vh>&lt;&lt; Remove leading and trailing delims if they exist &gt;&gt;</vh></v>
</v>
<v t="T431"><vh>&lt;&lt; Test for @header or @noheader &gt;&gt;</vh></v>
<v t="T432"><vh>&lt;&lt; Set self.tangle_directory &gt;&gt;</vh></v>
</v>
</v>
<v><vh>(Show Invisibles)</vh>
<v t="T433" a="C"><vh>OnViewAllCharacters</vh></v>
<v t="T434" a="C"><vh>&lt;&lt; configure tags &gt;&gt;</vh></v>
</v>
<v><vh>(slow find)</vh>
<v t="T341" a="C"><vh>tree.redraw , force_redraw, redraw_now</vh></v>
<v t="T386" a="C"><vh>showSuccess</vh></v>
</v>
<v><vh>(Sort headline)</vh>
<v t="T435" a="C"><vh>sortChildren, sortSiblings</vh></v>
<v t="T436" a="C"><vh>v.sortChildren</vh></v>
</v>
<v><vh>(Tangle marked &amp; Tangle All</vh>
<v t="T437" a="C"><vh>tangleAll</vh></v>
<v t="T438" a="C"><vh>tangleMarked</vh></v>
<v t="T439" a="C"><vh>tangleTree (calls cleanup)</vh></v>
</v>
<v t="T440" a="C"><vh>Sherlock...</vh>
<v t="T441"><vh>get_Sherlock_args</vh></v>
<v t="T442"><vh>init_trace</vh></v>
<v t="T443"><vh>trace</vh></v>
</v>
</v>
<v><vh>Drawing</vh>
<v t="T444"><vh>(body flashing &amp; recolor)</vh>
<v t="T445" a="C"><vh>tree.onBodyChanged &amp; OnBodyKey &amp; idle_body_key</vh>
<v t="T446"><vh>&lt;&lt; Do Auto indent &gt;&gt;</vh></v>
</v>
<v t="T447" a="C"><vh>tree.select</vh></v>
<v t="T448" a="C"><vh>tree.recolor &amp; recolor_now</vh></v>
</v>
<v><vh>(c.makeVisible &amp; scrolling)</vh>
<v t="T449"><vh>c.makeVisible</vh></v>
<v t="T450" a="C"><vh>lastVisible</vh></v>
<v t="T451" a="C"><vh>yoffset</vh></v>
<v t="T452" a="C"><vh>tree.expandAllAncestors</vh></v>
<v t="T453" a="C"><vh>tree.idle_scrollTo</vh></v>
<v t="T341" a="C"><vh>tree.redraw , force_redraw, redraw_now</vh></v>
</v>
<v t="T454"><vh>(headline states)</vh>
<v t="T455" a="C"><vh>Selecting &amp; editing (tree)</vh>
<v t="T456"><vh>dimEditLabel, undimEditLabel</vh></v>
<v t="T457" a="C"><vh>editLabel</vh></v>
<v t="T458" a="C"><vh>endEditLabel</vh></v>
<v t="T447" a="C"><vh>tree.select</vh></v>
<v t="T342" a="C"><vh>tree.set...LabelState</vh></v>
</v>
</v>
<v t="T459"><vh>(Simplified redraw)</vh>
<v t="T460" a="C"><vh>tree.__init__</vh></v>
<v t="T341" a="C"><vh>tree.redraw , force_redraw, redraw_now</vh></v>
<v t="T461" a="C"><vh>beginUpdate</vh></v>
<v t="T462" a="C"><vh>endUpdate</vh></v>
</v>
</v>
<v><vh>Events</vh>
<v t="T463"><vh>(Double-click and word select)</vh>
<v t="T301" a="C"><vh>frame.__init__</vh>
<v t="T302"><vh>&lt;&lt; set the LeoFrame ivars &gt;&gt;</vh></v>
<v t="T303"><vh>&lt;&lt; create the Leo frame &gt;&gt;</vh></v>
<v t="T304"><vh>&lt;&lt; create the first tree node &gt;&gt;</vh></v>
</v>
<v t="T319" a="C"><vh>setTextSelection</vh></v>
<v t="T464" a="C"><vh>OnActivateBody &amp; OnBodyDoubleClick</vh></v>
<v t="T445" a="C"><vh>tree.onBodyChanged &amp; OnBodyKey &amp; idle_body_key</vh>
<v t="T446"><vh>&lt;&lt; Do Auto indent &gt;&gt;</vh></v>
</v>
</v>
<v><vh>(event handlers)</vh>
<v t="T445" a="C"><vh>tree.onBodyChanged &amp; OnBodyKey &amp; idle_body_key</vh>
<v t="T446"><vh>&lt;&lt; Do Auto indent &gt;&gt;</vh></v>
</v>
<v t="T340" a="C"><vh>tree.OnHeadlineKey</vh></v>
<v t="T457" a="C"><vh>editLabel</vh></v>
<v t="T458" a="C"><vh>endEditLabel</vh></v>
</v>
<v><vh>(hypertext links)</vh>
<v t="T465" a="C"><vh>color.__init__</vh></v>
<v t="T466" a="C"><vh>colorizePython</vh>
<v t="T434" a="C"><vh>&lt;&lt; configure tags &gt;&gt;</vh></v>
<v t="T467"><vh>&lt;&lt; continue doc part &gt;&gt;</vh></v>
<v t="T468"><vh>&lt;&lt; continue python triple string &gt;&gt;</vh></v>
<v t="T469"><vh>&lt;&lt; continue nocolor state &gt;&gt;</vh></v>
<v t="T470"><vh>&lt;&lt; handle python string &gt;&gt;</vh></v>
<v t="T471"><vh>&lt;&lt; handle python comment &gt;&gt;</vh></v>
<v t="T472"><vh>&lt;&lt; handle possible @keyword &gt;&gt;</vh></v>
<v t="T473"><vh>&lt;&lt; handle possible section ref &gt;&gt;</vh>
<v t="T474"><vh>&lt;&lt; set the hyperlink &gt;&gt;</vh></v>
</v>
<v t="T475"><vh>&lt;&lt; handle possible python keyword &gt;&gt;</vh></v>
<v t="T476"><vh>&lt;&lt; handle blank &gt;&gt;</vh></v>
<v t="T477"><vh>&lt;&lt; handle tab &gt;&gt;</vh></v>
<v t="T478"><vh>&lt;&lt; handle normal character &gt;&gt;</vh></v>
</v>
<v t="T452" a="C"><vh>tree.expandAllAncestors</vh></v>
<v t="T479" a="C"><vh>v.Callbacks</vh>
<v t="T480"><vh>OnBoxClick</vh></v>
<v t="T481"><vh>OnHeadlineClick</vh></v>
<v t="T482"><vh>OnHeadlineKey</vh></v>
<v t="T483"><vh>OnHyperLinkControlClick</vh></v>
<v t="T484"><vh>OnHyperLinkEnter</vh></v>
<v t="T485"><vh>OnHyperLinkLeave</vh></v>
<v t="T486"><vh>OnIconClick</vh></v>
</v>
<v t="T487" a="C"><vh>findReference</vh></v>
</v>
<v><vh>(Per-window default tangle directory)</vh>
<v t="T488" a="CM"><vh>prefs.__init__</vh>
<v t="T489"><vh>&lt;&lt; Set ivars &gt;&gt;</vh></v>
<v t="T490"><vh>&lt;&lt; Create the Global Options frame &gt;&gt;</vh></v>
<v t="T491"><vh>&lt;&lt; Create the Tangle Options frame &gt;&gt;</vh></v>
<v t="T492"><vh>&lt;&lt; Create the Target Language frame &gt;&gt;</vh></v>
</v>
<v t="T493" a="CM"><vh>prefs.set_ivars &amp; idle_set_ivars &amp; print_ivars</vh>
<v t="T494"><vh>&lt;&lt; update ivars &gt;&gt;</vh></v>
</v>
<v t="T495" a="CM"><vh>prefs.init</vh>
<v t="T496"><vh>&lt;&lt; set widgets &gt;&gt;</vh></v>
</v>
<v t="T497" a="CM"><vh>OnActivateLeoEvent</vh></v>
</v>
<v t="T498"><vh>(present_language)</vh>
<v t="T495" a="C"><vh>prefs.init</vh>
<v t="T496"><vh>&lt;&lt; set widgets &gt;&gt;</vh></v>
</v>
<v t="T499" a="C"><vh>set_lang</vh></v>
<v t="T488" a="C"><vh>prefs.__init__</vh>
<v t="T489"><vh>&lt;&lt; Set ivars &gt;&gt;</vh></v>
<v t="T490"><vh>&lt;&lt; Create the Global Options frame &gt;&gt;</vh></v>
<v t="T491"><vh>&lt;&lt; Create the Tangle Options frame &gt;&gt;</vh></v>
<v t="T492"><vh>&lt;&lt; Create the Target Language frame &gt;&gt;</vh></v>
</v>
<v t="T493" a="C"><vh>prefs.set_ivars &amp; idle_set_ivars &amp; print_ivars</vh>
<v t="T494"><vh>&lt;&lt; update ivars &gt;&gt;</vh></v>
</v>
<v t="T416" a="C"><vh>scanColorDirectives</vh>
<v t="T417"><vh>&lt;&lt; Test for @comment or @language &gt;&gt;</vh></v>
</v>
<v t="T445" a="C"><vh>tree.onBodyChanged &amp; OnBodyKey &amp; idle_body_key</vh>
<v t="T446"><vh>&lt;&lt; Do Auto indent &gt;&gt;</vh></v>
</v>
</v>
<v><vh>(tree bindings)</vh>
<v t="T500" a="C"><vh>v.__init__</vh>
<v t="T501"><vh>&lt;&lt; initialize vnode data members &gt;&gt;</vh></v>
</v>
<v t="T502" a="C"><vh>drawBox</vh></v>
<v t="T503" a="C"><vh>tree.drawIcon</vh></v>
<v t="T504" a="C"><vh>drawText</vh>
<v t="T505"><vh>&lt;&lt; configure the text depending on state &gt;&gt;</vh></v>
</v>
<v><vh>&lt;&lt; update the canvas &gt;&gt;</vh></v>
</v>
</v>
<v><vh>Files &amp; Directories</vh>
<v t="T506"><vh>(missing dirty marks ) </vh>
<v t="T445" a="C"><vh>tree.onBodyChanged &amp; OnBodyKey &amp; idle_body_key</vh>
<v t="T446"><vh>&lt;&lt; Do Auto indent &gt;&gt;</vh></v>
</v>
<v t="T340" a="C"><vh>tree.OnHeadlineKey</vh></v>
<v t="T507" a="C"><vh>setDirty &amp; initDirtyBit</vh></v>
<v t="T508" a="C"><vh>setAncestorAtFileNodeDirty</vh></v>
</v>
<v t="T509"><vh>(computing loaddir)</vh>
<v t="T510" a="C"><vh>app.finishCreate</vh>
<v t="T511" a="C"><vh>&lt;&lt; set loaddir &gt;&gt;</vh></v>
</v>
</v>
<v t="T512"><vh>(eliminating os.chdir)</vh>
<v t="T513"><vh>Notes</vh></v>
<v><vh>leo.py (done)</vh>
<v t="T511" a="C"><vh>&lt;&lt; set loaddir &gt;&gt;</vh></v>
<v t="T514" a="C"><vh>leo.run</vh>
<v t="T515" a="C"><vh>&lt;&lt; set the icon image &gt;&gt;</vh></v>
</v>
</v>
<v><vh>App (done)</vh>
<v t="T516" a="C"><vh>app.__init__</vh></v>
<v t="T510" a="C"><vh>app.finishCreate</vh>
<v t="T511" a="C"><vh>&lt;&lt; set loaddir &gt;&gt;</vh></v>
</v>
</v>
<v><vh>AtFile... (done)</vh>
<v t="T517" a="C"><vh>atFile ctor</vh>
<v t="T518"><vh>&lt;&lt; initialize atFile ivars &gt;&gt;</vh></v>
</v>
<v t="T418" a="C"><vh>atFile.scanAllDirectives (calls writeError on errors) </vh>
<v t="T419"><vh>&lt;&lt; Set delims to default values &gt;&gt;</vh></v>
<v t="T420"><vh>&lt;&lt; Set path from @file node &gt;&gt;</vh></v>
<v t="T421"><vh>&lt;&lt; Test for @comment or @language &gt;&gt;</vh></v>
<v t="T422"><vh>&lt;&lt; Test for @path &gt;&gt;</vh></v>
<v t="T423"><vh>&lt;&lt; Test for @pagewidth and @tabwidth &gt;&gt;</vh></v>
<v t="T424"><vh>&lt;&lt; Set current directory &gt;&gt;</vh></v>
<v t="T425"><vh>&lt;&lt; Set comment Strings from delims &gt;&gt;</vh></v>
</v>
<v t="T519" a="C"><vh>atFile.read</vh>
<v t="T520"><vh>&lt;&lt; open file &gt;&gt;</vh></v>
<v t="T521"><vh>&lt;&lt; Scan the file buffer  &gt;&gt;</vh></v>
<v t="T522"><vh>&lt;&lt; Bump mStructureErrors if any vnodes are unvisited &gt;&gt;</vh></v>
<v t="T523"><vh>&lt;&lt; Delete root's tree and body text &gt;&gt;</vh></v>
<v t="T524"><vh>&lt;&lt; Handle clone bits &gt;&gt;</vh></v>
<v t="T525"><vh>&lt;&lt; Join cloned trees &gt;&gt;</vh></v>
<v t="T526"><vh>&lt;&lt; Handle all status bits &gt;&gt;</vh></v>
</v>
<v t="T408" a="C"><vh>atFile.write</vh>
<v t="T409"><vh>&lt;&lt; Open files.  Set orphan and dirty flags and return on errors &gt;&gt;</vh></v>
<v t="T410"><vh>&lt;&lt; put all @first lines in root &gt;&gt;</vh></v>
<v t="T411"><vh>&lt;&lt; Warn about @ignored and orphans  &gt;&gt;</vh></v>
<v t="T412"><vh>&lt;&lt; Replace the target with the temp file if different &gt;&gt;</vh></v>
</v>
</v>
<v t="T527"><vh>File Commands... (done) </vh>
<v t="T528" a="C"><vh>fileCommands.readOutlineOnly</vh>
<v t="T529" a="C"><vh>&lt;&lt; Set the default directory &gt;&gt;</vh></v>
</v>
<v t="T530" a="C"><vh>fileCommands.open</vh>
<v t="T529" a="C"><vh>&lt;&lt; Set the default directory &gt;&gt;</vh></v>
</v>
<v t="T531" a="C"><vh>fileCommands.getPrefs</vh>
<v t="T532"><vh>&lt;&lt; check for syntax coloring prefs &gt;&gt;</vh></v>
</v>
<v t="T533" a="C"><vh>fileCommands.OnReadOutlineOnly</vh></v>
<v t="T534" a="C"><vh>fileCommands.write_LEO_file</vh></v>
</v>
<v><vh>Frame... (done)</vh>
<v t="T301" a="C"><vh>frame.__init__</vh>
<v t="T302"><vh>&lt;&lt; set the LeoFrame ivars &gt;&gt;</vh></v>
<v t="T303"><vh>&lt;&lt; create the Leo frame &gt;&gt;</vh></v>
<v t="T304"><vh>&lt;&lt; create the first tree node &gt;&gt;</vh></v>
</v>
<v t="T535" a="C"><vh>frame.OnOpen</vh>
<v t="T536"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="T537" a="C"><vh>frame.OpenWithFileName</vh></v>
</v>
<v t="T538"><vh>Import... (no changes needed)</vh>
<v t="T539"><vh>importFiles.createRootBody</vh></v>
<v t="T540" a="C"><vh>importFiles.flattenOutline</vh></v>
<v t="T541" a="C"><vh>importFiles.outlineToNoweb</vh></v>
</v>
<v><vh>Tangle... (done)</vh>
<v t="T542" a="C"><vh>tangle.init_ivars &amp; init_directive_ivars</vh>
<v t="T543"><vh>&lt;&lt; init tangle ivars &gt;&gt;</vh></v>
<v t="T544"><vh>&lt;&lt; init directive ivars &gt;&gt;</vh></v>
</v>
<v t="T545" a="C"><vh>tangle.put_all_roots</vh>
<v t="T546"><vh>&lt;&lt;Write a banner at the start of the output file&gt;&gt;</vh></v>
<v t="T547"><vh>&lt;&lt; Erase the temporary file &gt;&gt;</vh></v>
</v>
<v t="T426" a="C"><vh>tangle.scanAllDirectives</vh>
<v t="T427"><vh>&lt;&lt; Test for @comment or @language &gt;&gt;</vh></v>
<v t="T428"><vh>&lt;&lt; Test for @verbose, @terse or @silent &gt;&gt;</vh></v>
<v t="T429"><vh>&lt;&lt; Test for @path, @pagewidth and @tabwidth &gt;&gt;</vh>
<v t="T430"><vh>&lt;&lt; Remove leading and trailing delims if they exist &gt;&gt;</vh></v>
</v>
<v t="T431"><vh>&lt;&lt; Test for @header or @noheader &gt;&gt;</vh></v>
<v t="T432"><vh>&lt;&lt; Set self.tangle_directory &gt;&gt;</vh></v>
</v>
</v>
<v><vh>Tree... (done)</vh>
<v t="T503" a="C"><vh>tree.drawIcon</vh></v>
<v t="T548" a="C"><vh>tree.getIconImage</vh></v>
</v>
</v>
</v>
<v><vh>Menus</vh>
<v t="T301" a="C"><vh>frame.__init__</vh>
<v t="T302"><vh>&lt;&lt; set the LeoFrame ivars &gt;&gt;</vh></v>
<v t="T303"><vh>&lt;&lt; create the Leo frame &gt;&gt;</vh></v>
<v t="T304"><vh>&lt;&lt; create the first tree node &gt;&gt;</vh></v>
</v>
<v t="T549" a="C"><vh>frame.__del__</vh></v>
<v t="T550" a="C"><vh>createAccelerators</vh>
<v t="T551"><vh>&lt;&lt; control key bindings &gt;&gt;</vh></v>
<v t="T552"><vh>&lt;&lt; canvas control bindings &gt;&gt;</vh></v>
<v t="T553"><vh>&lt;&lt; alt key bindings &gt;&gt;</vh></v>
</v>
<v t="T554" a="C"><vh>createMenuBar</vh>
<v t="T555"><vh>&lt;&lt; create the file menu &gt;&gt;</vh>
<v t="T556"><vh>&lt;&lt; create the top-level file entries &gt;&gt;</vh></v>
<v t="T557"><vh>&lt;&lt; create the read/write submenu &gt;&gt;</vh></v>
<v t="T558"><vh>&lt;&lt; create the tangle submenu &gt;&gt;</vh></v>
<v t="T559"><vh>&lt;&lt; create the untangle submenu &gt;&gt;</vh></v>
<v t="T560"><vh>&lt;&lt; create the import submenu &gt;&gt;</vh></v>
</v>
<v t="T561"><vh>&lt;&lt; create the edit menu &gt;&gt;</vh>
<v t="T562"><vh>&lt;&lt; create the edit body submenu &gt;&gt;</vh></v>
<v t="T563"><vh>&lt;&lt; create the find submenu &gt;&gt;</vh></v>
</v>
<v t="T564"><vh>&lt;&lt; create the outline menu &gt;&gt;</vh>
<v t="T565"><vh>&lt;&lt; create expand/contract submenu &gt;&gt;</vh></v>
<v t="T566"><vh>&lt;&lt; create move/select submenu &gt;&gt;</vh></v>
<v t="T567"><vh>&lt;&lt; create mark/goto submenu &gt;&gt;</vh></v>
</v>
<v t="T568"><vh>&lt;&lt; create the window menu &gt;&gt;</vh></v>
<v t="T569"><vh>&lt;&lt; create the help menu &gt;&gt;</vh></v>
</v>
<v t="T570" a="C"><vh>Enabling Menu Items (Commands)</vh>
<v t="T571"><vh>canContractAllHeadlines</vh></v>
<v t="T572"><vh>canContractAllSubheads</vh></v>
<v t="T573"><vh>canContractParent</vh></v>
<v t="T574"><vh>canContractSubheads</vh></v>
<v t="T575"><vh>canCutOutline &amp; canDeleteHeadline</vh></v>
<v t="T576"><vh>canDemote</vh></v>
<v t="T577"><vh>canExpandAllHeadlines</vh></v>
<v t="T578"><vh>canExpandAllSubheads</vh></v>
<v t="T579"><vh>canExpandSubheads</vh></v>
<v t="T325" a="C"><vh>canExtract, canExtractSection &amp; canExtractSectionNames</vh></v>
<v t="T580"><vh>canGoToNextDirtyHeadline</vh></v>
<v t="T581"><vh>canGoToNextMarkedHeadline</vh></v>
<v t="T582"><vh>canMarkChangedHeadline</vh></v>
<v t="T583"><vh>canMarkChangedRoots</vh></v>
<v t="T584"><vh>canMoveOutlineDown</vh></v>
<v t="T585"><vh>canMoveOutlineLeft</vh></v>
<v t="T586"><vh>canMoveOutlineRight</vh></v>
<v t="T587"><vh>canMoveOutlineUp</vh></v>
<v t="T308" a="C"><vh>canPasteOutline</vh></v>
<v t="T588"><vh>canPromote</vh></v>
<v t="T313" a="C"><vh>canRevert</vh></v>
<v t="T388" a="C"><vh>canSelectThreadBack</vh></v>
<v t="T389" a="C"><vh>canSelectThreadNext</vh></v>
<v t="T390" a="C"><vh>canSelectVisBack</vh></v>
<v t="T391" a="C"><vh>canSelectVisNext</vh></v>
<v t="T589"><vh>canShiftBodyLeft</vh></v>
<v t="T590"><vh>canShiftBodyRight</vh></v>
<v t="T591"><vh>canSortChildren, canSortSiblings</vh></v>
<v t="T592"><vh>canUnmarkAll</vh></v>
</v>
<v t="T593" a="C"><vh>Menu enablers (Frame)</vh>
<v t="T594"><vh>OnMenuClick (enables and disables all menu items)</vh></v>
<v t="T595"><vh>enable &amp; disable &amp; setLabel</vh></v>
<v t="T596"><vh>hasSelection</vh></v>
<v t="T597"><vh>updateFileMenu</vh></v>
<v t="T598"><vh>updateEditMenu</vh></v>
<v t="T599"><vh>updateOutlineMenu</vh></v>
</v>
<v t="T600"><vh>(Problem bindings)</vh>
<v t="T535" a="C"><vh>frame.OnOpen</vh>
<v t="T536"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="T601" a="C"><vh>OnMoveDownwn</vh></v>
<v t="T602" a="C"><vh>OnToggleActivePane</vh></v>
</v>
<v t="T603" a="C"><vh>Menu Command Handlers</vh>
<v t="T604"><vh>File Menu (Unfinished: Page Setup, Print, Import...)</vh>
<v t="T605"><vh>top level</vh>
<v t="T606"><vh>OnNew</vh></v>
<v t="T535" a="C"><vh>frame.OnOpen</vh>
<v t="T536"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="T537" a="C"><vh>frame.OpenWithFileName</vh></v>
<v t="T607"><vh>OnClose</vh></v>
<v t="T608"><vh>OnSave</vh></v>
<v t="T609"><vh>OnSaveAs</vh></v>
<v t="T610"><vh>OnSaveTo</vh></v>
<v t="T314" a="C"><vh>OnRevert (rewrite)</vh></v>
<v t="T404" a="C"><vh>frame.OnQuit</vh></v>
</v>
<v t="T611"><vh>Read/Write submenu</vh>
<v t="T533" a="C"><vh>fileCommands.OnReadOutlineOnly</vh></v>
<v t="T612"><vh>OnReadAtFileNodes</vh></v>
<v t="T613"><vh>OnWriteOutlineOnly</vh></v>
<v t="T614"><vh>OnWriteAtFileNodes</vh></v>
</v>
<v t="T615"><vh>Tangle submenu</vh>
<v t="T616"><vh>OnTangleAll</vh></v>
<v t="T617"><vh>OnTangleMarked</vh></v>
<v t="T618"><vh>OnTangle</vh></v>
</v>
<v t="T619"><vh>Untangle submenu</vh>
<v t="T620"><vh>OnUntangleAll</vh></v>
<v t="T621"><vh>OnUntangleMarked</vh></v>
<v t="T622"><vh>OnUntangle</vh></v>
</v>
<v t="T623"><vh>Import&amp;Export submenu</vh>
<v t="T624"><vh>OnImportFiles  (not ready yet)</vh></v>
<v t="T625"><vh>OnImportCWEBFiles  (not ready yet)</vh></v>
<v t="T626"><vh>OnImportNowebFiles (not ready yet)</vh></v>
<v t="T627"><vh>OnImportMoreText  (not ready yet)</vh></v>
<v t="T628"><vh>OnOutlineToCWEB (not ready yet)</vh></v>
<v t="T629"><vh>OnOutlineToNoweb  (not ready yet)</vh></v>
<v t="T630"><vh>OnExportMoreText  (not ready yet)</vh></v>
<v t="T631"><vh>OnFlattenOutline  (not ready yet)</vh></v>
</v>
</v>
<v t="T632"><vh>Edit Menu (change to handle log pane too)</vh>
<v t="T633"><vh>Edit top level</vh>
<v t="T634"><vh>OnUndo</vh></v>
<v t="T635"><vh>OnRedo</vh></v>
<v t="T307" a="C"><vh>frame.OnCut, OnCutFrom Menu</vh></v>
<v t="T306" a="C"><vh>frame.OnCopy, OnCopyFromMenu</vh></v>
<v t="T305" a="C"><vh>frame.OnPaste, OnPasteNode, OnPasteFromMenu</vh></v>
<v t="T315" a="C"><vh>OnDelete</vh></v>
<v t="T300" a="C"><vh>OnSelectAll</vh></v>
<v t="T636"><vh>OnEditHeadline</vh></v>
<v t="T637"><vh>OnFontPanel (set font)</vh></v>
<v t="T638"><vh>OnSyntaxColoring (rewrite)</vh></v>
<v t="T433" a="C"><vh>OnViewAllCharacters</vh></v>
<v t="T639"><vh>OnPreferences</vh></v>
</v>
<v t="T640"><vh>Edit Body submenu</vh>
<v t="T641"><vh>OnConvertBlanks</vh></v>
<v t="T642"><vh>OnDedent</vh></v>
<v t="T643"><vh>OnExtract</vh></v>
<v t="T644"><vh>OnExtractNames</vh></v>
<v t="T645"><vh>OnExtractSection</vh></v>
<v t="T646"><vh>OnIndent</vh></v>
</v>
<v t="T647"><vh>Find submenu (frame methods)</vh>
<v t="T648"><vh>OnFindPanel</vh></v>
<v t="T649"><vh>OnFindNext</vh></v>
<v t="T650"><vh>OnFindPrevious</vh></v>
<v t="T651"><vh>OnReplace</vh></v>
<v t="T652"><vh>OnReplaceThenFind</vh></v>
</v>
</v>
<v t="T653"><vh>Outline Menu</vh>
<v t="T654"><vh>top level</vh>
<v t="T655"><vh>OnCutNode</vh></v>
<v t="T656"><vh>OnCopyNode </vh></v>
<v t="T657"><vh>OnPasteNodee</vh></v>
<v t="T658"><vh>OnDeleteNode</vh></v>
<v t="T659"><vh>OnInsertNode</vh></v>
<v t="T660"><vh>OnCloneNode</vh></v>
<v t="T661"><vh>OnSortChildren, OnSortSiblings</vh></v>
</v>
<v t="T662"><vh>Expand/Contract</vh>
<v t="T663"><vh>OnContractParent</vh></v>
<v t="T664"><vh>OnExpandAll</vh></v>
<v t="T665"><vh>OnExpandAllChildren</vh></v>
<v t="T666"><vh>OnExpandChildren</vh></v>
<v t="T667"><vh>OnContractAll</vh></v>
<v t="T668"><vh>OnContractAllChildren</vh></v>
<v t="T669"><vh>OnContractChildren</vh></v>
<v t="T670"><vh>OnExpandNextLevel</vh></v>
<v t="T671"><vh>OnExpandToLevel1</vh></v>
<v t="T672"><vh>OnExpandToLevel2</vh></v>
<v t="T673"><vh>OnExpandToLevel3</vh></v>
<v t="T674"><vh>OnExpandToLevel4</vh></v>
<v t="T675"><vh>OnExpandToLevel5</vh></v>
<v t="T676"><vh>OnExpandToLevel6</vh></v>
<v t="T677"><vh>OnExpandToLevel7</vh></v>
<v t="T678"><vh>OnExpandToLevel8</vh></v>
<v t="T679"><vh>OnExpandToLevel9</vh></v>
</v>
<v t="T680"><vh>Move/Select</vh>
<v t="T601" a="C"><vh>OnMoveDownwn</vh></v>
<v t="T681"><vh>OnMoveLeft</vh></v>
<v t="T682"><vh>OnMoveRight</vh></v>
<v t="T683"><vh>OnMoveUp</vh></v>
<v t="T684"><vh>OnPromote</vh></v>
<v t="T685"><vh>OnDemote</vh></v>
<v t="T686"><vh>OnGoPrevVisible</vh></v>
<v t="T687"><vh>OnGoNextVisible</vh></v>
<v t="T688"><vh>OnGoBack</vh></v>
<v t="T689"><vh>OnGoNext</vh></v>
</v>
<v t="T690"><vh>Mark/Goto</vh>
<v t="T691"><vh>OnMark</vh></v>
<v t="T692"><vh>OnMarkSubheads</vh></v>
<v t="T693"><vh>OnMarkChangedItems</vh></v>
<v t="T694"><vh>OnMarkChangedRoots</vh></v>
<v t="T695"><vh>OnUnmarkAll</vh></v>
<v t="T696"><vh>OnGoToNextMarked</vh></v>
<v t="T697"><vh>OnGoToNextChanged</vh></v>
</v>
</v>
<v t="T698"><vh>Window Menu (complete excet Recent Windows)</vh>
<v t="T699"><vh>OnEqualSizedPanes</vh></v>
<v t="T602" a="C"><vh>OnToggleActivePane</vh></v>
<v t="T700"><vh>OnToggleSplitDirection</vh></v>
<v t="T701"><vh>OnCascade</vh></v>
<v t="T702"><vh>OnMinimizeAll</vh></v>
<v t="T703"><vh>OnOpenPythonWindow</vh></v>
<v t="T704"><vh>OnRecentWindows (to do)</vh></v>
</v>
<v t="T705"><vh>Help Menu</vh>
<v t="T706" a="C"><vh>OnAbout (version number)</vh></v>
<v t="T707"><vh>OnLeoDocumentation</vh></v>
</v>
</v>
</v>
<v t="T708"><vh>(memory management)</vh>
<v t="T397" a="C"><vh>tree.destroy</vh></v>
<v t="T398" a="C"><vh>v.destroy</vh></v>
<v t="T500" a="C"><vh>v.__init__</vh>
<v t="T501"><vh>&lt;&lt; initialize vnode data members &gt;&gt;</vh></v>
</v>
<v t="T516" a="C"><vh>app.__init__</vh></v>
</v>
</v>
<v t="T709"><vh>Scripts</vh>
<v t="T710"><vh> Files that must use @root and @silent</vh>
<v t="T711"><vh>go.bat</vh></v>
<v t="T712"><vh>help.bat</vh></v>
<v t="T713"><vh>sdist.bat</vh></v>
<v t="T714"><vh>bdist.bat</vh></v>
<v t="T715"><vh>manifest.in</vh></v>
</v>
<v t="T716"><vh>@file c2py.py</vh>
<v><vh>Documentation</vh>
<v t="T717"><vh>&lt;&lt; what c2py does &gt;&gt;</vh></v>
<v t="T718"><vh>&lt;&lt; theory of operation &gt;&gt;</vh></v>
</v>
<v t="T719"><vh>&lt;&lt; specifying user types &gt;&gt;</vh></v>
<v t="T720"><vh>&lt;&lt; define testData &gt;&gt;</vh></v>
<v t="T721"><vh>speedTest</vh></v>
<v><vh>leo1to2</vh>
<v t="T722"><vh>leo1to2</vh></v>
<v t="T723"><vh>convertLeo1to2</vh></v>
<v t="T724"><vh>convertStringLeo1to2</vh></v>
<v t="T725"><vh>convertCodeList1to2</vh></v>
</v>
<v t="T726"><vh>c2py entry points</vh>
<v t="T727"><vh>convertCurrentTree</vh></v>
<v t="T728"><vh>convertLeoTree</vh></v>
<v t="T729"><vh>convertCFileToPython</vh></v>
</v>
<v><vh>c2py Top Level</vh>
<v t="T730"><vh>convertCStringToPython</vh></v>
<v t="T731"><vh>convertCodeList</vh></v>
<v t="T732"><vh>convertDocList</vh></v>
<v t="T733"><vh>skipDocPart</vh></v>
<v t="T734"><vh>skipCodePart</vh></v>
</v>
<v><vh>Scanning &amp; Replacing</vh>
<v t="T735"><vh>convertLeadingBlanks</vh></v>
<v t="T736"><vh>findInList</vh></v>
<v t="T737"><vh>findInCode</vh></v>
<v t="T738"><vh>mungeAllFunctions</vh>
<v t="T739"><vh>handlePossibleFunctionHeader</vh></v>
<v t="T740"><vh>massageFunctionArgs</vh></v>
<v t="T741"><vh>massageFunctionHead (sets gClassName)</vh></v>
<v t="T742"><vh>massageFunctionBody</vh>
<v t="T743"><vh>massageIvars</vh></v>
<v t="T744"><vh>removeCasts</vh></v>
<v t="T745"><vh>removeTypeNames</vh></v>
</v>
</v>
<v t="T746"><vh>handleAllKeywords</vh>
<v t="T747"><vh>handleKeyword</vh></v>
</v>
<v t="T748"><vh>isWs and isWOrNl</vh></v>
<v t="T749"><vh>isSectionDef</vh></v>
<v t="T750"><vh>isStringOrComment</vh></v>
<v t="T751"><vh>match</vh></v>
<v t="T752"><vh>matchWord</vh></v>
<v t="T753"><vh>prevNonWsChar and prevNonWsOrNlChar</vh></v>
<v t="T754"><vh>removeAllCComments</vh></v>
<v t="T755"><vh>removeAllCSentinels</vh></v>
<v t="T756"><vh>removeAllPythonComments</vh></v>
<v t="T757"><vh>removeAllPythonSentinels</vh></v>
<v t="T758"><vh>removeAtRoot</vh></v>
<v t="T759"><vh>removeBlankLines</vh></v>
<v t="T760"><vh>removeExcessWs</vh>
<v t="T761"><vh>removeExessWsFromLine</vh></v>
</v>
<v t="T762"><vh>removeLeadingAtCode</vh></v>
<v t="T763"><vh>removeMatchingBrackets</vh></v>
<v t="T764"><vh>removeSemicolonsAtEndOfLines</vh></v>
<v t="T765"><vh>removeTrailingWs</vh></v>
<v t="T766"><vh>replace</vh></v>
<v t="T767"><vh>replaceComments</vh></v>
<v t="T768"><vh>replaceSectionDefs</vh></v>
<v t="T769"><vh>safeReplace</vh></v>
<v t="T770"><vh>skipCBlockComment</vh></v>
<v t="T771"><vh>skipPastLine</vh></v>
<v t="T772"><vh>skipPastWord</vh></v>
<v t="T773"><vh>skipString</vh></v>
<v t="T774"><vh>skipStringOrComment</vh></v>
<v t="T775"><vh>skipToMatchingBracket</vh></v>
<v t="T776"><vh>skipWs and skipWsAndNl</vh></v>
<v t="T777"><vh>stringToList</vh></v>
<v t="T778"><vh>listToString</vh></v>
</v>
</v>
<v t="T779" a="M"><vh>@file leoCompare.py</vh>
<v t="T780"><vh>choose</vh></v>
<v t="T781"><vh>cmp</vh></v>
<v t="T782"><vh>compare</vh>
<v t="T783"><vh>&lt;&lt; ignore blank lines &gt;&gt;</vh></v>
</v>
<v t="T784"><vh>compare_files</vh></v>
<v t="T785"><vh>compare_lines</vh></v>
<v t="T786"><vh>compareDirs</vh></v>
<v t="T787"><vh>compare_directories</vh></v>
<v t="T788"><vh>crlf &amp; count_crlf</vh></v>
<v t="T789"><vh>diff (does not exist!)</vh></v>
<v t="T790"><vh>doOpen</vh></v>
<v t="T791"><vh>dump</vh></v>
<v t="T792"><vh>dumpEnd</vh></v>
<v t="T793"><vh>go()</vh></v>
<v t="T794"><vh>sequence (hangs)</vh></v>
</v>
<v t="T795"><vh>@file leoFindScript.py</vh>
<v t="T796"><vh>changeAll</vh></v>
<v t="T797"><vh>changeNext</vh></v>
<v t="T798"><vh>changePrev</vh></v>
<v t="T799"><vh>findAll</vh></v>
<v t="T800"><vh>findNext</vh></v>
<v t="T801"><vh>findPrev</vh></v>
<v t="T802"><vh>reChangeAll</vh></v>
<v t="T803"><vh>reChangeNext</vh></v>
<v t="T804"><vh>reChangePrev</vh></v>
<v t="T805"><vh>reFindAll</vh></v>
<v t="T806"><vh>reFindNext</vh></v>
<v t="T807"><vh>reFindPrev</vh></v>
<v t="T808"><vh>lineAtPos</vh></v>
<v t="T809"><vh>printFindList</vh></v>
</v>
<v t="T810"><vh>@file openLeo.py</vh></v>
<v t="T811"><vh>@file setup.py</vh></v>
<v t="T812"><vh>@file tangle_done.py</vh></v>
<v t="T813"><vh>@file untangle_done.py</vh></v>
</v>
<v t="T814" a="V"><vh>Code</vh>
<v t="T706" a="C"><vh> OnAbout (version number)</vh></v>
<v t="T815"><vh> Partially converted (do not delete!)</vh>
<v t="T816"><vh>fileCommands (Import and Export)</vh>
<v><vh>Export</vh>
<v t="T817"><vh>exportMoreText</vh></v>
<v t="T540" a="C"><vh>importFiles.flattenOutline</vh></v>
<v t="T541" a="C"><vh>importFiles.outlineToNoweb</vh></v>
<v t="T818"><vh>convertToNoweb</vh></v>
<v t="T819"><vh>convertCodePartToNoweb</vh>
<v t="T820"><vh>&lt;&lt; handle @c &gt;&gt;</vh>
<v t="T821"><vh>&lt;&lt; point j and k at section name in v's headline &gt;&gt;</vh></v>
</v>
<v t="T822"><vh>&lt;&lt; handle @root &gt;&gt;</vh>
<v t="T823"><vh>&lt;&lt; Set name to the file name p2..p &gt;&gt;</vh></v>
</v>
<v t="T824"><vh>&lt;&lt; copy the line to result &gt;&gt;</vh></v>
</v>
<v t="T825"><vh>convertDocPartToNoweb</vh></v>
<v t="T826"><vh>copyPart</vh></v>
</v>
<v><vh>Import</vh>
<v t="T827"><vh>convertMoreStringsToOutlineAfter</vh>
<v t="T828"><vh>&lt;&lt; Declare the vars for convertMoreStringsToOutlineAfter &gt;&gt;</vh></v>
<v t="T829"><vh>&lt;&lt; Link a new vnode v into the outline &gt;&gt;</vh></v>
<v t="T830"><vh>&lt;&lt; Set the headline string, skipping over the leader &gt;&gt;</vh></v>
<v t="T831"><vh>&lt;&lt; Count the number of following body lines &gt;&gt;</vh></v>
<v t="T832"><vh>&lt;&lt; Add the lines to the body text of v &gt;&gt;</vh></v>
</v>
<v t="T833"><vh>importMoreText</vh>
<v t="T834"><vh>&lt;&lt; Read the file into array &gt;&gt;</vh></v>
</v>
<v t="T835"><vh>moreHeadlineLevel</vh></v>
<v t="T836"><vh>stringsAreValidMoreFile</vh></v>
</v>
</v>
<v t="T837"><vh>CWEBToOutline</vh>
<v t="T838"><vh>Sections that might change for noweb (ignore)</vh>
<v t="T839" a="C"><vh>&lt;&lt; CWEBToOutline abbreviations &gt;&gt;</vh></v>
<v t="T840" a="C"><vh>CWEBToOutlineCommand</vh></v>
<v t="T841" a="C"><vh>massageCWEBBody</vh>
<v t="T842"><vh>&lt;&lt; Remove most newlines from @space and @* sections &gt;&gt;</vh></v>
<v t="T843"><vh>&lt;&lt; Replace abbreviated names with full names &gt;&gt;</vh></v>
<v t="T844"><vh>&lt;&lt; Remove trailing blank lines &gt;&gt;</vh></v>
</v>
<v t="T845" a="C"><vh>scanCWEBFile</vh>
<v t="T846"><vh>&lt;&lt; Create a symbol table of all section names &gt;&gt;</vh></v>
<v t="T847"><vh>&lt;&lt; Create a node for limbo text &gt;&gt;</vh></v>
<v t="T848"><vh>&lt;&lt; Create a node for the next module &gt;&gt;</vh></v>
</v>
</v>
<v t="T849"><vh>CWEBToOutline.cpp</vh>
<v t="T850"><vh>&lt;&lt; CWEBToOutline includes &gt;&gt;</vh></v>
<v t="T839" a="C"><vh>&lt;&lt; CWEBToOutline abbreviations &gt;&gt;</vh></v>
<v t="T851"><vh>&lt;&lt; CWEBToOutline private globals &gt;&gt;</vh></v>
</v>
<v t="T840" a="C"><vh>CWEBToOutlineCommand</vh></v>
<v t="T852"><vh>createHeadlineFromBody</vh>
<v t="T853"><vh>&lt;&lt; Scan for a section definition, @d or @c &gt;&gt;</vh>
<v t="T854"><vh>&lt;&lt; set macro_start and macro_end &gt;&gt;</vh></v>
<v t="T855"><vh>&lt;&lt; Return the function name &gt;&gt;</vh></v>
</v>
</v>
<v t="T856"><vh>createOutlineFromCWEB</vh>
<v t="T857"><vh>&lt;&lt; Set shortFileName &gt;&gt;</vh></v>
</v>
<v t="T841" a="C"><vh>massageCWEBBody</vh>
<v t="T842"><vh>&lt;&lt; Remove most newlines from @space and @* sections &gt;&gt;</vh></v>
<v t="T843"><vh>&lt;&lt; Replace abbreviated names with full names &gt;&gt;</vh></v>
<v t="T844"><vh>&lt;&lt; Remove trailing blank lines &gt;&gt;</vh></v>
</v>
<v t="T845" a="C"><vh>scanCWEBFile</vh>
<v t="T846"><vh>&lt;&lt; Create a symbol table of all section names &gt;&gt;</vh></v>
<v t="T847"><vh>&lt;&lt; Create a node for limbo text &gt;&gt;</vh></v>
<v t="T848"><vh>&lt;&lt; Create a node for the next module &gt;&gt;</vh></v>
</v>
<v t="T858"><vh>createCWEBHeadline</vh></v>
<v t="T859"><vh>cstCanonicalize</vh></v>
<v t="T860"><vh>cstDump</vh></v>
<v t="T861"><vh>cstEnter</vh></v>
<v t="T862"><vh>cstLookup</vh>
<v t="T863"><vh>&lt;&lt; Tell about the substitution &gt;&gt;</vh></v>
<v t="T864"><vh>&lt;&lt; Warn if there are other matches &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T865"><vh>@file __init__.py</vh></v>
<v t="T866"><vh>@file leo.py</vh>
<v t="T867"><vh>Functions for scripts</vh></v>
<v t="T868"><vh>go</vh></v>
<v t="T869"><vh>open</vh>
<v t="T515" a="C"><vh>&lt;&lt; set the icon image &gt;&gt;</vh></v>
</v>
<v t="T514" a="C"><vh>leo.run</vh>
<v t="T515" a="C"><vh>&lt;&lt; set the icon image &gt;&gt;</vh></v>
</v>
<v t="T870"><vh>reload_all</vh></v>
</v>
<v t="T871"><vh>@file leoApp.py</vh>
<v t="T516" a="C"><vh>app.__init__</vh></v>
<v t="T510" a="C"><vh>app.finishCreate</vh>
<v t="T511" a="C"><vh>&lt;&lt; set loaddir &gt;&gt;</vh></v>
</v>
<v t="T872"><vh>destroyAllGlobalWindows</vh></v>
<v t="T405" a="C"><vh>app.quit</vh></v>
</v>
<v t="T873"><vh>@file leoAtFile.py</vh>
<v t="T874"><vh>&lt;&lt; atFile constants &gt;&gt;</vh></v>
<v t="T517" a="C"><vh>atFile ctor</vh>
<v t="T518"><vh>&lt;&lt; initialize atFile ivars &gt;&gt;</vh></v>
</v>
<v><vh>Sentinels</vh>
<v t="T875"><vh>nodeSentinelText</vh></v>
<v t="T876"><vh>putCloseNodeSentinel</vh></v>
<v t="T877"><vh>putCloseSentinels</vh></v>
<v t="T878"><vh>putOpenLeoSentinel</vh></v>
<v t="T879"><vh>putOpenNodeSentinel</vh></v>
<v t="T880"><vh>putOpenSentinels</vh></v>
<v t="T881"><vh>putSentinel</vh></v>
<v t="T882"><vh>sentinelKind</vh></v>
<v t="T883"><vh>sentinelName</vh></v>
<v t="T884"><vh>skipSentinelStart</vh></v>
</v>
<v><vh>Utilites</vh>
<v t="T418" a="C"><vh>atFile.scanAllDirectives (calls writeError on errors)</vh>
<v t="T419"><vh>&lt;&lt; Set delims to default values &gt;&gt;</vh></v>
<v t="T420"><vh>&lt;&lt; Set path from @file node &gt;&gt;</vh></v>
<v t="T421"><vh>&lt;&lt; Test for @comment or @language &gt;&gt;</vh></v>
<v t="T422"><vh>&lt;&lt; Test for @path &gt;&gt;</vh></v>
<v t="T423"><vh>&lt;&lt; Test for @pagewidth and @tabwidth &gt;&gt;</vh></v>
<v t="T424"><vh>&lt;&lt; Set current directory &gt;&gt;</vh></v>
<v t="T425"><vh>&lt;&lt; Set comment Strings from delims &gt;&gt;</vh></v>
</v>
<v t="T885"><vh>directiveKind</vh></v>
<v t="T886"><vh>error</vh></v>
<v t="T887"><vh>skipIndent</vh></v>
<v t="T888"><vh>readError</vh></v>
<v t="T889"><vh>updateCloneIndices</vh></v>
<v t="T890"><vh>writeError</vh></v>
</v>
<v><vh>Reading</vh>
<v t="T891"><vh>createNthChild</vh></v>
<v t="T892"><vh>joinTrees</vh></v>
<v t="T519" a="C"><vh>atFile.read</vh>
<v t="T520"><vh>&lt;&lt; open file &gt;&gt;</vh></v>
<v t="T521"><vh>&lt;&lt; Scan the file buffer  &gt;&gt;</vh></v>
<v t="T522"><vh>&lt;&lt; Bump mStructureErrors if any vnodes are unvisited &gt;&gt;</vh></v>
<v t="T523"><vh>&lt;&lt; Delete root's tree and body text &gt;&gt;</vh></v>
<v t="T524"><vh>&lt;&lt; Handle clone bits &gt;&gt;</vh></v>
<v t="T525"><vh>&lt;&lt; Join cloned trees &gt;&gt;</vh></v>
<v t="T526"><vh>&lt;&lt; Handle all status bits &gt;&gt;</vh></v>
</v>
<v t="T893"><vh>readAll (Leo2)</vh></v>
<v t="T894"><vh>scanDoc</vh>
<v t="T895"><vh>&lt;&lt; Skip the opening sentinel &gt;&gt;</vh></v>
<v t="T896"><vh>&lt;&lt; Skip an opening block delim &gt;&gt;</vh></v>
<v t="T897"><vh>&lt;&lt; set kind, nextLine &gt;&gt;</vh></v>
<v t="T898"><vh>&lt;&lt; Skip the leading stuff &gt;&gt;</vh></v>
<v t="T899"><vh>&lt;&lt; Append s to out &gt;&gt;</vh></v>
<v t="T900"><vh>&lt;&lt; Remove a closing block delim from out &gt;&gt;</vh></v>
</v>
<v t="T901"><vh>scanHeader</vh></v>
<v t="T902"><vh>scanText</vh>
<v t="T903"><vh>&lt;&lt; set kind, nextKind &gt;&gt;</vh></v>
<v t="T904"><vh>&lt;&lt; Set lineIndent, linep and leading_ws &gt;&gt;</vh></v>
<v t="T905"><vh>&lt;&lt; append non-sentinel line &gt;&gt;</vh></v>
<v t="T906"><vh>&lt;&lt; handle an ending sentinel &gt;&gt;</vh></v>
<v t="T907"><vh>&lt;&lt; handle unexpected end of text &gt;&gt;</vh></v>
<v><vh>start sentinels</vh>
<v t="T908"><vh>&lt;&lt; scan @+at &gt;&gt;</vh></v>
<v t="T909"><vh>&lt;&lt; scan @+body &gt;&gt;</vh></v>
<v t="T910"><vh>&lt;&lt; scan @+doc &gt;&gt;</vh></v>
<v t="T911"><vh>&lt;&lt; scan @+leo &gt;&gt;</vh></v>
<v t="T912"><vh>&lt;&lt; scan @+node &gt;&gt;</vh>
<v t="T913"><vh>&lt;&lt; Set childIndex &gt;&gt;</vh></v>
<v t="T914"><vh>&lt;&lt; Set cloneIndex &gt;&gt;</vh></v>
<v t="T915"><vh>&lt;&lt; Set headline and ref &gt;&gt;</vh></v>
<v t="T916"><vh>&lt;&lt; Check the filename in the sentinel &gt;&gt;</vh></v>
</v>
<v t="T917"><vh>&lt;&lt; scan @+others &gt;&gt;</vh></v>
</v>
<v><vh>unpaired sentinels</vh>
<v t="T918"><vh>&lt;&lt; scan @delims &gt;&gt;</vh></v>
<v t="T919"><vh>&lt;&lt; scan @ref &gt;&gt;</vh></v>
<v t="T920"><vh>&lt;&lt; scan @verbatim &gt;&gt;</vh></v>
<v t="T921"><vh>&lt;&lt; scan @@ &gt;&gt;</vh></v>
</v>
<v t="T922"><vh>&lt;&lt; warn about unknown sentinel &gt;&gt;</vh></v>
</v>
</v>
<v><vh>Writing</vh>
<v t="T923"><vh>os, onl, etc.</vh></v>
<v t="T924"><vh>putBody</vh></v>
<v t="T925"><vh>putBodyPart (removes trailing lines)</vh>
<v t="T926"><vh>&lt;&lt; put code/doc parts and sentinels &gt;&gt;</vh></v>
</v>
<v t="T927"><vh>putCodePart &amp; allies</vh>
<v t="T928"><vh>&lt;&lt; handle the start of a line &gt;&gt;</vh>
<v t="T929"><vh>&lt;&lt; compute delta, the width of the whitespace &gt;&gt;</vh></v>
<v t="T930"><vh>&lt;&lt; handle @others &gt;&gt;</vh></v>
<v t="T931"><vh>&lt;&lt; put @verbatim sentinel if necessary &gt;&gt;</vh></v>
</v>
<v t="T932"><vh>&lt;&lt; put the line &gt;&gt;</vh>
<v t="T933"><vh>&lt;&lt; put possible section reference &gt;&gt;</vh></v>
</v>
<v t="T934"><vh>isSectionName</vh></v>
<v t="T935"><vh>inAtOthers</vh></v>
<v t="T936"><vh>putAtOthers</vh></v>
<v t="T937"><vh>putAtOthersChild</vh></v>
</v>
<v t="T938"><vh>putDirective  (handles @delims)</vh>
<v t="T939"><vh>&lt;&lt; handle @delims &gt;&gt;</vh></v>
</v>
<v t="T940"><vh>putDoc</vh></v>
<v t="T941"><vh>putDocPart</vh>
<v t="T942"><vh>&lt;&lt; copy words, splitting the line if needed &gt;&gt;</vh></v>
</v>
<v t="T943"><vh>putIndent</vh></v>
<v t="T408" a="C"><vh>atFile.write</vh>
<v t="T409"><vh>&lt;&lt; Open files.  Set orphan and dirty flags and return on errors &gt;&gt;</vh></v>
<v t="T410"><vh>&lt;&lt; put all @first lines in root &gt;&gt;</vh></v>
<v t="T411"><vh>&lt;&lt; Warn about @ignored and orphans  &gt;&gt;</vh></v>
<v t="T412"><vh>&lt;&lt; Replace the target with the temp file if different &gt;&gt;</vh></v>
</v>
<v t="T944"><vh>writeAll</vh>
<v t="T945"><vh>&lt;&lt; Clear all orphan bits &gt;&gt;</vh></v>
</v>
</v>
<v><vh>Testing</vh>
<v t="T946"><vh>scanAll</vh></v>
<v t="T947"><vh>scanFile</vh>
<v t="T948"><vh>&lt;&lt; open file &gt;&gt;</vh></v>
<v t="T949"><vh>&lt;&lt; Scan the file buffer  &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T950"><vh>@file leoColor.py</vh>
<v t="T951"><vh>&lt;&lt; define colorizer constants &gt;&gt;</vh></v>
<v t="T952"><vh>&lt;&lt; define colorizer keywords &gt;&gt;</vh></v>
<v t="T953"><vh>&lt;&lt; define colorizer functions &gt;&gt;</vh></v>
<v t="T465" a="C"><vh>color.__init__</vh></v>
<v><vh>color.callbacks...</vh>
<v t="T954"><vh>OnHyperLinkControlClick</vh></v>
<v t="T955"><vh>OnHyperLinkEnter</vh></v>
<v t="T956"><vh>OnHyperLinkLeave</vh></v>
</v>
<v t="T957"><vh>colorize</vh></v>
<v t="T958"><vh>colorizePlain</vh></v>
<v t="T466" a="C"><vh>colorizePython</vh>
<v t="T434" a="C"><vh>&lt;&lt; configure tags &gt;&gt;</vh></v>
<v t="T467"><vh>&lt;&lt; continue doc part &gt;&gt;</vh></v>
<v t="T468"><vh>&lt;&lt; continue python triple string &gt;&gt;</vh></v>
<v t="T469"><vh>&lt;&lt; continue nocolor state &gt;&gt;</vh></v>
<v t="T470"><vh>&lt;&lt; handle python string &gt;&gt;</vh></v>
<v t="T471"><vh>&lt;&lt; handle python comment &gt;&gt;</vh></v>
<v t="T472"><vh>&lt;&lt; handle possible @keyword &gt;&gt;</vh></v>
<v t="T473"><vh>&lt;&lt; handle possible section ref &gt;&gt;</vh>
<v t="T474"><vh>&lt;&lt; set the hyperlink &gt;&gt;</vh></v>
</v>
<v t="T475"><vh>&lt;&lt; handle possible python keyword &gt;&gt;</vh></v>
<v t="T476"><vh>&lt;&lt; handle blank &gt;&gt;</vh></v>
<v t="T477"><vh>&lt;&lt; handle tab &gt;&gt;</vh></v>
<v t="T478"><vh>&lt;&lt; handle normal character &gt;&gt;</vh></v>
</v>
<v t="T416" a="C"><vh>scanColorDirectives</vh>
<v t="T417"><vh>&lt;&lt; Test for @comment or @language &gt;&gt;</vh></v>
</v>
<v t="T959"><vh>color.schedule</vh></v>
<v t="T960"><vh>updateSyntaxColorer</vh></v>
<v t="T961"><vh>useSyntaxColoring</vh></v>
<v t="T962"><vh>Utils</vh>
<v t="T963"><vh>skip_id</vh></v>
<v t="T964"><vh>skip_python_string</vh></v>
<v t="T965"><vh>skip_string</vh></v>
</v>
</v>
<v t="T966"><vh>@file leoCommands.py</vh>
<v t="T967"><vh>&lt;&lt; Commands constants &gt;&gt;</vh></v>
<v t="T968"><vh>c.__init__</vh>
<v t="T969"><vh>&lt;&lt; initialize ivars &gt;&gt;</vh></v>
</v>
<v t="T970"><vh>c.__del__</vh></v>
<v t="T971"><vh>c.__repr__</vh></v>
<v t="T399" a="C"><vh>c.destroy</vh></v>
<v t="T972"><vh>c.setIvarsFromPrefs</vh></v>
<v t="T973"><vh>c.setIvarsFromFind</vh></v>
<v t="T309" a="C"><vh>Cut &amp; Paste Outlines</vh>
<v t="T310"><vh>cutOutline</vh></v>
<v t="T311"><vh>copyOutline</vh></v>
<v t="T312"><vh>pasteOutline</vh></v>
</v>
<v><vh>Drawing Utilities</vh>
<v t="T974"><vh>beginUpdate</vh></v>
<v t="T975"><vh>bringToFront</vh></v>
<v t="T976"><vh>endUpdate</vh></v>
<v t="T977"><vh>recolor</vh></v>
<v t="T978"><vh>redraw &amp; repaint</vh></v>
</v>
<v t="T326" a="C"><vh>Edit Body Text</vh>
<v t="T327"><vh>convertBlanks</vh></v>
<v t="T328"><vh>createLastChildNode</vh></v>
<v t="T329"><vh>dedentBody</vh></v>
<v t="T330"><vh>extract</vh>
<v t="T331"><vh>&lt;&lt; Set headline for extract &gt;&gt;</vh></v>
</v>
<v t="T332"><vh>extractSection</vh>
<v t="T333"><vh>&lt;&lt; Set headline for extractSection &gt;&gt;</vh></v>
</v>
<v t="T334"><vh>extractSectionNames</vh>
<v t="T335"><vh>&lt;&lt; Find the next section name &gt;&gt;</vh></v>
</v>
<v t="T336"><vh>getBodyLines</vh></v>
<v t="T337"><vh>getBodySelection</vh></v>
<v t="T338"><vh>indentBody</vh></v>
<v t="T339"><vh>updateBodyPane</vh></v>
</v>
<v t="T570" a="C"><vh>Enabling Menu Items (Commands)</vh>
<v t="T571"><vh>canContractAllHeadlines</vh></v>
<v t="T572"><vh>canContractAllSubheads</vh></v>
<v t="T573"><vh>canContractParent</vh></v>
<v t="T574"><vh>canContractSubheads</vh></v>
<v t="T575"><vh>canCutOutline &amp; canDeleteHeadline</vh></v>
<v t="T576"><vh>canDemote</vh></v>
<v t="T577"><vh>canExpandAllHeadlines</vh></v>
<v t="T578"><vh>canExpandAllSubheads</vh></v>
<v t="T579"><vh>canExpandSubheads</vh></v>
<v t="T325" a="C"><vh>canExtract, canExtractSection &amp; canExtractSectionNames</vh></v>
<v t="T580"><vh>canGoToNextDirtyHeadline</vh></v>
<v t="T581"><vh>canGoToNextMarkedHeadline</vh></v>
<v t="T582"><vh>canMarkChangedHeadline</vh></v>
<v t="T583"><vh>canMarkChangedRoots</vh></v>
<v t="T584"><vh>canMoveOutlineDown</vh></v>
<v t="T585"><vh>canMoveOutlineLeft</vh></v>
<v t="T586"><vh>canMoveOutlineRight</vh></v>
<v t="T587"><vh>canMoveOutlineUp</vh></v>
<v t="T308" a="C"><vh>canPasteOutline</vh></v>
<v t="T588"><vh>canPromote</vh></v>
<v t="T313" a="C"><vh>canRevert</vh></v>
<v t="T388" a="C"><vh>canSelectThreadBack</vh></v>
<v t="T389" a="C"><vh>canSelectThreadNext</vh></v>
<v t="T390" a="C"><vh>canSelectVisBack</vh></v>
<v t="T391" a="C"><vh>canSelectVisNext</vh></v>
<v t="T589"><vh>canShiftBodyLeft</vh></v>
<v t="T590"><vh>canShiftBodyRight</vh></v>
<v t="T591"><vh>canSortChildren, canSortSiblings</vh></v>
<v t="T592"><vh>canUnmarkAll</vh></v>
</v>
<v><vh>Expand &amp; Contract</vh>
<v><vh>Commands</vh>
<v t="T979"><vh>contractAllHeadlines</vh></v>
<v t="T980"><vh>contractAllSubheads</vh></v>
<v t="T981"><vh>contractParent</vh></v>
<v t="T982"><vh>contractSubheads</vh></v>
<v t="T983"><vh>expandLevel1</vh></v>
<v t="T984"><vh>expandLevel2</vh></v>
<v t="T985"><vh>expandLevel3</vh></v>
<v t="T986"><vh>expandLevel4</vh></v>
<v t="T987"><vh>expandLevel5</vh></v>
<v t="T988"><vh>expandLevel6</vh></v>
<v t="T989"><vh>expandLevel7</vh></v>
<v t="T990"><vh>expandLevel8</vh></v>
<v t="T991"><vh>expandLevel9</vh></v>
<v t="T992"><vh>expandNextLevel</vh></v>
<v t="T993"><vh>expandAllHeadlines</vh></v>
<v t="T994"><vh>expandAllSubheads</vh></v>
<v t="T995"><vh>expandSubheads</vh></v>
</v>
<v><vh>Utilities</vh>
<v t="T996"><vh>contractSubtree</vh></v>
<v t="T997"><vh>contractVnode</vh></v>
<v t="T998"><vh>expandSubtree</vh></v>
<v t="T999"><vh>expandToLevel</vh></v>
<v t="T1000"><vh>expandVnode</vh></v>
<v t="T1001"><vh>expandTreeToLevelFromLevel</vh></v>
</v>
</v>
<v><vh>Getters &amp; Setters</vh>
<v t="T1002"><vh>c.currentVnode</vh></v>
<v t="T1003"><vh>clearAllMarked</vh></v>
<v t="T1004"><vh>clearAllVisited</vh></v>
<v t="T1005"><vh>fileName</vh></v>
<v t="T1006"><vh>isChanged</vh></v>
<v t="T1007"><vh>rootVnode</vh></v>
<v t="T1008"><vh>setChanged</vh></v>
</v>
<v><vh>Insert, Delete &amp; Clone (Commands)</vh>
<v t="T1009"><vh>checkMoveWithParentWithWarning</vh></v>
<v t="T1010"><vh>clone (Commands)</vh></v>
<v t="T1011"><vh>deleteHeadline</vh></v>
<v t="T1012"><vh>initAllCloneBits</vh></v>
<v t="T1013"><vh>insertHeadline</vh></v>
<v t="T1014"><vh>validateOutline</vh></v>
</v>
<v><vh>Mark &amp; Unmark</vh>
<v t="T1015"><vh>goToNextDirtyHeadline</vh></v>
<v t="T1016"><vh>goToNextMarkedHeadline</vh></v>
<v t="T1017"><vh>markChangedHeadlines</vh></v>
<v t="T1018"><vh>markChangedRoots</vh></v>
<v t="T1019"><vh>markAllAtFileNodesDirty</vh></v>
<v t="T1020"><vh>markAtFileNodesDirty</vh></v>
<v t="T1021"><vh>markHeadline</vh></v>
<v t="T1022"><vh>markSubheads</vh></v>
<v t="T1023"><vh>unmarkAll</vh></v>
</v>
<v><vh>Moving, Promote, Demote, Sort</vh>
<v t="T1024"><vh>demote</vh></v>
<v t="T1025"><vh>moveOutlineDown</vh>
<v t="T1026"><vh>&lt;&lt; Move v down &gt;&gt;</vh></v>
</v>
<v t="T1027"><vh>moveOutlineLeft</vh></v>
<v t="T1028"><vh>moveOutlineRight</vh></v>
<v t="T1029"><vh>moveOutlineUp</vh>
<v t="T1030"><vh>&lt;&lt; Move v up &gt;&gt;</vh></v>
</v>
<v t="T1031"><vh>promote</vh></v>
<v t="T435" a="C"><vh>sortChildren, sortSiblings</vh></v>
</v>
<v><vh>Selecting &amp; Updating (commands)</vh>
<v t="T1032"><vh>editVnode (calls tree.editLabel)</vh></v>
<v t="T1033"><vh>endEditing (calls tree.endEditLabel)</vh></v>
<v t="T392" a="C"><vh>selectThreadBack</vh></v>
<v t="T393" a="C"><vh>selectThreadNext</vh></v>
<v t="T394" a="C"><vh>selectVisBack</vh></v>
<v t="T395" a="C"><vh>selectVisNext</vh></v>
<v t="T1034"><vh>c.selectVnode (calls tree.select)</vh></v>
<v t="T1035"><vh>selectVnodeWithEditing</vh></v>
</v>
<v t="T1036"><vh>Syntax coloring interface</vh>
<v t="T1037"><vh>updateSyntaxColorer</vh></v>
</v>
<v t="T1038"><vh>Undo</vh>
<v t="T1039"><vh>canUndo</vh></v>
<v t="T1040"><vh>undoCaption</vh></v>
<v t="T1041"><vh>findSharedVnode</vh></v>
<v t="T1042"><vh>setUndoParams</vh></v>
<v t="T1043"><vh>undo</vh>
<v t="T1044"><vh>&lt;&lt; save the undo vars in local vars &gt;&gt;</vh></v>
<v t="T1045"><vh>&lt;&lt; clone cases &gt;&gt;</vh></v>
<v t="T1046"><vh>&lt;&lt; delete cases &gt;&gt;</vh></v>
<v t="T1047"><vh>&lt;&lt; insert cases &gt;&gt;</vh></v>
<v t="T1048"><vh>&lt;&lt; move cases &gt;&gt;</vh></v>
<v t="T1049"><vh>&lt;&lt; promote and demote cases &gt;&gt;</vh></v>
</v>
<v t="T1050"><vh>undoDemote</vh></v>
<v t="T1051"><vh>undoPromote</vh></v>
</v>
</v>
<v t="T1052"><vh>@file leoDialog.py</vh>
<v t="T1053"><vh>__init__</vh></v>
<v t="T1054"><vh>askYesNoCancel</vh></v>
<v t="T1055"><vh>askYesNo</vh></v>
<v t="T1056"><vh>cancelButton, noButton, yesButton</vh></v>
<v t="T1057"><vh>dialog.center</vh></v>
<v t="T1058"><vh>OnKey</vh></v>
</v>
<v t="T1059"><vh>@file leoFileCommands.py</vh>
<v t="T1060"><vh>ctor leoFileCommands</vh></v>
<v><vh>Reading</vh>
<v t="T1061"><vh>checkAllFileDates</vh>
<v t="T1062"><vh>&lt;&lt; update v if it has changed since last load &gt;&gt;</vh></v>
</v>
<v t="T1063"><vh>createVnode</vh></v>
<v t="T1064"><vh>finishPaste (creating join lists could be a problem)</vh>
<v t="T1065"><vh>&lt;&lt; Create join lists of all pasted vnodes &gt;&gt;</vh></v>
<v t="T1066"><vh>&lt;&lt; Recompute clone bits for pasted vnodes &gt;&gt;</vh></v>
</v>
<v><vh>get routines</vh>
<v t="T1067"><vh>get &amp; match (basic)</vh></v>
<v t="T1068"><vh>getClipboardHeader</vh></v>
<v t="T1069"><vh>getCloneWindows</vh></v>
<v t="T1070"><vh>getEscapedString</vh></v>
<v t="T1071"><vh>getFindPanelSettings</vh>
<v t="T1072"><vh>&lt;&lt; Set defaults of all flags &gt;&gt;</vh></v>
</v>
<v t="T1073"><vh>getGlobals</vh></v>
<v t="T1074"><vh>getLeoFile (Leo2)</vh>
<v t="T1075"><vh>&lt;&lt; Create join lists of all vnodes &gt;&gt;</vh></v>
</v>
<v t="T1076"><vh>getLeoHeader</vh></v>
<v t="T1077"><vh>getLeoOutline (from clipboard)</vh></v>
<v t="T1078"><vh>getPosition</vh></v>
<v t="T531" a="C"><vh>fileCommands.getPrefs</vh>
<v t="T532"><vh>&lt;&lt; check for syntax coloring prefs &gt;&gt;</vh></v>
</v>
<v t="T1079"><vh>getSize</vh></v>
<v t="T1080"><vh>getT</vh></v>
<v t="T1081"><vh>getTnode</vh></v>
<v t="T1082"><vh>getTnodes</vh></v>
<v t="T1083"><vh>getVnode (Leo2)</vh>
<v t="T1084"><vh>&lt;&lt; Handle vnode attribute bits  &gt;&gt;</vh></v>
</v>
<v t="T1085"><vh>getVnodes</vh></v>
<v t="T1086"><vh>skipWs</vh></v>
<v t="T1087"><vh>skipWsAndNl</vh></v>
</v>
<v t="T1088"><vh>newTnode</vh></v>
<v t="T1089"><vh>readAtFileNodes</vh></v>
<v t="T528" a="C"><vh>fileCommands.readOutlineOnly</vh>
<v t="T529" a="C"><vh>&lt;&lt; Set the default directory &gt;&gt;</vh></v>
</v>
<v t="T530" a="C"><vh>fileCommands.open</vh>
<v t="T529" a="C"><vh>&lt;&lt; Set the default directory &gt;&gt;</vh></v>
</v>
<v t="T1090"><vh>xmlUnescape</vh></v>
</v>
<v><vh>Writing</vh>
<v t="T1091"><vh>assignFileIndices</vh></v>
<v t="T1092"><vh>compactFileIndices</vh></v>
<v t="T1093"><vh>shouldCompactOnSave</vh></v>
<v><vh>put routines</vh>
<v t="T1094"><vh>putClipboardHeader</vh>
<v t="T1095"><vh>&lt;&lt; count the number of tnodes &gt;&gt;</vh></v>
</v>
<v t="T1096"><vh>put (basic)</vh></v>
<v t="T1097"><vh>putEscapedString</vh></v>
<v t="T1098"><vh>putFindSettings</vh></v>
<v t="T1099"><vh>putGlobals</vh>
<v t="T1100"><vh>&lt;&lt; put the body/outline ratio &gt;&gt;</vh></v>
<v t="T1101"><vh>&lt;&lt; put the position of this frame &gt;&gt;</vh></v>
<v t="T1102"><vh>&lt;&lt; put the position of the log window &gt;&gt;</vh></v>
</v>
<v t="T1103"><vh>putHeader</vh>
<v t="T1104"><vh>&lt;&lt; count the number of tnodes and clone windows &gt;&gt;</vh></v>
</v>
<v t="T1105"><vh>putLeoOutline (to clipboard)</vh></v>
<v t="T1106"><vh>putPrefs</vh>
<v t="T1107"><vh>&lt;&lt; put syntax coloring prefs &gt;&gt;</vh></v>
<v t="T1108"><vh>&lt;&lt; put default directory &gt;&gt;</vh></v>
</v>
<v t="T1109"><vh>putProlog</vh></v>
<v t="T1110"><vh>putPostlog</vh></v>
<v t="T1111"><vh>putTnodes (Leo2)</vh></v>
<v t="T1112"><vh>putTnode</vh></v>
<v t="T1113"><vh>putVnodes (Leo2)</vh></v>
<v t="T1114"><vh>putVnode (Leo2)</vh>
<v t="T1115"><vh>&lt;&lt; Put tnode index if this vnode has body text &gt;&gt;</vh></v>
<v t="T1116"><vh>&lt;&lt; Put attribute bits &gt;&gt;</vh></v>
<v t="T1117"><vh>&lt;&lt; write the head text &gt;&gt;</vh></v>
</v>
</v>
<v t="T1118"><vh>save</vh></v>
<v t="T1119"><vh>saveAs</vh></v>
<v t="T1120"><vh>saveTo</vh></v>
<v t="T1121"><vh>xmlEscape</vh></v>
<v t="T1122"><vh>writeAtFileNodes</vh></v>
<v t="T1123"><vh>writeOutlineOnly</vh></v>
<v t="T534" a="C"><vh>fileCommands.write_LEO_file</vh></v>
</v>
</v>
<v t="T1124"><vh>@file leoFind.py</vh>
<v t="T343" a="C"><vh>&lt;&lt; Theory of operation &gt;&gt;</vh></v>
<v t="T344" a="C"><vh>find.__init__</vh>
<v t="T345"><vh>&lt;&lt; Initialize the leoFind ivars &gt;&gt;</vh></v>
<v t="T346"><vh>&lt;&lt; Create the Find and Change panes &gt;&gt;</vh></v>
<v t="T347"><vh>&lt;&lt; Create two columns of checkboxes &gt;&gt;</vh></v>
<v t="T348"><vh>&lt;&lt; Create two rows of buttons &gt;&gt;</vh></v>
</v>
<v t="T349" a="C"><vh>find.init</vh>
<v t="T350"><vh>&lt;&lt; set widgets &gt;&gt;</vh></v>
</v>
<v t="T1125"><vh>find.set_ivars</vh></v>
<v t="T351" a="C"><vh>resetWrap</vh></v>
<v t="T1126"><vh>OnCloseFindEvent</vh></v>
<v t="T352" a="C"><vh>Top Level Commands</vh>
<v t="T353"><vh>changeButton</vh></v>
<v t="T354"><vh>changeAllButton</vh></v>
<v t="T355"><vh>changeThenFindButton</vh></v>
<v t="T356"><vh>findButton</vh></v>
<v t="T357"><vh>findAllButton</vh></v>
<v t="T358"><vh>changeCommand</vh></v>
<v t="T359"><vh>changeThenFindCommandd</vh></v>
<v t="T360"><vh>findNextCommand</vh></v>
<v t="T361"><vh>fndPreviousCommand</vh></v>
<v t="T362"><vh>setup_button</vh></v>
<v t="T363"><vh>setup_command</vh></v>
</v>
<v t="T364" a="C"><vh>Utilities</vh>
<v t="T365"><vh>batchChange</vh></v>
<v t="T366"><vh>change</vh></v>
<v t="T367"><vh>changeAll</vh></v>
<v t="T368"><vh>changeSelection</vh></v>
<v t="T369"><vh>changeThenFind</vh></v>
<v t="T370"><vh>findAll</vh></v>
<v t="T371"><vh>findNext</vh></v>
<v t="T372"><vh>findNextMatch</vh></v>
<v t="T373"><vh>selectNextVnode</vh></v>
<v t="T374"><vh>search</vh>
<v t="T375"><vh>&lt;&lt; return if we are passed the wrap point &gt;&gt;</vh></v>
<v t="T376"><vh>&lt;&lt; test for whole word match &gt;&gt;</vh></v>
</v>
<v t="T377"><vh>Initializing &amp; finalizing &amp; selecting</vh>
<v t="T378"><vh>checkArgs</vh></v>
<v t="T379"><vh>initBatchCommands</vh></v>
<v t="T380"><vh>initBatchText &amp; initNextText</vh></v>
<v t="T381"><vh>initInHeadline</vh></v>
<v t="T382"><vh>initInteractiveCommands</vh></v>
<v t="T383"><vh>printLine</vh></v>
<v t="T384"><vh>restore</vh></v>
<v t="T385"><vh>save</vh></v>
<v t="T386" a="C"><vh>showSuccess</vh></v>
</v>
</v>
</v>
<v t="T1127"><vh>@file leoFrame.py</vh>
<v t="T301" a="C"><vh>frame.__init__</vh>
<v t="T302"><vh>&lt;&lt; set the LeoFrame ivars &gt;&gt;</vh></v>
<v t="T303"><vh>&lt;&lt; create the Leo frame &gt;&gt;</vh></v>
<v t="T304"><vh>&lt;&lt; create the first tree node &gt;&gt;</vh></v>
</v>
<v t="T549" a="C"><vh>frame.__del__</vh></v>
<v t="T1128"><vh>frame.__repr__</vh></v>
<v t="T400" a="C"><vh>frame.destroy</vh></v>
<v t="T554" a="C"><vh>createMenuBar</vh>
<v t="T555"><vh>&lt;&lt; create the file menu &gt;&gt;</vh>
<v t="T556"><vh>&lt;&lt; create the top-level file entries &gt;&gt;</vh></v>
<v t="T557"><vh>&lt;&lt; create the read/write submenu &gt;&gt;</vh></v>
<v t="T558"><vh>&lt;&lt; create the tangle submenu &gt;&gt;</vh></v>
<v t="T559"><vh>&lt;&lt; create the untangle submenu &gt;&gt;</vh></v>
<v t="T560"><vh>&lt;&lt; create the import submenu &gt;&gt;</vh></v>
</v>
<v t="T561"><vh>&lt;&lt; create the edit menu &gt;&gt;</vh>
<v t="T562"><vh>&lt;&lt; create the edit body submenu &gt;&gt;</vh></v>
<v t="T563"><vh>&lt;&lt; create the find submenu &gt;&gt;</vh></v>
</v>
<v t="T564"><vh>&lt;&lt; create the outline menu &gt;&gt;</vh>
<v t="T565"><vh>&lt;&lt; create expand/contract submenu &gt;&gt;</vh></v>
<v t="T566"><vh>&lt;&lt; create move/select submenu &gt;&gt;</vh></v>
<v t="T567"><vh>&lt;&lt; create mark/goto submenu &gt;&gt;</vh></v>
</v>
<v t="T568"><vh>&lt;&lt; create the window menu &gt;&gt;</vh></v>
<v t="T569"><vh>&lt;&lt; create the help menu &gt;&gt;</vh></v>
</v>
<v t="T550" a="C"><vh>createAccelerators</vh>
<v t="T551"><vh>&lt;&lt; control key bindings &gt;&gt;</vh></v>
<v t="T552"><vh>&lt;&lt; canvas control bindings &gt;&gt;</vh></v>
<v t="T553"><vh>&lt;&lt; alt key bindings &gt;&gt;</vh></v>
</v>
<v t="T1129"><vh>getFocus</vh></v>
<v t="T1130"><vh>notYet</vh></v>
<v t="T406" a="C"><vh>frame.put, putnl</vh></v>
<v t="T1131"><vh>resizePanesToRatio</vh></v>
<v><vh>Event handlers</vh>
<v t="T401" a="C"><vh>frame.OnCloseLeoEvent</vh>
<v t="T402"><vh>&lt;&lt; Prompt for change.  Set veto if the user cancels &gt;&gt;</vh>
<v t="T403"><vh>&lt;&lt; Put up a file save dialog; set veto if the user cancels &gt;&gt;</vh></v>
</v>
</v>
<v t="T497" a="C"><vh>OnActivateLeoEvent</vh></v>
<v t="T464" a="C"><vh>OnActivateBody &amp; OnBodyDoubleClick</vh></v>
<v t="T1132"><vh>OnActivateLog</vh></v>
<v t="T1133"><vh>OnActivateTree</vh></v>
</v>
<v t="T593" a="C"><vh>Menu enablers (Frame)</vh>
<v t="T594"><vh>OnMenuClick (enables and disables all menu items)</vh></v>
<v t="T595"><vh>enable &amp; disable &amp; setLabel</vh></v>
<v t="T596"><vh>hasSelection</vh></v>
<v t="T597"><vh>updateFileMenu</vh></v>
<v t="T598"><vh>updateEditMenu</vh></v>
<v t="T599"><vh>updateOutlineMenu</vh></v>
</v>
<v t="T603" a="C"><vh>Menu Command Handlers</vh>
<v t="T604"><vh>File Menu (Unfinished: Page Setup, Print, Import...)</vh>
<v t="T605"><vh>top level</vh>
<v t="T606"><vh>OnNew</vh></v>
<v t="T535" a="C"><vh>frame.OnOpen</vh>
<v t="T536"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="T537" a="C"><vh>frame.OpenWithFileName</vh></v>
<v t="T607"><vh>OnClose</vh></v>
<v t="T608"><vh>OnSave</vh></v>
<v t="T609"><vh>OnSaveAs</vh></v>
<v t="T610"><vh>OnSaveTo</vh></v>
<v t="T314" a="C"><vh>OnRevert (rewrite)</vh></v>
<v t="T404" a="C"><vh>frame.OnQuit</vh></v>
</v>
<v t="T611"><vh>Read/Write submenu</vh>
<v t="T533" a="C"><vh>fileCommands.OnReadOutlineOnly</vh></v>
<v t="T612"><vh>OnReadAtFileNodes</vh></v>
<v t="T613"><vh>OnWriteOutlineOnly</vh></v>
<v t="T614"><vh>OnWriteAtFileNodes</vh></v>
</v>
<v t="T615"><vh>Tangle submenu</vh>
<v t="T616"><vh>OnTangleAll</vh></v>
<v t="T617"><vh>OnTangleMarked</vh></v>
<v t="T618"><vh>OnTangle</vh></v>
</v>
<v t="T619"><vh>Untangle submenu</vh>
<v t="T620"><vh>OnUntangleAll</vh></v>
<v t="T621"><vh>OnUntangleMarked</vh></v>
<v t="T622"><vh>OnUntangle</vh></v>
</v>
<v t="T623"><vh>Import&amp;Export submenu</vh>
<v t="T624"><vh>OnImportFiles  (not ready yet)</vh></v>
<v t="T625"><vh>OnImportCWEBFiles  (not ready yet)</vh></v>
<v t="T626"><vh>OnImportNowebFiles (not ready yet)</vh></v>
<v t="T627"><vh>OnImportMoreText  (not ready yet)</vh></v>
<v t="T628"><vh>OnOutlineToCWEB (not ready yet)</vh></v>
<v t="T629"><vh>OnOutlineToNoweb  (not ready yet)</vh></v>
<v t="T630"><vh>OnExportMoreText  (not ready yet)</vh></v>
<v t="T631"><vh>OnFlattenOutline  (not ready yet)</vh></v>
</v>
</v>
<v t="T632"><vh>Edit Menu (change to handle log pane too)</vh>
<v t="T633"><vh>Edit top level</vh>
<v t="T634"><vh>OnUndo</vh></v>
<v t="T635"><vh>OnRedo</vh></v>
<v t="T307" a="C"><vh>frame.OnCut, OnCutFrom Menu</vh></v>
<v t="T306" a="C"><vh>frame.OnCopy, OnCopyFromMenu</vh></v>
<v t="T305" a="C"><vh>frame.OnPaste, OnPasteNode, OnPasteFromMenu</vh></v>
<v t="T315" a="C"><vh>OnDelete</vh></v>
<v t="T300" a="C"><vh>OnSelectAll</vh></v>
<v t="T636"><vh>OnEditHeadline</vh></v>
<v t="T637"><vh>OnFontPanel (set font)</vh></v>
<v t="T638"><vh>OnSyntaxColoring (rewrite)</vh></v>
<v t="T433" a="C"><vh>OnViewAllCharacters</vh></v>
<v t="T639"><vh>OnPreferences</vh></v>
</v>
<v t="T640"><vh>Edit Body submenu</vh>
<v t="T641"><vh>OnConvertBlanks</vh></v>
<v t="T642"><vh>OnDedent</vh></v>
<v t="T643"><vh>OnExtract</vh></v>
<v t="T644"><vh>OnExtractNames</vh></v>
<v t="T645"><vh>OnExtractSection</vh></v>
<v t="T646"><vh>OnIndent</vh></v>
</v>
<v t="T647"><vh>Find submenu (frame methods)</vh>
<v t="T648"><vh>OnFindPanel</vh></v>
<v t="T649"><vh>OnFindNext</vh></v>
<v t="T650"><vh>OnFindPrevious</vh></v>
<v t="T651"><vh>OnReplace</vh></v>
<v t="T652"><vh>OnReplaceThenFind</vh></v>
</v>
</v>
<v t="T653"><vh>Outline Menu</vh>
<v t="T654"><vh>top level</vh>
<v t="T655"><vh>OnCutNode</vh></v>
<v t="T656"><vh>OnCopyNode</vh></v>
<v t="T657"><vh>OnPasteNodee</vh></v>
<v t="T658"><vh>OnDeleteNode</vh></v>
<v t="T659"><vh>OnInsertNode</vh></v>
<v t="T660"><vh>OnCloneNode</vh></v>
<v t="T661"><vh>OnSortChildren, OnSortSiblings</vh></v>
</v>
<v t="T662"><vh>Expand/Contract</vh>
<v t="T663"><vh>OnContractParent</vh></v>
<v t="T664"><vh>OnExpandAll</vh></v>
<v t="T665"><vh>OnExpandAllChildren</vh></v>
<v t="T666"><vh>OnExpandChildren</vh></v>
<v t="T667"><vh>OnContractAll</vh></v>
<v t="T668"><vh>OnContractAllChildren</vh></v>
<v t="T669"><vh>OnContractChildren</vh></v>
<v t="T670"><vh>OnExpandNextLevel</vh></v>
<v t="T671"><vh>OnExpandToLevel1</vh></v>
<v t="T672"><vh>OnExpandToLevel2</vh></v>
<v t="T673"><vh>OnExpandToLevel3</vh></v>
<v t="T674"><vh>OnExpandToLevel4</vh></v>
<v t="T675"><vh>OnExpandToLevel5</vh></v>
<v t="T676"><vh>OnExpandToLevel6</vh></v>
<v t="T677"><vh>OnExpandToLevel7</vh></v>
<v t="T678"><vh>OnExpandToLevel8</vh></v>
<v t="T679"><vh>OnExpandToLevel9</vh></v>
</v>
<v t="T680"><vh>Move/Select</vh>
<v t="T601" a="C"><vh>OnMoveDownwn</vh></v>
<v t="T681"><vh>OnMoveLeft</vh></v>
<v t="T682"><vh>OnMoveRight</vh></v>
<v t="T683"><vh>OnMoveUp</vh></v>
<v t="T684"><vh>OnPromote</vh></v>
<v t="T685"><vh>OnDemote</vh></v>
<v t="T686"><vh>OnGoPrevVisible</vh></v>
<v t="T687"><vh>OnGoNextVisible</vh></v>
<v t="T688"><vh>OnGoBack</vh></v>
<v t="T689"><vh>OnGoNext</vh></v>
</v>
<v t="T690"><vh>Mark/Goto</vh>
<v t="T691"><vh>OnMark</vh></v>
<v t="T692"><vh>OnMarkSubheads</vh></v>
<v t="T693"><vh>OnMarkChangedItems</vh></v>
<v t="T694"><vh>OnMarkChangedRoots</vh></v>
<v t="T695"><vh>OnUnmarkAll</vh></v>
<v t="T696"><vh>OnGoToNextMarked</vh></v>
<v t="T697"><vh>OnGoToNextChanged</vh></v>
</v>
</v>
<v t="T698"><vh>Window Menu (complete excet Recent Windows)</vh>
<v t="T699"><vh>OnEqualSizedPanes</vh></v>
<v t="T602" a="C"><vh>OnToggleActivePane</vh></v>
<v t="T700"><vh>OnToggleSplitDirection</vh></v>
<v t="T701"><vh>OnCascade</vh></v>
<v t="T702"><vh>OnMinimizeAll</vh></v>
<v t="T703"><vh>OnOpenPythonWindow</vh></v>
<v t="T704"><vh>OnRecentWindows (to do)</vh></v>
</v>
<v t="T705"><vh>Help Menu</vh>
<v t="T706" a="C"><vh>OnAbout (version number)</vh></v>
<v t="T707"><vh>OnLeoDocumentation</vh></v>
</v>
</v>
<v><vh>Splitter stuff</vh>
<v t="T1134"><vh>createSplitter</vh></v>
<v t="T1135"><vh>divideSplitter</vh></v>
<v t="T1136"><vh>onGrabSplitterBar, onGrabHSplitBar, onGrabVSplitVar</vh></v>
<v t="T1137"><vh>onDragSplitterBar, onDragHSplitBar, onDragVSplitBar</vh></v>
<v t="T1138"><vh>onDropSplitterBar, onDropHSplitBar, onDropVSplitBar</vh></v>
</v>
</v>
<v t="T1139"><vh>@file leoGlobals.py</vh>
<v t="T1140"><vh>&lt;&lt; define global constants &gt;&gt;</vh></v>
<v t="T1141"><vh>alert</vh></v>
<v t="T1142"><vh>app, setApp</vh></v>
<v t="T1143"><vh>appendToList</vh></v>
<v t="T1144"><vh>choose</vh></v>
<v t="T1145"><vh>listToString</vh></v>
<v t="T1146"><vh>es, enl, ecnl</vh></v>
<v t="T1147"><vh>print_stack</vh></v>
<v t="T1148"><vh>top</vh></v>
</v>
<v t="T1149"><vh>@file leoImport.py</vh>
<v t="T1150"><vh>&lt;&lt; constants and synonyms &gt;&gt;</vh></v>
<v t="T1151"><vh>error</vh></v>
<v t="T1152"><vh>import.__init__ (new)</vh>
<v t="T1153"><vh>&lt;&lt; initialize importFiles ivars &gt;&gt;</vh></v>
</v>
<v><vh>Top Level</vh>
<v t="T1154"><vh>ImportFilesCommand</vh>
<v t="T1155" a="M"><vh>&lt;&lt; Create a parent for two files having a common prefix &gt;&gt;</vh></v>
</v>
<v t="T1156"><vh>createOutline</vh>
<v t="T1157"><vh>&lt;&lt; Read file into buf &gt;&gt;</vh></v>
</v>
</v>
<v><vh>Utilities</vh>
<v t="T1158"><vh>createHeadline</vh></v>
<v t="T1159"><vh>getPythonIndent (replace?)</vh></v>
<v t="T1160"><vh>massageBody</vh>
<v t="T1161"><vh>&lt;&lt; massage python text &gt;&gt;</vh></v>
<v t="T1162"><vh>&lt;&lt; massage other text &gt;&gt;</vh></v>
</v>
<v t="T1163"><vh>massageAngleBrackets (do not use!)</vh></v>
<v t="T1164"><vh>massageComment</vh></v>
<v t="T1165"><vh>skipLeadingComments</vh></v>
<v t="T1166" a="M"><vh>undentPythonBody (rewrite)</vh></v>
</v>
<v><vh>Language Specific</vh>
<v t="T1167"><vh>scanJavaText</vh>
<v t="T1168" a="C"><vh>&lt;&lt; Initialize the ImportFiles private globals &gt;&gt;</vh></v>
<v t="T1169"><vh>&lt;&lt; handle open curly bracket in Java &gt;&gt;</vh>
<v t="T1170"><vh>&lt;&lt; create a Java declaration node &gt;&gt;</vh></v>
<v t="T1171"><vh>&lt;&lt; append Java method reference to parent node &gt;&gt;</vh></v>
<v t="T1172"><vh>&lt;&lt; recursively scan the text &gt;&gt;</vh></v>
</v>
<v t="T1173"><vh>&lt;&lt; skip and remember the Java id &gt;&gt;</vh></v>
<v t="T1174" a="C"><vh>Shared by C and Java</vh>
<v t="T1175"><vh>&lt;&lt; handle possible C comments &gt;&gt;</vh></v>
<v t="T1176"><vh>&lt;&lt; handle equal sign in C or Java &gt;&gt;</vh></v>
<v t="T1177"><vh>&lt;&lt; handle open paren in C or Java &gt;&gt;</vh></v>
<v t="T1178"><vh>&lt;&lt; handle semicolon in C or Java &gt;&gt;</vh></v>
</v>
<v t="T1179" a="C"><vh>&lt;&lt; Append any unused text to the parent's body text &gt;&gt;</vh></v>
</v>
<v t="T1180"><vh>scanCText</vh>
<v t="T1168" a="C"><vh>&lt;&lt; Initialize the ImportFiles private globals &gt;&gt;</vh></v>
<v t="T1181"><vh>&lt;&lt; handle # sign &gt;&gt;</vh>
<v t="T1182"><vh>&lt;&lt; create a child node for all #include statements &gt;&gt;</vh></v>
</v>
<v t="T1183"><vh>&lt;&lt; handle open curly bracket in C &gt;&gt;</vh>
<v t="T1184"><vh>&lt;&lt; create a declaration node &gt;&gt;</vh></v>
<v t="T1185"><vh>&lt;&lt; append C function/method reference to parent node &gt;&gt;</vh></v>
</v>
<v t="T1186"><vh>&lt;&lt; skip c identifier, typedef, struct, union, namespace &gt;&gt;</vh>
<v t="T1187" a="M"><vh>&lt;&lt; test for operator keyword &gt;&gt;</vh></v>
<v t="T1188" a="M"><vh>&lt;&lt; Create children for the namespace &gt;&gt;</vh></v>
</v>
<v t="T1174" a="C"><vh>Shared by C and Java</vh>
<v t="T1175"><vh>&lt;&lt; handle possible C comments &gt;&gt;</vh></v>
<v t="T1176"><vh>&lt;&lt; handle equal sign in C or Java &gt;&gt;</vh></v>
<v t="T1177"><vh>&lt;&lt; handle open paren in C or Java &gt;&gt;</vh></v>
<v t="T1178"><vh>&lt;&lt; handle semicolon in C or Java &gt;&gt;</vh></v>
</v>
<v t="T1179" a="C"><vh>&lt;&lt; Append any unused text to the parent's body text &gt;&gt;</vh></v>
</v>
<v t="T1189"><vh>scanPascalText</vh>
<v t="T1168" a="C"><vh>&lt;&lt; Initialize the ImportFiles private globals &gt;&gt;</vh></v>
<v t="T1190"><vh>&lt;&lt; handle possible Pascal function &gt;&gt;</vh>
<v t="T1191"><vh>&lt;&lt; create a child node for leading declarations &gt;&gt;</vh></v>
<v t="T1192"><vh>&lt;&lt; create a child node for the function &gt;&gt;</vh></v>
<v t="T1193"><vh>&lt;&lt; remember the function name, or continue &gt;&gt;</vh></v>
<v t="T1194"><vh>&lt;&lt; skip the function definition, or continue &gt;&gt;</vh>
<v t="T1195"><vh>&lt;&lt; skip past the semicolon &gt;&gt;</vh>
<v t="T1196"><vh>&lt;&lt; handle possible Pascal single-line comment &gt;&gt;</vh></v>
<v t="T1197"><vh>&lt;&lt; handle possible Pascal block comment &gt;&gt;</vh></v>
</v>
</v>
<v t="T1198"><vh>&lt;&lt; append noweb method reference to the parent node &gt;&gt;</vh></v>
</v>
<v t="T1179" a="C"><vh>&lt;&lt; Append any unused text to the parent's body text &gt;&gt;</vh></v>
</v>
<v><vh>Python scanners</vh>
<v t="T1199"><vh>scanPythonClass</vh>
<v t="T1200"><vh>&lt;&lt; set classname and headline, or return i &gt;&gt;</vh></v>
<v t="T1201"><vh>&lt;&lt; create class_vnode  &gt;&gt;</vh></v>
<v t="T1202"><vh>&lt;&lt; Append a reference to class_vnode's methods &gt;&gt;</vh></v>
<v t="T1203"><vh>&lt;&lt; create nodes for all defs of the class &gt;&gt;</vh></v>
</v>
<v t="T1204"><vh>scanPythonDef</vh>
<v t="T1205"><vh>&lt;&lt; set headline or return i &gt;&gt;</vh></v>
<v t="T1206"><vh>&lt;&lt; skip the Python def &gt;&gt;</vh></v>
<v t="T1207"><vh>&lt;&lt; Create def node &gt;&gt;</vh></v>
</v>
<v t="T1208"><vh>scanPythonDecls</vh>
<v t="T1209"><vh>&lt;&lt; break on def or class &gt;&gt;</vh></v>
<v t="T1210"><vh>&lt;&lt; Create a child node for declarations &gt;&gt;</vh></v>
</v>
<v t="T1211"><vh>scanPythonText</vh>
<v t="T1212"><vh>&lt;&lt; handle possible Python function or class &gt;&gt;</vh></v>
<v t="T1213"><vh>&lt;&lt; Append a reference to the methods of this file &gt;&gt;</vh></v>
<v t="T1214"><vh>&lt;&lt; Append any unused python text to the parent's body text &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="T1215"><vh>@file leoNodes.py</vh>
<v t="T1216"><vh>&lt;&lt; About the vnode and tnode classes &gt;&gt;</vh></v>
<v t="T1217"><vh>&lt;&lt; About clones &gt;&gt;</vh></v>
<v t="T1218"><vh>&lt;&lt; tnode members &gt;&gt;</vh>
<v t="T1219"><vh>&lt;&lt; tnode constants &gt;&gt;</vh></v>
<v t="T1220"><vh>t.__init__</vh></v>
<v t="T1221"><vh>t.__del__</vh></v>
<v t="T1222"><vh>t.destroy</vh></v>
<v><vh>Getters</vh>
<v t="T1223"><vh>hasBody</vh></v>
<v t="T1224"><vh>loadBodyPaneFromTnode</vh></v>
<v><vh>Status bits</vh>
<v t="T1225"><vh>isDirty</vh></v>
<v t="T1226"><vh>isRichTextBit</vh></v>
<v t="T1227"><vh>isVisited</vh></v>
</v>
</v>
<v><vh>Setters</vh>
<v><vh>Setting body text</vh>
<v t="T1228"><vh>saveBodyPaneToTnode</vh></v>
<v t="T1229"><vh>setTnodeText</vh></v>
<v t="T1230"><vh>setSelection</vh></v>
</v>
<v><vh>Status bits</vh>
<v t="T1231"><vh>clearDirty</vh></v>
<v t="T1232"><vh>clearRichTextBit</vh></v>
<v t="T1233"><vh>clearVisited</vh></v>
<v t="T1234"><vh>setDirty</vh></v>
<v t="T1235"><vh>setRichTextBit</vh></v>
<v t="T1236"><vh>setVisited</vh></v>
</v>
<v t="T1237"><vh>setCloneIndex</vh></v>
<v t="T1238"><vh>setFileIndex</vh></v>
<v t="T1239"><vh>setJoinHead</vh></v>
</v>
</v>
<v t="T1240"><vh>&lt;&lt; vnode members &gt;&gt;</vh>
<v t="T1241"><vh>&lt;&lt; vnode constants &gt;&gt;</vh></v>
<v t="T500" a="C"><vh>v.__init__</vh>
<v t="T501"><vh>&lt;&lt; initialize vnode data members &gt;&gt;</vh></v>
</v>
<v t="T1242"><vh>v.__del__</vh></v>
<v t="T1243"><vh>vnode.__repr__</vh></v>
<v t="T1244"><vh>vnode.__cmp__ (not used)</vh></v>
<v t="T398" a="C"><vh>v.destroy</vh></v>
<v t="T479" a="C"><vh>v.Callbacks</vh>
<v t="T480"><vh>OnBoxClick</vh></v>
<v t="T481"><vh>OnHeadlineClick</vh></v>
<v t="T482"><vh>OnHeadlineKey</vh></v>
<v t="T483"><vh>OnHyperLinkControlClick</vh></v>
<v t="T484"><vh>OnHyperLinkEnter</vh></v>
<v t="T485"><vh>OnHyperLinkLeave</vh></v>
<v t="T486"><vh>OnIconClick</vh></v>
</v>
<v><vh>Comparisons</vh>
<v t="T1245"><vh>atFileNodeName</vh></v>
<v t="T1246"><vh>isAtFileNode</vh></v>
<v t="T1247"><vh>isAtIgnoreNode</vh></v>
<v t="T1248"><vh>isAtOthersNode</vh></v>
<v t="T1249"><vh>matchHeadline</vh></v>
</v>
<v><vh>File Conversion (vnode)</vh>
<v t="T1250"><vh>convertTreeToString</vh></v>
<v t="T1251"><vh>moreHead</vh></v>
<v t="T1252"><vh>moreBody</vh></v>
</v>
<v><vh>Getters</vh>
<v t="T1253"><vh>bodyString</vh></v>
<v><vh>Children</vh>
<v t="T1254"><vh>childIndex</vh></v>
<v t="T1255"><vh>firstChild</vh></v>
<v t="T1256"><vh>hasChildren</vh></v>
<v t="T1257"><vh>lastChild</vh></v>
<v t="T1258"><vh>nthChild</vh></v>
<v t="T1259"><vh>numberOfChildren (n)</vh></v>
</v>
<v t="T1260"><vh>currentVnode (vnode)</vh></v>
<v t="T1261"><vh>findRoot</vh></v>
<v t="T1262"><vh>getJoinList</vh></v>
<v t="T1263"><vh>headString</vh></v>
<v t="T1264"><vh>isAncestorOf</vh></v>
<v t="T1265"><vh>isRoot</vh></v>
<v><vh>Status Bits</vh>
<v t="T1266"><vh>isCloned</vh></v>
<v t="T1267"><vh>isDirty</vh></v>
<v t="T1268"><vh>isExpanded</vh></v>
<v t="T1269"><vh>isMarked</vh></v>
<v t="T1270"><vh>isOrphan</vh></v>
<v t="T1271"><vh>isSelected</vh></v>
<v t="T1272"><vh>isTopBitSet</vh></v>
<v t="T1273"><vh>isVisible</vh></v>
<v t="T1274"><vh>isVisited</vh></v>
<v t="T1275"><vh>status</vh></v>
</v>
<v><vh>Structure Links</vh>
<v t="T1276"><vh>back</vh></v>
<v t="T1277"><vh>lastNode</vh></v>
<v t="T1278"><vh>level</vh></v>
<v t="T1279"><vh>next</vh></v>
<v t="T1280"><vh>nodeAfterTree</vh></v>
<v t="T1281"><vh>parent</vh></v>
<v t="T1282"><vh>threadBack</vh></v>
<v t="T1283"><vh>threadNext</vh></v>
<v t="T1284"><vh>visBack</vh></v>
<v t="T1285"><vh>visNext</vh></v>
</v>
</v>
<v><vh>Setters</vh>
<v><vh>Head and body text</vh>
<v t="T1286"><vh>appendStringToBody</vh></v>
<v t="T1287"><vh>setBodyStringOrPane &amp; setBodyTextOrPane</vh></v>
<v t="T1288"><vh>setHeadString &amp; initHeadString</vh></v>
<v t="T1289"><vh>setHeadStringOrHeadline</vh></v>
</v>
<v t="T1290"><vh>computeIcon &amp; setIcon</vh></v>
<v><vh>Status bits</vh>
<v t="T1291"><vh>clearAllVisited</vh></v>
<v t="T1292"><vh>clearAllVisitedInTree</vh></v>
<v t="T1293"><vh>clearClonedBit</vh></v>
<v t="T1294"><vh>clearDirty &amp; clearDirtyJoined</vh></v>
<v t="T1295"><vh>clearMarked</vh></v>
<v t="T1296"><vh>clearOrphan</vh></v>
<v t="T1297"><vh>clearVisited</vh></v>
<v t="T1298"><vh>clearVisitedInTree</vh></v>
<v t="T1299"><vh>contract &amp; expand &amp; initExpandedBit</vh></v>
<v t="T1300"><vh>initStatus</vh></v>
<v t="T508" a="C"><vh>setAncestorAtFileNodeDirty</vh></v>
<v t="T1301"><vh>setClonedBit &amp; initClonedBit</vh></v>
<v t="T507" a="C"><vh>setDirty &amp; initDirtyBit</vh></v>
<v t="T1302"><vh>setMarked &amp; initMarkedBit</vh></v>
<v t="T1303"><vh>setOrphan</vh></v>
<v t="T1304"><vh>setSelected (vnode, new)</vh></v>
<v t="T1305"><vh>setVisited</vh></v>
</v>
<v t="T1306"><vh>setJoinList</vh></v>
<v t="T1307"><vh>setSelection</vh></v>
<v t="T1308"><vh>setT</vh></v>
<v t="T436" a="C"><vh>v.sortChildren</vh></v>
<v t="T1309"><vh>trimTrailingLines</vh></v>
</v>
<v><vh>Moving, Inserting, Deleting, Cloning</vh>
<v><vh>Entry Points (vnode)</vh>
<v t="T1310"><vh>vnode::clone</vh></v>
<v t="T1311"><vh>doDelete</vh></v>
<v t="T1312"><vh>insertAfter</vh></v>
<v t="T1313"><vh>insertAsLastChild</vh></v>
<v t="T1314"><vh>insertAsNthChild</vh></v>
<v t="T1315"><vh>moveAfter</vh></v>
<v t="T1316"><vh>moveToRoot</vh></v>
<v t="T1317"><vh>moveToNthChildOf</vh></v>
<v t="T1318"><vh>restoreOutlineFromDVnodes (test)</vh></v>
</v>
<v><vh>Public helper functions</vh>
<v t="T1319"><vh>copyTree</vh></v>
<v t="T1320"><vh>joinTreeTo</vh></v>
<v t="T1321"><vh>shouldBeClone</vh></v>
<v t="T1322"><vh>validateOutlineWithParent</vh>
<v t="T1323"><vh>&lt;&lt; validate parent ivar &gt;&gt;</vh></v>
<v t="T1324"><vh>&lt;&lt; validate childIndex ivar &gt;&gt;</vh></v>
<v t="T1325"><vh>&lt;&lt; validate x ivar &gt;&gt;</vh></v>
</v>
</v>
<v><vh>Private helper functions</vh>
<v t="T1326"><vh>cloneTree</vh></v>
<v t="T1327"><vh>copyCloneBitsTo</vh></v>
<v t="T1328"><vh>copyNode</vh></v>
<v t="T1329"><vh>createDependents (bug fix: 4/22/01)</vh></v>
<v t="T1330"><vh>destroyDependents</vh></v>
<v t="T1331"><vh>destroyTree (does nothing!)</vh></v>
<v t="T1332"><vh>invalidOutline</vh></v>
<v t="T1333"><vh>isJoinedTo</vh></v>
<v t="T1334"><vh>isOnJoinListOf</vh></v>
<v t="T1335"><vh>joinNodeTo</vh></v>
<v t="T1336"><vh>linkAfter</vh></v>
<v t="T1337"><vh>linkAsNthChild</vh></v>
<v t="T1338"><vh>linkAsRoot</vh></v>
<v t="T1339"><vh>saveOutlineWithLevel</vh></v>
<v t="T1340"><vh>setThreadLinks (not used, untested)</vh></v>
<v t="T1341"><vh>unlink</vh></v>
<v t="T1342"><vh>unjoinNode</vh>
<v t="T1343"><vh>&lt;&lt; Set prev to the node that points to self &gt;&gt;</vh></v>
</v>
<v t="T1344"><vh>unjoinTree</vh></v>
</v>
</v>
</v>
</v>
<v t="T1345"><vh>@file leoPrefs.py</vh>
<v t="T488" a="C"><vh>prefs.__init__</vh>
<v t="T489"><vh>&lt;&lt; Set ivars &gt;&gt;</vh></v>
<v t="T490"><vh>&lt;&lt; Create the Global Options frame &gt;&gt;</vh></v>
<v t="T491"><vh>&lt;&lt; Create the Tangle Options frame &gt;&gt;</vh></v>
<v t="T492"><vh>&lt;&lt; Create the Target Language frame &gt;&gt;</vh></v>
</v>
<v t="T495" a="C"><vh>prefs.init</vh>
<v t="T496"><vh>&lt;&lt; set widgets &gt;&gt;</vh></v>
</v>
<v t="T493" a="C"><vh>prefs.set_ivars &amp; idle_set_ivars &amp; print_ivars</vh>
<v t="T494"><vh>&lt;&lt; update ivars &gt;&gt;</vh></v>
</v>
<v t="T499" a="C"><vh>set_lang</vh></v>
<v t="T1346"><vh>OnClosePrefsFrame</vh></v>
</v>
<v t="T1347"><vh>@file leoTangle.py</vh>
<v t="T1348"><vh>&lt;&lt; constants &amp; synonyms &gt;&gt;</vh></v>
<v t="T1349"><vh>&lt;&lt; define node classes &gt;&gt;</vh>
<v t="T1350"><vh>&lt;&lt; tst_node methods &gt;&gt;</vh>
<v t="T1351"><vh>tst_node.__init__</vh></v>
<v t="T1352"><vh>tst_node.__repr__</vh></v>
</v>
<v t="T1353"><vh>&lt;&lt; part_node methods &gt;&gt;</vh>
<v t="T1354"><vh>part_node.__init__</vh></v>
<v t="T1355"><vh>part_node.__repr__</vh></v>
</v>
<v t="T1356"><vh>&lt;&lt; ust_node methods &gt;&gt;</vh>
<v t="T1357"><vh>ust_node.__init__</vh></v>
<v t="T1358"><vh>ust_node.__repr__</vh></v>
</v>
</v>
<v t="T1359"><vh>&lt;&lt; tangleCommands methods &gt;&gt;</vh>
<v t="T1360"><vh>tangle.__init__</vh></v>
<v t="T542" a="C"><vh>tangle.init_ivars &amp; init_directive_ivars</vh>
<v t="T543"><vh>&lt;&lt; init tangle ivars &gt;&gt;</vh></v>
<v t="T544"><vh>&lt;&lt; init directive ivars &gt;&gt;</vh></v>
</v>
<v t="T1361"><vh>top level</vh>
<v t="T396" a="C"><vh>cleanup</vh></v>
<v t="T1362"><vh>initTangleCommand</vh></v>
<v t="T1363"><vh>initUntangleCommand</vh></v>
<v t="T1364"><vh>tangle</vh></v>
<v t="T437" a="C"><vh>tangleAll</vh></v>
<v t="T438" a="C"><vh>tangleMarked</vh></v>
<v t="T1365"><vh>tanglePass1</vh></v>
<v t="T1366"><vh>tanglePass2</vh></v>
<v t="T439" a="C"><vh>tangleTree (calls cleanup)</vh></v>
<v t="T1367"><vh>untangle</vh></v>
<v t="T1368"><vh>untangleAll</vh></v>
<v t="T1369"><vh>untangleMarked</vh></v>
<v t="T1370"><vh>untangleTree (calls cleanup)</vh>
<v t="T1371"><vh>&lt;&lt; set end to the next root in the unit &gt;&gt;</vh></v>
</v>
<v t="T1372"><vh>untangleRoot (uses token_type)</vh>
<v t="T1373"><vh>&lt;&lt; return if @silent or unknown language &gt;&gt;</vh></v>
<v t="T1374"><vh>&lt;&lt; Set path &amp; root_name to the file specified in the @root directive &gt;&gt;</vh></v>
<v t="T1375"><vh>&lt;&lt; Read the file into file_buf  &gt;&gt;</vh></v>
<v t="T1376"><vh>&lt;&lt; Pass 2:  Untangle the outline using the UST and a newly-created TST &gt;&gt;</vh></v>
</v>
</v>
<v><vh>tangle</vh>
<v><vh>Pass 1</vh>
<v t="T1377"><vh>handle_newline</vh></v>
<v t="T1378"><vh>skip_body</vh>
<v t="T1379"><vh>The interface between tangle and untangle</vh>
<v t="T1380"><vh>&lt;&lt; Define a section containing only an @doc part &gt;&gt;</vh></v>
<v t="T1381"><vh>&lt;&lt; Scan and define a section definition &gt;&gt;</vh></v>
<v t="T1382"><vh>&lt;&lt; Scan and define an @code defininition &gt;&gt;</vh></v>
<v t="T1383"><vh>&lt;&lt; Scan and define a root section &gt;&gt;</vh></v>
</v>
</v>
<v t="T1384"><vh>skip_code</vh>
<v t="T1385"><vh>&lt;&lt; skip a noweb code section &gt;&gt;</vh>
<v t="T1386"><vh>&lt;&lt; handle possible noweb section reference &gt;&gt;</vh></v>
</v>
<v t="T1387"><vh>&lt;&lt; skip a CWEB code section &gt;&gt;</vh>
<v t="T1388"><vh>&lt;&lt; handle CWEB control code &gt;&gt;</vh></v>
</v>
</v>
<v t="T1389"><vh>skip_doc</vh></v>
<v t="T1390"><vh>skip_headline</vh></v>
</v>
<v><vh>Pass 2</vh>
<v t="T1391"><vh>oblank, oblanks, os, otab, otabs</vh></v>
<v t="T545" a="C"><vh>tangle.put_all_roots</vh>
<v t="T546"><vh>&lt;&lt;Write a banner at the start of the output file&gt;&gt;</vh></v>
<v t="T547"><vh>&lt;&lt; Erase the temporary file &gt;&gt;</vh></v>
</v>
<v t="T1392"><vh>put_code</vh>
<v t="T1393"><vh>&lt;&lt;put possible section reference &gt;&gt;</vh></v>
<v t="T1394"><vh>&lt;&lt; handle 2-character CWEB control codes &gt;&gt;</vh></v>
<v t="T1395"><vh>&lt;&lt; handle noweb @ &lt; &lt; convention &gt;&gt;</vh></v>
</v>
<v t="T1396"><vh>put_doc</vh>
<v t="T1397"><vh>&lt;&lt;put the doc part&gt;&gt;</vh>
<v t="T1398"><vh>&lt;&lt;output or skip whitespace or newlines&gt;&gt;</vh></v>
<v t="T1399"><vh>&lt;&lt;compute the width of the next word&gt;&gt;</vh></v>
<v t="T1400"><vh>&lt;&lt;output next word&gt;&gt;</vh></v>
</v>
</v>
<v t="T1401"><vh>put_leading_ws</vh></v>
<v t="T1402"><vh>put_newline</vh>
<v t="T1403"><vh>&lt;&lt; Output leading white space except for blank lines &gt;&gt;</vh></v>
</v>
<v t="T1404"><vh>put_part_node</vh></v>
<v t="T1405"><vh>put_section</vh>
<v t="T1406"><vh>&lt;&lt; Calculate the new value of tangle_indent &gt;&gt;</vh></v>
<v t="T1407"><vh>&lt;&lt; Set 'newline_flag' if the line ends with the reference &gt;&gt;</vh></v>
<v t="T1408"><vh>&lt;&lt;put all parts of the section definition&gt;&gt;</vh>
<v t="T1409"><vh>&lt;&lt; Put the section name in a comment &gt;&gt;</vh>
<v t="T1410"><vh>&lt;&lt; put ( n of m ) &gt;&gt;</vh></v>
</v>
<v t="T1411"><vh>&lt;&lt; Put the ending comment &gt;&gt;</vh></v>
</v>
<v t="T1412"><vh>&lt;&lt;Put a comment about the undefined section&gt;&gt;</vh></v>
</v>
<v t="T1413"><vh>section_check</vh></v>
</v>
</v>
<v><vh>tst</vh>
<v t="T1414"><vh>st_check</vh></v>
<v t="T1415"><vh>st_dump</vh></v>
<v t="T1416"><vh>st_dump_node</vh></v>
<v t="T1417"><vh>st_enter</vh>
<v t="T1418"><vh>&lt;&lt;check for duplicate code definitions &gt;&gt;</vh></v>
</v>
<v t="T1419"><vh>st_enter_section_name</vh></v>
<v t="T1420"><vh>st_enter_root_name</vh></v>
<v t="T1421"><vh>st_lookup</vh></v>
</v>
<v><vh>untangle</vh>
<v t="T1422"><vh>compare_comments</vh>
<v t="T1423" a="C"><vh>&lt;&lt; Check both parts for @ comment conventions &gt;&gt;</vh></v>
</v>
<v><vh>definition stack</vh>
<v t="T1424"><vh>pop_def_node</vh></v>
<v t="T1425"><vh>push_new_def_node</vh></v>
</v>
<v t="T1426"><vh>forgiving_compare</vh>
<v t="T1427"><vh>&lt;&lt; Define forgiving_compare vars &gt;&gt;</vh></v>
<v t="T1423" a="C"><vh>&lt;&lt; Check both parts for @ comment conventions &gt;&gt;</vh></v>
<v t="T1428"><vh>&lt;&lt; Compare non-critical newlines &gt;&gt;</vh></v>
<v t="T1429"><vh>&lt;&lt; Compare non-critical whitespace &gt;&gt;</vh></v>
<v t="T1430"><vh>&lt;&lt; Compare possible preprocessor directives &gt;&gt;</vh>
<v t="T1431" a="C"><vh>&lt;&lt; Compare single characters &gt;&gt;</vh></v>
<v t="T1432"><vh>&lt;&lt; Compare preprocessor directives &gt;&gt;</vh></v>
</v>
<v t="T1433"><vh>&lt;&lt; Compare possible strings &gt;&gt;</vh>
<v t="T1431" a="C"><vh>&lt;&lt; Compare single characters &gt;&gt;</vh></v>
<v t="T1434"><vh>&lt;&lt; Compare C strings &gt;&gt;</vh></v>
<v t="T1435"><vh>&lt;&lt; Compare Pascal strings &gt;&gt;</vh></v>
</v>
<v t="T1436"><vh>&lt;&lt; Compare possible section references &gt;&gt;</vh></v>
<v t="T1437"><vh>&lt;&lt; Compare comments or single characters &gt;&gt;</vh>
<v t="T1431" a="C"><vh>&lt;&lt; Compare single characters &gt;&gt;</vh></v>
</v>
<v t="T1438"><vh>&lt;&lt; Make sure both parts have ended &gt;&gt;</vh></v>
<v t="T1439"><vh>&lt;&lt; Give error message &gt;&gt;</vh></v>
</v>
<v t="T1440"><vh>massage_block_comment</vh></v>
<v t="T1441"><vh>scan_derived_file (pass 1)</vh>
<v t="T1442"><vh>&lt;&lt; define scan_derived_file vars &gt;&gt;</vh></v>
<v t="T1443"><vh>&lt;&lt; set the private global matching vars &gt;&gt;</vh></v>
<v t="T1444"><vh>&lt;&lt; Skip the header line output by tangle &gt;&gt;</vh></v>
<v t="T1445"><vh>&lt;&lt; handle the start of a new line &gt;&gt;</vh></v>
<v t="T1446"><vh>&lt;&lt; handle a sentinel line &gt;&gt;</vh>
<v t="T1447"><vh>&lt;&lt; terminate the previous part of this section if it exists &gt;&gt;</vh></v>
</v>
<v t="T1448"><vh>&lt;&lt; copy the entire line &gt;&gt;</vh></v>
<v t="T1449"><vh>&lt;&lt; copy a string &gt;&gt;</vh></v>
<v t="T1450"><vh>&lt;&lt; copy a multi-line comment &gt;&gt;</vh></v>
<v t="T1451"><vh>&lt;&lt; copy an alternate multi-line comment &gt;&gt;</vh></v>
<v t="T1452"><vh>&lt;&lt; end all open sections &gt;&gt;</vh></v>
</v>
<v><vh>scanning &amp; copying</vh>
<v t="T1453"><vh>copy</vh></v>
<v t="T1454"><vh>is_end_of_directive</vh></v>
<v t="T1455"><vh>is_end_of_string</vh></v>
<v t="T1456"><vh>is_escaped</vh></v>
<v t="T1457"><vh>is_sentinel_line &amp; is_sentinel_line_with_data</vh>
<v t="T1458"><vh>&lt;&lt; Initialize the return values  &gt;&gt;</vh></v>
<v t="T1459"><vh>&lt;&lt; Make sure the line starts with start_sentinel &gt;&gt;</vh></v>
<v t="T1460"><vh>&lt;&lt; Set end_flag if we have -- end -- &gt;&gt;</vh></v>
<v t="T1461"><vh>&lt;&lt; Make sure we have a section reference &gt;&gt;</vh></v>
<v t="T1462"><vh>&lt;&lt; Set part and of if they exist &gt;&gt;</vh></v>
<v t="T1463"><vh>&lt;&lt; Set nl_flag to false if !newline exists &gt;&gt;</vh></v>
<v t="T1464"><vh>&lt;&lt; Make sure the line ends with end_sentinel &gt;&gt;</vh></v>
</v>
<v t="T1465"><vh>scan_short_val</vh></v>
</v>
<v t="T1466"><vh>update_def (pass 2)</vh>
<v t="T1467"><vh>&lt;&lt; Remove leading blank lines and block comments from ucode &gt;&gt;</vh></v>
</v>
<v t="T1468"><vh>update_current_vnode</vh></v>
</v>
<v><vh>ust</vh>
<v t="T1469"><vh>ust_dump</vh></v>
<v t="T1470"><vh>ust_enter</vh>
<v t="T1471"><vh>&lt;&lt; remove blank lines from the start and end of the text &gt;&gt;</vh></v>
</v>
<v t="T1472"><vh>ust_lookup</vh></v>
<v t="T1473"><vh>ust_warn_about_orphans</vh></v>
</v>
<v t="T1474"><vh>utility methods</vh>
<v t="T1475"><vh>error &amp; warning</vh></v>
<v t="T1476"><vh>is_section_name</vh></v>
<v t="T426" a="C"><vh>tangle.scanAllDirectives</vh>
<v t="T427"><vh>&lt;&lt; Test for @comment or @language &gt;&gt;</vh></v>
<v t="T428"><vh>&lt;&lt; Test for @verbose, @terse or @silent &gt;&gt;</vh></v>
<v t="T429"><vh>&lt;&lt; Test for @path, @pagewidth and @tabwidth &gt;&gt;</vh>
<v t="T430"><vh>&lt;&lt; Remove leading and trailing delims if they exist &gt;&gt;</vh></v>
</v>
<v t="T431"><vh>&lt;&lt; Test for @header or @noheader &gt;&gt;</vh></v>
<v t="T432"><vh>&lt;&lt; Set self.tangle_directory &gt;&gt;</vh></v>
</v>
<v t="T1477"><vh>set_root_delims</vh></v>
<v t="T1478"><vh>set_root_from_headline</vh></v>
<v t="T1479"><vh>set_root_from_text</vh></v>
<v t="T1480"><vh>skip_CWEB_section_name</vh></v>
<v t="T1481"><vh>skip_noweb_section_name</vh></v>
<v t="T1482"><vh>skip_section_name</vh></v>
<v t="T1483"><vh>standardize</vh></v>
<v t="T1484"><vh>token_type</vh>
<v t="T1485"><vh>&lt;&lt; set token_type in noweb mode &gt;&gt;</vh></v>
<v t="T1486"><vh>&lt;&lt; set token_type for CWEB mode &gt;&gt;</vh></v>
<v t="T1487"><vh>&lt;&lt; set kind for directive &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="T1488"><vh>@file leoTree.py</vh>
<v t="T1489"><vh>&lt;&lt; drawing constants &gt;&gt;</vh></v>
<v t="T460" a="C"><vh>tree.__init__</vh></v>
<v t="T1490"><vh>tree.__del__</vh></v>
<v t="T397" a="C"><vh>tree.destroy</vh></v>
<v t="T452" a="C"><vh>tree.expandAllAncestors</vh></v>
<v><vh>Drawing</vh>
<v t="T1491"><vh>About drawing and updating</vh></v>
<v t="T461" a="C"><vh>beginUpdate</vh></v>
<v t="T502" a="C"><vh>drawBox</vh></v>
<v t="T503" a="C"><vh>tree.drawIcon</vh></v>
<v t="T1492"><vh>drawTree</vh>
<v t="T1493"><vh>&lt;&lt; draw vertical line &gt;&gt;</vh></v>
</v>
<v t="T1494"><vh>drawNode</vh></v>
<v t="T504" a="C"><vh>drawText</vh>
<v t="T505"><vh>&lt;&lt; configure the text depending on state &gt;&gt;</vh></v>
</v>
<v t="T462" a="C"><vh>endUpdate</vh></v>
<v t="T548" a="C"><vh>tree.getIconImage</vh></v>
<v t="T1495"><vh>headWidth</vh></v>
<v t="T1496"><vh>hideAllChildren</vh></v>
<v t="T1497"><vh>hideNode (no longer used)</vh></v>
<v t="T1498"><vh>hideTree (no longer used)</vh></v>
<v t="T450" a="C"><vh>lastVisible</vh></v>
<v t="T448" a="C"><vh>tree.recolor &amp; recolor_now</vh></v>
<v t="T341" a="C"><vh>tree.redraw , force_redraw, redraw_now</vh></v>
<v t="T453" a="C"><vh>tree.idle_scrollTo</vh></v>
<v t="T451" a="C"><vh>yoffset</vh></v>
</v>
<v><vh>Event handers</vh>
<v t="T1499"><vh>OnActivate</vh></v>
<v t="T1500"><vh>OnBoxClick</vh></v>
<v t="T445" a="C"><vh>tree.onBodyChanged &amp; OnBodyKey &amp; idle_body_key</vh>
<v t="T446"><vh>&lt;&lt; Do Auto indent &gt;&gt;</vh></v>
</v>
<v t="T1501"><vh>OnDeactivate</vh></v>
<v t="T340" a="C"><vh>tree.OnHeadlineKey</vh></v>
</v>
<v t="T455" a="C"><vh>Selecting &amp; editing (tree)</vh>
<v t="T456"><vh>dimEditLabel, undimEditLabel</vh></v>
<v t="T457" a="C"><vh>editLabel</vh></v>
<v t="T458" a="C"><vh>endEditLabel</vh></v>
<v t="T447" a="C"><vh>tree.select</vh></v>
<v t="T342" a="C"><vh>tree.set...LabelState</vh></v>
</v>
</v>
<v t="T1502"><vh>@file leoUndo.py</vh></v>
<v t="T1503"><vh>@file leoUtils.py</vh>
<v t="T1504"><vh>angleBrackets &amp; virtual_event_name</vh></v>
<v t="T1505"><vh>btest</vh></v>
<v t="T1506"><vh>Timing</vh></v>
<v t="T1507"><vh>compare_section_names (rewrite or eliminate)</vh></v>
<v t="T1508"><vh>create_temp_name</vh></v>
<v t="T1509"><vh>dump</vh></v>
<v t="T1510"><vh>ensure_extension</vh></v>
<v t="T487" a="C"><vh>findReference</vh></v>
<v t="T320" a="C"><vh>Leading whitespace...</vh>
<v t="T321"><vh>computeLeadingWhitespace</vh></v>
<v t="T322"><vh>removeLeadingWhitespace</vh></v>
<v t="T323"><vh>optimizeLeadingWhitespace</vh></v>
<v t="T324"><vh>skip_leading_ws_with_indent</vh></v>
</v>
<v t="T1511"><vh>removeTrailingWs</vh></v>
<v t="T1512"><vh>printBindings</vh></v>
<v t="T1513"><vh>scanError</vh></v>
<v t="T440" a="C"><vh>Sherlock...</vh>
<v t="T441"><vh>get_Sherlock_args</vh></v>
<v t="T442"><vh>init_trace</vh></v>
<v t="T443"><vh>trace</vh></v>
</v>
<v t="T316" a="C"><vh>Tk.Text selection</vh>
<v t="T317"><vh>getTextSelection</vh></v>
<v t="T318"><vh>getSelectedText</vh></v>
<v t="T319" a="C"><vh>setTextSelection</vh></v>
</v>
<v t="T1514"><vh>update_file_if_changed</vh></v>
<v><vh>Scanners: no error messages</vh>
<v t="T1515"><vh>escaped</vh></v>
<v t="T1516"><vh>find_line_start</vh></v>
<v t="T1517"><vh>find_on_line</vh></v>
<v t="T1518"><vh>is_c_id</vh></v>
<v t="T1519"><vh>is_c_word</vh></v>
<v t="T1520"><vh>is_nl</vh></v>
<v t="T1521"><vh>is_special</vh></v>
<v t="T1522"><vh>is_special_bits</vh>
<v t="T1523"><vh>&lt;&lt; set bits for @ directives &gt;&gt;</vh></v>
<v t="T1524"><vh>&lt;&lt; set root bits for noweb * chunks &gt;&gt;</vh></v>
</v>
<v t="T1525"><vh>is_ws &amp; is_ws_or_nl</vh></v>
<v t="T1526"><vh>match</vh></v>
<v t="T1527"><vh>match_ignoring_case</vh></v>
<v t="T1528"><vh>match_word</vh></v>
<v t="T1529"><vh>skip_blank_lines</vh></v>
<v t="T1530"><vh>skip_c_id</vh></v>
<v t="T1531"><vh>skip_line, skip_to_end_of_line</vh></v>
<v t="T1532"><vh>skip_long</vh></v>
<v t="T1533"><vh>skip_nl</vh></v>
<v t="T1534"><vh>skip_pascal_braces</vh></v>
<v t="T1535"><vh>skip_ws, skip_ws_and_nl</vh></v>
</v>
<v t="T1536"><vh>Scanners: calling scanError</vh>
<v t="T1537"><vh>skip_block_comment</vh></v>
<v t="T1538"><vh>skip_braces</vh></v>
<v t="T1539"><vh>skip_parens</vh></v>
<v t="T1540"><vh>skip_pascal_begin_end</vh></v>
<v t="T1541"><vh>skip_pascal_block_comment</vh></v>
<v t="T1542"><vh>skip_pascal_string : called by tangle</vh></v>
<v t="T1543"><vh>skip_pp_directive</vh></v>
<v t="T1544"><vh>skip_pp_if</vh></v>
<v t="T1545"><vh>skip_to_semicolon</vh></v>
<v t="T1546"><vh>skip_python_string</vh></v>
<v t="T1547"><vh>skip_string : called by tangle</vh></v>
<v t="T1548"><vh>skip_typedef</vh></v>
</v>
<v><vh>@language and @comment directives</vh>
<v t="T1549"><vh>set_delims_from_language</vh></v>
<v t="T1550"><vh>set_delims_from_string</vh></v>
<v t="T1551"><vh>set_language</vh></v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="T1">@nocolor</t>
<t tx="T2">This is a really useful command!</t>
<t tx="T3">This is quite tricky code.  To capture changed values we typically must set a commands method that calls an idle routine. We can't capture the values by binding Button clicks because values haven't changed yet, or so it seems.

Anyway, the preferences panel settings now appear to "stick" to the presently active window.

The print_prefs routine was vital to sorting out what was happening.</t>
<t tx="T4">Now the real work begins.</t>
<t tx="T5">This will serve as a start for CVS.</t>
<t tx="T6">Added commands handler for all radio buttons.  There was a timing problem: it took 2 clicks to set the current language.  Also added code to recolor the body pane immediately.</t>
<t tx="T7">It is vital that @file nodes remain dirty until they are written without errors.  Otherwise, a Save command will succeeed without warning, and a later read may cause the dreaded "clones have been cleared" message.</t>
<t tx="T8">The settings in the Preferences panel now "stick" to the current window.  This turns out to be very important for Tangling: I ran into serious problems with Tangling to the wrong directory when more than one window was open.</t>
<t tx="T9">This turns out to be more useful than Sort Children.</t>
<t tx="T10">All the "Tangle" Constants must be defined in the same place.  It turns out that leoUtils no longer use any of these constants anyway, so I moved them to leoTangle where they have always belonged.

scanError() is now the only part of leoUtils that uses Tangle data.  It accesses the commands instances using the top() function.  A kludge...

In any event, when I split them I also defined some new values, so values from leoGlobals.py overlapped with values from leoTangle.py.  It is a good thing I caught the problem now...</t>
<t tx="T11">Moved the tangle constants into the tangle class.

Changed header to self.header in an error message in scanAllDirective.

The source of the "mismatch" in Utils.h was that somehow I inserted @c into the root of Utils.h, which should produce errors, and eventually it did.</t>
<t tx="T12">I reset the default tangle directory while doing regression testing, then saved LeoPy.leo.  This destroyed files LeoPy directory, I'm not sure how, so I had to revert.  All looks well now.</t>
<t tx="T13">There was a problem with a global change command.  I'll have to do a full regression test of Tangle.  This would be a good time to use the new whitespace utility routines.</t>
<t tx="T14">This was the result of a Change All disaster.</t>
<t tx="T15">We have to update s_text as well as c.body so that another call to search on the same line will find the updated text.</t>
<t tx="T16">Newlines now set the dirty bit.

We increase auto indent after a colon.  This should happen only for Python mode...</t>
<t tx="T17">Once again, I am astounded at how easy this is.</t>
<t tx="T18">Convert Blanks now converts the entire body pane if there is no selected text.</t>
<t tx="T19">It is doubtful that leo.py will ever support a Print command directly.  Rather, users can use export commands to create text files that may then be formatted and printed as desired.  Tk does provide print support.</t>
<t tx="T20">Only blanks and tabs are shown, and they not very well.

What we need is a font that shows blanks and tabs as descent symbols for blanks, tabs and newlines.</t>
<t tx="T21">The key is that two things have to happen:

1. Menu items should be enabled only when focus is in the canvas pane.
2. Bindings for for the outline commands should be added only to the canvas pane.</t>
<t tx="T22">A useful convenience method that makes it much clearer what is going on.</t>
<t tx="T23">Sherlock attempts to read the file SherlockArgs.  If found, each line is assumed to be a separate sherlock argument.

However, the main improvement is defaulting empty arguments to "+*".  This makes tracing as easy to use as print statements.

Could trace accept multiple arguments, just like print?  No: we would lose the ability to specify tracepoints by default.  There is no need to duplicate print!</t>
<t tx="T24">Very easy to do, compared with other systems.</t>
<t tx="T25">This should solve some compatibility problems.</t>
<t tx="T26">Alt-1 refers to Alt-Button-1, not Alt-Key-1 (!)</t>
<t tx="T27">Changed frame.put routines so that they return during quitting.

Also removed trace statements from __del__ routines.</t>
<t tx="T28">We must be careful to enclose all find/change code in c.beginUpdate/c.endUpdate(false) so a redraw after the call to tree.redraw_now() in find.showSuccess won't deselect the headline text.

It would be elegant to cancel any pending redraw in tree.redraw_now, and that does not seem to work.

Because we don't always redraw the screen, we must update icons "by hand" by calling c.tree.drawIcon.

It is very tricky to compute self.in_headline correctly.

Perhaps a more sensible approach would be to have the tree.redraw routine save and restore the editing status and selection of the current headline.  However, the present code works and minimizes redraws, so there isn't much incentive...</t>
<t tx="T29">The idea was that if all drawing happens at idle time we could do the following:

	Eliminate all c.beginUpdate()
	Eliminate all c.endUpdate(false)
	Replace c.endUpdate() with c.redraw()
	Replace c.endUpdate(flag) with if flag: c.redraw()
	
However, the find command needs to _prohibit_ drawing, and there doesn't seem to be a clean way to do this, so using c.endUpdate(false) seems to be needed.

In other words, without c.endUpdate(false) we would need c.cancelDrawing(), and this doesn't seem any cleaner than the present code.</t>
<t tx="T30">I messed things up when I "optimized" the redraw code.  The Find code must redraw the screen _before_ making selections in the headline--otherwise the headline becomes inactive.</t>
<t tx="T31">Altered the Cut/Copy routines so they set Leo's internal clipboard (app().clipboard).  So to cut from LeoCB to leo.py do the following:

Copy the tree in LeoCB.
Paste the tree into empty body text of leo.py.
Select all the body text and paste.
Move to the tree view, and do a Paste Node.

Yes, this is very clumsy, but how often do we want to transfer information between LeoCB and leo.py?</t>
<t tx="T32">This is defensive programming.  Only a few event handlers override body handlers:  These include Control-I, Control-T and Control-D.

Exception: the command handlers for cut/copy/paste must _not_ return "break"!  The actual work is done by the Tk.Text widget.</t>
<t tx="T33">Now that event handlers return "break" they can do things involving focus that they could not do before.</t>
<t tx="T34">This is done in frame.createAccelerators().  For the first time leo.py handles keystrokes properly!

We could override _all_ body pane keys, and this would be dangerous until all event handlers return "break."  Indeed, doing so would create duplicate bindings, one for frame.top and one for frame.body, so without a "break" the command would be done twice!</t>
<t tx="T35">Event scripts need only return the string "break" to inhibit all further event processing!  This is what I have been missing all along, and it was staring me right in the face.  Sheesh.

This eliminates the need for several kludgy workarounds:
	The double-click event handler no longer needs to wait till idle time.
	The c.moveDown routine no longer needs to call c.select.

Another breakthrough.  Way down at the bottom of the Tk.Text documentation I discovered a list of all the key bindings defined by default in Text widgets.  This includes Control-O, which explains why body text sometimes had blanks lines inserted at the top. (Amazingly, Control-O never seems to have split lines, purely by luck.)

I can now use control-I to insert nodes again!</t>
<t tx="T36">This is similar to the double-click logic!</t>
<t tx="T37">We must compute the word to be selected before the Tk.Text widget does its default double-click handling, then actually select the text at idle-time.</t>
<t tx="T38">The code was easy to write and worked the first time.  I love Python.  I chose to ignore case in the comparison.

A more elegant solution would be to define a v.__cmp__ method, but the present code is clear enough and works.</t>
<t tx="T39">Fixed the Tangle Marked command.  It had numerous problems.

The code that executes Leo_done.bat and Leo_un.bat didn't work.  Now these options specify Python scripts to execute, and these scripts are passed a list of filenames that were tangled or untangled.</t>
<t tx="T40">Created go.bat and openLeo.py.  These simplify the process of starting leo.  Just open a console window and type go.

Added "c:\prog\LeoPy\LeoPy.leo" as default to filename argument to leo.open().</t>
<t tx="T41">The whole-word search only fails if there are two consecutive "in-word" characters at the beginning or end of the supposed match.

Added some logic to make suboutline-only searches work correctly.

In the process, discovered a bug in is_c_id.  It was testing for blank instead of underscore!</t>
<t tx="T42">tree.select now calls tree.recolor_now instead of tree.recolor.  The result is much better than before.

Did add the tree.updateScheduled ivar and logic.  This ensures that only one redraw ever happens at idle time.  It seems like the body text is drawn much faster now.  This may have been a big performance bug!

At present the performance of leo.py seems excellent.</t>
<t tx="T43">When the "Move Down" command did nothing the control-d ate the character at the cursor!  The workaround is to have c.moveOutlineDown call c.selectVnode(v) even if nothing happens.  This forces the body text to be restored.</t>
<t tx="T44">c.makeVisible and even c.beginUpdate/c.endUpdate can be eliminated!  Indeed, the tree class can work as follows:

1. All ancestors of the current node are expanded at the start of tree.redraw.
2. The current node is scrolled into view at the end of tree.redraw.

We want to do the expansion of nodes before drawing so offsets are computed properly.  We must do scrolling after idle tasks are complete so Tk.Scrollbar.get() will return proper values.

Note: we still may want to inhibit drawing even though all drawing happens at idle time.  We don't really need begin/endUpdate to do that:  just keep a flag and call c.redraw() only if the flag is true.

I'm not going to eliminate c.beginUpdate/c.endUpdate just yet.</t>
<t tx="T45">Eliminated redundant error messages.
All path problems now generate an error.  This seems safest.</t>
<t tx="T46">tree.makeVisible and tree.scrollTo are called before the tree is redrawn, so we can't get accurate measurements from the canvas class.  I created tree.yoffset() and tree.lastVisible() to get proper measurements.  The final code is deceptively simple; it took several hours to get it all right.

This is an important step forward because now the screen is drawn properly during interactive search commands.  It would have been intolerable to release Leo with only partly functional Find commands.

There are still "policy" questions about when and how to scroll.  The present code doesn't work smoothly in all cases.  It may be that the Tk.canvas.yview routine doesn nothing in certain unexpected situations.</t>
<t tx="T47">I have spent several pleasant hours preparing setup.py, manifest.in and sdist.bat.

Create a source distribution (.zip file) by running sdist.bat from c:\prog\LeoPy.

I have not been able to create a .gzip file yet.</t>
<t tx="T48">There was an assignment kind = kind in the section &lt;&lt; set kind for directive &gt;&gt;, so @chapter, @section were never recognized.  Amazingly, this blunder did not seem to affect anything else.

With this this bug fixed, all files in LeoCB.leo are tangled the same by LeoCB and leo.py, except for the first line and whitespace.  The first line is different because LeoCB puts slashes differently than leo.py.

When ignoring only trailing whitespace and blank lines, we see that LeoCB and leo.py differ in how they output (!newline).  LeoCB outputs a single space before (!newline) in put_section(), so this is what leo.py must do as well.

With this bugs fixed, the only differences between LeoCB.leo and leo.py involve leading and trailing whitespace and blank lines.  Tangle works!  Actually, leo.py now does a better job than LeoCB, for the following reasons:

1. leo.py does a good job of deleting trailing blank lines in sections, and this should simplify Untangle.
2. leo.py does a better job of putting leading whitespace than LeoCB, because leo.py more accurately computes the effective width of leading whitespace than does LeoCB.</t>
<t tx="T49">This allows us to open a file when leo starts.  From the Python interpreter do the following:

import leo
fn = "c:\prog\LeoPy\LeoPy.leo"
leo.open(fn)

The open script is the companion to the run and go scripts.  leo.run() just runs leo.  leo.go() reloads all modules before running. For reasons that I don't fully understand, leo.go() does not always handle leoUtils properly: it is sometimes necessary to do

from leoUtils import *</t>
<t tx="T50">Actually, clicking on another node should probably reset the "wrap_node", but it doesn't.  Only changing something in the Find panel does that.</t>
<t tx="T51">Tested paths when Leo invoked directly.
Tested explicit paths in @file nodes
Tested paths in prefs panel.
Tested paths in @path directive.
Tested no path anywhere.

As a result, changed writeError by error in atFile.scanAllDirectives.</t>
<t tx="T52">frame.defaultDirectory was never being used.</t>
<t tx="T53">It appears that putting the following in app.finishCreate will work:

	import leo
	loaddir = os.path.dirname(leo.__file__)

Apparently we can not reference leo.__file__ reliably until leo has been completely imported.  The workaround is to do so in app.finishCreate.  This is a bit mysterious, and it appears to work.</t>
<t tx="T54">The new path philosophy is as follows:

1. Leo will not call os.chdir except possibly after file dialogs that are not cancelled.  This will leave the file system's current directory (returned by os.getcwd()) unchanged by tangling, importing, reading or writing.

2. Commands that access files (tangling, untangling, reading, writing, importing) call either os.getcwd(), atFile.scanAllDirectives or tangle.scanAllDirectives to set appropriate ivars indicating what the proper default directory will be.

3. These commands open a file as follows, where self.default_directory is set in step 2:

	fn = os.path.join(self.default_directory, fileName)
	f = open(fn,...)</t>
<t tx="T55">@file trees were not being marked as dirty when cloned headlines outside those trees were changed.  This definitely would have caused errors while reading @file trees!  Fixing this bug is a big step forward.

The fix was to to have v.setDirty() ensure that all cloned nodes are set dirty and that all ancestor @file nodes are set dirty.  I eliminated v.setDirtyJoined() entirely, and eliminated all calls to v.setAncestorAtFileNodeDirty() outside of v.setDirty().  The result is much safer, cleaner and simpler code.

As a side effect, nodes now become dirty when they move.</t>
<t tx="T56">leo.py used to call chdir from many places to indicate which default directory should be in effect.  That was wrong. From now on, leo.py will call chdir only file dialogs return without being cancelled, that is, for Open, Save and Import commands.

Otherwise, directives will set ivars, and the code will compute full path names using
os.path.join(directory_ivar, pathname).  The neat thing about this is that if pathname already contains a full path name it will override the path in directory_ivar.

For example, the Tangle code now writes the final file like this:

	file_name = os.path.join(self.tangle_directory,section.name)
	... # tangle into temp file
	update_file_if_changed(file_name,temp_name)

This works properly whether or not section.name contains a full path name.</t>
<t tx="T57">If the present node is expanded, the Paste Nodes command now pastes the pasted node as the first child of the present node, rather than as the next sibling of the present node.</t>
<t tx="T58">trace(a) prints a if s is a string and executes a() if a is a function.</t>
<t tx="T59">The symptom of the bug was that it was taking a _long_ time to close windows after doing many interactive find commands.  Actually, it was redrawing the tree that was the real problem.

Disable the recycling of nodes made no difference.  By removing code I isolated the performance bug to the call to tree.redraw in find.showSuccess().  This was very good news, as it meant that the bug was in the tree code rather than in Tk or Tkinter.

The bug was caused by "extra" links to the Tk.text widgets in the vnode, specifically, the v.box_id, v.edit_text_id, v.icon_id and v.box_id ivars.  These links apparently created permanent references that prevented widgets from being deallocated when the tree was redrawn, so a large number of widgets and their binding had to be deleted when the tree was deleted.

The fix was just to eliminate these vnode ivars entirely: they were not being used!  The v.edit_text ivar could not be eliminated, so I added a call to self.edit_text.destroy() just before reallocating.  Perhaps just moving the edit_text would be better than destroying and reallocating it, but that wouldn't be so easy because of the call to self.canvas.destroy("all").</t>
<t tx="T60">If a clone problem is reported, the @file node is not marked dirty again, so if we save the .leo file and then quit the problem will still exist in the derived file.

This happened in Borland Leo, so it is clear if it is a problem in leo.py.

I recovered by doing a Read Outline Only.</t>
<t tx="T61">Moved Tangle utils into Tangle leoTangle.py.  These should be methods because they deal with tangle ivars.

Separated utils that call scanError from other utils.</t>
<t tx="T62">This happened after deleting a clone outside of the tree for @file leoColor.py.  I am not sure of the exact sequence.  Perhaps LeoCB was involved.</t>
<t tx="T63">This was pretty easy.  I think underlining hyperlinked section references looks good.

Still to do:

1. We need browser-style navigation: forward, up, back, home.

2. We may have to change things for Leo1.</t>
<t tx="T64">I finally realized why c.redraw and c.endUpdate wiped out the edit status:

1.  tree.redraw does not preserve the edit status (it probably should)
2.  tree.redraw only causes queuing of the redraw.  It doesn't happen immediately.

This was causing problems in find.show_success.  My quick fix was to create tree.redraw_now, and then to restore the status as needed.  Another, probably better, way would be to have tree.redraw restore edit status.  Duh.

However, in this case tree.redraw_now is exactly what is needed, so I feel a bit less stupid...</t>
<t tx="T65">There are a huge number of details to get exactly correct.  It appears that the code is close to working.</t>
<t tx="T66">I finally realized that v.edit_text is defined only if v is visible on the screen, that is, only if all of v's ancestors are expanded.</t>
<t tx="T67">Previously, cloned headlines were not updated in unison.  This could have been the source of some apparent "lost data".  It is remarkable how complex this logic is.

I finally chose to do a redraw in tree.endUpdate() to force headlines in synch.  We can't typically just do a redraw() in idle_headline because that messes up the editing state of v.edit_text.

I also fixed a bug in idle_body that caused control-Q to call c.setChanged() again.  The new code just sees whether the code has caused the text to change: it does not need the value of ch to do that.

idle_headline also now handles all details of marking nodes dirty.  This used to be done partly in undimHeadline.</t>
<t tx="T68">I made terrible blunder: I eliminated a commands ivar that was involved in writing, so the write failed and wiped out the .leo file.  Since I didn't have a recent backup .leo file, I lost todays notes.

Let this be a lesson to myself:

1.  Backup .leo files _are_ useful for backing up ouline only data.
2.  Make backup of entire LeoPy folder when there are problems.  I came very close to all of today's programming work, which would have been hard to bear.</t>
<t tx="T69">We don't need to keep track of the status of control or alt keys!  Instead, we let idle_body_key and idle_head_key compare the old with the new value.  They do nothing on a match.

An important point:  idle_body_key must make sure that v == c.currentVnode.  If it doesn't make this check we will lose data when the user types Control-K to create a new node.

The new code also takes care not to allow any newlines in headline text.</t>
<t tx="T70">This code is _vastly_ superior to the Borland code, for several reasons:

1.  Unlike the Borland code, the Python code uses no "state" variables.  This not only greatly simplifies the code, it makes it possible to restart incremental searches after the user has changed nodes or changed postion in body text.

Instead of using state variables in the find class, the code uses the c.currentVnode and the "insert" and "sel" tags of the Tk.text widgets.  This automatically ensures that the state of the search matches the state of the outline and body panes!

2. At last!  I know how to restart incremental searches without using state variables.  The trick is _not_ to call c.endEditing() in the setup routines, so set_in_headline() can use c.tree.editVnode to see if we are editing a headline.  If so, we start there.  OTOH, select_next_v _does_ call c.endEditing() and c.editVnode() to force c.tree.editVnode to have the proper value.

3. Leo now uses Tk.Text widgets for both headline and body text.  This eliminates all the special case code that selects between headline and body searches.  Moreover, the same regular expressions are now used for searches in both headlines and body text.  I doubt I could ever have produced bug-free code without this simplification.</t>
<t tx="T71">This hugely simplfies the find/change commands, and makes them more capable.

This also solves the "Control-K" problem in headlines.</t>
<t tx="T72">The ensure_extension routine was adding a .leo extension, thereby defeating the test for an empty file name.</t>
<t tx="T73">This code is much cleaner than the Borland code.  The search commands keep almost no state variables now: we always search from the present location.  This hugely simplifies the logic, and makes the code do what is expected more often.

In particular, is no longer any "first_v" or "first_position" state.  The various find and change commands will save the present state on entry, and restore that state if no finds are found.  This "local" save/restore makes much clearer what is happening.

Still to do: searching in headlines.</t>
<t tx="T74">The save message immediately showed a Save bug.  After doing a Save To, a following Save command used the Save To file name!  This explains why some saves "didn't take".</t>
<t tx="T75">This probably should depend on the size of the window, and at present it does not.</t>
<t tx="T76">I have a new toy: Python's exec statement.  This allows one to have all the flexibility found in tcl scripts.  For example, one can treat the name of variables as variables themselves.  Building statements from strings isn't quite as simple as in tcl, but the effect is exactly the same.

The added flexibily is useful when loading and saving many variables, as in the prefs and find code.  For example:

ivars = [ "tangle_batch_flag", "untangle_batch_flag",
	"use_header_flag", "output_doc_flag",
	"tangle_directory", "page_width", "tab_width" ]
	
for var in ivars:
	exec("self." + var + " = c." + var)  # self.var = c.var
	
This exec statement expresses the pattern directly.  Moreover, once the ivars list is defined many similar exec statements are possible.  Using the % operator might be even clearer:

	exec("self.%s = c.%s" % (var,var))</t>
<t tx="T77">This is tedious code, and Tk makes it much simpler than with other systems.</t>
<t tx="T78">Replaced global with app().idle_imported.

Replaced global with fileCommands.dummy_v.  This fixed a big memory botch: previously a new dummy vnode was allocated for every vnode created!

Replaced es_newline global with app().log.es_newline, i.e., frame.es_newline.  This is better than before because each log stream has its own count.</t>
<t tx="T79">These allow us to reclaim memory when closing a window.  It also showed a that we are wasting lots of space allocating dummy vnodes in the read logic.

With these routines in place, all __del__ routines are eventually being called, which indicates that all circular references are being destroyed by the destroy() routines.  Note that it is _not_ necessary to do any of the following:  del v, del tree, del commands or del frame.  Setting the pointers to None is enough.

Added tree.vnode_alloc_list.  v.__init__ adds items to this list.  tree.destroy removes items from this list.  This is an elegant and powerful solution: all vnodes will be reclaimed eventually, and we don't need to worry about reclaiming them while the window is open.  In particular, this avoids all problems with undo.

Added two new app() ivars to control memory management and tracing.
	self.deleteOnClose	# true: delete all frame objects when a frame closes.
	self.printDel		# true: enable prints in __del__ routines</t>
<t tx="T80">The frame dtor is never being called because (I think) of circular references throughout the vnode, commands and frame classes.  There are several possible approaches:

1.  Ignore the problem completely.  This makes a lot of sense, for several reasons.
	A: Memory is not an issue, and reclaiming memory at termination time doesn't help!
	B: Memory reclamation can legitimately be called a Python implementation issue.
	C: It takes time and memory to reclaim memory.
	D: Errors in reclaiming memory can lead to intermittent crashes.
	
2.  Create destroy() routine for vnodes, tnodes, commands and frames.  These routines would eliminate links between nodes, thereby freeing Python's references.  The frame.destroy() routine would also call self.top.destroy() to force the closing of the frame's window.  The destroy() routine would also do a del self to reduce the reference count of the object.

Note:  deleting vnodes and tnodes is tricky because of undo.  By far the safest course of action is never to delete these nodes until a window closes.  The easy way to do this is put every vnode in a vnode allocation list, an ivar of the tree class.  Calling tree.destroy() would do the following:

	for v in self.vnode_alloc_list:
		v.destroy()
		del v
		
With this structure in place, the __del__ routines would do nothing.  We could insert a print statement in the routines to show when the routines are actually called.  This would indicate whether circular references remain.</t>
<t tx="T81">The old code marked the loading headline as changed.  Added c.loading ivar to disable update of window title during loading.</t>
<t tx="T82">This happens when a save is quickly followed by a quit.  I can get this error when in the Python window, which is reassuring, I suppose.

frame in app().windowList trick doesn't work: very weird.

I enclosed the code in idle_redraw() in a try/except block.  I'm not sure whether this will cure all problems, but it seems like it should.</t>
<t tx="T83">The old code never got around to deleting the frame, tree and commands objects.

However, del self just decrements the reference count; it does not guarantee that self.__del__ is called.  In fact, it doesn't seem that __del_ is _ever_ called!  So much for cleaning up memory.

There may be a bug here, or perhaps this is just a weirdness of usint Tk or Tkinter.  At this point I haven't a clue.</t>
<t tx="T84">This is a strange one.  The problem happens when a save is quickly followed by a quit.  It appears that there is a fault in idle_redraw(), even when the code is locked out with if self in app().windowList.  This is very weird.  Even stranger is that the error traceback never happens when the Python window is opened first (so it stays open).</t>
<t tx="T85">Tested c2py.leo1to2() on LeoCB.  The script now works on both Borland and leo.py.

There is a problem with the v.commands method on Borland. The workaround was to pass the value from top() to convertLeo1to2(v,c).</t>
<t tx="T86">Once again, I am making faster progress with Python than expected.  Amazing.</t>
<t tx="T87">I just imported idle and voila: the IDLE IDE is available!

I did have to add r"c:\Python21\Tools\Idle" to sys.path.  I also removed the wxPython stuff from the path: they interfered with the include.

I added a few top-level functions to leo.py that were described in the scripting documentation.

I added the public commands and vnodes methods described in the scripting documentation.  Several of these routines had names that conflicted with ivars.  In those cases I changed x to mX.  The changed vnode ivars were back, firstChild, headString, next and parent.

I also added several vnode and commands methods that were described in the documentation but that did not presently exist.  Like c.findRoot, c.currentVnode, etc.

The script c2py.convertLeoTree(v) appears to work, so leo.py appears to be largely compatible with scripting in LeoCB.</t>
<t tx="T88">I spent almost an entire day messing with focus issues.  There are two choices:

1.  If tree.bodyKeepsFocus is true the body pane will always have focus unless we are editing a headline.  The current headline is highlighted in grey to indicate the tree has no focus.

2.  If tree.bodyKeepsFocus is false the body pane will not have focus if we select a headline by clicking on it.  In that case the curren headline will be white text on a dark blue background.  When focus shifts to the body pane, the current headline will be greyed.

After much experimentation, it seems that the first way is more convenient, though slightly less accurate as far as visual protocol goes.  I think the convenience of having focus in the body pane (where it is useful) outweighs the small visual incongruity of having the current headline be grayed even when the tree canvas is selected.

Warning: Using frame.getFocus() is much less good than using the tree.active flag, because we can edit a headline with at most two clicks.  That is not true when using frame.getFocus()

The bodyKeepsFocus logic affects all routines that alter the highlighting of headlines.</t>
<t tx="T89">Changed OnCloseLeoEvent so it returns not veto.</t>
<t tx="T90">TThe body handler didn't call setDirtyJoined.  Changed setDirtyJoined so it returns a redraw flag.</t>
<t tx="T91">Added virtual_event_name utility to generate &lt; &lt; name &gt; &gt;.  Sigh.

The OnCut, OnCopy and OnPaste routines just call the body key event handler to do syntax coloring and set the various dirty/changed bits.

There is a small glitch: choosing cut/copy/paste "by hand" from the menu doesn't work when the focus is in an edit label in a headline.  I'm not sure how to fix this and it is extremely minor anyway.</t>
<t tx="T92">Added v param to tree.recolor so we don't assume that v is the current vnode.</t>
<t tx="T93">I tried several options, with no luck: selectborderwidth, selectbackground, selectforground.</t>
<t tx="T94">Added code to leo.py to set the window icon.  Alas, the documentation is poor enough so that I don't know what the arguments to iconbitmap should be.</t>
<t tx="T95">I tried a lot of experiments in fileCommands.getGlobals(), and it is still not possible to set the height and width of the top level window properly.  It is still too large, and its size does not depend on the requrested width.

Note that the size of the window is set in createSplitter, by setting the size of a Frame object.  Perhaps this is interfering with matters.

The present situation is poor, but tolerable.</t>
<t tx="T96">Changed bd="2m" to bd=2.  This makes a big difference in how the panel looks.</t>
<t tx="T97">The syntax colorers can use tag_config to show tabs and spaces.  This isn't perfect (it doesn't look good now) and does not work for newlines.  It may be better than nothing, however.</t>
<t tx="T98">I just forgot to add it to the list of @keywords.</t>
<t tx="T99">These "bugs" may be appearing because these commands are always enabled in the menu.  In any case, the fixes were straightforward.</t>
<t tx="T100">The problem was that the body key handler was being scheduled before the new node was inserted and being called at idle time after the new node was inserted, so the body text disappeared.  The fix was to disabling scheduling if control or alt keys are down.</t>
<t tx="T101">All it took was the following:

font = tkFont.Font(family="Courier",size=9)
tabw = font.measure("    ")
self.body = body = Tk.Text(...font=font,tabs=tabw...)

This hard codes tabs as 4 spaces.  Later I'll make it more general.</t>
<t tx="T102">I am getting closer to getting the look of the splitter panes just right.  Setting bg="white",relief="flat",bd=0 in createSplitter helps quite a bit.

The problem with the tree pane is clearly in the Canvas widget.  If that widget is not packed the pane looks fine.  There seems to be no way to eliminate the canvas's border, and no way to prevent the border from being overwritten by the Entry widget.

Maybe there is a way: the problem may be that Entry widgets are embedded in their own windows...</t>
<t tx="T103">I will use leo.py from now on to develop leo.py.  It is the only way to really get the bugs out.

Changed the code that computes the length of the edit box for headlines.  We always use len(v.headString) now.  This still does not quite work properly, but it is better.

Fixed a bug in the selection logic.  The colors for the previous headline are changed only if the previous is not the same as the current.  This can happen if we click in the icon or plus/minus icon of the current headline.

Added the v.iconx and v.icony ivars so the tree.OnHeadlineKey routine can just redraw the cursor in place if it needs to change.  This is a workaround to a problem that I haven't been able to solve: namely, how to force the cursor to be visible again after the headline loses focus.  This is more than a little kludgy, especially after creating the elegant endUpdate mechanisim.  OTOH, it may point a way towards incremental redrawing of the screen.</t>
<t tx="T104">Changed "darkblue" to "DarkBlue".  The colors known to Tk are listed at
	http://tcl.activestate.com/man/tcl8.4/TkCmd/colors.htm 

Changed print_stack() to Print statements in es() logic.  This was more confusing than helpful.

Eliminated some accelerators (Linux only)

Added loaddir code to leo.py.
</t>
<t tx="T105">Added many terms to the Glossary.

Improved description of Leo2.  Partially merged Leo1 and Leo2 documentation.  It still isn't perfect.</t>
<t tx="T106">Probably very few people could understand the description of Leo2.</t>
<t tx="T107">I fixed the "last" serious bug in this version.  What was happening was that the clone information in leoFileCommands.py and leoCommands.py was alternatively being written and not being written.  The fix was to v.joinNodeTo:  there was a bug that was fixed in the Borland version that had not been fixed in this version.</t>
<t tx="T108">It turns out the updateCloneIndices routines in both LeoCB and leo.py are slightly buggy.  Both can increment indices multiple times for the same tnode.  In addition, LeoCB computes indices for parts of the tree beyond the actual tree, so that would increase the indices further, which is why the LeoCB version sometimes has a larger clone indices.

Neither of these "bugs" really makes a difference.  In either case, nodes are joined properly.

To "minimize" the clone indices we would do the following:

	index = 0
	v = root
	# Zero all indices.
	while v and v != next:
		v.t.cloneIndex = 0
	# Set clone index only if it has not already been set.
	while v and v != next:
		if v.t.cloneIndex == 0 and v.isCloned() and v.shouldBeClone():
			index += 1
			v.t.cloneIndex = index
		v = v.threadNext()
		
This might be just slightly slower than the "wasteful" way.</t>
<t tx="T109">The directory compare routines in the Python lib do not seem to exist.  The new routines compare only .py files.</t>
<t tx="T110">The lineIndent var was not set properly in &lt;&lt; Set lineIndent, linep and leading_ws &gt;&gt;, with the result that some sections contained extra leading whitespace in their body parts.

With this bug fixed, leo.py reads and writes all files correctly!</t>
<t tx="T111">Fixed a bug that was causing the last newline of doc parts to be deleted.  The problem was that string.rstrip() also strips newlines!  With this bug fixed it appears that Leo.py can read and write @file nodes just like Leo2CB does.

Created the removeTrailingWs() in leoUtils that strips trailing blanks and tabs.</t>
<t tx="T112">Rewrote the code in scanText and scanDoc that figures out where sentinels start.

The new nextLine and nextKind vars clarify what is going on.  When a non-sentinel line is output, the trailing newline is part of a sentinel if and only if nextKind is some kind of sentinel.

I'm not convinced the code in scanDoc is correct...

</t>
<t tx="T113">This is a very useful comparison tool.  It allows me to compare whitespace easily.</t>
<t tx="T114">This puts up a model dialog.  The hardest part was writing the code that centers the dialog on the screen.  Sheesh.</t>
<t tx="T115">I fixed many minor problems in preparation for releasing the first usable version of Leo.py.</t>
<t tx="T116">These bugs were simple transcription errors; they do not occur in LeoCB.

v.childIndex() was always returning 0, so naturally v.createDependents() was not working well.

Added a call to v.unlink() in v.destroyDependents.  The call to v.destroyTree() no longer does anything.</t>
<t tx="T117">We no longer need setIcon!!  Indeed, setIcon just calls c.redraw(), so as long as the callers enclose code in beginUpdate/endUpdate all will be well.  This eliminates a _major_ mess, and will result in further simplifications: we no longer need the distinction between the setX and initX routines!</t>
<t tx="T118">It turned out that tree.idle_body_key was the bottleneck, _not_ syntax coloring!

What was happening was this:  tree.redraw was being called on _every_ keystroke, and that was causing a huge amount of memory allocation and deallocation.  After a while everything ground to a halt.

The fix was very clever: I added a flag to c.endUpdate and tree.endUpdate, true by default.  tree.redraw is called only if count==0 and flag==true. So calling endUpdate(false) prevents all redraws from happening in a range of code.  This is a wonderful addition to the beginUpdate/endUpdate pattern.

Both tree.idle_body_key and v.setAncestorAtFileNodeDirty use this pattern.  The result is that tree.redraw() is called only when the icon really and truly must change.
</t>
<t tx="T119">Amazing.  I wrote some dummy code last night, read up on indices this morning, and got everything to work in a couple of hours. The result is very fast: no optimization is needed for Leo. I love Tkinter!

Added c.recolor and tree.recolor routines.  This hooks should be called whenever the body text changes.  Apparently there is no "OnTextChanged" event in Tk.</t>
<t tx="T120">Implementing this was trivial: we use a app.clipboard ivar, a string.  Using an internal clipboard means that we can't inadvertantly paste the XML representation of a string into body text.</t>
<t tx="T121">The only major step left before releasing a functional version of Leo is to check the @file write code.
</t>
<t tx="T122">The Tk clipboard handling is confusing: there are routines for clearing and setting the clipboard, but no obvious way to get the contents of the clipboard.  I could use an internal clipboard (part of the LeoApp class) for leo nodes, which would work pretty well.  If I did that I might want other commands: cut, copy and paste between node clipboard and the text widgets...

There doesn't seem to be any Python support for the clipboard, which is weird.</t>
<t tx="T123">This is a tedious task, no matter how it is done.</t>
<t tx="T124">Simplified the code that sets the current vnode and initializes icons.  Having tree.redraw update icons automatically helps a lot.

Added tree.initing hack to disable endEditLabel from marking the tree as changed. Actually, this probably isn't necessary, as top.title probably won't be redrawn until idle time anyway.</t>
<t tx="T125">Here is how to get accelerators working:

fileMenu.add_command(label="New", accelerator="Ctrl+N", command=self.OnNew)
self.top.bind("&lt;Control-n&gt;", self.OnNew)

Warning: using top.bind_all would not work well with multiple windows.

The accelerator="Ctrl+N" option merely sets the menu text(!).  The bind_all method actually does the work.  BTW, I had to change (self) to (self,event=None) in all the command handlers.  When an accelerator is used the handler is called with two args.  When the menu is used the handler is called with only one arg.

IDLE shows how to be a bit more clever with initialization.  I probably should study the Idle code and be clever ;-)  IDLE also use the configuration data base, and I probably should study that too.</t>
<t tx="T126">There are now just two routines, v.computeIcon() and v.setIcon().

v.setIcon just does c.tree.redraw() (!)

c.tree.redraw() now does nothing if the update count &gt; 0, so this is safe. Moreover, we can now enclose any code in c.beginUpdate()/c.endUpdate() without worry.

This is the way it is written in the Book.</t>
<t tx="T127">The &lt;Key&gt; event is called _before_ the body text is updated, so it is not possible to properly update syntax coloring, icons or tnodes there.  Instead, the &lt;Key&gt; event handler just registers an idle-time event to do the real work.  Very simple!</t>
<t tx="T128">The canvas widget appears to have an improper 1 or 2 pixel gray border.  I have worked around this by limiting the size of the Tk.Entry widget: expanding it only when editing is enabled.</t>
<t tx="T129">Following the IDLE code lead me astray.  IDLE does not allow the headline text to be edited!  At last some of the confusion is gone.</t>
<t tx="T130">openWithFileName now shows the window before loading, so that reading messages become visible.  To do this, we call app().root.update().

Made leoFrames bigger: this is done in createSplitter(!)</t>
<t tx="T131">We close the initial open window if it has not been changed.

app.quit() now closes the hidden root window to close the app.

Close processing now calls the close event handler.

There are no bugs as in wxWindows!  Everything is straightforward.</t>
<t tx="T132">I have rewritten the code to draw the tree, and it seems to work reliably.  However, expanding an entire tree is slow, and redrawing the tree is also slow is many nodes are visible.  I'm not sure what is causing this...

Disabling drawNode speeds up the redraw greatly.
Disabling only tags also speeds up the redraw greatly.  Indeed, way too many tags appear to be created...

Still to do: I have not been able to create edit windows in the canvas properly...</t>
<t tx="T133">I'm not sure whether Tkinter can read .bmp icons, so I created .gif icons, which work well.</t>
<t tx="T134">Rewrote v.restoreOutlineFromDVnodes.  It is now very simple because undo no longer creates dvnodes; vnodes now contain all tree information.  So when we "delete" a tree we just unlink and unjoin it, and when we "restore a tree we just relink and rejoin it.  It is truly amazing how simple the tree code now is.</t>
<t tx="T135">It now takes about 3 seconds to read this file, rather than the 9+ seconds needed by wxPython!  Apparently the wxPython tree class was very slow.

The _old_ bottleneck was as follows:
	Most of the time is spent in atFile scanning code
		.. c.clearAllVisited is very slow(!!) because it clears the entire tree.
			c.clearAllVisited takes about 1/3 time of the entire scanning phase (!!)
		.. Reading the file itself, is very fast, scanning in atFile::read is slow.
		.. es calls are fast.
</t>
<t tx="T136">A milestone.  It is now possible to read a .leo file and to draw the tree at least partially.  Most of the conversion to Tkinter has now been completed.

I removed vnode and commands getters that merely returned ivars.  Also converted wxWindows calls to Tk calls.  It is remarkable how easily the changes went.  
</t>
<t tx="T137">Converted all Tk prototype code to Tkinter.  It was straightforward for the most part.  The Leo window works: scrollbars work and the text panes work.  However, the tree pane is a text pane at present.

Copied menu code from Leo.py version 0.04.  Somehow the old code was lost, I have no idea why.  The copied code is wxWindows code, so it will have to be rewritten for Python.  Still, it is much easier to use the properly converted Python code.  Perhaps I deleted the code thinking that it would all have to be rewritten.  If so, that was a minor mistake.</t>
<t tx="T138">The use_tk global indicates whether Leo will use wxPython or Tkinter.  The next step is to transliterate the Tk code that creates the Leo window into Tkinter.</t>
<t tx="T139">After much experimentation, adding a -padx param to the log window pane seems like the only way to handle the width of the vertical scroll bar.  Without this extra padding, the scroll bar obscures the left edge of the log window.</t>
<t tx="T140">It simplifies and speeds up the code to use file.readline to process lines as a unit.  This way I never have to scan to the end of a line.  However, it turns out that scanning is not really the bottleneck.  In addition, we no longer read entire derived files into memory at once.

BTW, it may be possible to use readline() in the getLeoFile logic as well.  I have no idea whether this would help or not.

The problem is the _second_ half of atFile::read, that is, after the derived file has been completely scanned and all vnodes have been created!  Apparently, something (maybe shouldBeClone?) involved with setting bits is horribly slow.  I'm not sure why earlier testing didn't show this problem.  I must have been mistaken somehow in my earlier conclusions.

This actually is very good news.  It means that the raw file code is good enough as it is.  Note:  reading derived files will not slow down when I switch to Tk because we don't create vnodes unless there are file errors!

I have just found that a single call to c.clearAllVisited() in read() _substantially_ slows down the read!  Amazing.

Create v.clearVisitedInTree() and v.clearAllVisitedInTree()</t>
<t tx="T141">@nocolor
@ignore

This is a _very_ easy class.

Ivars
	self.root: the root vnode
	self.update: update count
		tree::beginUpdate increments.  tree::endUpdate decrements.
		Disable redraw if &gt; 0
		Redraw when falls to 0.
	self.selected: the selected vnode
	self.top the top vnode on the screen (needed?)

Tree methods know about vnodes(!) Greatly simplifies both tree and vnode classes.
tree:endUpdate does nothing if self.update &gt; 0
	User code should not call tree::redraw directly.
	Most tree methods call redraw
Insert methods create a vnode, set links and redraw.
Move methods just set links and redraw
Commands methods enclose complex operations in tree.beginUpdate/endUpdate, as they do now.
tree::delete(v) just unlinks v's tree
	vnodes are not deleted until window goes away: unlimited undo!
	v.threadNext ivar makes deleting a list trivial.

vnodes

vnodes contain headString, expanded, firstChild, parent, back, next and threadNext ivars
	tree::getThreadNext() used to set v.threadNext
	no need for dvnodes: vnodes contain all undo info!


		</t>
<t tx="T142">added use_tk constant in leoGlobals.</t>
<t tx="T143">es now outputs a newline, which makes most uses of enl and ecnl superfluous.  We can do this be string concatenation is so easy.</t>
<t tx="T144">There was a transliteration error in computing the line to be output which mangled long lines.</t>
<t tx="T145">This code has not been tested.</t>
<t tx="T146">There was a bug in sentinelKind.  skip_c_id won't handle @@, so @@ must be handled separately.</t>
<t tx="T147">It is not possible to access global _variables_ using from leoGlobals import * because that creates copies of the data.  The new way is simpler and more modular.

Revised how the prefs panel works.  The new code just sets the prefs ivars.  It is up to the caller to access the prefs panel as needed. Added tab_width preference and prefs.tab_width ivar.  This should have been done long ago.</t>
<t tx="T148">Fixed problems with at_xxx_ptr globals.  The problem that from leoGlobals import * doesn't work, so I changed is_special_bits so it returns a dictionary containing name:value pairs rather than setting globals.

Fixed many problems in scanAllDirectives involving paths.  Also rewrote the code in atFile::write that opens files.

At this point leo.py can read and write files except files containing @first.
</t>
<t tx="T149">.. initAllCloneBits had several errors.
.. self.structureErrors wasn't being initialized in atFile::Read
.. createNthChild must mark nodes as visited to suppress unvisited node logic later.
.. Added log messages any time self.structureErrors is incremented in createNthChild

At this point leo.py can read a simple test file properly, except files containing @first.</t>
<t tx="T150">It wasn't too hard to create a proper splitter window.  After that, creating a Leo window was trivial.</t>
<t tx="T151">I am beginning to think that globals should _never_ be used.

The @language bug appears to be a problem of not setting globals properly.</t>
<t tx="T152">Added assert in tnode::setTnodeText that we are getting a string.  This assert was not always true before I added a call to listToString in &lt;&lt; copy new_out to child's body t't' in scanText.</t>
<t tx="T153">The read code is slow.  I'll have to see why.

3 seconds with read doing nothing (reads leoPy.leo)
5 seconds with read reading files but not scanning them.
9 seconds with read fully enabled.

Therefore:

3 sec to read and scan LeoPy.leo
2 sec for reading all derived files
4 sec to scan all derived files.

So scanning derived files is pretty slow.

BTW, LeoCB can do everything in about 2 sec.
</t>
<t tx="T154">There was the usual assortment of minor problems.

.. The write code was writing flags using `flag`, and this fails if false is None.
.. Added code to make sure None is never passed to wxFileDialog as a file name.  I wonder if this could have caused problems earlier.  Once again, the C++ code is shown to be radically unsafe.

.. I think false should be defined as 0, not None.  There are several advantages:

1.  not 0 == not None, so various tests work as before.
2.  `0` is very different from `None`, and this affects the file format.

I'll make this change.  Hope it works ;-)</t>
<t tx="T155">A major milestone:  the read command works and so do most outline commands.  It is now clear that reading a file is fast enough so that no further work is required!

The main problems today:

1.  The code must use the test: id and id.IsOk().  Failure to make _both_ tests will cause the code to fail, possibly in an unbounded loop.  This was ultimately the problem with the Move Down command:  the threadNext code didn't make these test.  I finally called wxGetThreadNext inside threadNext and that solved the problem.

2.  I added the self.changing lockout in the LeoFrame OnTextUpdate handler so that tnodes would not be erroneously updated while switching tnodes.  The new code seems simple and robust.</t>
<t tx="T156">A case can be made for getters of the form:

	def getX():
		return x
		
In particular, they are a reaonable place to put asserts.  However, such getters do not seem good style in Python because all ivars are public anyway.  Moreover, getters like

	def x():
		return x
		
are invalid in Python, so there is a problem.  The simplest approach seems to be to get rid of all such redundant getters, and that is what I have just done.  Note that assert's aren't so important in wxPython, because nothing bad can happen anyway.</t>
<t tx="T157">This was a very interesting experience, for the following reason.

1.  The weakness of a non-compiled language is that problems don't show up until code is actually executed.
2.  Python is very safe.  The only real problem are unbounded loops.
3.  In particular, the continue statement will _always_ loop in Python unless progress the loop variable is incremented.  So care must be taken when translating C for loops into Python while loops.
4.  Even without the ability to set breakpoints (which means that single-stepping is impossible in wxPython!) it wasn't too hard to trace with print statements.  Amazing.
5.  The biggest mess came with getters that return an ivar of the same name.  I'll sleep on this, and I think the thing to do is get rid of the getter entirely:  convert x.getY() x.Y.
6.  Defining constants in a class is nice: they are accessed by class name.  For example: vnode.dirtyBit.

Status:
1.  The outline is being read in correctly.
2.  The atFile::read logic hasn't been tested.
3.  The body pane (and probably all the tnode text) is not being set properly.
4.  It is possible that we might be able to get rid of join lists!  They are used:
	a) To update the headline text
	b) For shouldBeClone.
	We could replace join lists by a reference count and temporary join lists.
	This could be really cool, and I'll have to think about this more...
	</t>
<t tx="T158">Created leoFileCommands.py.  We use com=self.mCommands to access the "real" commander for this class.  It would be wrong to make fileCommands a subclass of Commands; we must have exactly one commander per frame so that mCurrentVnode, mRootVnode, etc. are updated properly.

In short, the ivars of fileCommands are mFrame, mCommands and any ivars used exclusively by fileCommands.  This pattern will be used to create outlineCommands.py, findCommands.py, etc.</t>
<t tx="T159">The info class was confusing.  All the ivars from that class now become ivars in the fileCommands class.  The mTnodes array is now a Python dict, so there is no need for the mNumberOfTnodes or mMaxTnodeIndex ivars!  The new clode is _much_ clearer.  A major victory.</t>
<t tx="T160">Fixed several bugs in c2py.

Greatly simplified handlePossibleFunctionHeader; there is no need to compute a delta there:  we munge the head, args and body separately, then replace the original all at once with the new lists.  This is bullet proof.

Fixed some bugs in safeReplace and matchWord.

Fixed bugs in convertCStringToPython that caused skipDoc and skipCode to be called in the wrong places.  That was really messing things up!

Tested the speed of tests by writing speedTest.  This is so much fun!</t>
<t tx="T161">I have been happily converting, with the help of c2py, Leo's C++ code to python.  The new code is far, far easier to understand.</t>
<t tx="T162">Fixed several bugs in c2py:

1. removeExcessWS was sometimes skipping past a newline, thereby removing leading whitespace in the following line.  This made it look like the code for "if", "while" and "for" was bad.

2. the function scanning code had several bugs.  Added new code to ignore "if", "while" and "for" code.  Added new code to ignore # lines (preprocessor directives).  Added the firstOpen variable to eliminate scanning later.  This is pretty tricky code.

3. Added code to replace " . " by "." and "\t " by "\t".

4. Fixed skipPastWord so it handles underscores and digits.  This helped a lot ;-)

5. @code was not always properly converted to @c.

I think I will leave c2py as is for now.  It has the following rough edges:

1.  I don't know how to break long scripts.
2.  c2py doesn't handle : initializers in constructors well; they inhibit processing of the initializer.
3.  c2py doesn't place self. in all the places it is needed.  I'm not sure there is an elegant way to do this...</t>
<t tx="T163">Worked on c2py.  As documented in LeoCB.leo, had to add a __cmp__ routine in leo.py so that vnodes compare equal properly.  Fixed some minor bugs in c2py.

We now have two separate routines called leo.py.  The one used by LeoCB and LeoWX is the python expression evaluator.  The leo.py in LeoPy is the top level of leo.py.

Added signed, unsigned and bool to the list of type names.</t>
<t tx="T164">Documented the theory of operation of c2py.  This is a remarkably simple program!  Converting from string to list representation turns out to be a very good choice.</t>
<t tx="T165">For the last two days I have been working on c2py.py.  I am totally in love with Python.  Everything is so much easier:  Automatic debugging, no declarations, no types, no compilation. Great data structures. Even without single stepping the debugging is easy.

All major aspects of c2py are now complete.</t>
<t tx="T166">It has been staring me right in the face.  Idle.py supports tree views and syntax coloring!  All I need do is adapt the Idle code for Leo.  The only remaining piece of the puzzle is a good splitter window (and splitter events?)
</t>
<t tx="T167">All menu work is now complete, with stubs for many calls to Commands routines...
The Python menu is functional.
The Find Panel can be opened.
The Find Panel can be opened.

Still to do:
	Icons for outline
	Nodes classes
	Commands classes:
		outline commands
		file commands,
		find commands,
		tangle/untangle commands</t>
<t tx="T168">@nocolor</t>
<t tx="T169">sys.settrace(func) sets the global trace function. there can also a local trace function (see later)

Trace functions have three arguments: frame, event, and arg.
frame is the current stack frame.
event is a string: 'call', 'line', 'return' or 'exception'.
arg depends on the event type. 

The global trace function is invoked (with event set to 'call') whenever a new local scope is entered; it should return a reference to the local trace function to be used that scope, or None if the scope shouldn't be traced. 

The local trace function should return a reference to itself (or to another function for further tracing in that scope), or None to turn off tracing in that scope. 

Instance methods are accepted (and very useful!) as trace functions. 

The events have the following meaning: 

'call' 
A function is called (or some other code block entered). The global trace function is called
arg is the argument list to the function
the return value specifies the local trace function. 

'line' 
The interpreter is about to execute a new line of code (sometimes multiple line events on one line exist). The local trace function is called
arg is None
the return value specifies the new local trace function. 

'return' 
A function (or other code block) is about to return. The local trace function is called
arg is the value that will be returned.
The trace function's return value is ignored. 

'exception' 
An exception has occurred. The local trace function is called.
arg is a triple (exception, value, traceback)
the return value specifies the new local trace function 

Note that as an exception is propagated down the chain of callers, an 'exception' event is generated at each level. 

For more information on code and frame objects, refer to the Python Reference Manual.</t>
<t tx="T170">leo.py reads and writes exactly like LeoCB</t>
<t tx="T171">Amazing.  I wrote some dummy code last night, read up on indices this morning, and got everything to work in a couple of hours. The result is very fast: no optimization is needed for Leo. I love Tkinter!

Added c.recolor and tree.recolor routines.  This hooks should be called whenever the body text changes.  Apparently there is no "OnTextChanged" event in Tk.</t>
<t tx="T172">This marked my complete frustration with wxLeo and wxPython, and the real beginning of the work on leo.py.</t>
<t tx="T173">I am totally in love with Python.  Everything is so much easier:  Automatic debugging, no declarations, no types, no compilation. Great data structures. Even without single stepping the debugging is easy.

All major aspects of c2py are now complete.</t>
<t tx="T174">I am not sure exactly when this happened.  The details apparently have been lost.  There was a time when I was experimenting with Python and wxPython, and a time when I was working on wxWindows version of Leo.</t>
<t tx="T175">Executable scripts don't execute
	idle, other scripts
Linker sees .so file, loader doesn't
$PATH  no such file or directory
PS1 = "ekr" doesn't work
gdbtk doesn't spawn processes properly
error message (?) when installing using package manager
	no error message given
	Any way of seeing the message?
ldconfig doesn't show /usr/local/lib files
downloaded distributions to /home/edream/downloads and installed from there
Is there any way to allow null passwords?
strange core dumps
worked on Corel Linux
installed from /usr/edream/downloads
high partition with Windows
</t>
<t tx="T176">week 1: untangle
week 2: read error dialog, menu shortcuts and enablers
week 3: import commands, edit commands
week 4: leo article
</t>
<t tx="T177">@color</t>
<t tx="T178">c=leo.topCommand() # done, sort of

[c]=leo.getCommands() # done</t>
<t tx="T179"># Drawing utilities...
c.BeginUpdate() # also beginUpdate (done)
c.EndUpdate() # also endUpdate (done)
c.Repaint() # also repaint (done)
c.BringToFront() # also bringToFront (done)

# Getters...
v=c.currentVnode() # add (done)
v=c.rootVnode() # add (done)
b=c.isChanged()
s=c.fileName() # mFileName (done)

# Setters...
c.bringToFront()
c.clearAllVisited()
c.editVnode(v)
c.endEditing(v)
c.makeVisible(v)
c.selectVnode(v)
c.synchVnode()  # No longer used.</t>
<t tx="T180"># File menu commands
c.new(windowName)
b=c.open(fileName)
c.close()
b=c.save(fileName)
b=c.saveAs(fileName)
b=c.saveACopyAs(fileName)
c.revert(windowName)

c.tangle()
c.tangleAll()
c.tangleMarked()

c.untangle()
c.untangleAll()
c.untangleMarked()

c.flattenOutline( [fileNames] )
c.cwebToOutline( [fileNames] )
c.importFiles( [fileNames] )
c.importMoreText( [fileNames] )
c.exportMoreText()

# Edit menu commands
c.cut
c.copy
c.paste
c.delete
c.selectAll

c.editCurrentHeadline()
c.extract()
c.extractSection()
c.extractSectionNames()
c.convertBlanks()

# Outline menu commands
c.cutOutline()
c.copyOutline()
c.pasteOutline()
c.deleteHeadline()
c.insertHeadline()
c.clone()

c.contractSubheads()
c.contractAllSubheads()
c.contractAllHeadlines()

c.expandAllHeadlines()
c.expandAllSubheads()
c.expandSubheads()

c.expandLevel1()
c.expandLevel2()
c.expandLevel3()
c.expandLevel4()
c.expandLevel5()
c.expandLevel6()
c.expandLevel7()
c.expandLevel8()
c.expandLevel9()
c.expandNextLevel()

c.moveOutlineLeft()
c.moveOutlineRight()
c.moveOutlineUp()
c.moveOutlineDown()

c.promote()
c.demote()

c.selectThreadBack()
c.selectThreadNext()
c.selectVisBack()
c.selectVisNext()

c.markHeadline()
c.markSubheads()
c.markChangedHeadlines()
c.markChangedRoots()
c.unmarkAll()

c.goToNextDirtyHeadline()
c.goToNextMarkedHeadline()

# Window menu commands
c.equalSizedPanes()</t>
<t tx="T181"># Menu enablers
b=c.canContractAllHeadlines()
b=c.canContractAllSubheads()
b=c.canContractSubheads()
b=c.canCutOutline()
b=c.canDeleteHeadline()
b=c.canDemote()
b=c.canExpandAllHeadlines()
b=c.canExpandAllSubheads()
b=c.canExpandSubheads()
b=c.canExtractSection()
b=c.canExtractSectionNames()
b=c.canGoToNextDirtyHeadline ()
b=c.canGoToNextMarkedHeadline()
b=c.canMarkChangedHeadlines()
b=c.canMarkChangedRoots()
b=c.canMoveOutlineDown()
# Note: the docs do not indicate that these are commands methods (c. omitted)

b=c.canMoveOutlineLeft()
b=c.canMoveOutlineRight()
b=c.canMoveOutlineUp()
b=c.canPasteOutline()
b=c.canPromote()
b=c.canRevert()
b=c.canSelectVisBack()
b=c.canSelectVisNext()
b=c.canSelectThreadBack()
b=c.canSelectThreadNext()
b=c.canSelectToEnd()
b=c.canSelectToStart()
b=c.canShiftBodyLeft()
b=c.canShiftBodyRight()
b=c.canUndo()
b=c.canUnmarkAll()</t>
<t tx="T182"># Getters...
p = leo.getPrefs() # returns instance of the Prefs class
b=p.defaultTangleDirectory()
b=p.doLeoDoneBat()
b=p.doLeoUnBat()
s=p.logWindowString() # returns contents of log window
n=p.pageWidth()
b=p.tangleOutputsHeaderLine()
b=p.tangleOutputsDocChunks()

# Setters...
p.setDefaultTangleDirectory(s)
p.setDoLeoDoneBat(b)
p.setDoLeoUnBat(b)
p.setPageWidth(n)
p.setTangleOutputsHeaderLine(b)
p.setTangleOutputsDocChunks(b)
</t>
<t tx="T183"># Getters...

v=v.next() # mNext (done)
v=v.back() # mBack (done)
v=v.parent()  # mParent (done)
v=v.firstChild() # mFirstChild (done)
s=v.headString() # mHeadString (done)
v=v.findRoot() # (done)
s=v.bodyString() # add: return v.t.bodystring (done)

v=v.currentVnode()
v=v.lastChild()
v=v.lastNode()
v=v.nodeAfterTree()
v=v.nthChild(n)
v=v.threadBack()
v=v.threadNext()
v=v.visBack()
v=v.visNext()
n=v.childIndex()
n=v.numberOfChildren()
n=v.level()
b=v.hasChildren()
b=v.isAncestorOf(v2)
b=v.isCloned()
b=v.isDirty()
b=v.isExpanded()
b=v.isMarked()
b=v.isVisible()
b=v.isVisited()

s=v.convertTreeToString() # not ready yet
s=v.moreBody() # not ready yet
s=v.moreHead(n) # not ready yet

# Setters...
v.setBodyTextOrPane(s) # add (done)
v.setHeadStringOrHeadline(s)
v.setIcon() # add for compatibility (done)
v.trimTrailingLines() # not ready yet

v.moveAfter(v2)
v.moveToNthChildOf(v2,n)  
v.moveToRoot()

v.clearVisited()
v.setVisited()
</t>
<t tx="T184">@ignore
@color

	# To get the current selection
	sel = c.body.tag_ranges("sel")
	if len(sel) == 2:
		start,end = sel # unpack tuple.

	def selection_clear(text):
		text.tag_remove(SEL, 1.0, END)

	def selection_from(text, index):
		text._anchor = index

	def selection_present(text):
		return len(text.tag_ranges(SEL)) != 0

	def selection_range(text, start, end):
		text.tag_remove(SEL, 1.0, start)
		text.tag_add(SEL, start, end)
		text.tag_remove(SEL, end, END)

	def selection_to(text, index):
		if text.compare(index, "&lt;", text._anchor):
			selection_range(text, index, text._anchor)
		else:
			selection_range(text, text._anchor, index)</t>
<t tx="T185">Valid colors: ( see colors in main TOC )
  http://tcl.activestate.com/man/tcl8.4/TkCmd/colors.htm
Valid key names ( see keysyms in main TOC)
  http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm</t>
<t tx="T186">@nocolor

Not all keysyms will be valid on all platforms.

space                               32     0x0020
exclam                              33     0x0021
quotedbl                            34     0x0022
numbersign                          35     0x0023
dollar                              36     0x0024
percent                             37     0x0025
ampersand                           38     0x0026
quoteright                          39     0x0027
parenleft                           40     0x0028
parenright                          41     0x0029
asterisk                            42     0x002a
plus                                43     0x002b
comma                               44     0x002c
minus                               45     0x002d
period                              46     0x002e
slash                               47     0x002f
0                                   48     0x0030
1                                   49     0x0031
2                                   50     0x0032
3                                   51     0x0033
4                                   52     0x0034
5                                   53     0x0035
6                                   54     0x0036
7                                   55     0x0037
8                                   56     0x0038
9                                   57     0x0039
colon                               58     0x003a
semicolon                           59     0x003b
less                                60     0x003c
equal                               61     0x003d
greater                             62     0x003e
question                            63     0x003f
at                                  64     0x0040
A                                   65     0x0041
B                                   66     0x0042
C                                   67     0x0043
D                                   68     0x0044
E                                   69     0x0045
F                                   70     0x0046
G                                   71     0x0047
H                                   72     0x0048
I                                   73     0x0049
J                                   74     0x004a
K                                   75     0x004b
L                                   76     0x004c
M                                   77     0x004d
N                                   78     0x004e
O                                   79     0x004f
P                                   80     0x0050
Q                                   81     0x0051
R                                   82     0x0052
S                                   83     0x0053
T                                   84     0x0054
U                                   85     0x0055
V                                   86     0x0056
W                                   87     0x0057
X                                   88     0x0058
Y                                   89     0x0059
Z                                   90     0x005a
bracketleft                         91     0x005b
backslash                           92     0x005c
bracketright                        93     0x005d
asciicircum                         94     0x005e
underscore                          95     0x005f
quoteleft                           96     0x0060
a                                   97     0x0061
b                                   98     0x0062
c                                   99     0x0063
d                                  100     0x0064
e                                  101     0x0065
f                                  102     0x0066
g                                  103     0x0067
h                                  104     0x0068
i                                  105     0x0069
j                                  106     0x006a
k                                  107     0x006b
l                                  108     0x006c
m                                  109     0x006d
n                                  110     0x006e
o                                  111     0x006f
p                                  112     0x0070
q                                  113     0x0071
r                                  114     0x0072
s                                  115     0x0073
t                                  116     0x0074
u                                  117     0x0075
v                                  118     0x0076
w                                  119     0x0077
x                                  120     0x0078
y                                  121     0x0079
z                                  122     0x007a
braceleft                          123     0x007b
bar                                124     0x007c
braceright                         125     0x007d
asciitilde                         126     0x007e
nobreakspace                       160     0x00a0



BackSpace                        65288     0xff08
Tab                              65289     0xff09
Linefeed                         65290     0xff0a
Clear                            65291     0xff0b
Return                           65293     0xff0d
Pause                            65299     0xff13
Scroll_Lock                      65300     0xff14
Sys_Req                          65301     0xff15
Escape                           65307     0xff1b
Multi_key                        65312     0xff20
Kanji                            65313     0xff21
Home                             65360     0xff50
Left                             65361     0xff51
Up                               65362     0xff52
Right                            65363     0xff53
Down                             65364     0xff54
Prior                            65365     0xff55
Next                             65366     0xff56
End                              65367     0xff57
Begin                            65368     0xff58
Win_L                            65371     0xff5b
Win_R                            65372     0xff5c
App                              65373     0xff5d
Select                           65376     0xff60
Print                            65377     0xff61
Execute                          65378     0xff62
Insert                           65379     0xff63
Undo                             65381     0xff65
Redo                             65382     0xff66
Menu                             65383     0xff67
Find                             65384     0xff68
Cancel                           65385     0xff69
Help                             65386     0xff6a
Break                            65387     0xff6b
Hebrew_switch                    65406     0xff7e
Num_Lock                         65407     0xff7f
KP_Space                         65408     0xff80
KP_Tab                           65417     0xff89
KP_Enter                         65421     0xff8d
KP_F1                            65425     0xff91
KP_F2                            65426     0xff92
KP_F3                            65427     0xff93
KP_F4                            65428     0xff94
KP_Multiply                      65450     0xffaa
KP_Add                           65451     0xffab
KP_Separator                     65452     0xffac
KP_Subtract                      65453     0xffad
KP_Decimal                       65454     0xffae
KP_Divide                        65455     0xffaf
KP_0                             65456     0xffb0
KP_1                             65457     0xffb1
KP_2                             65458     0xffb2
KP_3                             65459     0xffb3
KP_4                             65460     0xffb4
KP_5                             65461     0xffb5
KP_6                             65462     0xffb6
KP_7                             65463     0xffb7
KP_8                             65464     0xffb8
KP_9                             65465     0xffb9
KP_Equal                         65469     0xffbd
F1                               65470     0xffbe
F2                               65471     0xffbf
F3                               65472     0xffc0
F4                               65473     0xffc1
F5                               65474     0xffc2
F6                               65475     0xffc3
F7                               65476     0xffc4
F8                               65477     0xffc5
F9                               65478     0xffc6
F10                              65479     0xffc7
L1                               65480     0xffc8
L2                               65481     0xffc9
L3                               65482     0xffca
L4                               65483     0xffcb
L5                               65484     0xffcc
L6                               65485     0xffcd
L7                               65486     0xffce
L8                               65487     0xffcf
L9                               65488     0xffd0
L10                              65489     0xffd1
R1                               65490     0xffd2
R2                               65491     0xffd3
R3                               65492     0xffd4
R4                               65493     0xffd5
R5                               65494     0xffd6
R6                               65495     0xffd7
R7                               65496     0xffd8
R8                               65497     0xffd9
R9                               65498     0xffda
R10                              65499     0xffdb
R11                              65500     0xffdc
R12                              65501     0xffdd
F33                              65502     0xffde
R14                              65503     0xffdf
R15                              65504     0xffe0
Shift_L                          65505     0xffe1
Shift_R                          65506     0xffe2
Control_L                        65507     0xffe3
Control_R                        65508     0xffe4
Caps_Lock                        65509     0xffe5
Shift_Lock                       65510     0xffe6
Meta_L                           65511     0xffe7
Meta_R                           65512     0xffe8
Alt_L                            65513     0xffe9
Alt_R                            65514     0xffea
Super_L                          65515     0xffeb
Super_R                          65516     0xffec
Hyper_L                          65517     0xffed
Hyper_R                          65518     0xffee
Delete                           65535     0xffff</t>
<t tx="T187">paragraph                          182     0x00b6
periodcentered                     183     0x00b7

section                            167     0x00a7
notsign                            172     0x00ac
hyphen                             173     0x00ad
degree                             176     0x00b0
plusminus                          177     0x00b1

copyright                          169     0x00a9
registered                         174     0x00ae</t>
<t tx="T188">exclamdown                         161     0x00a1
cent                               162     0x00a2
sterling                           163     0x00a3
currency                           164     0x00a4
yen                                165     0x00a5
brokenbar                          166     0x00a6
diaeresis                          168     0x00a8
ordfeminine                        170     0x00aa
guillemotleft                      171     0x00ab
macron                             175     0x00af
twosuperior                        178     0x00b2
threesuperior                      179     0x00b3
acute                              180     0x00b4
mu                                 181     0x00b5
cedilla                            184     0x00b8
onesuperior                        185     0x00b9
masculine                          186     0x00ba
guillemotright                     187     0x00bb
onequarter                         188     0x00bc
onehalf                            189     0x00bd
threequarters                      190     0x00be
questiondown                       191     0x00bf

Agrave                             192     0x00c0
Aacute                             193     0x00c1
Acircumflex                        194     0x00c2
Atilde                             195     0x00c3
Adiaeresis                         196     0x00c4
Aring                              197     0x00c5
AE                                 198     0x00c6
Ccedilla                           199     0x00c7
Egrave                             200     0x00c8
Eacute                             201     0x00c9
Ecircumflex                        202     0x00ca
Ediaeresis                         203     0x00cb
Igrave                             204     0x00cc
Iacute                             205     0x00cd
Icircumflex                        206     0x00ce
Idiaeresis                         207     0x00cf
Eth                                208     0x00d0
Ntilde                             209     0x00d1
Ograve                             210     0x00d2
Oacute                             211     0x00d3
Ocircumflex                        212     0x00d4
Otilde                             213     0x00d5
Odiaeresis                         214     0x00d6
multiply                           215     0x00d7
Ooblique                           216     0x00d8
Ugrave                             217     0x00d9
Uacute                             218     0x00da
Ucircumflex                        219     0x00db
Udiaeresis                         220     0x00dc
Yacute                             221     0x00dd
Thorn                              222     0x00de
ssharp                             223     0x00df
agrave                             224     0x00e0
aacute                             225     0x00e1
acircumflex                        226     0x00e2
atilde                             227     0x00e3
adiaeresis                         228     0x00e4
aring                              229     0x00e5
ae                                 230     0x00e6
ccedilla                           231     0x00e7
egrave                             232     0x00e8
eacute                             233     0x00e9
ecircumflex                        234     0x00ea
ediaeresis                         235     0x00eb
igrave                             236     0x00ec
iacute                             237     0x00ed
icircumflex                        238     0x00ee
idiaeresis                         239     0x00ef
eth                                240     0x00f0
ntilde                             241     0x00f1
ograve                             242     0x00f2
oacute                             243     0x00f3
ocircumflex                        244     0x00f4
otilde                             245     0x00f5
odiaeresis                         246     0x00f6
division                           247     0x00f7
oslash                             248     0x00f8
ugrave                             249     0x00f9
uacute                             250     0x00fa
ucircumflex                        251     0x00fb
udiaeresis                         252     0x00fc
yacute                             253     0x00fd
thorn                              254     0x00fe
ydiaeresis                         255     0x00ff
Aogonek                            417     0x01a1
breve                              418     0x01a2
Lstroke                            419     0x01a3
Lcaron                             421     0x01a5
Sacute                             422     0x01a6
Scaron                             425     0x01a9
Scedilla                           426     0x01aa
Tcaron                             427     0x01ab
Zacute                             428     0x01ac
Zcaron                             430     0x01ae
Zabovedot                          431     0x01af
aogonek                            433     0x01b1
ogonek                             434     0x01b2
lstroke                            435     0x01b3
lcaron                             437     0x01b5
sacute                             438     0x01b6
caron                              439     0x01b7
scaron                             441     0x01b9
scedilla                           442     0x01ba
tcaron                             443     0x01bb
zacute                             444     0x01bc
doubleacute                        445     0x01bd
zcaron                             446     0x01be
zabovedot                          447     0x01bf
Racute                             448     0x01c0
Abreve                             451     0x01c3
Cacute                             454     0x01c6
Ccaron                             456     0x01c8
Eogonek                            458     0x01ca
Ecaron                             460     0x01cc
Dcaron                             463     0x01cf
Nacute                             465     0x01d1
Ncaron                             466     0x01d2
Odoubleacute                       469     0x01d5
Rcaron                             472     0x01d8
Uring                              473     0x01d9
Udoubleacute                       475     0x01db
Tcedilla                           478     0x01de
racute                             480     0x01e0
abreve                             483     0x01e3
cacute                             486     0x01e6
ccaron                             488     0x01e8
eogonek                            490     0x01ea
ecaron                             492     0x01ec
dcaron                             495     0x01ef
nacute                             497     0x01f1
ncaron                             498     0x01f2
odoubleacute                       501     0x01f5
rcaron                             504     0x01f8
uring                              505     0x01f9
udoubleacute                       507     0x01fb
tcedilla                           510     0x01fe
abovedot                           511     0x01ff
Hstroke                            673     0x02a1
Hcircumflex                        678     0x02a6
Iabovedot                          681     0x02a9
Gbreve                             683     0x02ab
Jcircumflex                        684     0x02ac
hstroke                            689     0x02b1
hcircumflex                        694     0x02b6
idotless                           697     0x02b9
gbreve                             699     0x02bb
jcircumflex                        700     0x02bc
Cabovedot                          709     0x02c5
Ccircumflex                        710     0x02c6
Gabovedot                          725     0x02d5
Gcircumflex                        728     0x02d8
Ubreve                             733     0x02dd
Scircumflex                        734     0x02de
cabovedot                          741     0x02e5
ccircumflex                        742     0x02e6
gabovedot                          757     0x02f5
gcircumflex                        760     0x02f8
ubreve                             765     0x02fd
scircumflex                        766     0x02fe
kappa                              930     0x03a2
Rcedilla                           931     0x03a3
Itilde                             933     0x03a5
Lcedilla                           934     0x03a6
Emacron                            938     0x03aa
Gcedilla                           939     0x03ab
Tslash                             940     0x03ac
rcedilla                           947     0x03b3
itilde                             949     0x03b5
lcedilla                           950     0x03b6
emacron                            954     0x03ba
gacute                             955     0x03bb
tslash                             956     0x03bc
ENG                                957     0x03bd
eng                                959     0x03bf
Amacron                            960     0x03c0
Iogonek                            967     0x03c7
Eabovedot                          972     0x03cc
Imacron                            975     0x03cf
Ncedilla                           977     0x03d1
Omacron                            978     0x03d2
Kcedilla                           979     0x03d3
Uogonek                            985     0x03d9
Utilde                             989     0x03dd
Umacron                            990     0x03de
amacron                            992     0x03e0
iogonek                            999     0x03e7
eabovedot                         1004     0x03ec
imacron                           1007     0x03ef
ncedilla                          1009     0x03f1
omacron                           1010     0x03f2
kcedilla                          1011     0x03f3
uogonek                           1017     0x03f9
utilde                            1021     0x03fd
umacron                           1022     0x03fe
overline                          1150     0x047e
kana_fullstop                     1185     0x04a1
kana_openingbracket               1186     0x04a2
kana_closingbracket               1187     0x04a3
kana_comma                        1188     0x04a4
kana_middledot                    1189     0x04a5
kana_WO                           1190     0x04a6
kana_a                            1191     0x04a7
kana_i                            1192     0x04a8
kana_u                            1193     0x04a9
kana_e                            1194     0x04aa
kana_o                            1195     0x04ab
kana_ya                           1196     0x04ac
kana_yu                           1197     0x04ad
kana_yo                           1198     0x04ae
kana_tu                           1199     0x04af
prolongedsound                    1200     0x04b0
kana_A                            1201     0x04b1
kana_I                            1202     0x04b2
kana_U                            1203     0x04b3
kana_E                            1204     0x04b4
kana_O                            1205     0x04b5
kana_KA                           1206     0x04b6
kana_KI                           1207     0x04b7
kana_KU                           1208     0x04b8
kana_KE                           1209     0x04b9
kana_KO                           1210     0x04ba
kana_SA                           1211     0x04bb
kana_SHI                          1212     0x04bc
kana_SU                           1213     0x04bd
kana_SE                           1214     0x04be
kana_SO                           1215     0x04bf
kana_TA                           1216     0x04c0
kana_TI                           1217     0x04c1
kana_TU                           1218     0x04c2
kana_TE                           1219     0x04c3
kana_TO                           1220     0x04c4
kana_NA                           1221     0x04c5
kana_NI                           1222     0x04c6
kana_NU                           1223     0x04c7
kana_NE                           1224     0x04c8
kana_NO                           1225     0x04c9
kana_HA                           1226     0x04ca
kana_HI                           1227     0x04cb
kana_HU                           1228     0x04cc
kana_HE                           1229     0x04cd
kana_HO                           1230     0x04ce
kana_MA                           1231     0x04cf
kana_MI                           1232     0x04d0
kana_MU                           1233     0x04d1
kana_ME                           1234     0x04d2
kana_MO                           1235     0x04d3
kana_YA                           1236     0x04d4
kana_YU                           1237     0x04d5
kana_YO                           1238     0x04d6
kana_RA                           1239     0x04d7
kana_RI                           1240     0x04d8
kana_RU                           1241     0x04d9
kana_RE                           1242     0x04da
kana_RO                           1243     0x04db
kana_WA                           1244     0x04dc
kana_N                            1245     0x04dd
voicedsound                       1246     0x04de
semivoicedsound                   1247     0x04df
Arabic_comma                      1452     0x05ac
Arabic_semicolon                  1467     0x05bb
Arabic_question_mark              1471     0x05bf
Arabic_hamza                      1473     0x05c1
Arabic_maddaonalef                1474     0x05c2
Arabic_hamzaonalef                1475     0x05c3
Arabic_hamzaonwaw                 1476     0x05c4
Arabic_hamzaunderalef             1477     0x05c5
Arabic_hamzaonyeh                 1478     0x05c6
Arabic_alef                       1479     0x05c7
Arabic_beh                        1480     0x05c8
Arabic_tehmarbuta                 1481     0x05c9
Arabic_teh                        1482     0x05ca
Arabic_theh                       1483     0x05cb
Arabic_jeem                       1484     0x05cc
Arabic_hah                        1485     0x05cd
Arabic_khah                       1486     0x05ce
Arabic_dal                        1487     0x05cf
Arabic_thal                       1488     0x05d0
Arabic_ra                         1489     0x05d1
Arabic_zain                       1490     0x05d2
Arabic_seen                       1491     0x05d3
Arabic_sheen                      1492     0x05d4
Arabic_sad                        1493     0x05d5
Arabic_dad                        1494     0x05d6
Arabic_tah                        1495     0x05d7
Arabic_zah                        1496     0x05d8
Arabic_ain                        1497     0x05d9
Arabic_ghain                      1498     0x05da
Arabic_tatweel                    1504     0x05e0
Arabic_feh                        1505     0x05e1
Arabic_qaf                        1506     0x05e2
Arabic_kaf                        1507     0x05e3
Arabic_lam                        1508     0x05e4
Arabic_meem                       1509     0x05e5
Arabic_noon                       1510     0x05e6
Arabic_heh                        1511     0x05e7
Arabic_waw                        1512     0x05e8
Arabic_alefmaksura                1513     0x05e9
Arabic_yeh                        1514     0x05ea
Arabic_fathatan                   1515     0x05eb
Arabic_dammatan                   1516     0x05ec
Arabic_kasratan                   1517     0x05ed
Arabic_fatha                      1518     0x05ee
Arabic_damma                      1519     0x05ef
Arabic_kasra                      1520     0x05f0
Arabic_shadda                     1521     0x05f1
Arabic_sukun                      1522     0x05f2
Serbian_dje                       1697     0x06a1
Macedonia_gje                     1698     0x06a2
Cyrillic_io                       1699     0x06a3
Ukranian_je                       1700     0x06a4
Macedonia_dse                     1701     0x06a5
Ukranian_i                        1702     0x06a6
Ukranian_yi                       1703     0x06a7
Serbian_je                        1704     0x06a8
Serbian_lje                       1705     0x06a9
Serbian_nje                       1706     0x06aa
Serbian_tshe                      1707     0x06ab
Macedonia_kje                     1708     0x06ac
Byelorussian_shortu               1710     0x06ae
Serbian_dze                       1711     0x06af
numerosign                        1712     0x06b0
Serbian_DJE                       1713     0x06b1
Macedonia_GJE                     1714     0x06b2
Cyrillic_IO                       1715     0x06b3
Ukranian_JE                       1716     0x06b4
Macedonia_DSE                     1717     0x06b5
Ukranian_I                        1718     0x06b6
Ukranian_YI                       1719     0x06b7
Serbian_JE                        1720     0x06b8
Serbian_LJE                       1721     0x06b9
Serbian_NJE                       1722     0x06ba
Serbian_TSHE                      1723     0x06bb
Macedonia_KJE                     1724     0x06bc
Byelorussian_SHORTU               1726     0x06be
Serbian_DZE                       1727     0x06bf
Cyrillic_yu                       1728     0x06c0
Cyrillic_a                        1729     0x06c1
Cyrillic_be                       1730     0x06c2
Cyrillic_tse                      1731     0x06c3
Cyrillic_de                       1732     0x06c4
Cyrillic_ie                       1733     0x06c5
Cyrillic_ef                       1734     0x06c6
Cyrillic_ghe                      1735     0x06c7
Cyrillic_ha                       1736     0x06c8
Cyrillic_i                        1737     0x06c9
Cyrillic_shorti                   1738     0x06ca
Cyrillic_ka                       1739     0x06cb
Cyrillic_el                       1740     0x06cc
Cyrillic_em                       1741     0x06cd
Cyrillic_en                       1742     0x06ce
Cyrillic_o                        1743     0x06cf
Cyrillic_pe                       1744     0x06d0
Cyrillic_ya                       1745     0x06d1
Cyrillic_er                       1746     0x06d2
Cyrillic_es                       1747     0x06d3
Cyrillic_te                       1748     0x06d4
Cyrillic_u                        1749     0x06d5
Cyrillic_zhe                      1750     0x06d6
Cyrillic_ve                       1751     0x06d7
Cyrillic_softsign                 1752     0x06d8
Cyrillic_yeru                     1753     0x06d9
Cyrillic_ze                       1754     0x06da
Cyrillic_sha                      1755     0x06db
Cyrillic_e                        1756     0x06dc
Cyrillic_shcha                    1757     0x06dd
Cyrillic_che                      1758     0x06de
Cyrillic_hardsign                 1759     0x06df
Cyrillic_YU                       1760     0x06e0
Cyrillic_A                        1761     0x06e1
Cyrillic_BE                       1762     0x06e2
Cyrillic_TSE                      1763     0x06e3
Cyrillic_DE                       1764     0x06e4
Cyrillic_IE                       1765     0x06e5
Cyrillic_EF                       1766     0x06e6
Cyrillic_GHE                      1767     0x06e7
Cyrillic_HA                       1768     0x06e8
Cyrillic_I                        1769     0x06e9
Cyrillic_SHORTI                   1770     0x06ea
Cyrillic_KA                       1771     0x06eb
Cyrillic_EL                       1772     0x06ec
Cyrillic_EM                       1773     0x06ed
Cyrillic_EN                       1774     0x06ee
Cyrillic_O                        1775     0x06ef
Cyrillic_PE                       1776     0x06f0
Cyrillic_YA                       1777     0x06f1
Cyrillic_ER                       1778     0x06f2
Cyrillic_ES                       1779     0x06f3
Cyrillic_TE                       1780     0x06f4
Cyrillic_U                        1781     0x06f5
Cyrillic_ZHE                      1782     0x06f6
Cyrillic_VE                       1783     0x06f7
Cyrillic_SOFTSIGN                 1784     0x06f8
Cyrillic_YERU                     1785     0x06f9
Cyrillic_ZE                       1786     0x06fa
Cyrillic_SHA                      1787     0x06fb
Cyrillic_E                        1788     0x06fc
Cyrillic_SHCHA                    1789     0x06fd
Cyrillic_CHE                      1790     0x06fe
Cyrillic_HARDSIGN                 1791     0x06ff
Greek_ALPHAaccent                 1953     0x07a1
Greek_EPSILONaccent               1954     0x07a2
Greek_ETAaccent                   1955     0x07a3
Greek_IOTAaccent                  1956     0x07a4
Greek_IOTAdiaeresis               1957     0x07a5
Greek_IOTAaccentdiaeresis         1958     0x07a6
Greek_OMICRONaccent               1959     0x07a7
Greek_UPSILONaccent               1960     0x07a8
Greek_UPSILONdieresis             1961     0x07a9
Greek_UPSILONaccentdieresis       1962     0x07aa
Greek_OMEGAaccent                 1963     0x07ab
Greek_alphaaccent                 1969     0x07b1
Greek_epsilonaccent               1970     0x07b2
Greek_etaaccent                   1971     0x07b3
Greek_iotaaccent                  1972     0x07b4
Greek_iotadieresis                1973     0x07b5
Greek_iotaaccentdieresis          1974     0x07b6
Greek_omicronaccent               1975     0x07b7
Greek_upsilonaccent               1976     0x07b8
Greek_upsilondieresis             1977     0x07b9
Greek_upsilonaccentdieresis       1978     0x07ba
Greek_omegaaccent                 1979     0x07bb
Greek_ALPHA                       1985     0x07c1
Greek_BETA                        1986     0x07c2
Greek_GAMMA                       1987     0x07c3
Greek_DELTA                       1988     0x07c4
Greek_EPSILON                     1989     0x07c5
Greek_ZETA                        1990     0x07c6
Greek_ETA                         1991     0x07c7
Greek_THETA                       1992     0x07c8
Greek_IOTA                        1993     0x07c9
Greek_KAPPA                       1994     0x07ca
Greek_LAMBDA                      1995     0x07cb
Greek_MU                          1996     0x07cc
Greek_NU                          1997     0x07cd
Greek_XI                          1998     0x07ce
Greek_OMICRON                     1999     0x07cf
Greek_PI                          2000     0x07d0
Greek_RHO                         2001     0x07d1
Greek_SIGMA                       2002     0x07d2
Greek_TAU                         2004     0x07d4
Greek_UPSILON                     2005     0x07d5
Greek_PHI                         2006     0x07d6
Greek_CHI                         2007     0x07d7
Greek_PSI                         2008     0x07d8
Greek_OMEGA                       2009     0x07d9
Greek_alpha                       2017     0x07e1
Greek_beta                        2018     0x07e2
Greek_gamma                       2019     0x07e3
Greek_delta                       2020     0x07e4
Greek_epsilon                     2021     0x07e5
Greek_zeta                        2022     0x07e6
Greek_eta                         2023     0x07e7
Greek_theta                       2024     0x07e8
Greek_iota                        2025     0x07e9
Greek_kappa                       2026     0x07ea
Greek_lambda                      2027     0x07eb
Greek_mu                          2028     0x07ec
Greek_nu                          2029     0x07ed
Greek_xi                          2030     0x07ee
Greek_omicron                     2031     0x07ef
Greek_pi                          2032     0x07f0
Greek_rho                         2033     0x07f1
Greek_sigma                       2034     0x07f2
Greek_finalsmallsigma             2035     0x07f3
Greek_tau                         2036     0x07f4
Greek_upsilon                     2037     0x07f5
Greek_phi                         2038     0x07f6
Greek_chi                         2039     0x07f7
Greek_psi                         2040     0x07f8
Greek_omega                       2041     0x07f9
leftradical                       2209     0x08a1
topleftradical                    2210     0x08a2
horizconnector                    2211     0x08a3
topintegral                       2212     0x08a4
botintegral                       2213     0x08a5
vertconnector                     2214     0x08a6
topleftsqbracket                  2215     0x08a7
botleftsqbracket                  2216     0x08a8
toprightsqbracket                 2217     0x08a9
botrightsqbracket                 2218     0x08aa
topleftparens                     2219     0x08ab
botleftparens                     2220     0x08ac
toprightparens                    2221     0x08ad
botrightparens                    2222     0x08ae
leftmiddlecurlybrace              2223     0x08af
rightmiddlecurlybrace             2224     0x08b0
topleftsummation                  2225     0x08b1
botleftsummation                  2226     0x08b2
topvertsummationconnector         2227     0x08b3
botvertsummationconnector         2228     0x08b4
toprightsummation                 2229     0x08b5
botrightsummation                 2230     0x08b6
rightmiddlesummation              2231     0x08b7
lessthanequal                     2236     0x08bc
notequal                          2237     0x08bd
greaterthanequal                  2238     0x08be
integral                          2239     0x08bf
therefore                         2240     0x08c0
variation                         2241     0x08c1
infinity                          2242     0x08c2
nabla                             2245     0x08c5
approximate                       2248     0x08c8
similarequal                      2249     0x08c9
ifonlyif                          2253     0x08cd
implies                           2254     0x08ce
identical                         2255     0x08cf
radical                           2262     0x08d6
includedin                        2266     0x08da
includes                          2267     0x08db
intersection                      2268     0x08dc
union                             2269     0x08dd
logicaland                        2270     0x08de
logicalor                         2271     0x08df
partialderivative                 2287     0x08ef
function                          2294     0x08f6
leftarrow                         2299     0x08fb
uparrow                           2300     0x08fc
rightarrow                        2301     0x08fd
downarrow                         2302     0x08fe
blank                             2527     0x09df
soliddiamond                      2528     0x09e0
checkerboard                      2529     0x09e1
ht                                2530     0x09e2
ff                                2531     0x09e3
cr                                2532     0x09e4
lf                                2533     0x09e5
nl                                2536     0x09e8
vt                                2537     0x09e9
lowrightcorner                    2538     0x09ea
uprightcorner                     2539     0x09eb
upleftcorner                      2540     0x09ec
lowleftcorner                     2541     0x09ed
crossinglines                     2542     0x09ee
horizlinescan1                    2543     0x09ef
horizlinescan3                    2544     0x09f0
horizlinescan5                    2545     0x09f1
horizlinescan7                    2546     0x09f2
horizlinescan9                    2547     0x09f3
leftt                             2548     0x09f4
rightt                            2549     0x09f5
bott                              2550     0x09f6
topt                              2551     0x09f7
vertbar                           2552     0x09f8
emspace                           2721     0x0aa1
enspace                           2722     0x0aa2
em3space                          2723     0x0aa3
em4space                          2724     0x0aa4
digitspace                        2725     0x0aa5
punctspace                        2726     0x0aa6
thinspace                         2727     0x0aa7
hairspace                         2728     0x0aa8
emdash                            2729     0x0aa9
endash                            2730     0x0aaa
signifblank                       2732     0x0aac
ellipsis                          2734     0x0aae
doubbaselinedot                   2735     0x0aaf
onethird                          2736     0x0ab0
twothirds                         2737     0x0ab1
onefifth                          2738     0x0ab2
twofifths                         2739     0x0ab3
threefifths                       2740     0x0ab4
fourfifths                        2741     0x0ab5
onesixth                          2742     0x0ab6
fivesixths                        2743     0x0ab7
careof                            2744     0x0ab8
figdash                           2747     0x0abb
leftanglebracket                  2748     0x0abc
decimalpoint                      2749     0x0abd
rightanglebracket                 2750     0x0abe
marker                            2751     0x0abf
oneeighth                         2755     0x0ac3
threeeighths                      2756     0x0ac4
fiveeighths                       2757     0x0ac5
seveneighths                      2758     0x0ac6
trademark                         2761     0x0ac9
signaturemark                     2762     0x0aca
trademarkincircle                 2763     0x0acb
leftopentriangle                  2764     0x0acc
rightopentriangle                 2765     0x0acd
emopencircle                      2766     0x0ace
emopenrectangle                   2767     0x0acf
leftsinglequotemark               2768     0x0ad0
rightsinglequotemark              2769     0x0ad1
leftdoublequotemark               2770     0x0ad2
rightdoublequotemark              2771     0x0ad3
prescription                      2772     0x0ad4
minutes                           2774     0x0ad6
seconds                           2775     0x0ad7
latincross                        2777     0x0ad9
hexagram                          2778     0x0ada
filledrectbullet                  2779     0x0adb
filledlefttribullet               2780     0x0adc
filledrighttribullet              2781     0x0add
emfilledcircle                    2782     0x0ade
emfilledrect                      2783     0x0adf
enopencircbullet                  2784     0x0ae0
enopensquarebullet                2785     0x0ae1
openrectbullet                    2786     0x0ae2
opentribulletup                   2787     0x0ae3
opentribulletdown                 2788     0x0ae4
openstar                          2789     0x0ae5
enfilledcircbullet                2790     0x0ae6
enfilledsqbullet                  2791     0x0ae7
filledtribulletup                 2792     0x0ae8
filledtribulletdown               2793     0x0ae9
leftpointer                       2794     0x0aea
rightpointer                      2795     0x0aeb
club                              2796     0x0aec
diamond                           2797     0x0aed
heart                             2798     0x0aee
maltesecross                      2800     0x0af0
dagger                            2801     0x0af1
doubledagger                      2802     0x0af2
checkmark                         2803     0x0af3
ballotcross                       2804     0x0af4
musicalsharp                      2805     0x0af5
musicalflat                       2806     0x0af6
malesymbol                        2807     0x0af7
femalesymbol                      2808     0x0af8
telephone                         2809     0x0af9
telephonerecorder                 2810     0x0afa
phonographcopyright               2811     0x0afb
caret                             2812     0x0afc
singlelowquotemark                2813     0x0afd
doublelowquotemark                2814     0x0afe
cursor                            2815     0x0aff
leftcaret                         2979     0x0ba3
rightcaret                        2982     0x0ba6
downcaret                         2984     0x0ba8
upcaret                           2985     0x0ba9
overbar                           3008     0x0bc0
downtack                          3010     0x0bc2
upshoe                            3011     0x0bc3
downstile                         3012     0x0bc4
underbar                          3014     0x0bc6
jot                               3018     0x0bca
quad                              3020     0x0bcc
uptack                            3022     0x0bce
circle                            3023     0x0bcf
upstile                           3027     0x0bd3
downshoe                          3030     0x0bd6
rightshoe                         3032     0x0bd8
leftshoe                          3034     0x0bda
lefttack                          3036     0x0bdc
righttack                         3068     0x0bfc
hebrew_aleph                      3296     0x0ce0
hebrew_beth                       3297     0x0ce1
hebrew_gimmel                     3298     0x0ce2
hebrew_daleth                     3299     0x0ce3
hebrew_he                         3300     0x0ce4
hebrew_waw                        3301     0x0ce5
hebrew_zayin                      3302     0x0ce6
hebrew_het                        3303     0x0ce7
hebrew_teth                       3304     0x0ce8
hebrew_yod                        3305     0x0ce9
hebrew_finalkaph                  3306     0x0cea
hebrew_kaph                       3307     0x0ceb
hebrew_lamed                      3308     0x0cec
hebrew_finalmem                   3309     0x0ced
hebrew_mem                        3310     0x0cee
hebrew_finalnun                   3311     0x0cef
hebrew_nun                        3312     0x0cf0
hebrew_samekh                     3313     0x0cf1
hebrew_ayin                       3314     0x0cf2
hebrew_finalpe                    3315     0x0cf3
hebrew_pe                         3316     0x0cf4
hebrew_finalzadi                  3317     0x0cf5
hebrew_zadi                       3318     0x0cf6
hebrew_kuf                        3319     0x0cf7
hebrew_resh                       3320     0x0cf8
hebrew_shin                       3321     0x0cf9
hebrew_taf                        3322     0x0cfa</t>
<t tx="T189">@ignore</t>
<t tx="T190">@language python
@ignore
@color</t>
<t tx="T191">@ignore</t>
<t tx="T192"># How do we remember the state?
# How do we insert, delete and move nodes?
# Is it worth it to do this in tcl, or should I wait for tkinter??

proc createTree {w} {

	Canvas $w.c
	## pack??
}</t>
<t tx="T193">def flip(self, event=None):

	if self.state == 'expanded':
		self.collapse()
	else:
		self.expand()
	self.item.OnDoubleClick()
	return "break"
</t>
<t tx="T194">def expand(self, event=None):

	if not self.item._IsExpandable():
		return
	if self.state != 'expanded':
		self.state = 'expanded'
		self.update()
		self.view()
</t>
<t tx="T195">def collapse(self, event=None):

	if self.state != 'collapsed':
		self.state = 'collapsed'
		self.update()
</t>
<t tx="T196">def geticonimage(self, name):

	try:
		return self.iconimages[name]
	except KeyError:
		pass

	file, ext = os.path.splitext(name)
	ext = ext or ".gif"
	fullname = os.path.join(ICONDIR, file + ext)
	image = PhotoImage(master=self.canvas, file=fullname)
	self.iconimages[name] = image
	return image
</t>
<t tx="T197">def view(self):

	top = self.y - 2
	bottom = self.lastvisiblechild().y + 17
	height = bottom - top
	visible_top = self.canvas.canvasy(0)
	visible_height = self.canvas.winfo_height()
	visible_bottom = self.canvas.canvasy(visible_height)
	if visible_top &lt;= top and bottom &lt;= visible_bottom:
		return

	# EKR: I think this scrolls the canvas to match the scrollregion
	x0, y0, x1, y1 = self.canvas._getints(self.canvas['scrollregion'])
	if top &gt;= visible_top and height &lt;= visible_height:
		fraction = top + height - visible_height
	else:
		fraction = top
	fraction = float(fraction) / y1
	self.canvas.yview_moveto(fraction)
</t>
<t tx="T198">def lastvisiblechild(self):

	if self.children and self.state == 'expanded':
		return self.children[-1].lastvisiblechild()
	else:
		return self
</t>
<t tx="T199">def update(self):

	# EKR: I would do v=self.findRoot(), etc.

	if self.parent:  # EKR: update starting with root node.
		self.parent.update()
	else:
		oldcursor = self.canvas['cursor']
		self.canvas['cursor'] = "watch"
		if 1: # EKR: erase and redraw everything
			self.canvas.update()
			self.canvas.delete(ALL)     # XXX could be more subtle.  EKR, but why bother?
			self.draw(7, 2)
			x0, y0, x1, y1 = self.canvas.bbox(ALL)
			self.canvas.configure(scrollregion=(0, 0, x1, y1))
		self.canvas['cursor'] = oldcursor
</t>
<t tx="T200"># EKR: draws icon at self.x, self.y

def drawicon(self):

	if self.selected:
		imagename = (self.item.GetSelectedIconName() or
					 self.item.GetIconName() or
					 "openfolder")
	else:
		imagename = self.item.GetIconName() or "folder"
		
	# EKR: I would do: image = self.imageList[self.iconVal]
	image = self.geticonimage(imagename)
	id = self.canvas.create_image(self.x, self.y, anchor="nw", image=image)
	self.image_id = id
	self.canvas.tag_bind(id, "&lt;1&gt;", self.select)
	self.canvas.tag_bind(id, "&lt;Double-1&gt;", self.flip)
</t>
<t tx="T201">@ EKR: draws the receiver and all its descendants at x,y and returns the tree's total height.

EKR: modified from IDLE code
	all vnodes have treeNode and firstChild fields
	self.state --&gt; self.expanded
@c

def draw(self, x, y):
	# XXX This hard-codes too many geometry constants!
	self.x, self.y = x, y
	self.drawicon() # EKR: should return height of icon
	self.drawtext() # EKR: should return height of text
	if not self.expanded:
		return y+17
	# draw children
	cx = x+20 # ekr: indent child by 20
	cy = y+17 # ekr: height of first child is 17 below parent
	cylast = 0
	child = self.v.firstChild:
	while child:
		cylast = cy
		&lt;&lt; draw the horizontal line to the child &gt;&gt;
		# EKR: recursively draw child and all its descendants
		cy = child.treeNode.draw(cx, cy)
		if child.firstChild:
			&lt;&lt; draw the plus or minus icon &gt;&gt;
			&lt;&lt; Add bindings for plus or minus icon &gt;&gt;
		child = child.next
	&lt;&lt; draw the vertical line to the left of all children &gt;&gt;
	return cy # EKR: return total height of node and its children
</t>
<t tx="T202">sublist = self.item._GetSubList()
if not sublist:
	# _IsExpandable() was mistaken; that's allowed
	return y+17

for item in sublist:
	child = TreeNode(self.canvas, self, item)
	self.children.append(child)
</t>
<t tx="T203">@ EKR: The horizontal line runs from the vertical line to the left of all children at x+9 to the child's icon at cx = x+20
@c

self.canvas.create_line(x+9, cy+7, cx, cy+7, fill="gray50")
</t>
<t tx="T204"># EKR: this icon will overlay part of the horizontal line just drawn.

if child.state == 'expanded':
	iconname = "minusnode"
	callback = child.collapse
else:
	iconname = "plusnode"
	callback = child.expand

image = self.geticonimage(iconname)
id = self.canvas.create_image(x+9, cylast+7, image=image)
</t>
<t tx="T205"># XXX This leaks bindings until canvas is deleted:
self.canvas.tag_bind(id, "&lt;1&gt;", callback)
self.canvas.tag_bind(id, "&lt;Double-1&gt;", lambda x: None)
</t>
<t tx="T206"># EKR: the line is at x+9

id = self.canvas.create_line(x+9, y+10, x+9, cylast+7,
	##stipple="gray50",     # XXX Seems broken in Tk 8.0.x
	fill="gray50")
self.canvas.tag_lower(id) # XXX .lower(id) before Python 1.5.2
</t>
<t tx="T207">@ EKR
draws text at self.x+20-1, self.y-1
label text preceeds other text (no idea why we need both)
@c

def drawtext(self):

	textx = self.x+20-1
	texty = self.y-1
	
	# EKR: handle label text, whatever that is.
	labeltext = self.item.GetLabelText()
	if labeltext:
		id = self.canvas.create_text(textx, texty, anchor="nw",text=labeltext)
		self.canvas.tag_bind(id, "&lt;1&gt;", self.select)
		self.canvas.tag_bind(id, "&lt;Double-1&gt;", self.flip)
		x0, y0, x1, y1 = self.canvas.bbox(id)
		textx = max(x1, 200) + 10 # Minimum size of box is 200.  Allow 10 more
		
	# Handle regular text
	text = self.item.GetText() or "&lt;no text&gt;"
	try:
		self.entry
	except AttributeError:
		pass
	else:
		self.edit_finish()

	try:
		label = self.label
	except AttributeError:
		# padding carefully selected (on Windows) to match Entry widget:
		self.label = Label(self.canvas, text=text, bd=0, padx=2, pady=2)

	if self.selected:
		self.label.configure(fg="white", bg="darkblue")
	else:
		self.label.configure(fg="black", bg="white")

	id = self.canvas.create_window(textx,texty,anchor="nw",window=self.label)
	self.label.bind("&lt;1&gt;", self.select_or_edit)
	self.label.bind("&lt;Double-1&gt;", self.flip)
	self.text_id = id
</t>
<t tx="T208">def edit(self, event=None):

	self.entry = Entry(self.label, bd=0, highlightthickness=1, width=0)
	self.entry.insert(0, self.label['text'])
	self.entry.selection_range(0, END)
	self.entry.pack(ipadx=5)
	self.entry.focus_set()
	self.entry.bind("&lt;Return&gt;", self.edit_finish)
	self.entry.bind("&lt;Escape&gt;", self.edit_cancel)
</t>
<t tx="T209">def edit_finish(self, event=None):

	try:
		entry = self.entry
		del self.entry
	except AttributeError:
		return

	text = entry.get()
	entry.destroy()
	if text and text != self.item.GetText():
		self.item.SetText(text)
	text = self.item.GetText()
	self.label['text'] = text
	self.drawtext()
	self.canvas.focus_set()
</t>
<t tx="T210">def edit_cancel(self, event=None):

	try:
		entry = self.entry
		del self.entry
	except AttributeError:
		return

	entry.destroy()
	self.drawtext()
	self.canvas.focus_set()
</t>
<t tx="T211">def select(self, event=None):

	if self.selected:
		return
	self.deselectall()
	self.selected = 1
	self.canvas.delete(self.image_id)
	self.drawicon()
	self.drawtext()
</t>
<t tx="T212">def select_or_edit(self, event=None):

	if self.selected and self.item.IsEditable():
		self.edit(event)
	else:
		self.select(event)
</t>
<t tx="T213">def deselect(self, event=None):

	if not self.selected:
		return
	self.selected = 0
	self.canvas.delete(self.image_id)
	self.drawicon()
	self.drawtext()
</t>
<t tx="T214">def deselectall(self):

	if self.parent:
		self.parent.deselectall()
	else:
		self.deselecttree()
</t>
<t tx="T215">def deselecttree(self):

	if self.selected:
		self.deselect()
	for child in self.children:
		child.deselecttree()
</t>
<t tx="T216">#!/bin/sh
# the next line restarts using wish \
exec wish "$0" "$@"

# This script demonstrates the various widgets provided by Tk,
# along with many of the features of the Tk toolkit.  This file
# only contains code to generate the main window for the
# application, which invokes individual demonstrations.  The
# code for the actual demonstrations is contained in separate
# ".tcl" files is this directory, which are sourced by this script
# as needed.

eval destroy [winfo child .]
wm title . "Widget Demonstration"
set widgetDemo 1

&lt;&lt; Create the main window &gt;&gt;
&lt;&lt; Create the text for the text widget &gt;&gt;
@others

</t>
<t tx="T217"># The code below create the main window, consisting of a menu bar
# and a text widget that explains how to use the program, plus lists
# all of the demos as hypertext items.

&lt;&lt; Create the menu bar &gt;&gt;
&lt;&lt; Create the status bar &gt;&gt;
&lt;&lt; Create the text frame &gt;&gt;
&lt;&lt; Create tags for the text widget &gt;&gt;</t>
<t tx="T218">set font {Helvetica 14}
menu .menuBar -tearoff 0
.menuBar add cascade -menu .menuBar.file -label "File" -underline 0
menu .menuBar.file -tearoff 0

# On the Mac use the special .apple menu for the about item
if {$tcl_platform(platform) == "macintosh"} {
    .menuBar add cascade -menu .menuBar.apple
    menu .menuBar.apple -tearoff 0
    .menuBar.apple add command -label "About..." -command "aboutBox"
} else {
    .menuBar.file add command -label "About..." -command "aboutBox" \
	-underline 0 -accelerator "&lt;F1&gt;"
    .menuBar.file add sep
}

.menuBar.file add command -label "Quit" -command "exit" -underline 0 \
    -accelerator "Meta-Q"
. configure -menu .menuBar
bind . &lt;F1&gt; aboutBox
</t>
<t tx="T219">frame .statusBar
label .statusBar.lab -text "   " -relief sunken -bd 1 \
    -font -*-Helvetica-Medium-R-Normal--*-120-*-*-*-*-*-* -anchor w
label .statusBar.foo -width 8 -relief sunken -bd 1 \
    -font -*-Helvetica-Medium-R-Normal--*-120-*-*-*-*-*-* -anchor w
pack .statusBar.lab -side left -padx 2 -expand yes -fill both
pack .statusBar.foo -side left -padx 2
pack .statusBar -side bottom -fill x -pady 2
</t>
<t tx="T220">frame .textFrame
scrollbar .s -orient vertical -command {.t yview} -highlightthickness 0 \
    -takefocus 1
pack .s -in .textFrame -side right -fill y
text .t -yscrollcommand {.s set} -wrap word -width 60 -height 30 -font $font \
    -setgrid 1 -highlightthickness 0 -padx 4 -pady 2 -takefocus 0
pack .t -in .textFrame -expand y -fill both -padx 1
pack  .textFrame -expand yes -fill both
</t>
<t tx="T221"># Create a bunch of tags to use in the text widget, such as those for
# section titles and demo descriptions.  Also define the bindings for tags.

.t tag configure title -font {Helvetica 18 bold}

# We put some "space" characters to the left and right of each demo description
# so that the descriptions are highlighted only when the mouse cursor
# is right over them (but not when the cursor is to their left or right)

.t tag configure demospace -lmargin1 1c -lmargin2 1c

if {[winfo depth .] == 1} {
    .t tag configure demo -lmargin1 1c -lmargin2 1c \
	-underline 1
    .t tag configure visited -lmargin1 1c -lmargin2 1c \
	-underline 1
    .t tag configure hot -background black -foreground white
} else {
    .t tag configure demo -lmargin1 1c -lmargin2 1c \
	-foreground blue -underline 1
    .t tag configure visited -lmargin1 1c -lmargin2 1c \
	-foreground #303080 -underline 1
    .t tag configure hot -foreground red -underline 1
}

.t tag bind demo &lt;ButtonRelease-1&gt; {
    invoke [.t index {@%x,%y}]
}

set lastLine ""

.t tag bind demo &lt;Enter&gt; {
    set lastLine [.t index {@%x,%y linestart}]
    .t tag add hot "$lastLine +1 chars" "$lastLine lineend -1 chars"
    .t config -cursor hand2
    showStatus [.t index {@%x,%y}]
}

.t tag bind demo &lt;Leave&gt; {
    .t tag remove hot 1.0 end
    .t config -cursor xterm
    .statusBar.lab config -text ""
}

.t tag bind demo &lt;Motion&gt; {
    set newLine [.t index {@%x,%y linestart}]
    if {[string compare $newLine $lastLine] != 0} {
    	.t tag remove hot 1.0 end
    	set lastLine $newLine
    
    	set tags [.t tag names {@%x,%y}]
    	set i [lsearch -glob $tags demo-*]
    	if {$i &gt;= 0} {
    	    .t tag add hot "$lastLine +1 chars" "$lastLine lineend -1 chars"
    	}
    }
    showStatus [.t index {@%x,%y}]
}
</t>
<t tx="T222">.t insert end "Tk Widget Demonstrations\n" title

.t insert end {
This application provides a front end for several short scripts that demonstrate what you can do with Tk widgets.  Each of the numbered lines below describes a demonstration;  you can click on it to invoke the demonstration.  Once the demonstration window appears, you can click the "See Code" button to see the Tcl/Tk code that created the demonstration.  If you wish, you can edit the code and click the "Rerun Demo" button in the code window to reinvoke the demonstration with the modified code.

}

.t insert end "Labels, buttons, checkbuttons, and radiobuttons" title
.t insert end " \n " {demospace}
.t insert end "1. Labels (text and bitmaps)." {demo demo-label}
.t insert end " \n " {demospace}
.t insert end "2. Buttons." {demo demo-button}
.t insert end " \n " {demospace}
.t insert end "3. Checkbuttons (select any of a group)." {demo demo-check}
.t insert end " \n " {demospace}
.t insert end "4. Radiobuttons (select one of a group)." {demo demo-radio}
.t insert end " \n " {demospace}
.t insert end "5. A 15-puzzle game made out of buttons." {demo demo-puzzle}
.t insert end " \n " {demospace}
.t insert end "6. Iconic buttons that use bitmaps." {demo demo-icon}
.t insert end " \n " {demospace}
.t insert end "7. Two labels displaying images." {demo demo-image1}
.t insert end " \n " {demospace}
.t insert end "8. A simple user interface for viewing images." \
    {demo demo-image2}
.t insert end " \n " {demospace}

.t insert end \n {} "Listboxes" title
.t insert end " \n " {demospace}
.t insert end "1. 50 states." {demo demo-states}
.t insert end " \n " {demospace}
.t insert end "2. Colors: change the color scheme for the application." \
	{demo demo-colors}
.t insert end " \n " {demospace}
.t insert end "3. A collection of famous sayings." {demo demo-sayings}
.t insert end " \n " {demospace}

.t insert end \n {} "Entries" title
.t insert end " \n " {demospace}
.t insert end "1. Without scrollbars." {demo demo-entry1}
.t insert end " \n " {demospace}
.t insert end "2. With scrollbars." {demo demo-entry2}
.t insert end " \n " {demospace}
.t insert end "3. Simple Rolodex-like form." {demo demo-form}
.t insert end " \n " {demospace}

.t insert end \n {} "Text" title
.t insert end " \n " {demospace}
.t insert end "1. Basic editable text." {demo demo-text}
.t insert end " \n " {demospace}
.t insert end "2. Text display styles." {demo demo-style}
.t insert end " \n " {demospace}
.t insert end "3. Hypertext (tag bindings)." {demo demo-bind}
.t insert end " \n " {demospace}
.t insert end "4. A text widget with embedded windows." {demo demo-twind}
.t insert end " \n " {demospace}
.t insert end "5. A search tool built with a text widget." {demo demo-search}
.t insert end " \n " {demospace}

.t insert end \n {} "Canvases" title
.t insert end " \n " {demospace}
.t insert end "1. The canvas item types." {demo demo-items}
.t insert end " \n " {demospace}
.t insert end "2. A simple 2-D plot." {demo demo-plot}
.t insert end " \n " {demospace}
.t insert end "3. Text items in canvases." {demo demo-ctext}
.t insert end " \n " {demospace}
.t insert end "4. An editor for arrowheads on canvas lines." {demo demo-arrow}
.t insert end " \n " {demospace}
.t insert end "5. A ruler with adjustable tab stops." {demo demo-ruler}
.t insert end " \n " {demospace}
.t insert end "6. A building floor plan." {demo demo-floor}
.t insert end " \n " {demospace}
.t insert end "7. A simple scrollable canvas." {demo demo-cscroll}
.t insert end " \n " {demospace}

.t insert end \n {} "Scales" title
.t insert end " \n " {demospace}
.t insert end "1. Vertical scale." {demo demo-vscale}
.t insert end " \n " {demospace}
.t insert end "2. Horizontal scale." {demo demo-hscale}
.t insert end " \n " {demospace}

.t insert end \n {} "Menus" title
.t insert end " \n " {demospace}
.t insert end "1. Menus and cascades." \
	{demo demo-menu}
.t insert end " \n " {demospace}
.t insert end "2. Menubuttons"\
	{demo demo-menubu}
.t insert end " \n " {demospace}

.t insert end \n {} "Common Dialogs" title
.t insert end " \n " {demospace}
.t insert end "1. Message boxes." {demo demo-msgbox}
.t insert end " \n " {demospace}
.t insert end "2. File selection dialog." {demo demo-filebox}
.t insert end " \n " {demospace}
.t insert end "3. Color picker." {demo demo-clrpick}
.t insert end " \n " {demospace}

.t insert end \n {} "Miscellaneous" title
.t insert end " \n " {demospace}
.t insert end "1. The built-in bitmaps." {demo demo-bitmap}
.t insert end " \n " {demospace}
.t insert end "2. A dialog box with a local grab." {demo demo-dialog1}
.t insert end " \n " {demospace}
.t insert end "3. A dialog box with a global grab." {demo demo-dialog2}
.t insert end " \n " {demospace}

.t configure -state disabled
focus .s</t>
<t tx="T223"># Pops up a message box with an "about" message

proc aboutBox {} {
    tk_messageBox -icon info -type ok -title "About Widget Demo" -message \
		"Tk widget demonstration\n\n\Copyright (c) 1996-1997 Sun Microsystems, Inc."
}
</t>
<t tx="T224"># This procedure invokes a demo when the user clicks on a demo description.
# index - The index of the character that the user clicked on.

proc invoke index {
	global tk_library
	set tags [.t tag names $index]
	set i [lsearch -glob $tags demo-*]
	if {$i &lt; 0} {
		return
	}
	set cursor [.t cget -cursor]
	.t configure -cursor watch
	update
	set demo [string range [lindex $tags $i] 5 end]
	uplevel [list source [file join $tk_library demos $demo.tcl]]
	update
	.t configure -cursor $cursor

	.t tag add visited "$index linestart +1 chars" "$index lineend -1 chars"
}

</t>
<t tx="T225"># Invoked by most of the demos to position a new demo window.
# w - The name of the window to position.

proc positionWindow w {
    wm geometry $w +300+300
}</t>
<t tx="T226"># This procedure creates a toplevel window that displays the code for
# a demonstration and allows it to be edited and reinvoked.
#
# Arguments:
# w - The name of the demonstration's window,
# which can be used to derive the name of the file containing its code.

proc showCode w {
	global tk_library
	set file [string range $w 1 end].tcl
	if ![winfo exists .code] {
		toplevel .code
		frame .code.buttons
		pack .code.buttons -side bottom -fill x
		button .code.buttons.dismiss -text Dismiss \
			-default active -command "destroy .code"
		button .code.buttons.rerun -text "Rerun Demo" -command {
			eval [.code.text get 1.0 end]
		}
		pack .code.buttons.dismiss .code.buttons.rerun -side left \
			-expand 1 -pady 2
		frame .code.frame
		pack  .code.frame -expand yes -fill both -padx 1 -pady 1
		text .code.text -height 40 -wrap word \
			-xscrollcommand ".code.xscroll set" \
			-yscrollcommand ".code.yscroll set" \
			-setgrid 1 -highlightthickness 0 -pady 2 -padx 3
		scrollbar .code.xscroll -command ".code.text xview" \
			-highlightthickness 0 -orient horizontal
		scrollbar .code.yscroll -command ".code.text yview" \
			-highlightthickness 0 -orient vertical
	
		grid .code.text -in .code.frame -padx 1 -pady 1 \
			-row 0 -column 0 -rowspan 1 -columnspan 1 -sticky news
		grid .code.yscroll -in .code.frame -padx 1 -pady 1 \
			-row 0 -column 1 -rowspan 1 -columnspan 1 -sticky news
	#	grid .code.xscroll -in .code.frame -padx 1 -pady 1 \
	#	    -row 1 -column 0 -rowspan 1 -columnspan 1 -sticky news
		grid rowconfig    .code.frame 0 -weight 1 -minsize 0
		grid columnconfig .code.frame 0 -weight 1 -minsize 0
	} else {
		wm deiconify .code
		raise .code
	}
	wm title .code "Demo code: [file join $tk_library demos $file]"
	wm iconname .code $file
	set id [open [file join $tk_library demos $file]]
	.code.text delete 1.0 end
	.code.text insert 1.0 [read $id]
	.code.text mark set insert 1.0
	close $id
}
</t>
<t tx="T227">#	Show the name of the demo program in the status bar. This procedure
#	is called when the user moves the cursor over a demo description.

proc showStatus index {
	global tk_library
	set tags [.t tag names $index]
	set i [lsearch -glob $tags demo-*]
	set cursor [.t cget -cursor]
	if {$i &lt; 0} {
		.statusBar.lab config -text " "
		set newcursor xterm
	} else {
		set demo [string range [lindex $tags $i] 5 end]
		.statusBar.lab config -text "Run the \"$demo\" sample program"
		set newcursor hand2
	}
	if [string compare $cursor $newcursor] {
		.t config -cursor $newcursor
	}
}
</t>
<t tx="T228"># Displays the values of one or more variables in a window, and
# updates the display whenever any of the variables changes.
#
# Arguments:
# w -		Name of new window to create for display.
# args -	Any number of names of variables.

proc showVars {w args} {
	catch {destroy $w}
	toplevel $w
	wm title $w "Variable values"
	label $w.title -text "Variable values:" -width 20 -anchor center \
		-font {Helvetica 18}
	pack $w.title -side top -fill x
	set len 1
	foreach i $args {
		if {[string length $i] &gt; $len} {
			set len [string length $i]
		}
	}
	foreach i $args {
		frame $w.$i
		label $w.$i.name -text "$i: " -width [expr $len + 2] -anchor w
		label $w.$i.value -textvar $i -anchor w
		pack $w.$i.name -side left
		pack $w.$i.value -side left -expand 1 -fill x
		pack $w.$i -side top -anchor w -fill x
	}
	button $w.ok -text OK -command "destroy $w" -default active
	bind $w &lt;Return&gt; "tkButtonInvoke $w.ok"
	pack $w.ok -side bottom -pady 2
}
</t>
<t tx="T229">@ignore
@others</t>
<t tx="T230">proc go {} {
	createLeo 1
	createLeo 2
	createFindPanel
	createPrefsPanel
}

</t>
<t tx="T231">proc createLeo { n } {

	toplevel .leo$n

	# Create two splitters
	createSplitter .leo$n.s 1
	createSplitter .leo$n.s.pane1.s 0 ;# contains tree and log
	
	text      .leo$n.s.pane2.body -bd 2 -yscrollcommand ".leo$n.s.pane2.scroll set" -setgrid 1
	scrollbar .leo$n.s.pane2.scroll -command ".leo$n.s.pane2.body yview"

	pack .leo$n.s.pane2.scroll -side right -fill y
	pack .leo$n.s.pane2.body -expand yes -fill both

	text .leo$n.s.pane1.s.pane1.tree -bd 2 -yscrollcommand ".leo$n.s.pane1.s.pane1.scroll set" -setgrid 1
	scrollbar .leo$n.s.pane1.s.pane1.scroll -command ".leo$n.s.pane1.s.pane1.tree yview"
	
	pack .leo$n.s.pane1.s.pane1.scroll -side right -fill y
	pack .leo$n.s.pane1.s.pane1.tree   -expand yes -fill both

	# -padx is needed to handle overlap of splitter bar
	text      .leo$n.s.pane1.s.pane2.log    -yscrollcommand ".leo$n.s.pane1.s.pane2.scroll set" -setgrid 1 -padx 4
	scrollbar .leo$n.s.pane1.s.pane2.scroll -command ".leo$n.s.pane1.s.pane2.log yview"
	pack .leo$n.s.pane1.s.pane2.scroll -side right -fill y
	pack .leo$n.s.pane1.s.pane2.log -expand yes -fill both
	
	createMenus $n
}</t>
<t tx="T232">proc createMenus { n } {

	# Create the menu bar
	menu .leo$n.menu -tearoff 0

    set m .leo$n.menu.file
    menu $m -tearoff 0

    .leo$n.menu add cascade -label "File" -menu $m -underline 0
	# to do: fill in the commands...
    $m add command -label "Open..." -command {""}
    $m add command -label "New" -command {""}
    $m add command -label "Save" -command {""}
    $m add command -label "Save As..." -command {""}
    $m add separator
    $m add command -label "Print Setup..." -command {""}
    $m add command -label "Print..." -command {""}
    $m add separator
    $m add command -label "Quit" -command "destroy ."
	
	.leo$n configure -menu .leo$n.menu
}</t>
<t tx="T233"># Create a splitter window into which the caller packs widgets.

proc createSplitter {w verticalFlag} {
	# verticalFlag, height, width could be params
	frame $w -width 4i -height 3i
	frame $w.pane1
	frame $w.pane2
	if { $verticalFlag } {
		# Panes arranged vertically; horizontal splitter bar
		frame $w.bar -height 7
		place $w.pane1 -relx 0.5 -rely   0 -anchor n -relwidth 1.0 -relheight 0.5
		place $w.pane2 -relx 0.5 -rely 1.0 -anchor s -relwidth 1.0 -relheight 0.5
		place $w.bar   -relx 0.5 -rely 0.5 -anchor c -relwidth 1.0
		bind $w.bar &lt;ButtonPress-1&gt;		"onGrabSplitterBar $w 1"
		bind $w.bar &lt;B1-Motion&gt;			"onDragSplitterBar $w 1 %y"
		bind $w.bar &lt;ButtonRelease-1&gt;	"onDropSplitterBar $w 1 %y"
	} else {
		# Panes arranged horizontally; vertical splitter bar
		frame $w.bar -width 7
		place $w.pane1 -rely 0.5 -relx   0 -anchor w -relheight 1.0 -relwidth 0.5
		place $w.pane2 -rely 0.5 -relx 1.0 -anchor e -relheight 1.0 -relwidth 0.5
		place $w.bar   -rely 0.5 -relx 0.5 -anchor c -relheight 1.0
		bind $w.bar &lt;ButtonPress-1&gt;		"onGrabSplitterBar $w 0"
		bind $w.bar &lt;B1-Motion&gt;			"onDragSplitterBar $w 0 %x"
		bind $w.bar &lt;ButtonRelease-1&gt;	"onDropSplitterBar $w 0 %x"
	}
	# Borderwidth required
	$w.bar configure -borderwidth 2 -relief raised -background LightSteelBlue2 
	pack $w -expand yes -fill both
}
</t>
<t tx="T234">proc onGrabSplitterBar {w verticalFlag} {

	# We should change the cursor here.
	
	# Changing the relief is pointless.
		# $w.bar configure -relief sunken
	
	# Changing colors is really bad
		# $w.bar configure -relief sunken -background LightSteelBlue4
		# $w.bar configure -background LightSteelBlue4
}</t>
<t tx="T235">proc onDropSplitterBar {w verticalFlag xy} {

	# We should reset the cursor here.
	$w.bar configure -relief raised -background LightSteelBlue2
}
</t>
<t tx="T236"># xy is the coordinate of the cursor relative to the bar, not the main window.

proc onDragSplitterBar {w verticalFlag xy} {

	if { $verticalFlag } {
		# Panes arranged vertically; horizontal splitter bar
		set wRoot	[winfo rooty $w]
		set barRoot [winfo rooty $w.bar]
		set wMax	[winfo height $w]
	} else {
		# Panes arranged horizontally; vertical splitter bar
		set wRoot	[winfo rootx $w]
		set barRoot [winfo rootx $w.bar]
		set wMax	[winfo width $w]
	}
	set offset [expr double($barRoot) + $xy - $wRoot ]
	# Adjust the pixels, not the frac.
	if { $offset &lt; 3 } { set offset 3 }
	if { $offset &gt; [expr $wMax - 2] } { set offset [expr $wMax - 2] }
	set frac [ expr double($offset) / $wMax ]
	# This redraws the splitter as the drag is occuring.
	# We could also redraw in onDropSplitterBar for non-dynamic updates.
	divideSplitter $w $verticalFlag $frac
	return $frac ;# No longer used
}</t>
<t tx="T237">proc divideSplitter {w verticalFlag frac} {

	if { $verticalFlag } {
		# Panes arranged vertically; horizontal splitter bar
		place $w.bar -rely $frac
		place $w.pane1 -relheight $frac
		place $w.pane2 -relheight [expr 1 - $frac]
	} else {
		# Panes arranged horizontally; vertical splitter bar
		place $w.bar -relx $frac
		place $w.pane1 -relwidth $frac
		place $w.pane2 -relwidth [expr 1 - $frac]
	}
}</t>
<t tx="T238">proc createFindPanel {} {

	toplevel .find
	&lt;&lt; Create the Find and Change panes &gt;&gt;
	&lt;&lt; Create two columns of checkboxes &gt;&gt;
	&lt;&lt; Create two rows of buttons &gt;&gt;
}
</t>
<t tx="T239">frame .find.fc -bd 1m
pack  .find.fc -anchor n -expand yes -fill x

frame .find.fc.fpane -bd 1 -height 0.95i -width 1.5i
frame .find.fc.cpane -bd 1 -height 0.95i -width 1.5i

pack  .find.fc.fpane -anchor n -expand yes -fill x
pack  .find.fc.cpane -anchor s -expand yes -fill x

# Create the labels and text fields.
label .find.fc.fpane.lab -width 8 -text "Find:"
label .find.fc.cpane.lab -width 8 -text "Change:"
text  .find.fc.fpane.t -height 2 -width 20 ; # 2 lines, 20 characters
text  .find.fc.cpane.t -height 2 -width 20

pack  .find.fc.fpane.lab -side left 
pack  .find.fc.cpane.lab -side left
pack  .find.fc.cpane.t -side right -expand yes -fill both
pack  .find.fc.fpane.t -side right -expand yes -fill both
</t>
<t tx="T240">frame .find.boxes -bd 1m
pack  .find.boxes -anchor n -expand yes -fill x

frame .find.boxes.lt -bd 1
frame .find.boxes.rt -bd 1
pack  .find.boxes.lt -side left  -padx 5m
pack  .find.boxes.rt -side right -ipadx 2m

# Create the left column
checkbutton .find.boxes.lt.batch -anchor w -text "Batch"
checkbutton .find.boxes.lt.wrap  -anchor w -text "Wrap around"
checkbutton .find.boxes.lt.word  -anchor w -text "Whole word"
checkbutton .find.boxes.lt.case  -anchor w -text "Ignore case"
checkbutton .find.boxes.lt.pat   -anchor w -text "Pattern match"
pack .find.boxes.lt.batch -fill x
pack .find.boxes.lt.wrap  -fill x
pack .find.boxes.lt.word  -fill x
pack .find.boxes.lt.case  -fill x
pack .find.boxes.lt.pat    -fill x

# Create the right column
checkbutton .find.boxes.rt.headline -anchor w -text "Search Headline Text"
checkbutton .find.boxes.rt.body     -anchor w -text "Search Body Text"
checkbutton .find.boxes.rt.outline  -anchor w -text "Suboutline Only"
checkbutton .find.boxes.rt.mark     -anchor w -text "Mark Changes"
checkbutton .find.boxes.rt.markch   -anchor w -text "Mark Finds"
pack .find.boxes.rt.headline -side top -fill x
pack .find.boxes.rt.body     -side top -fill x
pack .find.boxes.rt.outline  -side top -fill x
pack .find.boxes.rt.mark     -side top -fill x
pack .find.boxes.rt.markch   -side top -fill x
</t>
<t tx="T241"># Create the button panes
frame .find.buttons -bd 1
pack  .find.buttons -anchor n -expand yes -fill x

frame .find.buttons2 -bd 1
pack  .find.buttons2 -anchor n -expand yes -fill x

# Create the first row of buttons
button      .find.buttons.find    -width 8 -text "Find"
checkbutton .find.buttons.reverse -width 8 -text "Reverse"
button      .find.buttons.findAll -width 8 -text "Find All"

pack .find.buttons.find    -pady 1m -padx 1m -side left
pack .find.buttons.reverse -pady 1m          -side left -expand 1
pack .find.buttons.findAll -pady 1m -padx 1m -side right

# Create the second row of buttons
button .find.buttons2.change     -width 8 -text "Change"
button .find.buttons2.changeFind           -text "Change, Then Find"
button .find.buttons2.changeAll  -width 8 -text "Change All"

pack .find.buttons2.change       -pady 1m -padx 1m -side left
pack .find.buttons2.changeFind   -pady 1m          -side left -expand 1
pack .find.buttons2.changeAll    -pady 1m -padx 1m -side right
</t>
<t tx="T242">proc createPrefsPanel {} {

	toplevel .prefs
	&lt;&lt; Create the Global Options frame &gt;&gt;
	&lt;&lt; Create the Tangle Options frame &gt;&gt;
	&lt;&lt; Create the Target Language frame &gt;&gt;
}</t>
<t tx="T243">frame .prefs.glob -bd 1m -relief groove
pack  .prefs.glob -anchor n -pady 1m -ipadx 1m -expand 1 -fill x

label .prefs.glob.title -text "Global Options..."
pack  .prefs.glob.title -pady 1m

# Page width &amp; page width
frame .prefs.glob.f
pack  .prefs.glob.f -anchor w -pady 1m -expand 1 -fill x

label .prefs.glob.f.lab -anchor w -padx 1m -text "Page width:"
text  .prefs.glob.f.txt -height 1 -width 4 ;# lines, characters
pack  .prefs.glob.f.lab .prefs.glob.f.txt -side left

label .prefs.glob.f.lab2 -padx 1m -text "Tab width:"
text  .prefs.glob.f.txt2 -height 1 -width 4 ;# lines, characters
pack  .prefs.glob.f.lab2 .prefs.glob.f.txt2 -side left

# Checkbuttons
checkbutton .prefs.glob.done -anchor w -text "Execute Leo_done.bat after Tangle"
checkbutton .prefs.glob.un   -anchor w -text "Execute Leo_un.bat after Tangle"
pack .prefs.glob.done .prefs.glob.un -fill x
</t>
<t tx="T244"># Frame and title
frame .prefs.tangle -bd 1m -relief groove
pack  .prefs.tangle -anchor n -ipadx 1m -expand 1 -fill x

label .prefs.tangle.title -text "Default Options..."
pack  .prefs.tangle.title -pady 1m

# Label and text
label .prefs.tangle.lab -anchor w -text "Default tangle directory"
text  .prefs.tangle.txt -height 1 -width 30 ;# width significant

pack  .prefs.tangle.lab           -padx 1m -pady 1m -fill x
pack  .prefs.tangle.txt -anchor w -padx 1m -pady 1m -fill x

# Checkbuttons
checkbutton .prefs.tangle.header -anchor w -text "Tangle outputs header line"
checkbutton .prefs.tangle.doc    -anchor w -text "Tangle outputs document chunks"
pack .prefs.tangle.header .prefs.tangle.doc -fill x
</t>
<t tx="T245"># Frame and title
frame .prefs.target -bd 1m -relief groove
pack  .prefs.target -anchor n -pady 1m -ipadx 1m -expand 1 -fill x

label .prefs.target.title -text "Default Target Language..."
pack  .prefs.target.title -pady 1m

# Frames for two columns of radio buttons
frame .prefs.target.lt 
frame .prefs.target.rt
pack  .prefs.target.lt -side left
pack  .prefs.target.rt -side right

## To do: make radio buttons functional.

# Left column of radio buttons
radiobutton .prefs.target.lt.c      -anchor w -text "C/C++"
radiobutton .prefs.target.lt.cweb   -anchor w -text "CWEB"
radiobutton .prefs.target.lt.html   -anchor w -text "HTML"
radiobutton .prefs.target.lt.java   -anchor w -text "Java"
radiobutton .prefs.target.lt.pascal -anchor w -text "Pascal"

pack .prefs.target.lt.c      -fill x
pack .prefs.target.lt.cweb   -fill x
pack .prefs.target.lt.html   -fill x
pack .prefs.target.lt.java   -fill x
pack .prefs.target.lt.pascal -fill x

# Right column of radio buttons
radiobutton .prefs.target.rt.perl   -width 12 -anchor w -text "Perl"
radiobutton .prefs.target.rt.pod              -anchor w -text "Perl + POD"
radiobutton .prefs.target.rt.plain            -anchor w -text "Plain Text"
radiobutton .prefs.target.rt.python           -anchor w -text "Python"

pack .prefs.target.rt.perl   -fill x
pack .prefs.target.rt.pod    -fill x
pack .prefs.target.rt.plain  -fill x
pack .prefs.target.rt.python -fill x
</t>
<t tx="T246">@ignore</t>
<t tx="T247">@ The section stack is used while scanning each .c file. It keeps track of nested section definitions that are presently being scanned.
@c

struct def_node
	xbuf *xbuffer # expandable buffer holding the sections definition.
	def_node * next   # The next def_stack_node in the stack or free list.
	char * name_ip1   # The start of the name of the section.
	char * name_ip2   # The character _after_ the name of the section.
	short indent   # The number of leading tabs for this section.
	short part   # m in "(part m of n)"
	short of   # n in "(part m of n)"
	int nl_flag  # TRUE if section starts on a new line.

static def_node * def_stack = None   # Pointer to the top of the section stack.
static def_node * def_free_list = None   # The list of free snodes.
@ 

The following globals are initialized by scan_derived_file() and used by forgiving_compare() and update_def().  They describe the strings used to delimit comments in the derived file presently being scanned.

@c
comment = None # Start of a multi-line comment.
comment2 = None   # Alternate multi-line comment.
comment_end = None   # End of a multi-line comment.
comment2_end = None   # End of alternate multi-line comment.
line_comment = None   # Start of a single-line comment.
sentinel = None  # Start of a sentinel comment.
sentinel_end = None   # End of a sentinel comment.
string1 = None   # Start of a string.
string2 = None   # Start of alternate string
	#(e.g.,C character constant).
verbatim = None   # Start of a line with significant whitespace.
	#(e.g.,C preprocessor directive).
line_comment_len = 0
comment_len = 0
comment2_len = 0
comment_end_len = 0
comment2_end_len = 0
sentinel_len = 0
sentinel_end_len = 0
string1_len = 0
string2_len = 0
verbatim_len = 0</t>
<t tx="T248">@ This code standardizes the name so that ust_enter and ust_lookup will compute the same hash value. We convert all characters to lower case,and convert all sequences of whitespace to a single whitespace.
@c

def ust_standardize_name(name_ipp1,name_ipp2):

	np1 = name_ipp1 ? *name_ipp1: None
	np2 = name_ipp2 ? *name_ipp2: None
	first_np1 = np1
	len = *name_ipp2 - *name_ipp1 + 1
	buf = tangle_new_mem(len)
	s = buf
	i = 0
	assert(name_ipp1 and name_ipp2)
	assert(np1 &lt; np2)
	assert(*np1 == '&lt;' or *np1 == '@')
	assert(*(np2-1)== '&gt;')
	if self.use_noweb_flag:
		&lt;&lt; Remove &lt; characters &gt;&gt;
	else:
		&lt;&lt; Remove @&lt; &gt;&gt;
	# Remove leading whitespace.
	while  np1 &lt; np2 and(*np1 == ' ' or *np1 == '\t'):
		np1 += 1
	while np1 &lt; np2:
		if
			is_ws(*np1)or
			(*np1 == '\\' and np1 + 1 &lt; np2 and is_nl(*(np1+1)))
		:
			assert(s != &amp;buf[0])
			if *(s-1)!= ' ':
				*s = ' ' ; s += 1
			if *np1 == '\\': np1 += 1
		  	np1 += 1
		elif isalpha(*np1):
			*s = tolower(*np1) ; s += 1
			np1 += 1
		else: *s++ = *np1++
	# Remove trailing whitespace and extra '&gt;' characters.
	# Bug fix: 8/11/99
	# Use s for the comparison,so we don't count repeated blanks twice.
	assert(np1 == np2)
	np1 = first_np1
	s -= 1
	while s &gt;= buf and(*s == ' ' or *s == '\t'):
		s -= 1
	i = 0
	while i &lt; 3 and s &gt;= buf:
		if *s == '&gt;':
			s -= 1 # Delete the '&gt;' characters.
		i += 1
	while s &gt;= buf and *s == '&gt;':
		s -= 1
	while s &gt;= buf and(*s == ' ' or *s == '\t'):
		s -= 1
	s += 1
	# End the name and set the params in the caller.
	assert(s &gt;= buf and s &lt; buf + len)
	*s = '\0'  # Useful for dumps.
	# Do the trace before resetting the args in the caller.
	trace(self, "[" + name + "] returns [" + buf + "]")
	*name_ipp1 = buf
	*name_ipp2 = s # The character _past_ the name.</t>
<t tx="T249">while np1 &lt; np2 and *np1 == '&lt;':
	np1 += 1
</t>
<t tx="T250">if np1 &lt; np2 and *np1 == '@':
	np1 += 1
	if np1 &lt; np2 and *np1 == '&lt;':
		np1 += 1
</t>
<t tx="T251">@ This function handles the actual updating of section definitions in the web. During pass 2 of Untangle self function is called from skip_body in the Tangle code at the point at which Tangle discovers the definition of a section in the outline.

We look up the section name(name1_ip1...name_ip2)in the ust. If an entry: exists in the ust we compare the code and doc parts of an outline node(code1_ip1...code_ip2 and doc_ip1...doc_ip2)with the code and doc parts in the ust. We will update either the code or doc parts of x as needed.

We use the forgiving_compare()to compare code and doc parts. It's not possible to change only trivial whitespace using Untangle because forgiving_compare()ignores trivial whitespace.
For this Windows version we pass v_ip and v_len into this function so we can easily recreate the entire old and new body texts.
@c

def update_def(s,name,part,code,doc,root_flag):

	&lt;&lt; Define update_def vars &gt;&gt;
	&lt;&lt; Initialize update_def vars &gt;&gt;
	s, nl_flag = ust_lookup(name,part,text,root_flag,true): # Set update
	if not s: return 0 # Not an error!
	&lt;&lt; Set udoc_ip pointers and adjust ucode_ip pointers &gt;&gt;
	&lt;&lt; Adjust ucode_ip pointers &gt;&gt;
	&lt;&lt; Set ust_doc and ust_code flags &gt;&gt;
	&lt;&lt; Set tst_doc and tst_code flags &gt;&gt;
	&lt;&lt; Set match_code and match_doc flags &gt;&gt;
	# Major change: 2/23/01: Untangle never updates doc parts.
	match_doc = true
	if match_doc and not match_code:
		&lt;&lt; Replace the code part &gt;&gt;
	elif match_code:
		&lt;&lt; Replace the doc part &gt;&gt;
	elif not match_doc and not match_code:
		&lt;&lt; Replace the doc part &gt;&gt;
		&lt;&lt; Adjust pointers after updating the doc part &gt;&gt;
		&lt;&lt; Replace the code part &gt;&gt;
	&lt;&lt; Report what happened &gt;&gt;
	return delta</t>
<t tx="T252"># General temps.
i = None
# Describing the vnode...
body_text = v_ip
head_text = None # Initialized later.
body_len = v_len
head_len = 0
delta = 0 # The difference between the_ip and the_limit on entry and exit.
# Describing the TST entry...
tst_code =(code_ip1 and code_ip2 and code_ip2 &gt; code_ip1)
	# TRUE if TST entry has a code part.
tst_doc =(doc_ip1 and doc_ip2 and doc_ip2 &gt; doc_ip1)
	# TRUE if TST entry has a doc part.
# Describing the TST entry.  initialized later...
code_ip1_offset = code_ip1 - body_text
code_ip2_offset = code_ip2 - body_text
doc_ip1_offset = doc_ip1 - body_text
doc_ip2_offset = doc_ip2 - body_text
# Describing the UST entry.
ucode_ip1 = None,* ucode_ip2 = None   # Pointers to updated code part.
udoc_ip1 = None,* udoc_ip2 = None   # Pointers to updated doc part.
ust_doc = false  # TRUE if UST entry has a code part.
ust_code = false  # TRUE if UST entry has a doc part.
nl_flag = false  # Unused param to UST routines.
# Describing the comparisons between the UST and TST entries.
match_doc = false  # TRUE if TST and UST doc parts exist and match.
match_code = false  # TRUE if TST and UST code parts exist and match.
</t>
<t tx="T253">head_text = get_current_head_text(&amp; head_len)</t>
<t tx="T254">@ This code looks for a leading block comment,and if found sets the udoc_ip1 and udoc_ip2 to point at it and adjusts ucode_ip1 to point past it.
@c

i = skip_ws_and_nl(ucode_ip1,ucode_ip2)
# 9/24/99: test for empty ucode part here.
if ucode_ip1 &gt;= ucode_ip2:
	ucode_ip1 = ucode_ip2 = None
if (comment and comment_end and
	i + len(comment) &lt;= ucode_ip2 and
	strn_eq(i,comment,len(comment))):
	# Don't include the delimiters: they don't exist in the outline.
	i += len(comment)
	udoc_ip1 = i
	# Skip to the end of the comment.
	while  i + len(comment_end) &lt; ucode_ip2:
		if strn_eq(i,comment_end,len(comment_end)): break
		else: i += 1
	if i + len(comment_end) &lt; ucode_ip2 and
		strn_eq(i,comment_end,len(comment_end))
	:
		udoc_ip2 = i
		i += len(comment_end)
		ucode_ip1 = skip_ws_and_nl(i,code_ip2)
	else: udoc_ip1 = None
</t>
<t tx="T255"># 9/24/99
while ucode_ip1  &lt; ucode_ip2 and is_nl(*ucode_ip1):
	ucode_ip1 += 1

if ucode_ip1 &gt;= ucode_ip2:
	ucode_ip1 = ucode_ip2 = None</t>
<t tx="T256">ust_doc =(udoc_ip1 and udoc_ip2 and udoc_ip2 &gt; udoc_ip1)
ust_code =(ucode_ip1 and ucode_ip2 and ucode_ip2 &gt; ucode_ip1)</t>
<t tx="T257"># These pointers may have changed, so we re-adjust them.

tst_code =(code_ip1 and code_ip2 and code_ip2 &gt; code_ip1)
tst_doc =(doc_ip1 and doc_ip2 and doc_ip2 &gt; doc_ip1)</t>
<t tx="T258">if not tst_doc and not ust_doc:
	match_doc = true
else:
	match_doc = tst_doc and ust_doc and
		compare_comments(doc_ip1,doc_ip2,udoc_ip1,udoc_ip2)
if not tst_code and not ust_code:
	match_code = true
else:
	match_code = tst_code and ust_code and forgiving_compare(
		name_ip1,name_ip2,part,
		code_ip1,code_ip2,ucode_ip1,ucode_ip2)</t>
<t tx="T259">@ replace_text()can reallocates the body text and changes the body_text pointer,so we must recompute all the pointers afresh.
@c

body_text = get_current_body_text(&amp; body_len)
doc_ip1 = body_text + doc_ip1_offset # delta does not affect this pointer.
doc_ip2  = body_text + doc_ip2_offset + delta
code_ip1 = body_text + code_ip1_offset + delta
code_ip2 = body_text + code_ip2_offset + delta</t>
<t tx="T260">&lt;&lt; Skip opening newlines in the new code part &gt;&gt;
&lt;&lt; Skip trailing whitespace in the new code part &gt;&gt;
replace_text(body_text,body_len,code_ip1,code_ip2,ucode_ip1,ucode_ip2)
body_text = get_current_body_text(&amp; body_len)
delta +=(ucode_ip2-ucode_ip1)-(code_ip2-code_ip1)</t>
<t tx="T261">while ucode_ip1 &lt; ucode_ip2 and is_nl(*ucode_ip1):
	ucode_ip1 += 1</t>
<t tx="T262"># This code ensures that at most one newline terminates the replacement text.

ucode_limit = ucode_ip2
# Scan backward past all whitespace and newlines.
while  --ucode_ip2 &gt;= ucode_ip1 and
	(is_nl(*ucode_ip2)or is_ws(*ucode_ip2)):
		pass ## ????
# Scan forward past at most one newline.
while  ++ucode_ip2 &lt; ucode_limit and is_ws(*ucode_ip2):
	pass ## ????
	
if ucode_ip2 &lt; ucode_limit and is_nl(*ucode_ip2):
	ucode_ip2 = skip_nl(ucode_ip2,ucode_limit)</t>
<t tx="T263">massage_block_comment(&amp; udoc_ip1,&amp; udoc_ip2)
&lt;&lt; Scan past trailing blank lines in the old doc part &gt;&gt;
replace_text(body_text,body_len,doc_ip1,doc_ip2,udoc_ip1,udoc_ip2)
body_text = get_current_body_text(&amp; body_len)
delta +=(udoc_ip2-udoc_ip1)-(doc_ip2-doc_ip1)</t>
<t tx="T264">@ We want the trailing whitespace in the old outline(the old doc part)to determine the trailing whitespace in the updated outline.
@c

if doc_ip1 and doc_ip2: # 8/4/00
	i = doc_ip2 - 1
	while i &gt; doc_ip1:
		if is_ws(*i):
			i -= 1
		elif is_nl(*i):
			i -= 1 ; doc_ip2 = i
		else:
			break
	doc_ip2 += 1
</t>
<t tx="T265">if not match_doc or not match_code:
	es("***Updating:   " + escans(head_text,head_text + head_len))</t>
<t tx="T266"># This inserts @c after leading comments.

def massageExtractedBody(self,s):

	newBody, comment = c.skipLeadingComments(s)
	newLine = choose(len(newBody) &gt; 0 and newBody[0] == '\n', "", '\n')
	if len(comment) &gt; 0:
		return comment + "\n@c\n" + newLine + newBody
	else:
		return newBody</t>
<t tx="T267">def getConvertVars (self):

	c = self ; v = c.currentVnode()
	if v and c.body:
		s = c.body.get("1.0","end")
		# string.replace(s,'\r',"")
		lines = string.split(s, '\n')
		i, j = getTextSelection(c.body)
		if i and j:
			if c.body.compare(i,"&gt;",j):
				i,j = j,i
		return lines, i, j, c.body.get(i,j)
	else:
		return [], 0, 0, ""</t>
<t tx="T268">@nocolor

Farewell to the Mac?

I still have hopes that Leo2 will someday work on the Mac.  However, I decline to create a new Mac-only version of Leo, nor will I revise previous versions of Leo for the Mac.  My reasons for this decision, taken after much thought, are as follows.

The present Mac versions can not, and should not, be brought up to date.  There are two Mac versions.  The first is written in C, the second in Objective C (using Yellow Box, aka Cocoa).  Neither version supports Leo2 @file nodes.  Neither version contains the latest Tangle/Untangle code, which is written in a strange mixture of C and C++.

Upgrading either of these versions would amount to a total rewrite.  It is tempting to revise them so that they could read and write the present XML file format.  Alas, that would hardly suffice.  The tangle and untangle code would have to be completely revised.  All the Leo2 code would have to be transliterated back to C or Objective C.  Indeed, every line of code would need a hard look.

Revising Mac code would be foolish.  Any work maintaining Mac code would detract from job of improving Leo.  What I want is fewer versions of Leo, not more.  My goal is to provide a single, cross-platform version of Leo.  Maintaining Mac code works against that goal.

What about wxWindows and wxPython?  Alas, wxWindows is too buggy, the Mac version of wxWindows is unacceptable, and wxPython does not exist on the Mac.  Moreover, wxPython is not nearly as safe as Python;  erroneous code often causes crashes inside wxWindows.  The C++ code in wxWindows makes wxPython unreliable.

I am committed to using the highest level tools and most portable tools.  The combination of Python and tkinter (the Python interface to Tk) appears to be the best, most stable and most portable platform on which to build Leo.  Indeed, IDLE, the Python IDE/Debugger, is written in Python + tkinter.  Alas, Tk does not work well on the Mac.  I can justify no further work on the Mac until it does.

This posting uses the word 'alas' three times, not counting the last one ;-)  I am indeed sorry about the present state of affairs; I have loved the Mac for a long time.  I hope that the best tools will be ported to the Mac, and I wonder whether that will happen.

Edward K. Ream
November 4, 2001
</t>
<t tx="T269">@nocolor

The more I look at Tk, the more convinced I am that Python + Tk (aka tkinter) is, by far, the best way to go with Leo.py.  I now have Open Source code for tree widgets and splitter windows, and have intensely studied how to modify that code for use in Leo.  It is clear, even at this early date, that this code will provide a very pleasant base on which to build Leo.

The tree code is based on code in IDLE, the Python IDE.  This code is simple, good and plenty fast enough. The tree code draws directly to a Tk canvas object.  The look and feel matches Windows exactly.  It would be trivial to use Mac triangle icons instead of the Windows plus and minus icons.  It would also be trivial to modify the look and feel for Linux.

The tree widget code solves several intractable problems with wxTreeCtrl.  Moving nodes becomes trivial.  Bugs in wxTreeCtrl involving editing and redrawing disappear.  Using Python/Tk code simplifies the vnode class, and having access to the vnode class simplifies and speeds up the tree widget code.  There is no SWIG overhead in calling the wxTreeCtrl code.  It will now be possible to bind keystrokes properly; this simply can not be done in wxWindows.

Actually, the tree widget code shows just how trivial the Windows native tree control is.  Of course, the Tk canvas class simplifies matters, but there are several important points here:

1. The wxTreeCtrl tree class actually does very little, and does it rather badly.
2. There is absolutely no need for C++ code (except in the Tk canvas class) to draw trees.
3. Leo can _easily_ have _complete_ control over the look and feel of tree controls.
4. I can modify in the tree code to simplify the rest of Leo, especially Leo's vnode class.

Here we have a splendid example of higher-level code being superior, in _every_ way, to lower level code.  The wxTreeCtrl code is horrendously complex, and in fact does almost nothing!

Similar remarks apply to the splitter window.  The Tk code for splitter windows is about a page long.  No code could be higher level because the Tk code describes only _what_ is to be done, not _how_ it is too be done.

Another big win comes from using the Tk text widget.  This widget is extraordinarily powerful.  The only text control that rivals it is the MacOS/Yellow Box text control.  Indeed, the Tk text widget does everything that Leo could possibly want.  One can even embed images in text!

Syntax coloring Tk text will be straightforward in Python. IDLE's syntax coloring is very fast on modern workstations.  There will be no need to use or modify the Scintilla C++ code.

In short, using Tk for Leo.py will be fast enough and will greatly increase what is possible in Leo while at the same time greatly simplifying Leo's code.  I am about to convert Leo.py from wxPython to Python + Tk.

Edward K. Ream
November 4, 2001</t>
<t tx="T270">@nocolor

I've known for a while that Python was interesting; I attended a Python conference last year and added Python support to Leo.  But last week I got that Python is something truly remarkable.  I wanted to convert Leo from wxWindows to wxPython, so I began work on c2py, a Python script that would help convert from C++ syntax to Python.  While doing so, I had an Aha experience.  Python is more than an incremental improvement over Smalltalk or C++ or objective-C; it is "something completely different".  The rest of this post tries to explain this difference.

Clarity: no clutter, easy prototyping

What struck me first as I converted C++ code to Python is how much less blah, blah, blah there is in Python.  No braces, no stupid semicolons and most importantly, _no declarations_.  No more pointless distinctions between const char *, char const *, char * and wxString. No more wondering whether a variable should be signed, unsigned, short or long.

Declarations add clutter, declarations are never obviously right and declarations don't prevent memory allocation tragedies.  Declarations also hinder prototyping.  In C++, if I change the type of something I much change all related declarations; this can be a huge and dangerous task.  With Python, I can change the type of an object without changing the code at all!  It's no accident that Leo's new log pane was created first in Python.

Functions returning tuples are a "minor" feature with a huge impact on code clarity.  No more passing pointers to data, no more defining (and allocating and deallocating) temporary structs to hold multiple values.

Python can't check declarations because there aren't any.  Python can only check for syntax errors before running a script; other errors must be found by executing code.  In practice, this drawback is minor: one simply writes code to ensure that all code gets tested.

Power

Python is much more powerful than C++, not because Python has more features, but because Python needs _less_ features.  Some examples:

1. Python does everything that the C++ Standard Template Library (STL) does, without any of the blah, blah, blah needed by STL.  No fuss, no muss, no code bloat.

2. Python's slicing mechanism is very powerful and applies to any sequence (string, list or tuple).  Python's string library does more with far less functions because slices replace many functions typically found in other string libraries.

3. Writing dict = {} creates a dictionary (hash table).  Hash tables can contain anything, including lists and other hash tables.

4. Python's special functions, like __init__, __del__, __repr__, __cmp__, etc. create an elegant way to handle any special need that might arise.

Safety

Before using Python I never fully realized how difficult and dangerous memory allocation is in C++.  Try doing

        aList[i:j] = list(aString)

in C.  You will write at least 10 - 20 lines of code.  Any error in this code will create a memory allocation crash or leak.

Python is fundamentally safe.  C++ is fundamentally unsafe.  When I am using Python I am free from worry and anxiety.  When I am using C++ I must be constantly "on guard."  A momentary lapse can create a hard-to-find pointer bug.  With Python, almost nothing serious can ever go wrong, so I can work late at night, or after a few beers.

And the Python debugger is always available.  If an unexpected exception occurs, the debugger/interpreter tells me just what went wrong.  I don't have to plan a debugging strategy!  Finally, wxPython recovers from exceptions, so Leo can keep right on going even after a crash!

Code Speed

Python has almost all the speed of C.  Other interpretive environments such as icon and smalltalk have clarity, power and safety similar to Python.  What makes Python unique is its seamless way of making C code look like Python code.

Much of Python executes at essentially the speed of C code because most Python modules are written in C.  The overhead in calling such modules is negligible.  Moreover, if code is too slow, one can always create a C module to do the job.

In fact, Python encourages optimization by moving to _higher_ levels of expression.  For example, Leo's Open command reads an XML file.  If this command is too slow I can use Python's XML parser module.  This will speed up Leo while at the same time raising the level of the code.

Conclusions

Little of Python is completely new.  What stands out is the superb engineering judgment evident in Python's design.  Python is extremely powerful, yet small, simple and elegant.  Python allows me to express my intentions clearly and at the highest possible level.

The only hope of making Leo all it can be is to use the best possible tools.  I believe Python (possibly with tkinter) will allow me to add, at long last, the new features that Leo should have.

Edward K. Ream
October 25, 2001</t>
<t tx="T271">@nocolor</t>
<t tx="T272"># Import/Export menu
notYet("Import Files")
notYet("Import CWEB Files")
notYet("Import Noweb Files")
notYet("Import MORE Text")
notYet("Outline To CWEB")
notYet("Outline To Noweb")
notYet("Export MORE Text")
notYet("Flatten Outline")

# Edit menu
notYet("Undo")
notYet("Redo")
notYet("Font Panel")
notYet("Syntax Coloring")

# Window menu
notYet("Toggle Split Direction")
notYet("Cascade")
notYet("Recent Windows")</t>
<t tx="T273">Support both Leo1 and Leo2 styles of Import</t>
<t tx="T274">@ on blank line just generates @@ and no doc part</t>
<t tx="T275">Improve leading whitespace handling in Tangle.
Fix clone bugs (rewrite vnode::setDirty)
Improve Find/Change commands.
	Change "batch" to "context"
Always recompute file indices and compute file indices just like leo.py.
Make sure all file names end in .leo.</t>
<t tx="T276">On this release leo.py will have all the essential features of Leo.</t>
<t tx="T277">Needed for CVS support</t>
<t tx="T278">
	This will allow great flexibility to users.</t>
<t tx="T279">This is less important now that cloned nodes are properly marked dirty, and it is still important.

Write a message on the first mismatch that creates a "minor" read error.

Add alert when there is a mismatch:

using multiple backups of .leo files is dangerous

use Read Outline Only to recover from mismatches
	radio buttons:
		reload from .leo file
		reload from derived files
		
Clones are a _huge_ problem when "minor" errors occur
	We can have "partial" clones: clones within .leo file that don't link to derived files!!
	This is really bad.
	I ended up erasing _all_ clones to counter-act the problem!</t>
<t tx="T280">Tk has a ButtonExposeMotion event.</t>
<t tx="T281">Add code to protect the old .leo file if the write fails.</t>
<t tx="T282">On this release leo.py will contain all features found in the Borland version of Leo except for the Print command, which can not be implemented in Tk.  That won't matter because users can export files and then print them.</t>
<t tx="T283">Toggle splitter direction command does not work
	onDragSplitterBar does nothing when panes are split horizontally.
	Splitter bar doesn't work when panes are split horizontally.</t>
<t tx="T284">These are nice features, and inessential.</t>
<t tx="T285">Comments:  color box,  button: browse
String:    color box,  button: browse
Keyword:   color box,  button: browse
Directive: color box,  button: browse</t>
<t tx="T286">Path 1: text box
Path 2: text box

check: File extension: text box

Radio buttons:
	* print all lines
	* print mismatches
	* print matches
	
check: stop after first mismatch
check: send result to file: text box
check: generate diffs
check: ignore whitespace
check: ignore blank lines</t>
<t tx="T287">Font:  choose box or text box
Style: choose box
Size:  choose box</t>
<t tx="T288">To make this work _all_ operations must be undoable.</t>
<t tx="T289">Update first page
	Put link to "leo's SourceForge site" near SourceForge icon.

Update acknowledgements

Improve description of Leo2 &amp; Glossary

Add history section</t>
<t tx="T290">Announcement to comp.prog.lit.</t>
<t tx="T291">@nocolor</t>
<t tx="T292">Leo is a programmers tool that improves seveveral aspects of how you view programs.
Leo improves how you see and organize computer programs and other data.

Improves browsers
Improves outlines
Improves languages
Extends text file formats

Leo is a tool for programmers--easy to use, flexible and powerful.  The article describes Leo and explains why Leo can be an important tool for any programmer or web designer.  

Leo is a unified approach to programming and data management, consisting of five inter-related aspects.  Leo is

1. A programmers tool, like a text editor or class browser,
2. A way of organizing huge amounts of information,
3. A powerful outlining editor,
4. A way of extending any programming language, from lowest level assembly language to highest-level Python, and
5. A way of embedding outline structure into any text file.  This embedding is complementary to, and distinct from, the outline structure implied by XML tags.

Leo has many features not mentioned here, and these 5 aspects of Leo create the "Leo Way".

As we shall see, these five aspects of Leo are tighly integrated into a single, unified and unifying whole.</t>
<t tx="T293">Leo can be introduced</t>
<t tx="T294">I have spent the last 5 years examining the implications of folding for
programming.  Yes, class and path browsers do provide folding, with
the following limitations:

1. Most browsers do not let the user arrange the tree as the user sees
fit.  The user is not allowed to add "organizing nodes" or indeed any
new kind of node.  The user is not allowed to move nodes around or
reorganize the outline in any way.

2. Most browsers remember neither the selected node, nor the top visible
node, nor the expansion state of nodes, and so do not restore the tree
as it was when the user last examined it.

3. Most browsers/editors do not understand the structure implied by
"folding" and have no operations that act on tree nodes as true
objects.  For example, most editors do not allow a search to be limited
to a particular part of a tree.

4. There is no way for the programming language to use the tree
structure.  It is not possible, for example, to name a part of the tree
and to reference that tree by name.

These limitations are, in fact, severe.  Leo removes them all.  I am
presently at work on a Python + Tk version of Leo using some IDLE code. 
In the future I hope to move this work into IDLE itself.

Bruce is correct, it is possible to implement folding with special
comment lines.  This is exactly what Leo does. I call these comment
lines "sentinels".  In fact, Leo uses almost a dozen different sentinels
to handle special cases.  Leo2 demonstrates that parsing sentinels on
opening a file is fast and robust.

What makes Leo significant is this: a source file with embedded
sentinels is simultaneously a source file and an outline.  Compilers and
text editors will view the file as text.  Leo, or any other outline
aware browser (maybe IDLE some day!) will view the file as an extremely
capable outline.

See the URL below for full details of Leo.  Leo is Open Software, hosted
on SourceForge and distributed under the Python License.

</t>
<t tx="T295">adds .? file extension</t>
<t tx="T296">This might be useful in moving the Find/Change code back to Borland version of Leo.</t>
<t tx="T297">1. The border of the tree control is gray, and it is overwritten with large headlines.  This may be a Tk or Tkinter bug.

2.  There doesn't seem to be any way to select all headline text when a headline is selected.  The click that starts editing seems to clear the selection.

3.  Adding trailing whitespace to a line in body text does not set the file-dirty mark.  This can never cause a derived file to become "out-of-synch" because the read code does not compare body text.

Apparently there is no way to fix this glitch because of holes in Tk's event mechanism.  Specifically, tree.idle_body_key has no way to tell directly what keystroke caused it to be entered.</t>
<t tx="T298">I haven't figured out how to set window icons yet.

Can I use the Window registery to do this??
	?? Use top.frame()(See property management routines)
		frame() returns a string containing a system-specific window id
		corresponding to self's outermost parent.
		For Windows, this is the HWND cast to a long integer.</t>
<t tx="T299">@ignore</t>
<t tx="T300">def OnSelectAll(self,event=None):

	setTextSelection(self.body,"1.0","end")
	return "break" # inhibit further command processing</t>
<t tx="T301">def __init__(self, title = None):

	Tk = Tkinter
	&lt;&lt; set the LeoFrame ivars &gt;&gt;
	self.top = top = Tk.Toplevel()
	if sys.platform=="win32":
		self.hwnd = top.frame()
		# trace("__init__", "frame.__init__: self.hwnd:" + `self.hwnd`)
	top.title(title)
	top.minsize(30,10) # This doesn't work as I expect.
	g = "+%d%+d" % (30, 30)
	top.geometry(g)
	# self.top.SetIcon("LeoIcon")
	&lt;&lt; create the Leo frame &gt;&gt;
	self.commands = c = leoCommands.Commands(self)
	self.tree = leoTree.leoTree(self.commands, self.canvas)
	c.tree = self.tree
	&lt;&lt; create the first tree node &gt;&gt;
	self.createMenuBar(top)
	self.createAccelerators(top)
	app().log = self # the LeoFrame containing the log
	app().windowList.append(self)
	es("Leo Log Window...") ; enl()

	self.top.protocol("WM_DELETE_WINDOW", self.OnCloseLeoEvent)
	self.top.bind("&lt;Button-1&gt;", self.OnActivateLeoEvent)
	self.tree.canvas.bind("&lt;Button-1&gt;", self.OnActivateTree)
	self.body.bind("&lt;Button-1&gt;", self.OnActivateBody)
	self.body.bind("&lt;Double-Button-1&gt;", self.OnBodyDoubleClick)
	self.log.bind("&lt;Button-1&gt;", self.OnActivateLog)
	self.body.bind("&lt;Key&gt;", self.tree.OnBodyKey)
	# self.body.bind("&lt;Control-d&gt;", self.OnMoveDown) # Makes control-d problem worse!!
	self.body.bind(virtual_event_name("Cut"), self.OnCut)
	self.body.bind(virtual_event_name("Copy"), self.OnCopy)
	self.body.bind(virtual_event_name("Paste"), self.OnPaste)</t>
<t tx="T302"># Set title and fileName
if title:
	self.mFileName = title
else:
	title = "untitled"
	n = app().numberOfWindows
	if n &gt; 0: title += `n`
	app().numberOfWindows = n+1
	self.mFileName = ""

self.title=title # Title of window, not including dirty mark
self.saved=false # True if ever saved
self.startupWindow=false # True if initially opened window
self.openDirectory = ""
self.splitVerticalFlag = true # True: main paines split vertically (horizontal main splitter)
self.ratio = 0.5 # Ratio of body pane to tree pane.
self.es_newlines = 0 # newline count for this log stream

# Created below
self.log = None
self.body = None
self.tree = None
self.treeBar = None # Used by tree.idle_scrollTo
self.canvas = None
self.splitter1 = self.splitter2 = None

# Menu bars
self.topMenu = self.fileMenu = self.editMenu = None
self.outlineMenu = self.windowMenu = self.helpMenu = None
# Submenus
self.editBodyMenu = self.moveSelectMenu = self.markGotoMenu = None

# Used by event handlers...
self.redrawCount = 0
self.activeFrame = None
self.draggedItem = None</t>
<t tx="T303"># Create two splitters
# Splitter 1 contains splitter2 and the body pane.
# Splitter 2 contains the tree and log panes.
bar1, split1Pane1, split1Pane2 = self.createSplitter(top, self.splitVerticalFlag)
self.bar1, self.split1Pane1, self.split1Pane2 = bar1, split1Pane1, split1Pane2

bar2, split2Pane1, split2Pane2 = self.createSplitter(split1Pane1, not self.splitVerticalFlag)
self.bar2, self.split2Pane1, self.split2Pane2 = bar2, split2Pane1, split2Pane2

# Create the body pane.
	# Verdana is good looking, but not fixed size.
	# Courier is fixed size, not great looking.
	# A light selectbackground value is needed to make syntax coloring look good.
font = tkFont.Font(family="Courier",size=9)
tabw = font.measure("    ")
self.body = body = Tk.Text(split1Pane2,name='body',bd=2,bg="white",relief="flat",
	setgrid=1,font=font,tabs=tabw,wrap="word",selectbackground="Gray80")
bodyBar = Tk.Scrollbar(split1Pane2,name='bodyBar')
body['yscrollcommand'] = bodyBar.set
bodyBar['command'] = body.yview
bodyBar.pack(side="right", fill="y")
body.pack(expand=1, fill="both")

# Create the tree pane.
self.canvas = tree = Tk.Canvas(split2Pane1,name="tree",bd=0,bg="white",relief="flat")
	# These do nothing...
	# selectborderwidth=0,selectforeground="white",selectbackground="white")
self.treeBar = treeBar = Tk.Scrollbar(split2Pane1,name="treeBar")
tree['yscrollcommand'] = treeBar.set
treeBar['command'] = tree.yview

treeBar.pack(side="right", fill="y")
tree.pack(expand=1,fill="both")

# Create the log pane.
# -padx is needed to handle overlap of splitter bar
self.log = log = Tk.Text(split2Pane2,name="log",setgrid=1,wrap="word",
	bd=4,bg="white",relief="flat")
logBar = Tk.Scrollbar(split2Pane2,name="logBar")
log['yscrollcommand'] = logBar.set
logBar['command'] = log.yview

logBar.pack(side="right", fill="y")
log.pack(expand=1, fill="both")</t>
<t tx="T304">t = leoNodes.tnode()
v = leoNodes.vnode(c,t)
v.initHeadString("NewHeadline")
v.moveToRoot()
c.tree.redraw()
c.tree.canvas.focus_get()
c.editVnode(v)</t>
<t tx="T305">def OnPaste (self,event=None):

	# Activate the body key handler by hand.
	self.commands.tree.onBodyChanged()
	return # Allow the actual paste!
	
def OnPasteNode (self,event=None):

	# trace(`event`)
	return "break" # inhibit further command processing ??
	
def OnPasteFromMenu (self,event=None):

	# trace()
	w = self.getFocus()
	w.event_generate(virtual_event_name("Paste"))</t>
<t tx="T306">def OnCopy (self,event=None):

	# Copy never changes dirty bits or syntax coloring.
	
	# Copy the selection to the internal clipboard.
	app().clipboard = getSelectedText(self.body)
	# trace(`app().clipboard`)
	return # Allow the actual copy!
	
def OnCopyFromMenu (self,event=None):

	# trace()
	w = self.getFocus()
	w.event_generate(virtual_event_name("Copy"))</t>
<t tx="T307">def OnCut (self,event=None):

	# Activate the body key handler by hand.
	self.commands.tree.onBodyChanged()
	
	# Copy the selection to the internal clipboard.
	app().clipboard = getSelectedText(self.body)
	# trace(`app().clipboard`)
	return # Allow the actual cut!

def OnCutFromMenu (self,event=None):

	w = self.getFocus()
	w.event_generate(virtual_event_name("Cut"))</t>
<t tx="T308">def canPasteOutline(self, s=None):

	c = self
	if s == None: s = app().clipboard

	# trace(`s`)
	if s and len(s) &gt;= len(prolog_string) and s[0:len(prolog_string)] == prolog_string:
		return true
	else:
		return false ## not yet.
		return c.stringsAreValidMoreFile(s)</t>
<t tx="T309"></t>
<t tx="T310">def cutOutline(self):

	c = self
	if c.canDeleteHeadline():
		c.copyOutline()
		c.deleteHeadline()
		c.recolor()
</t>
<t tx="T311">def copyOutline(self):

	c = self
	c.endEditing()
	c.fileCommands.assignFileIndices()
	s = c.fileCommands.putLeoOutline()
	app().clipboard = s

	# This is not essential for cutting and pasting between apps.
	if 0:
		if len(s) &gt; 0:
			app().root.clipboard_clear()
			app().root.clipboard_append(s)</t>
<t tx="T312">@ To cut and paste between apps, just copy into an empty body first, then copy to Leo's clipboard.
@c

def pasteOutline(self):

	c = self ; s = app().clipboard
	if not c.canPasteOutline(s):
		es("The clipboard is not a valid outline")
		return

	isLeo = len(s)&gt;=len(prolog_string) and prolog_string==s[0:len(prolog_string)]

	# trace(`s`)
	if isLeo:
		v = c.fileCommands.getLeoOutline(s)
	else:
		v = c.convertMoreStringsToOutlineAfter(s,current) ## s used to be a stringlist
	if v:
		c.endEditing()
		c.beginUpdate()
		if 1: # inside update...
			v.createDependents()# To handle effects of clones.
			c.validateOutline()
			c.selectVnode(v)
			v.setDirty()
			c.setChanged(true)
			# paste as first child if back is expanded.
			back = v.back()
			if back and back.isExpanded():
				v.moveToNthChildOf(back,0)
		c.endUpdate()
		c.recolor()
	else:
		es("The clipboard is not a valid " + choose(isLeo,"Leo","MORE") + " file")</t>
<t tx="T313">def canRevert(self):

	# c.mFileName will be "untitled" for unsaved files.
	c = self
	return ( c.frame and c.frame.mFileName and
		len(c.frame.mFileName) &gt; 0 and c.isChanged() )</t>
<t tx="T314">def OnRevert(self,event=None):

	# Make sure the user wants to Revert.
	if not self.mFileName:
		self.mFileName = ""
	if len(self.mFileName)==0:
		return "break" # inhibit further command processing
	
	d = leoDialog.leoDialog()
	reply = d.askYesNo("Revert",
		"Revert to previous version of " + self.mFileName + "?")

	if reply=="no":
		return "break" # inhibit further command processing

	# Kludge: rename this frame so OpenWithFileName won't think it is open.
	fileName = self.mFileName ; self.mFileName = ""

	# Create a new frame before deleting this frame.
	ok, frame = self.OpenWithFileName(fileName)
	if ok:
		frame.top.deiconify()
		app().windowList.remove(self)
		self.destroy() # Destroy this frame.
	else:
		self.mFileName = fileName
	return "break" # inhibit further command processing</t>
<t tx="T315">def OnDelete(self,event=None):

	c = self.commands
	first, last = getTextSelection(self.body)
	if first and last:
		self.body.delete(first,last)
		c.tree.onBodyChanged()
	return "break" # inhibit further command processing</t>
<t tx="T316"></t>
<t tx="T317"># t is a Tk.Text widget.  Returns the selected range of t.

def getTextSelection (t):

	# To get the current selection
	sel = t.tag_ranges("sel")
	if len(sel) == 2:
		start, end = sel # unpack tuple.
		return start, end
	else: return None, None</t>
<t tx="T318"># t is a Tk.Text widget.  Returns the text of the selected range of t.

def getSelectedText (t):

	start, end = getTextSelection(t)
	if start and end:
		return t.get(start,end)
	else:
		return None</t>
<t tx="T319">@ t is a Tk.Text widget.  start and end are positions.  Selects from start to end.
@c

def setTextSelection (t,start,end): 

	if not start or not end:
		return
	if t.compare(start, "&gt;", end):
		start,end = end,start
		
	t.tag_remove("sel","1.0",start)
	t.tag_add("sel",start,end)
	t.tag_remove("sel",end,"end")
	t.mark_set("insert",end)</t>
<t tx="T320"></t>
<t tx="T321"># Returns optimized whitespace corresponding to width with the indicated tab_width.

def computeLeadingWhitespace (width, tab_width):

	if width &lt;= 0:
		return ""
	if tab_width &gt; 1:
		tabs   = width / tab_width
		blanks = width % tab_width
		return ('\t' * tabs) + (' ' * blanks)
	else:
		return (' ' * width)</t>
<t tx="T322"># Remove whitespace up to ws wide in s, given tab_width, the width of a tab.

def removeLeadingWhitespace (s, ws, tab_width):

	j = 0 ; ws = 0
	for ch in s:
		if ws &gt;= first_ws:
			break
		elif ch == ' ':
			j += 1 ; ws += 1
		elif ch == '\t':
			j += 1 ; ws += (tab_width - (ws % tab_width))
		else: break
	if j &gt; 0:
		s = s[j:]

</t>
<t tx="T323"># Optimize leading whitespace in s with the given tab_width.

def optimizeLeadingWhitespace (line,tab_width):

	i, width = skip_leading_ws_with_indent(line,0,tab_width)
	s = computeLeadingWhitespace(width,tab_width) + line[i:]
	return s</t>
<t tx="T324">@ Skips leading whitespace and returns (i, indent), where i points after the whitespace and indent is the width of the whitespace, assuming tab_width wide tabs.
@c

def skip_leading_ws_with_indent(s,i,tab_width):

	count = 0 ; n = len(s)
	while i &lt; n:
		ch = s[i]
		if ch == ' ':
			count += 1
			i += 1
		elif ch == '\t':
			count += (tab_width - (count % tab_width))
			i += 1
		else: break

	return i, count



</t>
<t tx="T325">def canExtract(self):

	c = self
	if c.body:
		i, j = getTextSelection(c.body)
		return i and j and c.body.compare(i, "!=", j)
	else:
		return false

canExtractSection = canExtract
canExtractSectionNames = canExtract</t>
<t tx="T326"></t>
<t tx="T327">def convertBlanks (self):

	c = self ; v = c.currentVnode()
	head, lines, tail = self.getBodyLines()
	result = [] ; changed = false
	for line in lines:
		s = optimizeLeadingWhitespace(line,c.tab_width)
		if s != line: changed = true
		result.append(s)
	if changed:
		result = string.join(result,'\n')
		self.updateBodyPane(head,result,tail)</t>
<t tx="T328">def createLastChildNode (self,parent,headline,body):
	
	c = self
	if body and len(body) &gt; 0:
		body = string.rstrip(body)
	if not body or len(body) == 0:
		body = ""
	v = parent.insertAsLastChild()
	v.initHeadString(headline)
	v.t.setTnodeText(body)
	v.createDependents() # To handle effects of clones.
	v.setDirty()
	c.validateOutline()</t>
<t tx="T329">def dedentBody (self):

	c = self ; v = c.currentVnode()
	head, lines, tail = self.getBodyLines()
	result = [] ; changed = false
	for line in lines:
		i, width = skip_leading_ws_with_indent(line,0,c.tab_width)
		s = computeLeadingWhitespace(width-c.tab_width,c.tab_width) + line[i:]
		if s != line: changed = true
		result.append(s)
	if changed:
		result = string.join(result,'\n')
		self.updateBodyPane(head,result,tail)</t>
<t tx="T330">def extract(self):

	c = self ; v = c.currentVnode()
	head, lines, tail = self.getBodyLines()
	if not lines: return
	headline = lines[0] ; del lines[0]
	&lt;&lt; Set headline for extract &gt;&gt;
	# Remove leading whitespace from all body lines.
	result = []
	for line in lines:
		i, width = skip_leading_ws_with_indent(line,0,c.tab_width)
		result.append(line[i:])
	# Create a new node from lines.
	body = string.join(result,'\n')
	if head and len(head) &gt; 0:
		head = string.rstrip(head)
	c.beginUpdate()
	self.createLastChildNode(v,headline,body)
	self.updateBodyPane(head,None,tail)
	c.endUpdate()</t>
<t tx="T331">headline = string.strip(headline)
while len(headline) &gt; 0 and headline[0] == '/':
	headline = headline[1:]
headline = string.strip(headline)</t>
<t tx="T332">def extractSection(self):

	c = self ; v = c.currentVnode()
	head, lines, tail = self.getBodyLines()
	if not lines: return
	headline = lines[0] ; del lines[0]
	&lt;&lt; Set headline for extractSection &gt;&gt;
	# Remove leading whitespace from all body lines.
	result = []
	for line in lines:
		i, width = skip_leading_ws_with_indent(line,0,c.tab_width)
		result.append(line[i:])
	# Create a new node from lines.
	body = string.join(result,'\n')
	if head and len(head) &gt; 0:
		head = string.rstrip(head)
	c.beginUpdate()
	self.createLastChildNode(v,headline,body)
	self.updateBodyPane(head,None,tail)
	c.endUpdate()</t>
<t tx="T333">while len(headline) &gt; 0 and headline[0] == '/':
	headline = headline[1:]
headline = string.strip(headline)

# Make sure we have a @&lt; or &lt;&lt;
if headline[0:2] != '&lt;&lt;' and headline[0:2] != '@&lt;': return</t>
<t tx="T334">def extractSectionNames(self):

	c = self ; v = c.currentVnode()
	head, lines, tail = self.getBodyLines()
	if not lines: return
	# Save the selection.
	i, j = self.getBodySelection()
	c.beginUpdate()
	for s in lines:
		&lt;&lt; Find the next section name &gt;&gt;
		if name: self.createLastChildNode(v,name,None)
	c.selectVnode(v)
	c.validateOutline()
	c.endUpdate()
	# Restore the selection.
	setTextSelection(c.body,i,j)
	c.body.focus_force()</t>
<t tx="T335">head1 = string.find(s,"&lt;&lt;")
if head1 &gt; -1:
	head2 = string.find(s,"&gt;&gt;",head1)
else:
	head1 = string.find(s,"@&lt;")
	if head1 &gt; -1:
		head2 = string.find(s,"@&gt;",head1)
		
if head1 == -1 or head2 == -1 or head1 &gt; head2:
	name = None
else:
	name = s[head1:head2+2]</t>
<t tx="T336">def getBodyLines (self):
	
	c = self
	i, j = getTextSelection(c.body)
	if i and j: # Convert all lines containing any part of the selection.
		if c.body.compare(i,"&gt;",j): i,j = j,i
		i = c.body.index(i + "linestart")
		j = c.body.index(j + "lineend")
		head = c.body.get("1.0",i)
		tail = c.body.get(j,"end")
	else: # Convert the entire text.
		i = "1.0" ; j = "end" ; head = tail = ""
	lines = c.body.get(i,j)
	lines = string.split(lines, '\n')
	return head, lines, tail</t>
<t tx="T337">def getBodySelection (self):

	c = self
	i, j = getTextSelection(c.body)
	if i and j and c.body.compare(i,"&gt;",j):
		i,j = j,i
	return i, j</t>
<t tx="T338">def indentBody (self):

	c = self ; v = c.currentVnode()
	head, lines, tail = self.getBodyLines()
	result = [] ; changed = false
	for line in lines:
		i, width = skip_leading_ws_with_indent(line,0,c.tab_width)
		s = computeLeadingWhitespace(width+c.tab_width,c.tab_width) + line[i:]
		if s != line: changed = true
		result.append(s)
	if changed:
		result = string.join(result,'\n')
		self.updateBodyPane(head,result,tail)</t>
<t tx="T339">def updateBodyPane (self,head,middle,tail):
	
	c = self ; v = c.currentVnode()
	# Update the text and set start, end.
	c.body.delete("1.0","end")
	# The caller must do rstrip.head if appropriate.
	if head and len(head) &gt; 0:
		c.body.insert("end",head)
		start = c.body.index("end-1c")
	else: start = "1.0"
	if middle and len(middle) &gt; 0:
		middle = string.rstrip(middle)
	if middle and len(middle) &gt; 0:
		c.body.insert("end",middle)
		end = c.body.index("end-1c")
	else: end = start
	if tail and len(tail) &gt; 0:
		tail = string.rstrip(tail)
	if tail and len(tail) &gt; 0:
		c.body.insert("end",tail)
	# Activate the body key handler by hand.
	c.tree.onBodyChanged()
	# Update the changed mark.
	if not c.isChanged():
		c.setChanged(true)
	# Update the icon.
	c.beginUpdate()
	if not v.isDirty():
		v.setDirty()
	c.endUpdate()
	# Update the selection.
	# trace(`start` + "," + `end`)
	setTextSelection(c.body,start,end)
	c.body.see("insert")
	c.body.focus_force()</t>
<t tx="T340">@ The &lt;Key&gt; event generates the event before the headline text is changed(!), so we register an idle-event handler to do the work later.
@c

def OnHeadlineKey(self,v,event):

	v = self.currentVnode ; ch = event.char
	self.commands.body.after_idle(self.idle_head_key,v,ch)

def idle_head_key (self,v,ch=None):

	c = self.commands
	if not v or not v.edit_text or v != c.currentVnode():
		return
	s = v.edit_text.get("1.0","end")
	# print "idle_head_key", s
	# remove all newlines and update the vnode
	s = string.replace(s,'\n','')
	s = string.replace(s,'\r','')
	changed = s != v.headString()
	done = ch and (ch == '\r' or ch == '\n')

	if not changed and not done:
		return
		
	index = v.edit_text.index("insert")
		
	# print `ch` + ", changed:" + `changed` + ", " + `s`

	if changed:
		c.beginUpdate()
		# Update changed bit.
		if not c.changed:
			c.setChanged(true)
		# Update all dirty bits.
		v.setDirty() 
		# Update v.
		v.initHeadString(s)
		v.edit_text.delete("1.0","end")
		v.edit_text.insert("end",s)
		v.edit_text.mark_set("insert",index)
		# Update all joined nodes.
		v2 = v.joinList
		while v2 and v2 != v:
			v2.initHeadString(s)
			if v2.edit_text: # v2 may not be visible
				v2.edit_text.delete("1.0","end")
				v2.edit_text.insert("end",s)
			v2 = v2.joinList
		c.endUpdate(false) # do not redraw now.

	# Reconfigure v's headline.
	if done:
		if self.bodyKeepsFocus:
			v.edit_text.configure(state="disabled",fg="black",bg="gray80",width=self.headWidth(v))
		else:
			v.edit_text.configure(state="disabled",fg="white",bg="DarkBlue",width=self.headWidth(v))
	else:
		v.edit_text.configure(width=self.headWidth(v))

	# Reconfigure all joined headlines.
	v2 = v
	while v2 and v2 != v:
		if v2.edit_text: # v2 may not be visible
			v2.edit_text.configure(width=self.headWidth(v2))
		v2 = v2.joinList
		
	# Update the screen.
	if done:
		c.beginUpdate()
		self.endEditLabel()
		c.endUpdate()
	elif changed:
		# update v immediately.  Joined nodes are redrawn later by endEditLabel.
		# Redrawing the whole screen now messes up the cursor in the headline.
		self.drawIcon(v,v.iconx,v.icony) # just redraw the icon.</t>
<t tx="T341"># Calling redraw inside c.beginUpdate()/c.endUpdate() does nothing.
# This _is_ useful when a flag is passed to c.endUpdate.
def redraw (self):
	if self.updateCount == 0 and not self.redrawScheduled:
		# print "tree.redraw"
		self.redrawScheduled = true
		self.canvas.after_idle(self.idle_redraw)
		
# Schedules a redraw even if inside beginUpdate/endUpdate
def force_redraw (self):
	# print "tree.force_redraw"
	if not self.redrawScheduled:
		self.redrawScheduled = true
		self.canvas.after_idle(self.idle_redraw)
		
# Redraws immediately: used by Find so a redraw doesn't mess up selections.
# It is up to the caller to ensure that no other redraws are pending.
def redraw_now (self):

	# print "tree.redraw_now: ", self.redrawScheduled
	self.idle_redraw()

def idle_redraw (self):

	self.redrawScheduled = false
	frame = self.commands.frame
	if frame in app().windowList and app().quitting == 0:
		# self.redrawCount += 1 ; trace(`self.redrawCount`)
		self.expandAllAncestors(self.currentVnode)
		# Erase and redraw the entire tree.
		oldcursor = self.canvas['cursor']
		self.canvas['cursor'] = "watch"
		self.canvas.delete("all")
		self.drawTree(self.rootVnode,root_left,root_top,0,0)
		self.canvas['cursor'] = oldcursor
		# Set up the scroll region.
		x0, y0, x1, y1 = self.canvas.bbox("all")
		self.canvas.configure(scrollregion=(0, 0, x1, y1))
		# Schedule a scrolling operation after the scrollbar is redrawn
		self.canvas.after_idle(self.idle_scrollTo)</t>
<t tx="T342">def setNormalLabelState (self,v): # selected, editing
	if v and v.edit_text:
		v.edit_text.configure(state="normal",highlightthickness=1,fg="black", bg="white")

def setDisabledLabelState (self,v): # selected, disabled
	if v and v.edit_text:
		v.edit_text.configure(state="disabled",highlightthickness=0,fg="black",bg="gray80")

def setSelectedLabelState (self,v): # selected, not editing
	if self.bodyKeepsFocus:
		self.setDisabledLabelState(v)
	elif v and v.edit_text:
		v.edit_text.configure(state="disabled",highlightthickness=0,fg="white",bg="DarkBlue")

def setUnselectedLabelState (self,v): # not selected.
	if v and v.edit_text:
		v.edit_text.configure(state="disabled",highlightthickness=0,fg="black",bg="white")</t>
<t tx="T343">@ The find command is surprisingly tricky; there are many details that must be handled properly.  This documentation states some important design principles and discusses some code details.


Design Principles:

The following principles influence all aspects of the Find class:

1. Find and Change commands initialize themselves using only the state of the present Leo window. In particular, the Find class must not save internal state inforamtion from one invocation to the next.  This means that when the user changes the nodes, or selects new text in headline or body text, those changes will affect the next invocation of any Find or Change command.  Failure to follow this cardinal principle caused all kinds of problems in the Borland and Macintosh code.

This principle simplifies the code somewhat because ivars do not persist.  OTOH, each command must ensure that the Leo window is left in a state suitable for restarting the incremental(interactive) Find and Change commands.  Initialization is by far the most tricky aspect of the Find class.  Details are discussed below in the "About Initialization" section.

There is one exception to this rule. We must remember where interactive wrapped searches start. We clear self.wrapVnode when the Find panel changes.  Interactive searches set and clear these persistent ivars as needed.

2. Commands must not change the state of the outline or body pane during execution: that would cause severe flashing and slow down the commands a great deal.  In particular, c.selectVnode() and c.editVnode() must not be called while looking for matches.  This has several important consequences, discussed below in the About Searching section.

3.  The Find All and Change All commands always restore the Leo window to its state on entry.  Incremental commands restore the Leo window to its state on entry if no match is found.  The save and restore routines do this.

About Initialization

The setup_commands() and setup_buttons() methods perform common initialization for menu commands and Find panel buttons respectively.  The initBatchCommands(), initInteractiveCommands() and initInHeadline() methods handle details of initialization.  Initialization involves setting the self.c, self.v, self.in_headline, self.wrapping and self.s_text ivars.  Setting self.in_headline is tricky: we must be sure to retain the state of the outline pane until initialization is complete.  Initializing the Find All and Change All commands is much easier than initializing incremental Find or Change commands because such initialization does not depend greatly on the state of the Leo window.

About Searching

Using Tk.Text widgets for both headlines and body text results in a _huge_ simplification of the code.  The actual searching takes place in the search() method.  search() must not assume that c.currentVnode() is the current node to be searched.  Instead, search() assumes that:

1. self.s_text is a Tk.Text widget that contains the text to be searched or changed.
2. The "insert" and "sel" attributes of self.search_text indicate the range of text to be searched.

The selectNextVnode() method handles the many details of selecting the next node to be searched.  selectNextVnode() and its allies set self.s_text, including its "insert" and "sel" attributes.

The actual searching is easy: search() just calls the Tk search_text.search() method.

About Finalization

When incremental Find or Change commands succeeed they must leave the Leo window in the proper state to execute another incremental command.  The showSuccess() method does this.  show_success() calls c.currentVnode() or c.editVnode and set the insertion point and the range of selected text.

We restore the Leo window as it was on entry whenever an incremental search fails and after any Find All and Change All command.  The save() and restore() methods do this.
</t>
<t tx="T344">def __init__(self):

	Tk=Tkinter
	&lt;&lt; Initialize the leoFind ivars &gt;&gt;
	self.top = top = Tk.Toplevel()
	top.title("Leo Find/Change")
	top.resizable(0,0) # neither height or width is resizable.
	# self.top.SetIcon("LeoIcon")

	# Create the find panel...
	&lt;&lt; Create the Find and Change panes &gt;&gt;
	&lt;&lt; Create two columns of checkboxes &gt;&gt;
	&lt;&lt; Create two rows of buttons &gt;&gt;
	self.top.protocol("WM_DELETE_WINDOW", self.OnCloseFindEvent)
	self.find_text.bind  ("&lt;1&gt;", self.resetWrap)
	self.change_text.bind("&lt;1&gt;", self.resetWrap)
	self.find_text.bind  ("&lt;Key&gt;", self.resetWrap)
	self.change_text.bind("&lt;Key&gt;", self.resetWrap)</t>
<t tx="T345"># Initialize the ivars for the find panel.
for var in ivars:
	exec ("self.%s_flag = Tk.IntVar()" % var)
	
# The c.x_flag ivars contain the user preferences.
# These are updated just before executing any find/change command.

# Ivars containing internal state...
self.commands = None # The commander for this search.
self.v = None # The vnode being searched.  Never saved between searches!
self.in_headline = false # true: searching headline text.
self.wrapping = false # true: wrapping is enabled. _not_ the same as c.wrap_flag for batch searches.
self.s_text = Tk.Text() # Used by find.search()

@ Initializing a wrapped search is tricky.  The search() method will fail if v==wrapVnode and pos &gt;= wrapPos.  selectNextVnode() will fail if v == wrapVnode.  We set wrapPos on entry, before the first search.  We set wrapVnode in selectNextVnode after the first search fails.  We also set wrapVnode on exit if the first search suceeds.
@c
self.wrapVnode = None # The start of wrapped searches: persists between calls.
self.onlyVnode = None # The starting node for suboutline-only searches.
self.wrapPos = None # The starting position of the wrapped search: persists between calls.</t>
<t tx="T346">fc = Tk.Frame(top, bd="1m")
fc.pack(anchor="n", fill="x", expand=1)

fpane = Tk.Frame(fc, borderwidth=1, height="0.95i", width="1.5i")
cpane = Tk.Frame(fc, borderwidth=1, height="0.95i", width="1.5i")

fpane.pack(anchor="n", expand=1, fill="x")
cpane.pack(anchor="s", expand=1, fill="x")

# Create the labels and text fields...
flab = Tk.Label(fpane, width=8, text="Find:")
clab = Tk.Label(cpane, width=8, text="Change:")
self.find_text   = ftxt = Tk.Text(fpane, height=2, width=20)
self.change_text = ctxt = Tk.Text(cpane, height=2, width=20)

flab.pack(side="left")
clab.pack(side="left")
ctxt.pack(side="right", expand=1, fill="both")
ftxt.pack(side="right", expand=1, fill="both")</t>
<t tx="T347">boxes = Tk.Frame(top, bd="1m")
boxes.pack(anchor="n", expand=1, fill="x")

lt = Tk.Frame(boxes, bd=1)
rt = Tk.Frame(boxes, bd=1)
lt.pack(side="left", padx="5m")
rt.pack(side="right", ipadx="2m")

lt_list = [
	("Show Context", "batch"), # batch flag now records Show context.
	("Wrap Around", "wrap"), ("Whole Word", "whole_word"),
	("Ignore Case", "ignore_case"),("Pattern Match", "pattern_match") ]

rt_list = [ ("Search Headline Text", "search_headline"),
	("Search Body Text", "search_body"), ("Suboutline Only", "suboutline_only"),
	("Mark Changes", "mark_changes"), ("Mark Finds", "mark_finds") ]

for name, var in lt_list:
	exec ( 'box = Tk.Checkbutton(lt, anchor="w", text="' + name +
		'", variable=self.' + var + "_flag)" )
	box.pack(fill="x")
	box.bind("&lt;1&gt;", self.resetWrap)
	
for name, var in rt_list:
	exec ( 'box = Tk.Checkbutton(rt, anchor="w", text="' + name +
		'", variable=self.' + var + "_flag)" )
	box.pack(fill="x")
	box.bind("&lt;1&gt;", self.resetWrap)</t>
<t tx="T348"># Create the button panes
buttons  = Tk.Frame(top, bd=1)
buttons2 = Tk.Frame(top, bd=1)
buttons.pack (anchor="n", expand=1, fill="x")
buttons2.pack(anchor="n", expand=1, fill="x")

# Create the first row of buttons
findButton   =Tk.Button     (buttons,width=8,text="Find",command=self.findButton)
reverseBox   =Tk.Checkbutton(buttons,width=8,text="Reverse",variable=self.reverse_flag)
findAllButton=Tk.Button     (buttons,width=8,text="Find All",command=self.findAllButton)

reverseBox.bind("&lt;1&gt;", self.resetWrap)

findButton.pack   (pady="1m",padx="1m",side="left")
reverseBox.pack   (pady="1m",          side="left",expand=1)
findAllButton.pack(pady="1m",padx="1m",side="left")

# Create the second row of buttons
changeButton    =Tk.Button(buttons2,width=8,text="Change",command=self.changeButton)
changeFindButton=Tk.Button(buttons2,        text="Change, Then Find",command=self.changeThenFindButton)
changeAllButton =Tk.Button(buttons2,width=8,text="Change All",command=self.changeAllButton)

changeButton.pack    (pady="1m",padx="1m",side="left")
changeFindButton.pack(pady="1m",          side="left",expand=1)
changeAllButton.pack (pady="1m",padx="1m",side="right")</t>
<t tx="T349">def init (self,c):

	for var in ivars:
		exec("self.%s_flag.set(c.%s_flag)" % (var,var))

	&lt;&lt; set widgets &gt;&gt;
	
	# trace("__init__", "find.init")</t>
<t tx="T350">self.find_text.delete("1.0","end")
self.find_text.insert("end",c.find_text)

self.change_text.delete("1.0","end")
self.change_text.insert("end",c.change_text)</t>
<t tx="T351">def resetWrap (self,event=None):

	self.wrapVnode = None
	self.onlyVnode = None</t>
<t tx="T352"></t>
<t tx="T353">
# The user has pushed the "Change" button from the find panel.

def changeButton(self):

	c = self.setup_button()
	self.change()</t>
<t tx="T354"># The user has pushed the "Change All" button from the find panel.

def changeAllButton(self):

	c = self.setup_button()
	c.clearAllVisited() # Clear visited for context reporting.
	self.changeAll()</t>
<t tx="T355"># The user has pushed the "Change Then Find" button from the find panel.

def changeThenFindButton(self):

	c = self.setup_button()
	self.changeThenFind()</t>
<t tx="T356"># The user has pushed the "Find" button from the find panel.

def findButton(self):

	c = self.setup_button()
	self.findNext()</t>
<t tx="T357"># The user has pushed the "Find All" button from the find panel.

def findAllButton(self):

	c = self.setup_button()
	c.clearAllVisited() # Clear visited for context reporting.
	self.findAll()</t>
<t tx="T358"># The user has selected the "Replace" menu item.

def changeCommand(self,c):

	self.setup_command(c)
	self.change()</t>
<t tx="T359"># The user has pushed the "Change Then Find" button from the Find menu.

def changeThenFindCommand(self,c):

	self.setup_command(c)
	self.changeThenFind()</t>
<t tx="T360"># The user has selected the "Find Next" menu item.

def findNextCommand(self,c):

	self.setup_command(c)
	self.findNext()</t>
<t tx="T361"># The user has selected the "Find Previous" menu item.

def findPreviousCommand(self,c):

	self.setup_command(c)
	c.reverse_flag = not c.reverse_flag
	self.findNext()
	c.reverse_flag = not c.reverse_flag</t>
<t tx="T362"># Initializes a search when a button is pressed in the Find panel.

def setup_button(self):

	self.commands = c = app().log.commands
	self.v = c.currentVnode()
	assert(c)
	c.bringToFront()
	if 0: # We _must_ retain the editing status for incremental searches!
		c.endEditing()
	c.setIvarsFromFind()
	return c</t>
<t tx="T363"># Initializes a search when a command is invoked from the menu.

def setup_command(self,c):

	self.commands = c
	self.v = c.currentVnode()
	if 0: # We _must_ retain the editing status for incremental searches!
		c.endEditing()
	c.setIvarsFromFind()</t>
<t tx="T364"></t>
<t tx="T365">@ This routine performs a single batch change operation, updating the head or body string of v and leaving the result in s_text.  We update the c.body if we are changing the body text of c.currentVnode().

s_text contains the found text on entry and contains the changed text on exit.  pos and pos2 indicate the selection.  The selection will never be empty. NB: we can not assume that self.v is visible.
@c

def batchChange (self,pos1,pos2):

	c = self.commands ; v = self.v ; st = self.s_text
	# Replace the selection with c.change_text
	# s = st.get("1.0","end") ; trace("entry:" + `s`)
	if st.compare(pos1, "&gt;", pos2):
		pos1,pos2=pos2,pos1
	st.delete(pos1,pos2)
	st.insert(pos1,c.change_text)
	s = st.get("1.0","end")
	# Update the selection.
	insert=choose(c.reverse_flag,pos1,pos1+'+'+`len(c.change_text)`+'c')
	st.tag_remove("sel","1.0","end")
	st.mark_set("insert",insert)
	# trace("result:" + `insert` + ", " + `s`)
	# Update the node
	if self.in_headline:
		v.initHeadString(s)
	else:
		v.setBodyStringOrPane(s)
	# Set mark, changed and dirty bits.
	if c.mark_changes_flag:
		v.setMarked()
	if not c.isChanged():
		c.setChanged(true)
	v.setDirty()</t>
<t tx="T366">def change(self):

	if self.checkArgs():
		self.initInHeadline()
		self.changeSelection()</t>
<t tx="T367">def changeAll(self):

	c = self.commands ; st = self.s_text
	if not self.checkArgs():
		return
	self.initInHeadline()
	data = self.save()
	self.initBatchCommands()
	count = 0
	c.beginUpdate()
	while 1:
		pos1, pos2 = self.findNextMatch()
		if pos1:
			count += 1
			self.batchChange(pos1,pos2)
			line = st.get(pos1 + " linestart", pos1 + " lineend")
			self.printLine(line,all)
		else: break
	c.endUpdate() # self.restore
	# Make sure the headline and body text are updated.
	v = c.currentVnode()
	c.tree.idle_head_key(v)
	c.tree.idle_body_key(v)
	es("changed: " + `count`)
	self.restore(data)</t>
<t tx="T368"># Replace selection with c.change_text.
# If no selection, insert c.change_text at the cursor.

def changeSelection(self):
	
	c = self.commands ; v = self.v
	# trace(`self.in_headline`)
	t = choose(self.in_headline,v.edit_text,c.body)
	# Not yet: set undo params.
	sel = t.tag_ranges("sel")
	if len(sel) != 2:
		es("No text selected")
		return false
	# trace(`sel` + ", " + `c.change_text`)
	# Replace the selection
	start,end = sel
	t.delete(start,end)
	t.insert(start,c.change_text)
	# 2/7/02: Also update s_text in case we find another match on the same line.
	self.s_text.delete(start,end)
	self.s_text.insert(start,c.change_text)
	# Update the selection for the next match.
	setTextSelection(t,start,start + "+" + `len(c.change_text)` + "c")
	t.focus_force()

	c.beginUpdate()
	if c.mark_changes_flag:
		v.setMarked()
		c.tree.drawIcon(v,v.iconx,v.icony) # redraw only the icon.
	# update node, dirty flag, changed mark &amp; recolor
	if self.in_headline:
		c.tree.idle_head_key(v)
	else:
		c.tree.idle_body_key(v)
	c.endUpdate(false) # No redraws here: they would destroy the headline selection.
	# trace(c.body.index("insert")+":"+c.body.get("insert linestart","insert lineend"))
	return true</t>
<t tx="T369">def changeThenFind(self):

	c = self.commands
	if not self.checkArgs():
		return

	self.initInHeadline()
	if self.changeSelection():
		self.findNext(false) # don't reinitialize</t>
<t tx="T370">def findAll(self):

	c = self.commands ; st = self.s_text
	if not self.checkArgs():
		return
	self.initInHeadline()
	data = self.save()
	self.initBatchCommands()
	count = 0
	c.beginUpdate()
	while 1:
		pos, newpos = self.findNextMatch()
		if pos:
			count += 1
			line = st.get(pos + " linestart", pos + " lineend")
			self.printLine(line,all)
		else: break
	c.endUpdate()
	es("found: " + `count`)
	self.restore(data)</t>
<t tx="T371">def findNext(self,initFlag = true):

	c = self.commands ; v = self.v
	if not self.checkArgs():
		return
		
	if initFlag:
		self.initInHeadline()
		data = self.save()
		self.initInteractiveCommands()
	else:
		data = self.save()
	
	c.beginUpdate()
	pos, newpos = self.findNextMatch()
	c.endUpdate(false) # Inhibit redraws so that headline remains selected.
	
	if pos:
		self.showSuccess(pos,newpos)
	else:
		if self.wrapping:
			es("end of wrapped search")
		else:
			es("not found: " + `c.find_text`)
		self.restore(data)</t>
<t tx="T372"># Resumes the search where it left off.
# The caller must call set_first_incremental_search or set_first_batch_search.

def findNextMatch(self):

	c = self.commands

	if not c.search_headline_flag and not c.search_body_flag:
		return None, None

	if len(c.find_text) == 0:
		return None, None
		
	v = self.v
	while v:
		pos, newpos = self.search()
		if pos:
			if c.mark_finds_flag:
				v.setMarked()
				c.tree.drawIcon(v,v.iconx,v.icony) # redraw only the icon.
			return pos, newpos
		else:
			v = self.v = self.selectNextVnode()
	return None, None</t>
<t tx="T373"># Selects the next node to be searched.

def selectNextVnode(self):

	c = self.commands ; v = self.v
	# trace(`v`)
	
	# Start suboutline only searches.
	if c.suboutline_only_flag and not self.onlyVnode:
		self.onlyVnode = v

	# Start wrapped searches.
	if self.wrapping and not self.wrapVnode:
		assert(self.wrapPos != None)
		self.wrapVnode = v

	if self.in_headline and c.search_body_flag:
		# just switch to body pane.
		self.in_headline = false
		self.initNextText()
		# trace(`v`)
		return v

	if c.reverse_flag:
		v = v.threadBack()
	else:
		v = v.threadNext()

	# Wrap if needed.
	if not v and self.wrapping and not c.suboutline_only_flag:
		v = c.rootVnode()
		if c.reverse_flag:
			# Set search_v to the last node of the tree.
			while v and v.next():
				v = v.next()
			if v: v = v.lastNode()

	# End wrapped searches.
	if self.wrapping and v and v == self.wrapVnode:
		# trace("ending wrapped search")
		v = None ; self.resetWrap()
		
	# End suboutline only searches.
	if (c.suboutline_only_flag and self.onlyVnode and v and
		(v == self.onlyVnode or not self.onlyVnode.isAncestorOf(v))):
		# trace("end outline-only")
		v = None ; self.onlyVnode = None

	self.v = v # used in initNextText().
	if v: # select v and set the search point within v.
		self.in_headline = c.search_headline_flag
		self.initNextText()
	return v</t>
<t tx="T374">@ Searches the present headline or body text for c.find_text and returns true if found.
c.whole_word_flag, c.ignore_case_flag, and c.pattern_match_flag control the search.
@c

def search (self):

	c = self.commands ; v = self.v ; t = self.s_text
	assert(c and t and v)
	index = t.index("insert")
	stopindex = choose(c.reverse_flag,"1.0","end")
	while 1:
		# trace(`index`+":"+`stopindex`+":"+t.get(index+" linestart",index+" lineend"))
		pos = t.search(c.find_text,index,
			stopindex=stopindex,backwards=c.reverse_flag,
			regexp=c.pattern_match_flag,nocase=c.ignore_case_flag)
		if not pos:
			# trace("not found")
			return None, None
		newpos = pos + "+" + `len(c.find_text)` + "c"
		&lt;&lt; return if we are passed the wrap point &gt;&gt;
		if c.whole_word_flag:
			index = t.index(choose(c.reverse_flag,pos,newpos))
			&lt;&lt; test for whole word match &gt;&gt;
			if not pos: continue
		# trace("found:" + `pos` + ":" + `newpos` + ":" + `v`)
		# set the insertion point.
		setTextSelection(t,pos,newpos)
		t.mark_set("insert",choose(c.reverse_flag,pos,newpos))
		return pos, newpos</t>
<t tx="T375">if self.wrapping and self.wrapPos and self.wrapVnode and self.v == self.wrapVnode:
	if c.reverse_flag and t.compare(pos, "&lt;", self.wrapPos):
		# trace("wrap done")
		return None, None
	if not c.reverse_flag and t.compare(newpos, "&gt;", self.wrapPos):
		return None, None</t>
<t tx="T376"># Set pos to None if word characters preceed or follow the selection.

before = t.get(pos + "-1c", pos)
first  = t.get(pos)
last   = t.get(newpos)
after  = t.get(newpos, newpos + "+1c")
# print `before`, `first`, `last`, `after`

if before and is_c_id(before) and first and is_c_id(first):
	pos = None
if after  and is_c_id(after)  and last  and is_c_id(last):
	pos = None</t>
<t tx="T377"></t>
<t tx="T378">def checkArgs (self):

	c = self.commands 
	val = true
	if not c.search_headline_flag and not c.search_body_flag:
		es("not searching headline or body")
		val = false
	if len(c.find_text) == 0:
		es("empty find patttern")
		val = false
	return val</t>
<t tx="T379"># Initializes for the Find All and Change All commands.

def initBatchCommands (self):

	c = self.commands
	self.in_headline = c.search_headline_flag # Search headlines first.

	# Select the first node.
	if c.suboutline_only_flag:
		self.v = c.currentVnode()
	else:
		v = c.rootVnode()
		if c.reverse_flag:
			while v and v.next():
				v = v.next()
			v = v.lastNode()
		self.v = v
	
	# Set the insert point.
	self.initBatchText()</t>
<t tx="T380">@ Returns s_text with "insert" point set properly for batch searches.
@c

def initBatchText(self):
	c = self.commands ; v = self.v ; st = self.s_text	
	s = choose(self.in_headline,v.headString(), v.bodyString())
	st.delete("1.0","end")
	st.insert("end",s)
	st.mark_set("insert",choose(c.reverse_flag,"end","1.0"))
	self.wrapping = false # Only interactive commands allow wrapping.
	return st

# Call this routine when moving to the next node when a search fails.
# Same as above except we don't reset wrapping flag.
def initNextText(self):
	c = self.commands ; v = self.v ; st = self.s_text	
	s = choose(self.in_headline,v.headString(), v.bodyString())
	st.delete("1.0","end")
	st.insert("end",s)
	st.mark_set("insert",choose(c.reverse_flag,"end","1.0"))
	return st</t>
<t tx="T381"># Guesses which pane to start in for incremental searches and changes.
# This must not alter the current "insert" or "sel" marks.

def initInHeadline (self):

	c = self.commands ; v = self.v
	
	if c.search_headline_flag and c.search_body_flag:
		# Do not change this line without careful thought and extensive testing!
		self.in_headline = (v == c.tree.editVnode)
	else:
		self.in_headline = c.search_headline_flag</t>
<t tx="T382"># For incremental searches

def initInteractiveCommands(self):

	c = self.commands ; v = self.v
	
	if self.in_headline:
		t = v.edit_text
		c.tree.editVnode = v
		pos = t.index("insert")
		# trace(`pos` + ":" + `self.in_headline` + ":" + `v==c.tree.editVnode` + ":" + `v`)
	else:
		t = c.body
		pos = t.index("insert")

	st = self.initNextText()
	t.focus_force()
	st.mark_set("insert",pos)
	self.wrapping = c.wrap_flag
	if c.wrap_flag and self.wrapVnode == None:
		self.wrapPos = pos
		# Do not set self.wrapVnode here: that must be done after the first search.</t>
<t tx="T383">def printLine (self,line,allFlag=false):

	c = self.commands
	both = c.search_body_flag and c.search_headline_flag
	context = c.batch_flag # "batch" now indicates context

	if allFlag and both and context:
		es(`self.v`)
		type = choose(self.in_headline,"head: ","body: ")
		es(type + line)
	elif allFlag and context and not self.v.isVisited():
		# We only need to print the context once.
		es(`self.v`)
		es(line)
		self.v.setVisited()
	else:
		es(line)</t>
<t tx="T384"># Restores the screen after a search fails

def restore (self,data):

	c = self.commands
	v,t,insert,start,end = data
	# trace(`insert` + ":" + `start` + ":" + `end`)
	c.selectVnode(v) # Don't try to reedit headline.
	if 0: # Looks bad.
		if start and end:
			setTextSelection(t,start,end)
	else: # Looks good and provides clear indication of failure or termination.
		t.tag_remove("sel","1.0","end")
	t.mark_set("insert",insert)
	t.see("insert")
	t.focus_force()</t>
<t tx="T385">def save (self):

	c = self.commands ; v = self.v
	t = choose(self.in_headline,v.edit_text,c.body)
	insert = t.index("insert")
	sel = t.tag_ranges("sel")
	if len(sel) == 2:
		start,end = sel
	else:
		start,end = None,None
	return (v,t,insert,start,end)</t>
<t tx="T386">@ This is used for displaying the final result.  It returns self.dummy_vnode, v.edit_text or c.body with "insert" and "sel" points set properly.
@c

def showSuccess(self,pos,newpos):

	c = self.commands ; v = self.v
	
	c.beginUpdate() # Prevent all redraws except c.tree.redraw_now()
	if 1: # range of update...
		c.selectVnode(v)
		c.tree.redraw_now() # Redraw now so selections are not destroyed.
		# Select the found vnode again after redraw.
		if self.in_headline:
			c.editVnode(v)
			c.tree.setNormalLabelState(v)
			assert(v.edit_text)
		else:
			c.selectVnode(v)
	c.endUpdate(false) # Do not draw again!

	t = choose(self.in_headline,v.edit_text,c.body)
	# trace(`self.in_headline` + "," + `t`)
	insert = choose(c.reverse_flag,pos,newpos)
	t.mark_set("insert",insert)
	setTextSelection(t,pos,newpos)
	if not self.in_headline:
		t.see(insert)
	t.focus_force()
	if c.wrap_flag and not self.wrapVnode:
		self.wrapVnode = self.v</t>
<t tx="T387">@ Two things must happen:

1. Menu items should be enabled only when focus is in the canvas pane.
2. Bindings for for the outline commands should be added only to the canvas pane.</t>
<t tx="T388">def canSelectThreadBack(self):

	c = self ; v = c.currentVnode()
	w = c.frame.top.focus_get()
	return w == c.canvas and v and v.threadBack()</t>
<t tx="T389">def canSelectThreadNext(self):

	c = self ; v = c.currentVnode()
	w = c.frame.top.focus_get()
	return w == c.canvas and v and v.threadNext()</t>
<t tx="T390">def canSelectVisBack(self):

	c = self ; v = c.currentVnode()
	w = c.frame.top.focus_get()
	return w == c.canvas and v and v.visBack()</t>
<t tx="T391">def canSelectVisNext(self):

	c = self ; v = c.currentVnode()
	w = c.frame.top.focus_get()
	return w == c.canvas and v and v.visNext()</t>
<t tx="T392">def selectThreadBack(self):

	c = self ; current = c.currentVnode()
	if not current: return
	
	v = current.threadBack()
	if v:
		c.beginUpdate()
		c.selectVnode(v)
		c.endUpdate()
		c.frame.canvas.focus_force()</t>
<t tx="T393">def selectThreadNext(self):

	c = self ; current = c.currentVnode()
	if not current: return

	v = current.threadNext()
	if v:
		c.beginUpdate()
		c.selectVnode(v)
		c.endUpdate()
		c.frame.canvas.focus_force()</t>
<t tx="T394"># This has an up arrow for a control key.

def selectVisBack(self):

	c = self ; current = c.currentVnode()
	if not current: return

	v = current.visBack()
	if v:
		c.beginUpdate()
		c.selectVnode(v)
		c.endUpdate()
		c.frame.canvas.focus_force()</t>
<t tx="T395">def selectVisNext(self):

	c = self ; current = c.currentVnode()
	if not current: return
	
	v = current.visNext()
	if v:
		c.beginUpdate()
		c.selectVnode(v)
		c.endUpdate()
		c.frame.canvas.focus_force()</t>
<t tx="T396"># This code is called from tangleTree and untangleTree.

def cleanup(self):

	if self.errors == 0:
	
		# Create a list of root names:
		root_names = [] ; dir = app().loadDir
		for section in self.root_list:
			for part in section.parts:
				if part.is_root:
					root_names.append(os.path.join(dir,part.name))

		if self.tangling and self.tangle_batch_flag:
			try:
				import tangle_done
				tangle_done.run(root_names)
			except: es("Can not execute tangle_done.run()")
		if not self.tangling and self.untangle_batch_flag:
			try:
				import untangle_done
				untangle_done.run(root_names)
			except: es("Can not execute tangle_done.run()")

	# Reinitialize the symbol tables and lists.
	self.tst = {}
	self.ust = {}
	self.root_list = []
	self.def_stack = []</t>
<t tx="T397">def destroy (self):

	if not app().deleteOnClose:
		return
		
	# Can't trace while destroying.
	# print "tree.destroy"

	for v in self.vnode_alloc_list:
		v.destroy()
	del self.vnode_alloc_list # del all vnodes

	self.iconimages = None
	del self.colorizer
	self.colorizer = None

	# Remove links to objects destroyed by frame.
	self.commands = None
	self.canvas = None

	# Remove all links to nodes
	self.currentVnode = None # The presently selected vnode.
	self.editVnode = None # The vnode being edited.
	self.rootVnode = None
	self.topVnode = None</t>
<t tx="T398">@ This routine immediately removes all links from this node to other objects.  We expect this routine to be called only from tree.destroy when a window is being closed.
@c

def destroy (self):

	# Can't trace while destroying.
	# print "v.destroy"
	self.commands = None
	self.joinList = None
	self.t.destroy()
	self.t = None
	self.mParent = self.mFirstChild = self.mNext = self.mBack = None
	self.edit_text = None
	if 0: # These no longer exist
		self.box_id = self.icon_id = self.edit_text_id = None</t>
<t tx="T399">def destroy (self):

	# Can't trace while destroying.
	# print "c.destroy:", `self.frame`

	# Remove all links from this object to other objects.
	self.frame = None
	self.fileCommands = None
	self.atFileCommands = None
	self.importCommands = None
	self.tangleCommands = None</t>
<t tx="T400">def destroy (self):

	# don't trace during shutdown logic.
	# print "frame.destroy:", `self`
	self.tree.destroy()
	self.tree = None
	self.commands.destroy()
	self.commands = None
	self.top.destroy() # Actually close the window.
	self.top = None</t>
<t tx="T401"># Called from quit logic and when user closes the window.
# Returns true if the close happened.

def OnCloseLeoEvent(self):

	# trace(`self in app().windowList` + ":" + `self`)
	veto=false
	c = self.commands
	if c.changed:
		&lt;&lt; Prompt for change.  Set veto if the user cancels &gt;&gt;
	if veto: return false
	app().log = None # no log until we reactive a window
	if self in app().windowList:
		app().windowList.remove(self)
		self.destroy() # force the window to go away now.
	if app().windowList:
		# Pick a window to activate so we can set the log.
		w = app().windowList[0]
		w.top.deiconify()
		w.top.lift
		app().log = w
	else:
		app().quit()
	return true</t>
<t tx="T402">name = choose(self.mFileName, self.mFileName, self.title)
type = choose(app().quitting, "quitting?", "closing?")

d = leoDialog.leoDialog()
answer = d.askYesNoCancel("Confirm",
	'Save changes to "' + name + '" before ' + type)

if answer=="yes":
	if not self.mFileName or self.mFileName == "":
		&lt;&lt; Put up a file save dialog; set veto if the user cancels &gt;&gt;
	if veto==false and self.mFileName and self.mFileName != "":
		self.commands.fileCommands.save( self.mFileName )

elif answer=="cancel":
	veto = true #The user wants to cancel the close.

else: veto = false # The user wants to close without saving.</t>
<t tx="T403"># Make sure we never pass None to the ctor.
if not self.title:
	self.title = ""
	
self.mFileName = tkFileDialog.asksaveasfilename(
	initialfile = self.mFileName,
	title="Save",
	filetypes=[("Leo files", "*.leo")],
	defaultextension="leo")
	
if not self.mFileName:
	veto = true
</t>
<t tx="T404">def OnQuit(self,event=None):

	app().quitting += 1
	
	while app().windowList:
		w = app().windowList[0]
		if not w.OnCloseLeoEvent():
			break
			
	app().quitting -= 1 # If we get here the quit has been disabled.
	return "break" # inhibit further command processing</t>
<t tx="T405">def quit(self):

	# Wait until everything is quiet before really quitting.
	self.destroyAllGlobalWindows()
	if 1: # leaves Python window open.
		self.root.destroy()
	else: # closes Python window.
		self.root.quit()</t>
<t tx="T406"># All output to the log stream eventually comes here.

def put (self,s):
	if app().quitting &gt; 0: return
	if self.log:
			self.log.insert("end",s)
			self.log.see("end")
			self.log.update_idletasks()
	else:
		print "Null log"
		print s

def putnl (self):
	if app().quitting &gt; 0: return
	if self.log:
		self.log.insert("end",'\n')
		self.log.see("end")
		self.log.update_idletasks()
	else:
		print "Null log"
		print</t>
<t tx="T407">@ It is vital that @file nodes remain dirty until they are written without errors.  Otherwise, a Save command will succeeed without warning, and a later read may cause the dreaded "clones have been cleared" message.</t>
<t tx="T408">@ This is the entry point to the write code.  root should be an @file vnode. We set the orphan and dirty flags if there are problems writing the file to force Commands::write_LEO_file to write the tree to the .leo file.
@c
def write(self,root):

	c = self.commands
	c.setIvarsFromPrefs()
	self.root = root
	c.endEditing() # Capture the current headline.
	self.targetFileName = root.atFileNodeName()
	&lt;&lt; Open files.  Set orphan and dirty flags and return on errors &gt;&gt;
	# unvisited nodes will be orphans.
	root.clearVisitedInTree()
	next = root.nodeAfterTree()
	self.updateCloneIndices(root, next)
	&lt;&lt; put all @first lines in root &gt;&gt;
	if 1: # write the entire file
		self.putOpenLeoSentinel("@+leo")
		self.putOpenNodeSentinel(root)
		self.putBodyPart(root)
		root.setVisited()
		self.putCloseNodeSentinel(root)
		self.putSentinel("@-leo")
	if self.outputFile:
		self.outputFile.flush()
		self.outputFile.close()
		self.outputFile = None
	&lt;&lt; Warn about @ignored and orphans &gt;&gt;
	if self.errors &gt; 0 or self.root.isOrphan():
		root.setOrphan()
		root.setDirty() # 2/9/02: make _sure_ we try to rewrite this file.
		os.remove(self.outputFileName) # Delete the temp file.
	else:
		root.clearOrphan()
		root.clearDirty()
		&lt;&lt; Replace the target with the temp file if different &gt;&gt;</t>
<t tx="T409">self.scanAllDirectives(root)
valid = self.errors == 0

if valid:
	fn = root.atFileNodeName()
	self.shortFileName = fn # name to use in status messages.
	self.targetFileName = os.path.join(self.default_directory,fn)
	self.targetFileName = os.path.normpath(self.targetFileName)
	path = os.path.dirname(self.targetFileName)
	if len(path) &gt; 0:
		valid = os.path.exists(path)
		if not valid:
			writeError("Path does not exist: " + path)
	else:
		valid = false

if valid:
	self.outputFileName = self.targetFileName + ".tmp"
	self.outputFile = open(self.outputFileName, 'w')
	valid = self.outputFile != None
	if not valid:
		writeError("Can not open " + self.outputFileName)

if not valid:
	root.setOrphan()
	root.setDirty()
	return</t>
<t tx="T410">@ Write any @first lines to ms.  These lines are also converted to @verbatim lines, so the read logic simply ignores these lines.
@c

s = root.t.bodyString
tag = "@first"
i = 0
while match(s,i,"@first"):
	i += len(tag)
	i = skip_ws(s,i)
	j = i
	i = skip_to_end_of_line(s,i)
	if i &gt; j:
		line = s[j:i]
		self.os(line) ; self.onl()
	i = skip_nl(s,i)</t>
<t tx="T411">next = root.nodeAfterTree()
v = root
while v and v != next:
	if not v.isVisited():
		self.writeError("Orphan node:  " + v.headString())
	if v.isAtIgnoreNode():
		self.writeError("@ignore node: " + v.headString())
	v = v.threadNext()</t>
<t tx="T412">if os.path.exists(self.targetFileName):
	if filecmp.cmp(self.outputFileName, self.targetFileName):
		try: # Just delete the temp file.
			os.remove(self.outputFileName)
		except: pass
		es("Unchanged: " + self.shortFileName)
	else:
		try: # Replace target file with temp file.
			os.remove(self.targetFileName)
			os.rename(self.outputFileName, self.targetFileName)
			es("Writing: " + self.shortFileName)
		except:
			self.writeError("Rename failed: no file created! (file may be read-only)")
else:
	os.rename(self.outputFileName, self.targetFileName)
	es("Creating: " + self.targetFileName)</t>
<t tx="T413">@ignore</t>
<t tx="T414"># Used by Tangle/Untangle

# arg_allow_rich_text = false # No longer used.
arg_extended_noweb_flag = true
arg_output_doc_flag = true
arg_tangle_batch = false
arg_untangle_batch = false
arg_use_noweb_flag = true
arg_use_CWEB_flag = false
arg_use_header_flag = true
long arg_tab_width = 4  # Now set by the TSyntaxMemo options.
long arg_page_width = 132
long arg_present_language = c_language
long arg_target_language = c_language

// Used by Prefs panel.
default_allow_rich_text = false
default_extended_noweb_flag = false
default_output_doc_flag = true
default_tangle_batch = false
default_untangle_batch = false
default_use_noweb_flag = true
default_use_CWEB_flag = false
default_use_header_flag = true
default_page_width = 132
default_tab_width = 4
# extern long default_present_language
default_target_language = c_language
</t>
<t tx="T415">flag = false # true if we have suceeded.

if frame and frame.mDefaultDirectory.Length()&gt; 0:
	flag = SetCurrentDir(frame.mDefaultDirectory)
	if not flag and not path_warning_given:
		self.path_warning_given = true
		self.error("Invalid Default Tangle Directory: " + frame.mDefaultDirectory)

if not flag and frame and frame.mOpenDirectory.Length()&gt; 0:
	flag = SetCurrentDir(frame.mOpenDirectory.c_str())
	if not flag and not path_warning_given:
		self.path_warning_given = true
		self.error("Directory no longer valid: " + frame.mDefaultDirectory)

if not flag and self.root_name:
	# Try to get the directory from the root name.
	dir = ExtractFileDir(root_name)
	if len(s) &gt; 0:
		flag = SetCurrentDir(dir)
		if not flag and not path_warning_given:
			path_warning_given = true
			self.error("Invalid @root directory: " + frame.mDefaultDirectory)

if not flag and issue_error_flag and not path_warning_given:
	self.path_warning_given = true # Disable further error messages.
	self.error("No directory specified by @root,@path or Preferences.")
</t>
<t tx="T416">@ This code scans the node v and all of v's ancestors looking for @color and @nocolor directives.
@c

def scanColorDirectives(self,v):

	c = self.commands
	val = c.target_language
	while v:
		s = v.t.bodyString
		bits, dict = is_special_bits(s,dont_set_root_from_headline)
		&lt;&lt; Test for @comment or @language &gt;&gt;
		v = v.parent()
	# trace(`val`)
	return val</t>
<t tx="T417">if btest(comment_bits,bits):
	# @comment effectively disables syntax coloring.
	val = plain_text_language
	break

elif btest(language_bits,bits):
	issue_error_flag = false
	i = dict["language"]
	val, delim1, delim2, delim3 = set_language(s,i,issue_error_flag,c.target_language)
	break</t>
<t tx="T418">@ This code scans the node v and all of v's ancestors looking for directives.  If found, the corresponding Tangle/Untangle globals are set.

Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node x, no @owncolor or @nocolor directives are examined in any ancestor of x.

This code is similar to Commands::scanAllDirectives, but it has been modified for use by the atFile class.
@c

def btest(self, b1, b2):
	return (b1 &amp; b2) != 0

def scanAllDirectives(self,v):

	ftag = "scanAllDirectives: "
	c = self.commands
	bits = 0 ; old_bits = 0 ; val = 0
	&lt;&lt; Set delims to default values &gt;&gt;
	&lt;&lt; Set path from @file node &gt;&gt;
	dont_set_root_from_headline = false
	while v:
		s = v.t.bodyString
		bits, dict = is_special_bits(s,dont_set_root_from_headline)
		&lt;&lt; Test for @path &gt;&gt;
		&lt;&lt; Test for @comment or @language &gt;&gt;
		&lt;&lt; Test for @pagewidth and @tabwidth &gt;&gt;
		old_bits |= bits
		v = v.parent()
	if c.frame and not self.default_directory:		# No path in @file headline and no @path directive.
		&lt;&lt; Set current directory &gt;&gt;
	&lt;&lt; Set comment Strings from delims &gt;&gt;</t>
<t tx="T419">prefs = app().prefsFrame
c.page_width = prefs.page_width
c.tab_width = prefs.tab_width
self.presentLanguage = self.targetLanguage = prefs.target_language
self.default_directory = None

delim1, delim2, delim3 = set_delims_from_language(self.presentLanguage)</t>
<t tx="T420"># A directory in an @file node over-rides everything else.

name = v.atFileNodeName()
dir = os.path.dirname(name)
if len(dir) &gt; 0:
	if os.path.exists(dir):
		self.default_directory = dir
	else:
		self.error("Directory \"" + dir + "\" does not exist")</t>
<t tx="T421">if self.btest(comment_bits, old_bits) or self.btest(language_bits, old_bits):
	pass # Do nothing more.

elif self.btest(comment_bits, bits):
	k = dict["language"]
	delim1, delim2, delim3 = set_delims_from_string(s[k:])
	# @comment effectively disables Untangle.
	self.presentLanguage = unknown_language
	
elif self.btest(language_bits, bits):
	k = dict["language"]
	issue_error_flag = false
	language, delim1, delim2, delim3 = set_language(
		s,k,issue_error_flag,self.targetLanguage)
	if delim1:
		self.targetLanguage = self.presentLanguage = language</t>
<t tx="T422"># We set the current director to a path so future writes will go to that directory.

if self.btest(path_bits, bits) and not self.default_directory and not self.btest(path_bits, old_bits):
	k = dict["path"]
	j = i = k + len("@path")
	i = skip_to_end_of_line(s,i)
	path = string.strip(s[j:i])
	# es(ftag + " path: " + path)
	# Remove leading and trailing delims if they exist.
	if len(path) &gt; 2 and (
		(path[0]=='&lt;' and path[-1] == '&gt;') or
		(path[0]=='"' and path[-1] == '"') ):
		path = path[1:-1]
	path = string.strip(path)
	if len(path) &gt; 0:
		if os.path.exists(path):
			self.default_directory = path
		else:
			self.error("Directory does not exist: " + path)
	else:
		self.error("ignoring empty @path")</t>
<t tx="T423">if self.btest(page_width_bits, bits) and not self.btest(page_width_bits, old_bits):
	k = dict["page_width"]
	j = i = k + len("@pagewidth")
	i, val = skip_long(s,i)
	if val:
		c.page_width = val
	else:
		i = skip_to_end_of_line(s,i)
		self.error("Ignoring " + s[k:i])

if self.btest(tab_width_bits, bits) and not self.btest(tab_width_bits, old_bits):
	k = dict["tab_width"]
	j = i = k + len("@tabwidth")
	i, val = skip_long(s, i)
	if val:
		c.tab_width = val
	else:
		i = skip_to_end_of_line(s,i)
		self.error("Ignoring " + s[k:i])</t>
<t tx="T424"># This code is executed if no valid path was specified in the @file node or in an @path directive. 

dir = c.tangle_directory # Try the directory in the Preferences panel
if dir and len(dir) &gt; 0:
	if os.path.exists(dir):
		self.default_directory = dir
	else:
		self.error("Invalid Default Tangle Directory: " + `dir`)

dir = c.frame.openDirectory # Try the directory used in the Open command
if not self.default_directory and dir and len(dir) &gt; 0:
	if os.path.exists(dir):
		self.default_directory = dir
	else:
		self.error("Open directory no longer valid: " + `dir`)
		
if not self.default_directory:
	self.error("No directory specified by @file, @path or Preferences.")
	self.default_directory = ""</t>
<t tx="T425"># Use single-line comments if we have a choice.

if delim3:
	# choice
	self.startSentinelComment = delim1
	self.endSentinelComment = ""
elif delim2:
	# no choice
	self.startSentinelComment = delim1
	self.endSentinelComment = delim2
elif delim1:
	# no choice
	self.startSentinelComment = delim1
	self.endSentinelComment = ""
else: pass</t>
<t tx="T426">@ This code scans the node v and all its ancestors looking for directives.  If found,the corresponding globals are set for use by Tangle, Untangle and syntax coloring.

Once a directive is seen, related directives in ancesors have no effect.  For example, if an @color directive is seen in node x, no @color or @nocolor directives are examined in any ancestor of x.
@c

def scanAllDirectives(self,v,require_path_flag,issue_error_flag):

	c = self.commands ; frame = c.frame
	# trace(`v`)
	old_bits = 0 # One bit for each directive.
	self.init_directive_ivars()
	while v:
		s = v.bodyString()
		bits, dict = is_special_bits(s,dont_set_root_from_headline)
		# trace("bits:" + `bits` + ", dict:" + `dict`, ", " + `v`)
		&lt;&lt; Test for @comment or @language &gt;&gt;
		&lt;&lt; Test for @verbose,@terse or @silent &gt;&gt;
		&lt;&lt; Test for @path,@pagewidth and @tabwidth &gt;&gt;
		&lt;&lt; Test for @header or @noheader &gt;&gt;
		old_bits |= bits
		v = v.parent()
	if c.frame and require_path_flag and not self.tangle_directory:
		# No path is in effect.
		&lt;&lt; Set self.tangle_directory &gt;&gt;
	# trace(`self.tangle_directory`)</t>
<t tx="T427">if btest(old_bits,comment_bits)or btest(old_bits,language_bits):
	 pass # Do nothing more.
elif btest(bits,comment_bits):
	i = dict["comment"]
	set_root_delims(s[i:])
	# @comment effectively disables Untangle.
	arg_present_language = unknown_language
elif btest(bits,language_bits):
	issue_error_flag = false
	i = dict["language"]
	set_language(s,i,issue_error_flag,c.target_language)
</t>
<t tx="T428">@ It is valid to have more than one of these directives in the same body text: the more verbose directive takes precedence.
@c

if btest(old_bits,verbose_bits)or btest(old_bits,terse_bits)or btest(old_bits,silent_bits):
	pass # Do nothing more.
elif btest(bits,verbose_bits):
	self.print_bits = verbose_bits
elif btest(bits,terse_bits):
	self.print_bits = terse_bits
elif btest(bits,silent_bits):
	self.print_bits = silent_bits
</t>
<t tx="T429">if require_path_flag and btest(bits,path_bits)and not btest(old_bits,path_bits):
	i = dict["path"]
	j = skip_to_end_of_line(s,i+5) # Point past @path
	path = string.strip(s[i+5:j])
	&lt;&lt; Remove leading and trailing delims if they exist &gt;&gt;
	if len(path) &gt; 0:
		dir = os.path.dirname(path)
		if len(dir) &gt; 0 and os.path.exists(dir):
			self.tangle_directory = dir
			# trace("@path dir:" + `dir`)
		elif issue_error_flag and not self.path_warning_given:
			self.path_warning_given = true # supress future warnings
			self.error("Invalid directory: " + `s[i:j]`)
	elif issue_error_flag and not self.path_warning_given:
		self.path_warning_given = true # supress future warnings
		self.error("Empty @path")

if btest(bits,page_width_bits) and not btest(old_bits,page_width_bits):
	i = dict["pagewidth"]
	i, val = skip_long(s,i+10) # Point past @pagewidth
	if val == -1:
		if issue_error_flag:
			j = skip_to_end_of_line(s,i)
			es("ignoring " + s[i:j])
	else: arg_page_width = val

if btest(bits,tab_width_bits)and not btest(old_bits,tab_width_bits):
	i = dict["tabwidth"]
	i, val = skip_long(s,i+9) # Point past @tabwidth.
	if val == -1:
		if issue_error_flag:
			j = skip_to_end_of_line(s,i)
			es("ignoring " + s[i:j])
	else: arg_tab_width = val</t>
<t tx="T430"># es(ftag + " path: " + path)
# Remove leading and trailing delims if they exist.
if len(path) &gt; 2 and (
	(path[0]=='&lt;' and path[-1] == '&gt;') or
	(path[0]=='"' and path[-1] == '"') ):
	path = path[1:-1]
path = string.strip(path)</t>
<t tx="T431">if btest(old_bits,header_bits)or btest(old_bits,noheader_bits):
	pass # Do nothing more.
elif btest(bits,header_bits)and btest(bits,noheader_bits):
	if issue_error_flag:
		es("conflicting @header and @noheader directives")
elif btest(bits,header_bits):
	arg_use_header_flag = true
elif btest(bits,noheader_bits):
	arg_use_header_flag = false
</t>
<t tx="T432">@ This code sets self.tangle_directory--it has not already been set by an @path directive.

An explicit file name in an @root directive will override the directory set here.  The final file name will be os.path.join(self.tangle_directory,fileName)

If no @path directive is in effect we use the following directories:
1. The directory in the @root directive (self.root_name)
2. The Tangle Default Directory specified in the Preferences panel.
3. The directory set by the Open command
@c

# Always check @root directory if it exists.
if self.root_name and len(self.root_name) &gt; 0:
	dir = os.path.dirname(self.root_name)
	if len(dir) &gt; 0 and os.path.exists(dir):
		self.tangle_directory = dir
		# trace("@root directory:" + `dir`)
	elif len(dir) &gt; 0 and issue_error_flag and not self.path_warning_given:
		self.path_warning_given = true
		self.error("@root directory missing or invalid: " + dir)

if not self.tangle_directory and c.tangle_directory and len(c.tangle_directory) &gt; 0:
	dir = c.tangle_directory
	if len(dir) &gt; 0 and os.path.exists(dir):
		self.tangle_directory = dir
		# trace("Default tangle directory:" + `dir`)
	elif len(dir) &gt; 0 and issue_error_flag and not self.path_warning_given:
		self.path_warning_given = true
		self.error("Invalid Default Tangle Directory: " + dir)

if not self.tangle_directory and c.frame.openDirectory and len(c.frame.openDirectory) &gt; 0:
	dir = c.frame.openDirectory # Try the directory used in the Open command
	if len(dir) &gt; 0 and os.path.exists(dir):
		self.tangle_directory = dir
		# trace("Open directory:" + `dir`)
	elif len(dir) &gt; 0 and issue_error_flag and not self.path_warning_given:
		self.path_warning_given = true
		self.error("Invalid Open directory: " + dir)

if not self.tangle_directory and issue_error_flag and not self.path_warning_given:
	self.path_warning_given = true
	self.error("No directory specified by @root, @path or Preferences.")</t>
<t tx="T433">def OnViewAllCharacters (self, event=None):

	c = self.commands ; v = c.currentVnode() ; colorizer = c.tree.colorizer
	colorizer.showInvisibles = choose(colorizer.showInvisibles,0,1)
	# It is much easier to change the menu name here than in the menu updater.
	menu = c.frame.editMenu
	if colorizer.showInvisibles:
		self.setLabel(menu,"Show Invisibles","Hide Invisibles")
	else:
		self.setLabel(menu,"Hide Invisibles","Show Invisibles")

	c.tree.recolor_now(v)
	return "break" # inhibit further command processing</t>
<t tx="T434"># Must use foreground, not fg
body.tag_config("comment", foreground="red")
body.tag_config("docPart", foreground="red")
body.tag_config("keyword", foreground="blue")
if self.use_hyperlinks: # underline=self.use_hyperlinks doesn't seem to work.
	body.tag_config("link", foreground="red",underline=1) # Defined section name
else:
	body.tag_config("link", foreground="red",underline=0) # Defined section name
body.tag_config("leoKeyword", foreground="blue")
if 0: # Looks good, but problems when text is selected.
	body.tag_config("name", foreground="red", background="gray90") # Undefined section name
else: # Reverse the underlining used for defined section names.
	if self.use_hyperlinks: # underline=(not self.use_hyperlinks) doesn't seem to work.
		body.tag_config("name", foreground="red", underline=0) # Undefined section name
	else:
		body.tag_config("name", foreground="red", underline=1) # Undefined section name
body.tag_config("nameBrackets", foreground="blue")
body.tag_config("string", foreground="gray50")

if self.showInvisibles:
	if 1: # Very poor, and vaguely usable.
		body.tag_config("blank",background="black",bgstipple="gray25")
		body.tag_config("tab",background="black",bgstipple="gray50")
	else: # Doesn't work, but does increase the spacing ;-)
		body.tag_config("blank",font="Symbol")
		body.tag_config("tab",font="Symbol")
else:
	body.tag_config("blank",background="white")
	body.tag_config("tab",background="white")

# body.tag_config("normal", foreground="black")</t>
<t tx="T435">def sortChildren(self):

	c = self ; v = c.currentVnode()
	if not v or not v.hasChildren(): return

	c.beginUpdate()
	if 1: # inside update...
		c.endEditing()
		# For now, sorting can not be undone.
		v.sortChildren()
		v.setDirty()
		c.setChanged(true)
	c.endUpdate()
	
def sortSiblings (self):
	
	c = self ; v = c.currentVnode()
	if not v: return
	parent = v.parent()
	if not parent: return # can't sort the top level this way.

	c.beginUpdate()
	if 1: # inside update...
		c.endEditing()
		# For now, sorting can not be undone.
		parent.sortChildren()
		parent.setDirty()
		c.setChanged(true)
	c.endUpdate()</t>
<t tx="T436">def sortChildren (self):

	v = self
	# Create a sorted list of all child names
	names = [] ; children = []
	child = v.firstChild()
	if not child: return
	while child:
		children.append(child)
		names.append(string.lower(child.headString()))
		child = child.next()
	names.sort()
	# Create a list of children sorted by name.
	sortedChildren = []
	for name in names:
		for child in children:
			if name == string.lower(child.headString()):
				sortedChildren.append(child)
				children.remove(child)
	# Move the children.
	index = 0
	for child in sortedChildren:
		child.moveToNthChildOf(v,index)
		index += 1</t>
<t tx="T437">def tangleAll(self):

	c = self.commands ; v = c.rootVnode()
	self.initTangleCommand()
	has_roots = false

	while v:
		ok = self.tangleTree(v,dont_report_errors)
		if ok: has_roots = true
		if self.path_warning_given:
			break # Fatal error.
		v = v.next()

	if not has_roots:
		es("----- The outline contains no roots")
	elif self.errors &gt; 0 and not self.path_warning_given:
		es("----- Tangle halted because of errors")</t>
<t tx="T438">def tangleMarked(self):

	c = self.commands ; v = c.rootVnode()
	c.clearAllVisited() # No roots have been tangled yet.
	self.initTangleCommand()
	any_marked = false

	while v:
		is_ignore, i = is_special(v.bodyString(),0,"@ignore")
		# Only tangle marked and unvisited nodes.
		if is_ignore:
			v = v.nodeAfterTree()
		elif v.isMarked():
			ok = self.tangleTree(v,dont_report_errors)
			if ok: any_marked = true
			if self.path_warning_given:
				break # Fatal error.
			v = v.nodeAfterTree()
		else: v = v.threadNext()

	if not any_marked:
		es("----- The outline contains no marked roots")
	elif self.errors &gt; 0 and not self.path_warning_given:
		es("----- Tangle halted because of errors")</t>
<t tx="T439">@ This funtion tangles all nodes in the tree whose root is v. It reports on its results if report_flag is true.

This function is called only from the top level, so there is no need to initialize globals.
@c

def tangleTree(self,v,report_flag):

	assert(v)
	any_root_flag = false
	next = v.nodeAfterTree()
	self.path_warning_given = false

	while v and v != next:
		self.set_root_from_headline(v)
		bits, dict = is_special_bits(v.bodyString(),set_root_from_headline)
		is_ignore = (bits &amp; ignore_bits) != 0
		is_root = (bits &amp; root_bits) != 0
		is_unit = (bits &amp; unit_bits) != 0
		if is_ignore:
			v = v.nodeAfterTree()
		elif not is_root and not is_unit:
			v = v.threadNext()
		else:
			self.tanglePass1(v) # sets self.v
			if self.root_list and self.tangling:
				any_root_flag = true
				self.tanglePass2(v,is_unit)
			self.cleanup()
			v = v.nodeAfterTree()
			if self.path_warning_given: break # Fatal error.

	if self.tangling and report_flag and not any_root_flag:
		# This is done by Untangle if we are untangling.
		es("----- The outline contains no roots")
	return any_root_flag</t>
<t tx="T440">@ Starting with this release, you will see trace statements throughout the code.  The trace function is defined in leoUtils.py; trace implements much of the functionality of my Sherlock tracing package.  Traces are more convenient than print statements for two reasons: 1) you don't need explicit trace names and 2) you can disable them without recompiling.

In the following examples, suppose that the call to trace appears in function f.

trace(string) prints string if tracing for f has been enabled.  For example, the following statment prints from s[i] to the end of the line if tracing for f has been enabled.

	j = skip_line(s,i) ; trace(s[i:j])

trace(function) exectutes the function if tracing for f has been enabled.  For example,

	trace(self.f2)

You enable and disable tracing by calling init_trace(args).  Examples:

	init_trace("+*")         # enable all traces
	init_trace("+a","+b")    # enable traces for a and b
	init_trace(("+a","+b"))  # enable traces for a and b
	init_trace("-a")         # disable tracing for a
	traces = init_trace("?") # return the list of enabled traces

If two arguments are supplied to trace, the first argument is the "tracepoint name" and the second argument is the "tracepoint action" as shown in the examples above.  If tracing for the tracepoint name is enabled, the tracepoint action is printed (if it is a string) or exectuted (if it is a function name).

"*" will not match an explicit tracepoint name that starts with a minus sign.  For example,

	trace("-nocolor", self.disable_color)
</t>
<t tx="T441">@ It no args are given we attempt to get them from the "SherlockArgs" file.  If there are still no arguments we trace everything.  This default makes tracing much more useful in Python.
@c

def get_Sherlock_args (args):

	if not args or len(args)==0:
		try:
			f = open(os.path.join(app().loadDir,"SherlockArgs"))
			args = f.readlines()
			f.close()
		except: pass
	elif type(args[0]) == type(("1","2")):
		args = args[0] # strip away the outer tuple.

	# No args means trace everything.
	if not args or len(args)==0: args = ["+*"] 
	# print "get_Sherlock_args:" + `args`
	return args</t>
<t tx="T442">def init_trace(args):

	t = app().trace_list
	args = get_Sherlock_args(args)

	for arg in args:
		if arg[0] in string.letters: prefix = '+'
		else: prefix = arg[0] ; arg = arg[1:]
		
		if prefix == '?': print "trace list:", `t`
		elif prefix == '+' and not arg in t:
			t.append(string.lower(arg)) ; print "enabling:", arg
		elif prefix == '-' and arg in t:
			t.remove(string.lower(arg)) ; print "disabling:", arg
		else: print "ignoring:", prefix + arg</t>
<t tx="T443">def trace (s1=None,s2=None):

	if s1 and s2:
		name = s1 ; message = s2
	else: # use the funtion name as the tracepoint name.
		message = s1 # may be None
		try: # get the function name from the call stack.
			f1 = sys._getframe(1) # The stack frame, one level up.
			code1 = f1.f_code # The code object
			name = code1.co_name # The code name
		except: name = ""
		
	t = app().trace_list
	# tracepoint names starting with '-' must match exactly.
	minus = len(name) &gt; 0 and name[0] == '-'
	if minus: name = name[1:]
	if (not minus and '*' in t) or string.lower(name) in t:
		if not message: message = ""
		if type(message) == type("a"):
			s = name + ": " + message
			if 1: print s
			else: es(s)
		else: # assume we have a method and try to execute it.
			# print `type(message)`
			message()</t>
<t tx="T444">@ignore

@ Calling tree.recolor_now in tree.select eliminates almost all flashing!</t>
<t tx="T445">@ The &lt;Key&gt; event generates the event before the body text is changed(!), so we register an idle-event handler to do the work later.

1/17/02: Rather than trying to figure out whether the control or alt keys are down, we always schedule the idle_handler.  The idle_handler sees if any change has, in fact, been made to the body text, and sets the changed and dirty bits only if so.  This is the clean and safe way.
@c

# Called by command handlers.
def onBodyChanged (self):
	v = self.currentVnode
	self.commands.body.after_idle(self.idle_body_key,v)

# Bound to any keystroke.
def OnBodyKey (self,event): 

	v = self.currentVnode ; ch = event.char
	self.commands.body.after_idle(self.idle_body_key,v,ch)

def idle_body_key (self,v,ch=None):

	c = self.commands
	if not c or not v or v != c.currentVnode(): return
	# Ignore characters that don't change the body text.
	s = c.body.get("1.0", "end")
	s = string.rstrip(s)
	changed = s != v.bodyString()
	# Needed so that control keys by themselves won't make a node dirty.
	if not changed and ch != '\r' and ch != '\n' :return
	# trace(c.body.index("insert")+":"+c.body.get("insert linestart","insert lineend"))
	# print "idle_body_key", `ch`	# Update changed mark if necessary.
	if ch == '\r' or ch == '\n':
		&lt;&lt; Do auto indent &gt;&gt;
		s = c.body.get("1.0", "end")
		s = string.rstrip(s)
	# Update the tnode.
	v.t.bodyString = s
	# Recolor the body.
	self.recolor_now(v) # We are already at idle time, so this doesn't help much.
	# Update dirty bits and changed bit.
	if not c.changed:
		c.setChanged(true) 
	redraw_flag = false
	c.beginUpdate()
	if not v.isDirty() and v.setDirty(): # Sets all cloned and @file dirty bits
		redraw_flag = true
	# update icons.
	val = v.computeIcon()
	if val != v.iconVal:
		v.iconVal = val
		redraw_flag = true
	c.endUpdate(redraw_flag) # redraw only if necessary</t>
<t tx="T446"># Get the previous line.
s=c.body.get("insert linestart - 1 lines","insert linestart -1c")

# Add the leading whitespace to the present line.
junk,width = skip_leading_ws_with_indent(s,0,c.tab_width)
if s and len(s) &gt; 0 and s[-1]==':':
	# For Python: increase auto-indent after colons.
	language = self.colorizer.scanColorDirectives(v)
	if language == python_language:
		width += c.tab_width
ws = computeLeadingWhitespace (width,c.tab_width)
if ws and len(ws) &gt; 0:
	c.body.insert("insert", ws)</t>
<t tx="T447">@ Warning: do not try to "optimize" this be returning if v==tree.currentVnode.
@c

def select (self, v):

	# Replace body text
	body = self.commands.frame.body
	body.delete("1.0", "end")
	body.insert("1.0", v.t.bodyString)
	self.recolor_now(v)
	# Unselect any previous selected but unedited label.
	self.endEditLabel()
	old = self.currentVnode
	if old and old != v and old.edit_text:
		self.setUnselectedLabelState(old)
	self.currentVnode = v
	self.setSelectedLabelState(v)
	# Set focus.
	if self.bodyKeepsFocus:
		self.commands.body.focus_set()
	else:
		self.canvas.focus_set()</t>
<t tx="T448">def recolor(self,v):

	body = self.commands.frame.body
	
	if 0: # Do immediately
		self.colorizer.colorize(v,body)
	else: # Do at idle time
		self.colorizer.schedule(v,body)

def recolor_now(self,v):

	body = self.commands.frame.body
	self.colorizer.colorize(v,body)</t>
<t tx="T449">def makeVisible(self,v):

	pass # This is now done automatically by the tree class.</t>
<t tx="T450"># Returns the last visible node of the screen.

def lastVisible (self):

	v = self.rootVnode
	while v:
		last = v
		if v.firstChild():
			if v.isExpanded():
				v = v.firstChild()
			else:
				v = v.nodeAfterTree()
		else:
			v = v.threadNext()
	return last</t>
<t tx="T451">@ We can't just return icony because the tree hasn't been redrawn yet.  For the same reason we can't rely on any TK canvas methods here.
@c

def yoffset(self, v1):

	# if not v1.isVisible(): print "yoffset not visible:", `v1`
	root = self.rootVnode
	h, flag = self.yoffsetTree(root,v1)
	# flag can be false during initialization.
	# if not flag: print "yoffset fails:", h, `v1`
	return h

# Returns the visible height of the tree and all sibling trees, stopping at v1

def yoffsetTree(self,v,v1):

	h = 0
	while v:
		# print "yoffsetTree:", `v`
		if v == v1:
			return h, true
		h += line_height
		child = v.firstChild()
		if v.isExpanded() and child:
			h2, flag = self.yoffsetTree(child,v1)
			h += h2
			if flag: return h, true
		v = v.next()
	return h, false</t>
<t tx="T452">def expandAllAncestors (self,v):

	redraw_flag = false
	p = v.parent()
	while p:
		if not p.isExpanded():
			p.expand()
			redraw_flag = true
		p = p.parent()
	return redraw_flag</t>
<t tx="T453">@ This scrolls the canvas so that v is in view.  This is done at idle time after a redraw so that treeBar.get() will return proper values.  Earlier versions of this routine were called _before_ a redraw so that the calls to yoffset() were required.  We could use v.icony instead, and that might be better.

Another approach would be to add a "draw" flat to the drawing routines so that they just compute a height if the draw flag is false.  However, that would complicate the drawing logic quite a bit.
@c

def idle_scrollTo(self):

	v = self.currentVnode
	last = self.lastVisible()
	h1 = self.yoffset(v)
	h2 = self.yoffset(last)
	# Compute the fraction to scroll, minus a smidge so the first line will be entirely visible.
	if h2 &gt; 0.1:
		frac = float(h1)/float(h2)
	else:
		frac = 0.0 # probably any value would work here.
	frac = min(frac,1.0)
	frac = max(frac,0.0)
	
	# Do nothing if the line is already in view
	frame = self.commands.frame
	lo, hi = frame.treeBar.get()
	if frac &lt; lo or frac &gt; hi:
		# print "h1, h2, frac, hi, lo:", h1, h2, frac, hi, lo
		self.canvas.yview("moveto", frac)</t>
<t tx="T454">@ignore</t>
<t tx="T455"></t>
<t tx="T456"># Convenience methods so the caller doesn't have to know the present edit node.

def dimEditLabel (self):

	v = self.currentVnode
	self.setDisabledLabelState(v)

def undimEditLabel (self):

	v = self.currentVnode
	self.setSelectedLabelState(v)</t>
<t tx="T457"># Start editing v.edit_text

def editLabel (self, v):

	# End any previous editing
	if self.editVnode and v != self.editVnode:
		self.endEditLabel()
		
	# Start editing
	if v and v.edit_text:
		self.setNormalLabelState(v)
		v.edit_text.tag_remove("sel","1.0","end")
		v.edit_text.tag_add("sel","1.0","end")
		self.editVnode = v
	else:
		self.editVnode = None</t>
<t tx="T458"># End editing for self.editText

def endEditLabel (self):

	v = self.editVnode
	
	if v and v.edit_text:
		self.setUnselectedLabelState(v)
		self.editVnode = None
	
	if v and v.joinList:
		self.redraw() # force a redraw of joined headlines.</t>
<t tx="T459">@  Warning: it _is_ sometimes useful to have the update_count logic in place even though all drawing is done at idle time.  Indeed, we don't want to schedule a redraw if we will call endupdate(false).

Howevever, we could replace beginUpdate/endUpdate() with c.redraw() and replace endUpdate(flag) with:
	if flag: c.redraw()</t>
<t tx="T460">def __init__(self,commands,canvas):

	self.canvas = canvas
	self.commands = commands
	self.rootVnode = None
	self.topVnode = None
	self.iconimages = {} # Image cache set by getIconImage().
	self.colorizer = leoColor.colorizer(commands)
	self.bodyKeepsFocus = true # true if body keeps focus when tree canvas clicked
	self.vnode_alloc_list = [] # List of all vnodes ever allocated in this tree.
	self.active = false # true if tree is active
	
	# Controlling redraws
	self.updateCount = 0 # self.redraw does nothing unless this is zero.
	self.redrawCount = 0 # For traces
	self.redrawScheduled = false # true if redraw scheduled.

	# Selection ivars.
	self.currentVnode = None # The presently selected vnode.
	self.editVnode = None # The vnode being edited.
	self.initing = false # true: opening file.</t>
<t tx="T461">def beginUpdate (self):

	self.updateCount += 1</t>
<t tx="T462">def endUpdate (self, flag=true):

	assert(self.updateCount &gt; 0)
	self.updateCount -= 1
	if flag and self.updateCount == 0:
		self.redraw()</t>
<t tx="T463">@ We must compute the word to be selected before the Tk.Text widget does its default double-click handling, then actually select the text at idle-time.</t>
<t tx="T464">def OnActivateBody (self,event=None):

	app().log = self
	self.tree.OnDeactivate()

def OnBodyDoubleClick (self,event=None):

	body = self.body
	start = body.index("insert wordstart")
	end = body.index("insert wordend")
	setTextSelection(self.body,start,end)
	return "break" # Inhibit all further event processing.</t>
<t tx="T465">def disable (self):

	print "disabling all syntax coloring"
	self.enabled=false

def __init__(self, commands):

	self.commands = commands
	self.count = 0 # how many times this has been called.
	self.use_hyperlinks = false # true: use hyperlinks and underline "live" links.
	self.enabled = true # true: syntax coloring enabled
	self.showInvisibles = false # true: show "invisible" characters.
	trace("-nocolor", self.disable)</t>
<t tx="T466">tags = (
	"blank", "comment", "docPart", "keyword", "leoKeyword",
	"link", "name", "nameBrackets", "string", "tab")

def colorizePython(self,v,body):

	hyperCount = 0 # Number of hypertext tags
	self.body = body # For callbacks
	s = body.get("1.0", "end")
	sel = body.index("insert") # get the location of the insert point
	start, end = string.split(sel,'.')
	start = int(start)
	# trace(`self.count` + `sel`)
	# trace(`body.tag_names()`)

	if 0: # Remove all tags from the selected line.
		for tag in self.tags:
			body.tag_remove(tag, index(start,0), index(start,"end"))
	else: # Remove all tags from body.
		body.tag_delete(
			"comment", "docPart", "keyword", "leoKeyword",
			"link", "name", "nameBrackets", "string")
	&lt;&lt; configure tags &gt;&gt;
	self.count += 1
	
	lines = string.split(s,'\n')
	state = normalState ; n = 0
	for s in lines:
		n += 1 ; i = 0 ; sLen = len(s)
		# trace(`n` + ", " + `s`)
		while i &lt; sLen:
			ch = s[i]
			if state == string3State:
				&lt;&lt; continue python triple string &gt;&gt;
				continue
			elif state == docState:
				&lt;&lt; continue doc part &gt;&gt;
				continue
			elif state == nocolorState:
				&lt;&lt; continue nocolor state &gt;&gt;
			else: assert(state == normalState)

			if ch == '"' or ch == "'":
				&lt;&lt; handle python string &gt;&gt;
			elif ch == '#':
				&lt;&lt; handle python comment &gt;&gt;
			elif ch == '&lt;':
				&lt;&lt; handle possible section ref &gt;&gt;
			elif ch == '@':
				&lt;&lt; handle possible @keyword &gt;&gt;
			elif ch in string.letters:
				&lt;&lt; handle possible python keyword &gt;&gt;
			elif ch == ' ':
				&lt;&lt; handle blank &gt;&gt;
			elif ch == '\t':
				&lt;&lt; handle tab &gt;&gt;
			else:
				&lt;&lt; handle normal character &gt;&gt;</t>
<t tx="T467">if i == 0 and ch == '@':
	j = self.skip_id(s,i+1)
	word = s[i:j]
	word = string.lower(word)
else:
	word = ""

if word == "@c" or word == "@code":
	# End of the doc part.
	body.tag_remove("docPart", index(n,i), index(n,j))
	body.tag_add("leoKeyword", index(n,i), index(n,j))
	i = j ; state = normalState
else:
	# The entire line is in the doc part.
	body.tag_add("docPart", index(n,i), index(n,sLen))
	i = sLen # skipt the rest of the line.
</t>
<t tx="T468">j = string.find(s, '"""', i)
if j == -1:
	# The entire line is part of the triple-quoted string.
	body.tag_add("string", index(n,i), index(n,"end"))
	i = sLen # skipt the rest of the line.
else:
	# End the string
	body.tag_add("string", index(n,i), index(n,j+3))
	i = j + 3 ; state = normalState</t>
<t tx="T469">if i == 0 and ch == '@':
	j = self.skip_id(s,i+1)
	word = s[i:j]
	word = string.lower(word)
else:
	word = ""

if word == "@color":
	# End of the nocolor part.
	## body.tag_remove("normal", index(n,0), index(n,j))
	body.tag_add("leoKeyword", index(n,0), index(n,j))
	i = j ; state = normalState
else:
	# The entire line is in the nocolor part.
	## body.tag_add("normal", index(n,0), index(n,sLen))
	i = sLen # skipt the rest of the line.</t>
<t tx="T470">j, state = self.skip_python_string(s,i)
body.tag_add("string", index(n,i), index(n,j))
i = j</t>
<t tx="T471">body.tag_add("comment", index(n,i), index(n,"end"))
i = sLen</t>
<t tx="T472">j = self.skip_id(s,i+1)
word = s[i:j]
word = string.lower(word)
if i != 0 and word != "@others":
	word = "" # can't be a Leo keyword, even if it looks like it.

# to do: the keyword should start the line.
if word == "@" or word == "@doc":
	# at-space starts doc part
	## body.tag_remove("normal", index(n,i), index(n,j))
	body.tag_add("leoKeyword", index(n,i), index(n,j))
	# Everything on the line is in the doc part.
	body.tag_add("docPart", index(n,j), index(n,sLen))
	i = sLen ; state = docState
elif word == "@nocolor":
	# Nothing on the line is colored.
	## body.tag_add("normal", index(n,j), index(n,sLen))
	i = sLen ; state = nocolorState
elif word in leoKeywords:
	## body.tag_remove("normal", index(n,i), index(n,j))
	body.tag_add("keyword", index(n,i), index(n,j))
	i = j
else:
	## body.tag_add("normal", index(n,i), index(n,j+1))
	i = j</t>
<t tx="T473">if s[i:i+2] == "&lt;&lt;":
	# See if the line contains &gt;&gt;
	j = string.find(s,"&gt;&gt;",i+2)
	if j == -1:
		## body.tag_add("normal", index(n,i), index(n,i+1))
		i += 2
	else:
		searchName = body.get(index(n,i),   index(n,j+2)) # includes brackets
		linkName   = body.get(index(n,i+2), index(n,j)) # does not include brackets
		ref = findReference(searchName,v)
		## body.tag_remove("normal", index(n,i), index(n,j+2))
		body.tag_add("nameBrackets", index(n,i), index(n,i+2))
		if ref:
			body.tag_add("link", index(n,i+2), index(n,j))
			&lt;&lt; set the hyperlink &gt;&gt;
		else:
			body.tag_add("name", index(n,i+2), index(n,j))
		body.tag_add("nameBrackets", index(n,j), index(n,j+2))
		i = j + 2
else: # a single '&lt;'
	## body.tag_add("normal", index(n,i))
	i += 1</t>
<t tx="T474"># Set the bindings to vnode callbacks.
if self.use_hyperlinks:
	# Create the tag.
	# Create the tag name.
	tagName = "hyper" + `hyperCount`
	hyperCount += 1
	body.tag_delete(tagName)
	body.tag_add(tagName, index(n,i+2), index(n,j))
	ref.tagName = tagName
	body.tag_bind(tagName,"&lt;Control-1&gt;",ref.OnHyperLinkControlClick)
	body.tag_bind(tagName,"&lt;Any-Enter&gt;",ref.OnHyperLinkEnter)
	body.tag_bind(tagName,"&lt;Any-Leave&gt;",ref.OnHyperLinkLeave)</t>
<t tx="T475">j = self.skip_id(s,i)
word = s[i:j]
if word in pythonKeywords:
	## body.tag_remove("normal", index(n,i), index(n,j))
	body.tag_add("keyword", index(n,i), index(n,j))
else:
	pass # body.tag_add("normal", index(n,i), index(n,j))
i = j
</t>
<t tx="T476">body.tag_add("blank", index(n,i)) ; i += 1
</t>
<t tx="T477">body.tag_add("tab", index(n,i)) ; i += 1
</t>
<t tx="T478"># body.tag_add("normal", index(n,i))
i += 1
</t>
<t tx="T479">@ These callbacks are vnode methods so we can pass the vnode back to the tree class.
</t>
<t tx="T480"># Called when the box is clicked or the icon or headline are double-clicked.

def OnBoxClick(self,event=None):

	self.commands.tree.OnBoxClick(self)</t>
<t tx="T481">def OnHeadlineClick(self,event=None):

	self.commands.tree.OnActivate(self)</t>
<t tx="T482">def OnHeadlineKey (self,event):

	self.commands.tree.OnHeadlineKey(self,event)</t>
<t tx="T483">def OnHyperLinkControlClick (self,event):

	c = self.commands ; v = self
	c.beginUpdate()
	c.selectVnode(v)
	c.endUpdate()
	c.body.mark_set("insert","1.0")</t>
<t tx="T484">def OnHyperLinkEnter (self,event):

	c = self.commands ; v = self
	if 0: # This works, and isn't very useful.
		c.body.tag_config(v.tagName,background="green")</t>
<t tx="T485">def OnHyperLinkLeave (self,event):

	c = self.commands ; v = self
	if 0: # This works, and isn't very useful.
		c.body.tag_config(v.tagName,background="white")</t>
<t tx="T486">def OnIconClick(self,event=None):

	self.commands.tree.select(self)</t>
<t tx="T487">@ We search the descendents of v looking for the definition node matching name.
There should be exactly one such node (descendents of other definition nodes are not searched).
@c

def findReference(name,root):

	after = root.nodeAfterTree()
	v = root.firstChild()
	while v and v != after:
		if v.matchHeadline(name) and not v.isAtIgnoreNode():
			return v
		v = v.threadNext()
	return None
</t>
<t tx="T488">def __init__ (self):

	Tk = Tkinter
	&lt;&lt; set ivars &gt;&gt;
	self.top = top = Tk.Toplevel()
	self.top.title("Leo Preferences")
	top.resizable(0,0) # neither height or width is resizable.
	&lt;&lt; Create the Global Options frame &gt;&gt;
	&lt;&lt; Create the Tangle Options frame &gt;&gt;
	&lt;&lt; Create the Target Language frame &gt;&gt;
	self.top.protocol("WM_DELETE_WINDOW", self.OnClosePrefsFrame)
	# es("Prefs.__init__")</t>
<t tx="T489"># These ivars have the same names as the corresponding ivars in commands class.

# Global options
self.page_width = 132
self.tab_width = 4
self.tangle_batch_flag = 0
self.untangle_batch_flag = 0

self.tangle_batch_var = Tk.IntVar()
self.untangle_batch_var = Tk.IntVar()

# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = 0
self.output_doc_flag = 0

self.use_header_var = Tk.IntVar()
self.output_doc_var = Tk.IntVar()

# Default Target Language
self.target_language = python_language
self.lang_var = Tk.IntVar()</t>
<t tx="T490">glob = Tk.Frame(top, bd="2", relief="groove") 
glob.pack(anchor="n", pady=2, ipadx="1m", expand=1, fill="x")

globTitle = Tk.Label(glob, text="Global Options...")
globTitle.pack(pady="1m")

# Page width &amp; page width
f = Tk.Frame(glob)
f.pack(anchor="w", pady="1m", expand=1, fill="x")

lab = Tk.Label(f, anchor="w", padx="1m", text="Page width:")
self.pageWidthText = txt = Tk.Text(f, height=1, width=4)
lab.pack(side="left")
txt.pack(side="left")
txt.bind("&lt;Key&gt;", self.idle_set_ivars)

lab2 = Tk.Label(f, padx="1m", text="Tab width:")
self.tabWidthText = txt2 = Tk.Text(f, height=1, width=4)
lab2.pack(side="left")
txt2.pack(side="left")
txt2.bind("&lt;Key&gt;", self.idle_set_ivars)

# Batch Checkbuttons...
# Can't easily use a list becasue we use different variables.
self.doneBox = doneBox = Tk.Checkbutton(glob,anchor="w",
	text="Run tangle_done.py after Tangle",
	variable=self.tangle_batch_var,command=self.idle_set_ivars)
self.unBox = unBox = Tk.Checkbutton(glob,anchor="w",
	text="Run untangle_done.py after Untangle",
	variable=self.untangle_batch_var,command=self.idle_set_ivars)
doneBox.pack(fill="x")
unBox.pack(fill="x")</t>
<t tx="T491"># Frame and title
tangle = Tk.Frame(top, bd="2", relief="groove")
tangle.pack(anchor="n", ipadx="1m", expand=1, fill="x")

tangleTitle = Tk.Label(tangle, text="Default Options...")
tangleTitle.pack(pady="1m")

# Label and text
lab3 = Tk.Label(tangle, anchor="w", text="Default tangle directory")
self.tangleDirectoryText = txt3 = Tk.Text(tangle, height=1, width=30)
txt3.bind("&lt;Key&gt;", self.idle_set_ivars) # Capture the change immediately
lab3.pack(            padx="1m", pady="1m", fill="x")
txt3.pack(anchor="w", padx="1m", pady="1m", fill="x")

# Checkbuttons
self.headerBox = header = Tk.Checkbutton(tangle,anchor="w",
	text="Tangle outputs header line",
	variable=self.use_header_var,command=self.idle_set_ivars)
self.docBox = doc = Tk.Checkbutton(tangle,anchor="w",
	text="Tangle outputs document chunks",
	variable=self.output_doc_var,command=self.idle_set_ivars)
header.pack(fill="x")
doc.pack(fill="x")</t>
<t tx="T492"># Frame and title
target = Tk.Frame(top, bd="2", relief="groove")
target.pack(anchor="n", pady=2, expand=1, fill="x") #   

targetTitle = Tk.Label(target, text="Default Target Language...")
targetTitle.pack(pady="1m")

# Frames for two columns of radio buttons
lt = Tk.Frame(target)
rt = Tk.Frame(target)
lt.pack(side="left")
rt.pack(side="right")

# Left column of radio buttons.
left_data = [
	("C/C++",c_language), ("CWEB", cweb_language),
	("HTML", html_language), ("Java", java_language),
	("Pascal", pascal_language) ]

for text,value in left_data:
	button = Tk.Radiobutton(lt,anchor="w",text=text,
		variable=self.lang_var,value=value,command=self.set_lang)
	button.pack(fill="x") 
	
# Right column of radio buttons.
right_data = [ ("Perl", perl_language), ("Perl+POD", perlpod_language),
	("Plain Text", plain_text_language), ("Python", python_language) ]
	
for text,value in right_data:
	button = Tk.Radiobutton(rt,anchor="w",text=text,
		variable=self.lang_var,value=value,command=self.set_lang)
	button.pack(fill="x")</t>
<t tx="T493">def set_ivars (self,c=None):

	if c == None: c = top()
	&lt;&lt; update ivars &gt;&gt;
	for var in ivars:
		exec("c.%s = self.%s" % (var,var))
	# print "set_ivars" ; print self.print_ivars()

def idle_set_ivars (self, event=None):
	
	c = top() ; v = c.currentVnode()
	self.top.after_idle(self.set_ivars,c)
	c.tree.recolor(v)
	# print "idle_set_ivars" ; print self.print_ivars()
	
def print_ivars (self):
	
	for var in ivars:
		exec("print self.%s, '%s'" % (var,var))</t>
<t tx="T494"># Global options
w = self.pageWidthText.get("1.0","end")
w = string.strip(w)
try: self.page_width = int(w)
except: self.page_width = default_page_width
	
w = self.tabWidthText.get("1.0","end")
w = string.strip(w)
try: self.tab_width = int(w)
except: self.tab_width = default_tab_width

self.tangle_batch_flag = self.tangle_batch_var.get()
self.untangle_batch_flag = self.untangle_batch_var.get()

# Default Tangle options
dir = self.tangleDirectoryText.get("1.0","end")
self.tangle_directory = string.strip(dir)
self.use_header_flag = self.use_header_var.get()
self.output_doc_flag = self.output_doc_var.get()

# Default Target Language
self.target_language = self.lang_var.get()</t>
<t tx="T495">def init(self,c):

	# trace(`self.target_language`)
	for var in ivars:
		exec("self.%s = c.%s" % (var,var))
		
	&lt;&lt; set widgets &gt;&gt;
	# print "init" ; print self.print_ivars()</t>
<t tx="T496"># Global options
self.tangle_batch_var.set(c.tangle_batch_flag)
self.untangle_batch_var.set(c.untangle_batch_flag)
self.pageWidthText.delete("1.0","end")
self.pageWidthText.insert("end",`c.page_width`)
self.tabWidthText.delete("1.0","end")
self.tabWidthText.insert("end",`c.tab_width`)
# Default Tangle Options
self.tangleDirectoryText.delete("1.0","end")
self.tangleDirectoryText.insert("end",c.tangle_directory)
self.output_doc_var.set(c.output_doc_flag)
self.use_header_var.set(c.use_header_flag)
# Default Target Language
self.lang_var.set(c.target_language)</t>
<t tx="T497">def OnActivateLeoEvent(self,event=None):

	c = self.commands
	app().log = self
	# 2/9/02: It is very important to handle Default Tangle Directory properly!
	prefs = app().prefsFrame
	if prefs:
		prefs.init(c)</t>
<t tx="T498">@ The syntax colorer needs to know what the present language is.  By analogy with tangle.scanAllDirectives, color.scanColorDirectives scans for @language and @color directives.  If not found, we use the Prefs panel setting.

There is no need for a c.present_language here, and idle_body_key calls this routine to determine what the present lanuage is.</t>
<t tx="T499">def set_lang (self):
	
	c = top() ; v = c.currentVnode()
	language = self.lang_var.get()
	c.target_language = self.target_language = language
	c.tree.recolor(v)
	# print "set_lang" ; print self.print_ivars()</t>
<t tx="T500">def __init__ (self, commands, t):

	assert(t and commands)
	&lt;&lt; initialize vnode data members &gt;&gt;
	if app().deleteOnClose:
		self.commands.tree.vnode_alloc_list.append(self)</t>
<t tx="T501">self.commands = commands # The commander for this vnode.
self.joinList = None # vnodes on the same joinlist are updated together.
self.t = t # The tnode, i.e., the body text.
self.statusBits = 0 # status bits
self.iconVal = -1 # The icon index.  -1 forces an update of icon.
self.mHeadString = "" # The headline text.

# Structure links
self.mParent = self.mFirstChild = self.mNext = self.mBack = None

# Canvas items.  Set by tree.redraw
self.iconx, self.icony = 0,0 # Coords of icon so icon can be redrawn separately.
self.edit_text = None # Essential: used by many parts of tree code.

if 0: # These links are harmful: they prevent old tree items from being recycled properly.
	self.box_id = self.icon_id = None
	self.edit_text_id = None # The editable text field for this vnode.</t>
<t tx="T502">def drawBox (self,v,x,y):

	y += 7 # draw the box at x, y+7

	iconname = choose(v.isExpanded(), "Icons\\minusnode.GIF", "Icons\\plusnode.GIF")
	image = self.getIconImage(iconname)
	id = self.canvas.create_image(x,y,image=image)
	if 0: # don't create a reference to this!
		v.box_id = id
	self.canvas.tag_bind(id, "&lt;1&gt;", v.OnBoxClick)
	self.canvas.tag_bind(id, "&lt;Double-1&gt;", lambda x: None)</t>
<t tx="T503"># Draws icon for v at x,y

def drawIcon(self,v,x,y):

	v.iconx, v.icony = x,y

	y += 2 # draw icon at y + 2

	# Always recompute icon.
	val = v.iconVal = v.computeIcon()
	assert(0 &lt;= val &lt;= 15)
	
	# Compute the image name
	imagename = os.path.join("Icons", "box")
	if val &lt; 10: imagename += "0"
	imagename += `val`

	# Get the image
	image = self.getIconImage(imagename + ".GIF")
	id = self.canvas.create_image(x,y,anchor="nw",image=image)
	if 0: # don't create a reference!
		v.icon_id = id
	self.canvas.tag_bind(id, "&lt;1&gt;", v.OnIconClick)
	self.canvas.tag_bind(id, "&lt;Double-1&gt;", v.OnBoxClick)

	return 0 # dummy icon height</t>
<t tx="T504"># draws text for v at x,y

def drawText(self,v,x,y):

	x += text_indent
	if v.edit_text: # self.canvas.delete("all") may already have done this, but do it anyway.
		v.edit_text.destroy()
	v.edit_text = t = Tkinter.Text(self.canvas,bd=0,relief="flat",width=self.headWidth(v),height=1)
	t.insert("end", v.headString())
	&lt;&lt; configure the text depending on state &gt;&gt;
	t.bind("&lt;1&gt;", v.OnHeadlineClick)
	t.bind("&lt;Double-1&gt;", v.OnBoxClick)
	t.bind("&lt;Key&gt;", v.OnHeadlineKey)
	id = self.canvas.create_window(x,y,anchor="nw",window=t)
	if 0: # don't create this reference!
		v.edit_text_id = id
	self.canvas.tag_lower(id)

	return line_height</t>
<t tx="T505">if v == self.currentVnode:
	if self.bodyKeepsFocus:
		t.configure(state="disabled",fg="black",bg="gray80")
	else:
		w = self.commands.frame.getFocus()
		if w == self.canvas:
			t.configure(state="normal",fg="white",bg="DarkBlue")
		else:
			t.configure(state="disabled",fg="black",bg="gray80")
else:
	t.configure(state="disabled",fg="black",bg="white")</t>
<t tx="T506"># Cutting a node definitely does not set the ancestor @file node dirty!</t>
<t tx="T507">@ This now ensures that all cloned nodes are marked dirty and that all ancestor @file nodes are marked dirty.  It is much safer to do it this way.
@c

def setDirty (self):

	v = self ; c = v.commands
	# trace(`v`)
	changed = false
	c.beginUpdate()
	if not v.t.isDirty():
		v.t.setDirty()
		changed = true
	# This must _always_ be called, even if v is already dirty.
	if v.setAncestorAtFileNodeDirty():
		changed = true
	v2 = v.getJoinList()
	while v2 and v2 != v: 
		if not v2.t.isDirty():
			v2.t.setDirty()
			changed = true
		# Again, must always be called.
		if v2.setAncestorAtFileNodeDirty():
			changed = true
		v2 = v2.getJoinList()
	c.endUpdate(changed)
	return changed

def initDirtyBit (self):
	self.t.setDirty()</t>
<t tx="T508">@ This is called from the key-event handler, so we must not force a redraw of the screen here. We avoid redraw in most cases by passing redraw_flag to c.endUpdate().

This is called from v.setDirty, so we avoid further calls to v.setDirty here.  The caller, that is, v.setDirty itself, handles all clones.

@c
def setAncestorAtFileNodeDirty(self):

	# Look up the tree for an ancestor @file node.
	v = self ; c = v.commands
	redraw_flag = false
	c.beginUpdate()
	while v:
		if not v.isDirty() and v.isAtFileNode():
			redraw_flag = true
			v.t.setDirty() # Do not call v.setDirty here!
		v = v.parent()
	c.endUpdate(redraw_flag) # A crucial optimization!
	return redraw_flag # Allow caller to do the same optimization.</t>
<t tx="T509">@ignore
@ Apparently we can not reference leo.__file__ reliably until leo has been completely imported.  The workaround is to do so in app.finishCreate.  This is a bit mysterious, and it appears to work.</t>
<t tx="T510"># Called when the gApp global has been defined.

def finishCreate(self):

	&lt;&lt; set loaddir &gt;&gt;
	
	# Create the global windows
	self.findFrame = leoFind.LeoFind()
	self.findFrame.top.withdraw()

	self.prefsFrame = leoPrefs.LeoPrefs()
	self.prefsFrame.top.withdraw()</t>
<t tx="T511"># loaddir should be the directory that contains leo.py

try:
	self.loadDir = os.path.dirname(leo.__file__)
except:
	# Emergency defaults.  Hopefully we will never have to use them.
	if sys.platform=="win32": # Windows
		self.loadDir = "c:\\prog\\LeoPy\\"
	else: # Linux, or whatever.
		self.loadDir = "LeoPy"
	print "Setting load directory to:", self.loadDir

# Trace hasn't been enabled yet.
# print `self.loadDir`</t>
<t tx="T512">@ignore

Better traces on @read failure.</t>
<t tx="T513">@nocolor

use os.path.join(a,b) rather than a + "\\" + b
use os.path.exists(path) to test whether directories exist.
use os.normpath(path) and os.normcase(path) ?

os.pathjoin(path1[, path2[, ...]]) Joins one or more path components intelligently. If any component is an absolute path, all previous components are thrown away, and joining continues. The return value is the concatenation of path1, and optionally path2, etc., with exactly one slash ('/') inserted between components, unless path is empty.

@color</t>
<t tx="T514">def run(*args):

	# Create a hidden main window: this window never becomes visible!
	root = Tkinter.Tk()
	&lt;&lt; set the icon image &gt;&gt;
	root.title("Leo Main Window")
	root.withdraw()
	# Initialize application globals
	app = leoApp.LeoApp(root)
	leoGlobals.setApp(app)
	app.finishCreate() # do this after gApp exists.
	# Create the first Leo window
	frame = leoFrame.LeoFrame()
	frame.startupWindow = leoGlobals.true
	# Initialize "Sherlock"
	leoUtils.init_trace(args)
	leoUtils.trace("argv", "sys.argv: " + `sys.argv`)
	root.mainloop()</t>
<t tx="T515">if 0: # not yet
	fullname = r"c:\prog\LeoPy\Icons\box05.GIF"
	image = Tkinter.PhotoImage(file=fullname)
	trace(`image`)
	image = Tkinter.BitmapImage(image)
	trace(`image`)
	image = Tkinter.BitmapImage("stop")
	trace(`image`)
	root.iconbitmap(image)</t>
<t tx="T516">def __init__(self, root, master=None):

	# These ivars are the global vars of this program.
	self.root = root # The hidden main window
	self.log = None # The LeoFrame containing the present log
	self.quitting = false # True if quitting.  Locks out some events.
	self.windowList = [] # Global list of all frames.  Does not include hidden root window.
	self.numberOfWindows = 0 # Number of opened windows.
	self.loadDir = None # The directory from which Leo was loaded.
	self.clipboard = None # A string used to cut, copy and paste trees.
	self.idle_imported = false # true: we have done an import idle
	
	# Global options...
	self.trace_list = [] # "Sherlock" argument list for tracing().
	self.deleteOnClose = true # true: delete frame objects when a frame closes.
	if 0: # app() is not accessible during shutdown!
		self.printDel = false # true: enable prints in __del__ routines

	# Set by finishCreate...
	self.prefsFrame = None
	self.findFrame = None
	self.pythonFrame = None</t>
<t tx="T517">def __init__(self,theCommander):

	# trace("__init__", "atFile.__init__")
	self.commands = theCommander # The commander for the current window.
	self.initIvars()

def initIvars(self):

	&lt;&lt; initialize atFile ivars &gt;&gt;</t>
<t tx="T518">@ errors is the number of errors seen while reading and writing.  structureErrors are errors reported by createNthChild.  If structure errors are found we delete the outline tree and rescan.
@c
self.errors = 0
self.structureErrors = 0

@ The directory set by atFile.scanAllDirectives
@c
self.default_directory = None

@ The files used by the output routines.  When tangling, we first write to a temporary output file.  After tangling is temporary file.  Otherwise we delete the old target file and rename the temporary file to be the target file.
@c
self.shortFileName = "" # short version of file name used for messages.
self.targetFileName = ""
self.outputFileName = ""
self.outputFile = None # The temporary output file.

@ The indentation used when outputting section references or at-others sections.  We add the indentation of the line containing the at-node directive and restore the old value when the
expansion is complete.
@c
self.indent = 0  # The unit of indentation is spaces, not tabs.

@ The strings specifying the beginning and end of sentinel comments. endSentinelComment is empty for single-line comment before and after the &lt;leo&gt; tag in the first line of the file.
@c
self.startSentinelComment = "//"
self.endSentinelComment = ""

# Used to parse @language and @comment directives.

self.presentLanguage = python_language
self.targetLanguage = python_language ## Should be set from the preferences panel.
self.singleCommentString = "#"
self.startCommentString = ""
self.endCommentString = ""

# The root of tree being written.

self.root = None</t>
<t tx="T519">@ This is the entry point to the read code.  The root vnode should be an @file node.  If doErrorRecoveryFlag is false we are doing an update.  In that case it would be very unwise to do any error recovery which might clear clone links.  If doErrorRecoveryFlag is TRUE and there are structure errors during the first pass we delete root's children and its body text, then rescan.  All other errors indicate potentially serious problems with sentinels.

The caller has enclosed this code in beginUpdate/endUpdate.
@c
def read(self,root,doErrorRecoveryFlag):

	# t1 = setTime()
	c = self.commands
	es("reading: " + root.headString())
	root.clearVisitedInTree() # Clear the list of nodes for orphans logic.
	self.targetFileName = root.atFileNodeName()
	self.root = root
	self.errors = self.structureErrors = 0
	&lt;&lt; open file &gt;&gt;
	if self.errors &gt; 0: return 0
	&lt;&lt; Scan the file buffer &gt;&gt;
	&lt;&lt; Bump mStructureErrors if any vnodes are unvisited &gt;&gt;
	next = root.nodeAfterTree()
	if self.structureErrors &gt; 0:
		self.readError("-- Rereading file.  Clone links into this file will be lost.") ;
		self.errors = 0
		root.clearVisitedInTree() # Clear the list of nodes for orphans logic.
		&lt;&lt; Delete root's tree and body text &gt;&gt;
		file.seek(0)
		&lt;&lt; Scan the file buffer &gt;&gt;
	file.close()
	if self.errors == 0:
		next = root.nodeAfterTree()
		root.clearAllVisitedInTree()
		&lt;&lt; Handle clone bits &gt;&gt;
		&lt;&lt; Join cloned trees &gt;&gt;
		&lt;&lt; Handle all status bits &gt;&gt;
	if self.errors &gt; 0:
		# A serious error has occured that has not been corrected.
		self.readError("----- File may have damaged sentinels!")
		root.unjoinTree();
	else: root.clearDirty()
	# esDiffTime("read: exit", t1)
	return self.errors == 0</t>
<t tx="T520">self.scanAllDirectives(root) # 1/30/02

if len(self.targetFileName) == 0:
	self.readError("Missing file name.  Restoring @file tree from .leo file.")
else:
	# print `self.default_directory`, `self.targetFileName`
	fn = os.path.join(self.default_directory, self.targetFileName)
	fn = os.path.normpath(fn)
	try:
		file = open(fn,'r')
	except:
		self.readError("File not found: " + `fn`)</t>
<t tx="T521">self.indent = 0
out = []
self.scanHeader(file)
self.scanText(file,root,out,atFile.endLeo)
s = string.join(out, "")
root.setBodyStringOrPane(s)</t>
<t tx="T522">@ createNthNode marks all nodes in the derived file as visited.  Any unvisited nodes are either dummies or nodes that don't exist in the derived file.
@c

next = root.nodeAfterTree()
v = root.threadNext()
while v and v != next:
	if not v.isVisited():
		es("unvisited node: " + v.headString())
		self.structureErrors += 1
	v = v.threadNext()
</t>
<t tx="T523">while root.firstChild():
	root.firstChild().doDelete(root)

root.setBodyStringOrPane("")</t>
<t tx="T524">h = {}
v = root
while v and v != next:
	cloneIndex = v.t.cloneIndex
	# new Leo2: we skip the root node: @file nodes can not be cloned.
	if cloneIndex &gt; 0 and v != root:
		if h.has_key(cloneIndex):
			t = h[cloneIndex]
			# v is a clone: share the previous tnode.
			v.setT(t)
			t.setVisited() # We will mark these clones later.
		else: h[cloneIndex] = v.t
	v = v.threadNext()

# Set clone marks for all visited tnodes.
v = root
while v and v != next:
	if v.t.isVisited():
		if v == root:
			pass
		elif v.shouldBeClone():
			v.initClonedBit(true)
		else:
			# Not a serious error.
			es("clone links cleared for: " + v.headString())
			v.unjoinTree();
			t.setCloneIndex(0) # t is no longer cloned.
	v = v.threadNext()</t>
<t tx="T525">@ In most cases, this code is not needed, because the outline already has been read and nodes joined.  However, there could be problems on read errors, so we also join nodes here.
@c

h = {}
v = root
while v and v != next:
	cloneIndex = v.t.cloneIndex
	# new Leo2: we skip the root node: @file nodes can not be cloned.
	if cloneIndex &gt; 0 and v != root:
		if h.has_key(cloneIndex):
			clone = h[cloneIndex]
			if v.headString() == clone.headString():
				self.joinTrees(clone,v)
			else:
				# An extremely serious error.  Data may be lost.
				self.readError(
					"Outline corrupted: " +
					"different nodes have same clone index!\n\t" +
					v.headString() + "\n\t" + clone.headString())
		# Enter v so we can join the next clone to it.
		# The next call to lookup will find this v, not the previous.
		h[cloneIndex] = v
	v = v.threadNext()</t>
<t tx="T526">current = None
v = root
while v and v != next:
	if v.isSelected():
		self.commands.tree.currentVnode = current = v
	if v.isTopBitSet():
		# Just tell the open code we have seen the top vnode.
		self.commands.tree.topVnode = v ;
	v = v.threadNext()

if current:
	# Indicate what the current node will be.
	c.tree.currentVnode = current
</t>
<t tx="T527">@ To do:

remove all calls to chdir
set ivar and use it in file commands</t>
<t tx="T528">def readOutlineOnly (self,file,fileName):

	c=self.commands
	# Read the entire file into the buffer
	self.fileBuffer = file.read() ; file.close()
	self.fileIndex = 0
	&lt;&lt; Set the default directory &gt;&gt;
	c.beginUpdate()
	ok, ratio = self.getLeoFile(self.frame, false) # readAtFileNodes
	c.endUpdate()
	c.frame.top.deiconify()
	c.setChanged(false)
	c.frame.resizePanesToRatio(ratio)
	# This should be done after the pane size has been set.
	if 0: # This can not be done at present.
		if self.topVnode:
			c.tree.scrollTo(self.topVnode)
			c.tree.Refresh()
	# delete the file buffer
	self.fileBuffer = ""
	return ok</t>
<t tx="T529">@ The most natural default directory is the directory containing the .leo file that we are about to open.  If the user has specified the "Default Directory" preference that will over-ride what we are about to set.
@c

dir = os.path.dirname(fileName) 
if len(dir) &gt; 0:
	c.openDirectory = dir</t>
<t tx="T530">def open(self,file,fileName):

	c=self.commands
	# Read the entire file into the buffer
	# t = setTime()
	self.fileBuffer = file.read() ; file.close()
	self.fileIndex = 0
	# esDiffTime("open:read all", t)
	&lt;&lt; Set the default directory &gt;&gt;
	es("reading: " + fileName)
	c.beginUpdate()
	if 1: # inside update...
		c.loading = true # disable c.changed
		ok, ratio = self.getLeoFile(self.frame, true) # readAtFileNodes
		c.loading = false # reenable c.changed
		c.setChanged(false)
		# c.frame.resizePanesToRatio(ratio)
		# This should be done after the pane size has been set.
		top = c.tree.topVnode
		if 0: # This can't be done directly.
			if top: c.tree.scrollTo(top)
	c.endUpdate()
	# delete the file buffer
	self.fileBuffer = ""
	# esDiffTime("open: exit",t)
	return ok</t>
<t tx="T531">def getPrefs(self):

	c = self.commands
	prefs = app().prefsFrame
	self.getTag("&lt;preferences")
	while 1:
		if self.matchTag("allow_rich_text="):
			self.getDquote() ; self.getBool() ; self.getDquote() #ignored
		elif self.matchTag("tab_width="):
			self.getDquote() ; c.tab_width = self.getLong() ; self.getDquote()
		elif self.matchTag("page_width="):
			self.getDquote() ; c.page_width = self.getLong() ; self.getDquote()
		elif self.matchTag("tangle_bat="):
			self.getDquote() ; c.tangle_batch_flag = self.getBool() ; self.getDquote()
		elif self.matchTag("untangle_bat="):
			self.getDquote() ; c.untangle_batch_flag = self.getBool() ; self.getDquote()
		# New in version 0.10
		elif self.matchTag("output_doc_chunks="):
			self.getDquote() ; c.output_doc_flag = self.getBool() ; self.getDquote()
		elif self.matchTag("noweb_flag="):
			# New in version 0.19: Ignore this flag.
			self.getDquote() ; self.getBool() ; self.getDquote()
		elif self.matchTag("extended_noweb_flag="):
			# New in version 0.19: Ignore this flag.
			self.getDquote() ; self.getBool() ; self.getDquote()
		elif self.matchTag("defaultTargetLanguage="):
			# New in version 0.15
			self.getDquote()
			&lt;&lt; check for syntax coloring prefs &gt;&gt;
		elif self.matchTag("use_header_flag="):
			self.getDquote() ; c.use_header_flag = self.getBool() ; self.getDquote()
		else: break
	self.getTag("&gt;")
	while 1:
		if self.matchTag("&lt;defaultDirectory&gt;"):
			# New in version 0.16.
			c.tangle_directory = self.getEscapedString()
			self.getTag("&lt;/defaultDirectory&gt;")
			if not os.path.exists(c.tangle_directory):
				es("Default tangle directory not found:" + c.tangle_directory)
		elif self.matchTag("&lt;TSyntaxMemo_options&gt;"):
			self.getEscapedString() # ignored
			self.getTag("&lt;/TSyntaxMemo_options&gt;")
		else: break
	self.getTag("&lt;/preferences&gt;")
	prefs.init(c)</t>
<t tx="T532"># Must match longer tags before short prefixes.
language = c_language # default

if self.matchTag("CWEB"):
	language = cweb_language ; self.getDquote();
elif self.matchTag("C"):
	language = c_language ; self.getDquote()
elif self.matchTag("HTML"):
	language = html_language ; self.getDquote()
elif self.matchTag("Java"):
	language = java_language ; self.getDquote()
elif self.matchTag("Pascal"):
	language = pascal_language ; self.getDquote()
elif self.matchTag("PerlPod"):
	language = perlpod_language ; self.getDquote()
elif self.matchTag("Perl"):
	language = perl_language ; self.getDquote()
elif self.matchTag("Plain"):
	language = plain_text_language ; self.getDquote()
elif self.matchTag("Python"):
	language = python_language ; self.getDquote()

c.target_language = language</t>
<t tx="T533">def OnReadOutlineOnly (self,event=None):

	fileName = tkFileDialog.askopenfilename(
		title="Read Outline Only",
		filetypes=[("Leo files", "*.leo"), ("All files", "*")],
		defaultextension="leo")

	if not fileName or len(fileName) == 0:
		return "break" # inhibit further command processing
		
	file = open(fileName,'r')
	if file:
		frame = LeoFrame(fileName)
		frame.top.deiconify()
		frame.top.lift()
		app().root.update() # Force a screen redraw immediately.
		frame.commands.fileCommands.readOutlineOnly(file,fileName) # closes file.
	else:
		es("can not open:" + fileName)
	return "break" # inhibit further command processing</t>
<t tx="T534">def write_LEO_file(self,fileName,outlineOnlyFlag):

	c=self.commands
	# Leo2: write all @file nodes and set orphan bits.
	if not outlineOnlyFlag:
		at = c.atFileCommands
		at.writeAll(c.tree.rootVnode, false) # forceFlag
	self.mFileName = fileName
	self.outputFile = open(fileName, 'w')
	if not self.outputFile:
		es("Can not open " + fileName)
		return false

	self.putProlog()
	self.putHeader()
	self.putGlobals()
	self.putPrefs()
	self.putFindSettings()
	self.putVnodes()
	self.putTnodes()
	self.putPostlog()

	if self.outputFile:
		self.outputFile.close()
		self.outputFile = None
		return true
	else:
		return false</t>
<t tx="T535">def OnOpen(self,event=None):

	c = self.commands
	&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;
	# trace(`closeFlag`)

	fileName = tkFileDialog.askopenfilename(
		title="Open",
		filetypes=[("Leo files", "*.leo"), ("All files", "*")],
		defaultextension="leo")

	if fileName and len(fileName) &gt; 0:
		ok, frame = self.OpenWithFileName(fileName)
		if ok and closeFlag:
			app().windowList.remove(self)
			self.destroy() # force the window to go away now.
			app().log = frame # Sets the log stream for es()

	return "break" # inhibit further command processing</t>
<t tx="T536">@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c
	
closeFlag = (
	self.startupWindow==true and # The window was open on startup
	c.changed==false and self.saved==false and # The window has never been changed
	app().numberOfWindows == 1) # Only one untitled window has ever been opened
</t>
<t tx="T537">def OpenWithFileName(self, fileName):

	if not fileName or len(fileName) == 0:
		return false, None
		
	# Display the _unnormalized_ file name
	oldFileName = fileName
		
	# Create a full normalized path name only for comparison.
	fileName = os.path.join(os.getcwd(), fileName)
	fileName = os.path.normcase(fileName)
	fileName = os.path.normpath(fileName)

	# If the file is already open just bring its window to the front.
	list = app().windowList
	for frame in list:
		fn = os.path.normcase(frame.mFileName)
		fn = os.path.normpath(fn)
		if fileName == fn:
			frame.top.deiconify()
			app().log = frame
			es("This window already open")
			return true, frame
			
	fileName = oldFileName # Use the idiosyncratic file name.

	file = open(fileName,'r')
	if file:
		frame = LeoFrame(fileName)
		frame.top.deiconify()
		frame.top.lift()
		app().root.update() # Force a screen redraw immediately.
		frame.commands.fileCommands.open(file,fileName) # closes file.
		frame.openDirectory=os.path.dirname(fileName)
		return true, frame
	else:
		es("can not open:" + fileName)
		return false, None</t>
<t tx="T538">@ These commands get their file names from dialogs, so there should be no need to adjust the filenames as long as we don't call chdir</t>
<t tx="T539">@ Returns a string consisting of @root "gFileName" followed by the contents of the file if appendFileFlag is true.
@c

def createRootBody (self,fileName,appendFileFlag):

	# root = "@root \"" + gFileName + "\"\n\n"
	if appendFileFlag:
		try:
			f=open(fileName,'r')
			s = f.read()
			f.close()
			return s
		except: return ""
	else: return ""</t>
<t tx="T540">def flattenOutline(self,fileName):

	v = self.getCurrentVnode()
	if not v: return
	after = v.nodeAfterTree()
	firstLevel = v.level()
	try:
		file = open(fileName,'w')
		while v and v != after:
			file.write(v.moreHead(firstLevel) + '\n')
			body = v.moreBody() # Inserts escapes.
			if len(body) &gt; 0:
				file.write(body + '\n')
			v = v.threadNext()
		file.close()
	except:
		alert("File error while flattening the outline")</t>
<t tx="T541">def outlineToNoweb(self,fileName):

	v = self.getCurrentVnode()
	if v == None: return
	after = v.nodeAfterTree()
	try:
		file = open(fileName,'w')
		while v and v != after:
			s = convertToNoweb(v)
			if len(s) &gt; 0:
				file.Write(s)
				if s[-1] != '\n':
					file.Write('\n')
			v = v.threadNext()
		file.Close()
	except:
		alert("File error in Outline To noweb command")</t>
<t tx="T542"># Called by __init__

def init_ivars(self):

	c = self.commands
	&lt;&lt; init tangle ivars &gt;&gt;
	
# Called by scanAllDirectives

def init_directive_ivars (self):

	c = self.commands
	&lt;&lt; init directive ivars &gt;&gt;</t>
<t tx="T543"># Various flags and counts...

self.errors = 0 # The number of errors seen.
self.tangling = true # true if tangling, false if untangling.
self.path_warning_given = false # true: suppress duplicate warnings.
self.tangle_indent = 0 # Level of indentation during pass 2, in spaces.
self.file_name = c.frame.mFileName # The file name (was a bridge function)
self.v = None # vnode being processed.
self.output_file = None # The file descriptor of the output file.
self.tangle_default_directory = None # Default directory set by scanAllDirectives.

@ Symbol tables: the TST (Tangle Symbol Table) contains all section names in the outline. The UST (Untangle Symbol Table) contains all sections defined in the derived file.
@c
self.tst = {}
self.ust = {}

# The section stack for Tangle and the definition stack for Untangle.
self.section_stack = []
self.def_stack = []

@ The list of all roots. The symbol table routines add roots to self list during pass 1. Pass 2 uses self list to generate code for all roots.
@c
self.root_list = []

# The delimiters for comments created by the @comment directive.
self.single_comment_string = "//"  # present comment delimiters.
self.start_comment_string = "/*"
self.end_comment_string = "*/"

# The filename following @root in a headline.
# The code that checks for &lt; &lt; * &gt; &gt; = uses these globals.
self.root = None
self.root_name = None

# Formerly the "tangle private globals"
# These save state during tangling and untangling.
# It is possible that these will be removed...
if 1:
	self.head_root = None
	self.code = None
	self.doc = None
	self.header_name = None
	self.header = None
	self.section_name = None

@ The following records whether we have seen an @code directive in a body text.
If so, an @code represents &lt; &lt; header name &gt; &gt; = and it is valid to continue a section definition.
@c
self.code_seen = false # true if @code seen in body text.</t>
<t tx="T544">if 0: # not used in this version of Leo
	self.allow_rich_text = default_allow_rich_text
	self.extended_noweb_flag = default_extended_noweb_flag
	self.target_language = default_target_language # uses c.target_lanuage instead
	
# Global options
self.page_width = c.page_width
self.tab_width = c.tab_width
self.tangle_batch_flag = c.tangle_batch_flag
self.untangle_batch_flag = c.untangle_batch_flag

# Default tangle options.
self.tangle_directory = None # Initialized by scanAllDirectives
self.output_doc_flag = c.output_doc_flag
self.use_header_flag = c.use_header_flag

# Default tangle language
self.language = c.target_language
(	self.single_comment_string,
	self.start_comment_string,
	self.end_comment_string ) = set_delims_from_language(self.language)

# Abbreviations for self.language
self.use_cweb_flag = self.language == cweb_language
self.use_noweb_flag = not self.use_cweb_flag

# Set only from directives.
self.print_bits = verbose_bits</t>
<t tx="T545">@ This is the top level method of the second pass. It creates a separate C file for each @root directive in the outline. As will be seen later,the file is actually written only if the new version of the file is different from the old version,or if the file did not exist previously. If changed_only_flag FLAG is true only changed roots are actually written.
@c

def put_all_roots(self):

	c = self.commands ; outline_name = c.frame.mFileName

	for section in self.root_list:
	
		# trace(`section.name`)
		file_name = os.path.join(self.tangle_directory,section.name)
		file_name = os.path.normpath(file_name)
		temp_name = create_temp_name(section.name)
		if not temp_name:
			es("Can not create temp file")
			break
		# Set the output_file global.
		self.output_file = open(temp_name,"w")
		if not self.output_file:
			es("Can not create: " + temp_name)
			break
		if self.use_header_flag and self.print_bits == verbose_bits:
			&lt;&lt; Write a banner at the start of the output file &gt;&gt;
		for part in section.parts:
			if part.is_root:
				self.tangle_indent = 0 # Initialize global.
				self.put_part_node(part,false) # output first lws
		self.onl() # Make sure the file ends with a cr/lf
		self.output_file.close()
		self.output_file = None
		if self.errors == 0:
			update_file_if_changed(file_name,temp_name)
		else:
			es("unchanged:  " + file_name)
			&lt;&lt; Erase the temporary file &gt;&gt;</t>
<t tx="T546">if self.single_comment_string:
	self.os(self.single_comment_string)
	self.os(" Created by Leo from: ")
	self.os(outline_name)
	self.onl() ; self.onl()
elif self.start_comment_string and self.end_comment_string:
	self.os(self.start_comment_string)
	self.os(" Created by Leo from: ")
	self.os(outline_name)
	self.oblank() ; self.os(self.end_comment_string)
	self.onl() ; self.onl()
</t>
<t tx="T547">
try: # Just delete the temp file.
	os.remove(temp_name)
except: pass
</t>
<t tx="T548">def getIconImage (self, name):

	# Return the image from the cache if possible.
	if self.iconimages.has_key(name):
		return self.iconimages[name]
		
	try:
		dir = app().loadDir
		file, ext = os.path.splitext(name)
		fullname = os.path.join(dir, file + ext)
		fullname = os.path.normpath(fullname)
		image = Tkinter.PhotoImage(master=self.canvas, file=fullname)
		self.iconimages[name] = image
		return image
	except:
		es("Can not load: " + fullname)
		es("dir:" + `dir` + ", file:" + `file` + ", ext:" + `ext`)
		return None</t>
<t tx="T549"># Warning:  call del self will not necessarily call this routine.

def __del__ (self):
	
	# Can't trace while destroying.
	# print "frame.__del__"
	
	self.log = self.body = self.tree = None
	self.treeBar = self.canvas = self.splitter1 = self.splitter2 = None
	# Menu bars.
	self.topMenu = self.fileMenu = self.editMenu = None
	self.outlineMenu = self.windowMenu = self.helpMenu = None
	# Submenus.
	self.editBodyMenu = self.moveSelectMenu = self.markGotoMenu = None</t>
<t tx="T550">@ The accelerator entry specified when creating a menu item just creates text.  The actual correspondance between keys and routines is defined here.
@c

def createAccelerators (self,top):

	body = self.body ; canvas = self.canvas

	fkeyBindings = [
		("F3", self.OnFindNext)
	]
	for accel, command in fkeyBindings:
		top.bind("&lt;" + accel + "&gt;", command)

	controlBindings = [
		&lt;&lt; control key bindings &gt;&gt;
	]
	# Warnings: two sets of actions will be taken for these
	# unless all event handlers returns "break".
	for accel, command in controlBindings:
		body.bind("&lt;Control-" + accel + "&gt;", command) # Necessary to override defaults in body.
		top.bind("&lt;Control-" + accel + "&gt;", command)
		
	# These keys must be bound only in the canvas widget.
	canvasControlBindings = [
		&lt;&lt; canvas control bindings &gt;&gt;
	]
	for accel, command in canvasControlBindings:
		canvas.bind("&lt;Control-" + accel + "&gt;", command)

	altBindings = [
		&lt;&lt; alt key bindings &gt;&gt;
	]
	# Warnings: two sets of actions will be taken for these
	# unless all event handlers returns "break".
	for accel, command in altBindings:
		body.bind("&lt;Alt-" + accel + "&gt;", command) # Necessary to override defaults in body.
		top.bind("&lt;Alt-" + accel + "&gt;", command)
		
	if 0: # A useful trace
		print_bindings("top",self.top)
		print_bindings("body",self.body)
		print_bindings("canvas",self.canvas)</t>
<t tx="T551"># The names at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm must be used here.
("equal", self.OnReplace), # "="
("quoteleft", self.OnCloneNode), # "`"
("minus", self.OnReplaceThenFind),

("braceleft", self.OnPromote), # "{"
("braceright", self.OnDemote), # "}"
("bracketleft", self.OnDedent), # "["
("bracketright", self.OnIndent), # "]"
("Shift-BackSpace", self.OnDeleteNode),

# Note: These keys must be bound _only_ to the body pane!
# ("Down", self.OnGoNextVisible),
# ("Up", self.OnGoPrevVisible),
# ("Shift-Down", self.OnGoBack),
# ("Shift-Up", self.OnGoNext),

("a", self.OnSelectAll),
# "b" unused
# ("c", self.OnCopy), # Done in frame.__init__
("d", self.OnMoveDown),
("e", self.OnEqualSizedPanes),
("f", self.OnFindPanel),
("g", self.OnFindNext),
("h", self.OnEditHeadline),
("i", self.OnInsertNode), # Control-I == '\t'
# Control-J == '\n'
# Control-k no longer used
("l", self.OnMoveLeft),
("m", self.OnMark),
("n", self.OnNew),
("o", self.OnOpen),
# "p" unused.
("q", self.OnQuit),
("r", self.OnMoveRight),
("s", self.OnSave),
("t", self.OnToggleActivePane),
("u", self.OnMoveUp),
# ("v", self.OnCopy), # Done in frame.__init__
("w", self.OnClose),
# ("x", self.OnCut), # Done in frame.__init__
("y", self.OnPreferences),
("z", self.OnUndo),
# Shift-Control...
("A", self.OnTangleAll),
("B", self.OnConvertBlanks),
("C", self.OnCopyNode),
("D", self.OnExtract),
("E", self.OnExtractSection),
("F", self.OnImportFiles),
("G", self.OnFindPrevious),
# H unused
# I reserved
# J reserved
# K unused
# L unused
("M", self.OnTangleMarked),
("N", self.OnExtractNames),
# O unused
# P unused
# Q unused
# R unused
("S", self.OnSaveAs),
("T", self.OnTangle),
("U", self.OnUntangle),
("V", self.OnPasteNode),
# W unused
("X", self.OnCutNode),
("Z", self.OnRedo)</t>
<t tx="T552">("Down", self.OnGoNextVisible),
("Up", self.OnGoPrevVisible),
("Shift-Down", self.OnGoNext),
("Shift-Up", self.OnGoBack),</t>
<t tx="T553">("equal", self.OnExpandNextLevel),
("Key-0", self.OnContractParent),
("Key-1", self.OnExpandToLevel1), # Note 1-5 all by itself refers to button 1-5, not key 1-5.
("Key-2", self.OnExpandToLevel2),
("Key-3", self.OnExpandToLevel3),
("Key-4", self.OnExpandToLevel4),
("Key-5", self.OnExpandToLevel5),
("Key-6", self.OnExpandToLevel6),
("Key-7", self.OnExpandToLevel7),
("Key-8", self.OnExpandToLevel8),
("Key-9", self.OnExpandAll),
("a", self.OnSortSiblings),
# "b" unused
("c", self.OnMarkChangedItems),
("d", self.OnGoToNextChanged),
# "e" opens Edit menu
# "f" opens File menu
# "g" unused
# "h" opens Help menu
# "i" unused (reserved?)
# "j" unused (reserved?)
# "k" unused
# "l" unused
("m", self.OnGoToNextMarked),
# "n" unused
# "o" opens Outline menu
("p", self.OnOpenPythonWindow),
# "q" unused
("r", self.OnMarkChangedRoots),
("s", self.OnMarkSubheads),
# "t" unused
("u", self.OnUnmarkAll),
("v", self.OnViewAllCharacters),
# "w" opens Window menu
# "x" unused
# "y" unused
# "z" unused
# Shift-Alt
# ("E", self.OnExecuteScript),
("S", self.OnSyntaxColoring),
("T", self.OnFontPanel)</t>
<t tx="T554">def createMenuBar(self, top):

	c = self.commands
	Tk = Tkinter
	self.topMenu = menu = Tk.Menu(top,postcommand=self.OnMenuClick)
	# To do: use Meta rathter than Control for accelerators for Unix
	&lt;&lt; create the file menu &gt;&gt;
	&lt;&lt; create the edit menu &gt;&gt;
	&lt;&lt; create the outline menu &gt;&gt;
	&lt;&lt; create the window menu &gt;&gt;
	&lt;&lt; create the help menu &gt;&gt;
	top.config(menu=menu) # Display the menu.</t>
<t tx="T555">self.fileMenu = fileMenu = Tk.Menu(menu,tearoff=0)
menu.add_cascade(label="File",menu=fileMenu)
&lt;&lt; create the top-level file entries &gt;&gt;
&lt;&lt; create the read/write submenu &gt;&gt;
&lt;&lt; create the tangle submenu &gt;&gt;
&lt;&lt; create the untangle submenu &gt;&gt;
&lt;&lt; create the import submenu &gt;&gt;
fileMenu.add_separator()
fileMenu.add_command(label="Exit", command=self.OnQuit)</t>
<t tx="T556">fileMenu.add_command(label="New",accelerator="Ctrl+N", command=self.OnNew)
fileMenu.add_command(label="Open...",accelerator="Ctrl+O", command=self.OnOpen)
fileMenu.add_separator()

fileMenu.add_command(label="Close",accelerator="Ctrl+W", command=self.OnClose)
fileMenu.add_command(label="Save",accelerator="Ctrl+S", command=self.OnSave)
fileMenu.add_command(label="Save As",accelerator="Shift+Ctrl+S", command=self.OnSaveAs)
fileMenu.add_command(label="Save To",command=self.OnSaveTo)
revert = fileMenu.add_command(label="Revert To Saved",command=self.OnRevert) # ,state="disabled") #
fileMenu.add_separator()

@ It is doubtful that leo.py will ever support a Print command directly.  Rather, users can use export commands to create text files that may then be formatted and printed as desired.
@c
if 0:
	fileMenu.add_command(label="Page Setup", accelerator="Shift+Ctrl+P",command=self.OnPageSetup)
	fileMenu.add_command(label="Print", accelerator="Ctrl+P", command=self.OnPrint)
	fileMenu.add_separator()</t>
<t tx="T557">readWriteMenu = Tk.Menu(fileMenu,tearoff=0)
fileMenu.add_cascade(label="Read/Write...", menu=readWriteMenu)

readWriteMenu.add_command(label="Read Outline Only",command=self.OnReadOutlineOnly)
readWriteMenu.add_command(label="Read @file Nodes",command=self.OnReadAtFileNodes)
readWriteMenu.add_command(label="Write Outline Only",command=self.OnWriteOutlineOnly)
readWriteMenu.add_command(label="Write @file Nodes",command=self.OnWriteAtFileNodes)</t>
<t tx="T558">tangleMenu = Tk.Menu(fileMenu,tearoff=0)
fileMenu.add_cascade(label="Tangle...", menu=tangleMenu)

tangleMenu.add_command(label="Tangle All",
	accelerator="Shift+Ctrl+A",
	command=self.OnTangleAll)
tangleMenu.add_command(label="Tangle Marked",
	accelerator="Shift+Ctrl+M",
	command=self.OnTangleMarked)
tangleMenu.add_command(label="Tangle",
	accelerator="Shift+Ctrl+T",
	command=self.OnTangle)</t>
<t tx="T559">untangleMenu = Tk.Menu(fileMenu,tearoff=0)
fileMenu.add_cascade(label="Untangle...", menu=untangleMenu)

untangleMenu.add_command(label="Untangle All",
	command=self.OnUntangleAll,state="disabled") #
untangleMenu.add_command(label="Untangle Marked",
	command=self.OnUntangleMarked,state="disabled") #
untangleMenu.add_command(label="Untangle",
	accelerator="Shift+Ctrl+U",command=self.OnUntangle,state="disabled") #</t>
<t tx="T560">importMenu = Tk.Menu(fileMenu,tearoff=0)
fileMenu.add_cascade(label="Import/Export...", menu=importMenu)

importMenu.add_command(label="Import Files",accelerator="Shift+Ctrl+F",
	command=self.OnImportFiles,state="disabled") #
importMenu.add_command(label="Import CWEB Files",
	command=self.OnImportCWEBFiles,state="disabled") #
importMenu.add_command(label="Import noweb Files",
	command=self.OnImportNowebFiles,state="disabled") #
importMenu.add_command(label="Import MORE Text",
	command=self.OnImportMoreText,state="disabled") #
importMenu.add_separator()

importMenu.add_command(label="OutlineToCWEB",
	command=self.OnOutlineToCWEB,state="disabled") #
importMenu.add_command(label="OutlineToNoweb",
	command=self.OnOutlineToNoweb,state="disabled") #
importMenu.add_command(label="Export MORE Text",
	command=self.OnExportMoreText,state="disabled") #
importMenu.add_command(label="Flatten Outline",
	command=self.OnFlattenOutline,state="disabled") #

</t>
<t tx="T561">self.editMenu = editMenu = Tk.Menu(menu,tearoff=0)
menu.add_cascade(label="Edit", menu=editMenu)

editMenu.add_command(label="Undo",
	accelerator="Ctrl+Z",command=self.OnUndo)
editMenu.add_command(label="Redo",
	accelerator="Shift+Ctrl+Z",command=self.OnRedo)
editMenu.add_separator()

editMenu.add_command(label="Cut", accelerator="Ctrl+X", command=self.OnCutFromMenu)
editMenu.add_command(label="Copy", accelerator="Ctrl+C", command=self.OnCopyFromMenu)
editMenu.add_command(label="Paste", accelerator="Ctrl+V", command=self.OnPasteFromMenu) 

editMenu.add_command(label="Delete",
	command=self.OnDelete)
editMenu.add_command(label="Select All",
	command=self.OnSelectAll)
editMenu.add_separator()

editMenu.add_command(label="Edit Headline",
	accelerator="Ctrl+H",command=self.OnEditHeadline)
&lt;&lt; create the edit body submenu &gt;&gt;
&lt;&lt; create the find submenu &gt;&gt;
editMenu.add_command(label="Font Panel",
	accelerator="Shift+Alt+T",command=self.OnFontPanel,state="disabled") #
editMenu.add_command(label="Syntax Coloring...",
	accelerator="Shift+Alt+S",command=self.OnSyntaxColoring,state="disabled") #

label = choose(c.tree.colorizer.showInvisibles,"Hide Invisibles","Show Invisibles")
editMenu.add_command(label=label,command=self.OnViewAllCharacters,
	accelerator="Alt+V")
editMenu.add_separator()

editMenu.add_command(label="Preferences",accelerator="Ctrl+Y",command=self.OnPreferences)</t>
<t tx="T562">self.editBodyMenu = editBodyMenu = Tk.Menu(editMenu,tearoff=0)
editMenu.add_cascade(label="Edit Body...", menu=editBodyMenu)

editBodyMenu.add_command(label="Extract Section",
	accelerator="Shift+Ctrl+E",command=self.OnExtractSection)
editBodyMenu.add_command(label="Extract Names",
	accelerator="Shift+Ctrl+N",command=self.OnExtractNames)
editBodyMenu.add_command(label="Extract",
	accelerator="Shift+Ctrl+D",command=self.OnExtract)
editBodyMenu.add_command(label="Convert Blanks",
	accelerator="Shift+Ctrl+B",command=self.OnConvertBlanks)
editBodyMenu.add_separator()

editBodyMenu.add_command(label="Indent",
	accelerator="Ctrl+]",command=self.OnIndent)
editBodyMenu.add_command(label="Unindent",
	accelerator="Ctrl+[",command=self.OnDedent)</t>
<t tx="T563">findMenu = Tk.Menu(editMenu,tearoff=0)
editMenu.add_cascade(label="Find...", menu=findMenu)

findMenu.add_command(label="Find Panel",accelerator="Ctrl+F",
	command=self.OnFindPanel)
findMenu.add_separator()

findMenu.add_command(label="Find Next",accelerator="F3",
	command=self.OnFindNext)
findMenu.add_command(label="Find Next",accelerator="Ctrl+G",
	command=self.OnFindNext)
findMenu.add_command(label="Find Previous",accelerator="Shift+Ctrl+G",
	command=self.OnFindPrevious)
findMenu.add_command(label="Replace",accelerator="Ctrl+=",
	command=self.OnReplace)
findMenu.add_command(label="Replace, Then Find",accelerator="Ctrl+-",
	command=self.OnReplaceThenFind)</t>
<t tx="T564">self.outlineMenu = outlineMenu = Tk.Menu(menu,tearoff=0)
menu.add_cascade(label="Outline", menu=outlineMenu)

outlineMenu.add_command(label="Cut Node",
	accelerator="Shift+Ctrl+X",command=self.OnCutNode)
outlineMenu.add_command(label="Copy Node",
	accelerator="Shift+Ctrl+C",command=self.OnCopyNode)
outlineMenu.add_command(label="Paste Node",
	accelerator="Shift+Ctrl+V",command=self.OnPasteNode)
outlineMenu.add_command(label="Delete Node",
	accelerator="Shift+Ctrl+BkSp",command=self.OnDeleteNode)
outlineMenu.add_separator()

outlineMenu.add_command(label="Insert Node",
	accelerator="Ctrl+I",command=self.OnInsertNode)
outlineMenu.add_command(label="Clone Node",
	accelerator="Ctrl+`",command=self.OnCloneNode)
outlineMenu.add_command(label="Sort Children",
	command=self.OnSortChildren)
outlineMenu.add_command(label="Sort Siblings",
	accelerator="Alt-A",command=self.OnSortSiblings)
outlineMenu.add_separator()

&lt;&lt; create expand/contract submenu &gt;&gt;
&lt;&lt; create move/select submenu &gt;&gt;
&lt;&lt; create mark/goto submenu &gt;&gt;</t>
<t tx="T565">self.expandContractMenu = expandContractMenu = Tk.Menu(outlineMenu,tearoff=0)
outlineMenu.add_cascade(label="Expand/Contract...", menu=expandContractMenu)

expandContractMenu.add_command(label="Expand All",
	accelerator="Alt+9",command=self.OnExpandAll)
expandContractMenu.add_command(label="Expand All Children",
	command=self.OnExpandAllChildren)
expandContractMenu.add_command(label="Expand Children",
	command=self.OnExpandChildren)
expandContractMenu.add_separator()

expandContractMenu.add_command(label="Contract Parent",
	accelerator="Alt+0",command=self.OnContractParent)
expandContractMenu.add_command(label="Contract All",
	accelerator="Alt+1",command=self.OnContractAll)
expandContractMenu.add_command(label="Contract All Children",
	command=self.OnContractAllChildren)
expandContractMenu.add_command(label="Contract Children",
	command=self.OnContractChildren)
expandContractMenu.add_separator()

expandContractMenu.add_command(label="Expand Next Level",
	accelerator="Alt+=",command=self.OnExpandNextLevel)
expandContractMenu.add_command(label="Expand To Level 1",
	accelerator="Alt+1",command=self.OnExpandToLevel1)
expandContractMenu.add_command(label="Expand To Level 2",
	accelerator="Alt+2",command=self.OnExpandToLevel2)
expandContractMenu.add_command(label="Expand To Level 3",
	accelerator="Alt+3",command=self.OnExpandToLevel3)
expandContractMenu.add_command(label="Expand To Level 4",
	accelerator="Alt+4",command=self.OnExpandToLevel4)
expandContractMenu.add_command(label="Expand To Level 5",
	accelerator="Alt+5",command=self.OnExpandToLevel5)
expandContractMenu.add_command(label="Expand To Level 6",
	accelerator="Alt+6",command=self.OnExpandToLevel6)
expandContractMenu.add_command(label="Expand To Level 7",
	accelerator="Alt+7",command=self.OnExpandToLevel7)
expandContractMenu.add_command(label="Expand To Level 8",
	accelerator="Alt+8",command=self.OnExpandToLevel8)
#expandContractMenu.add_command(label="Expand To Level 9",
	#accelerator="Alt+9",command=self.OnExpandToLevel9)</t>
<t tx="T566">self.moveSelectMenu = moveSelectMenu = Tk.Menu(outlineMenu,tearoff=0)
outlineMenu.add_cascade(label="Move/Select...", menu=moveSelectMenu)

moveSelectMenu.add_command(label="Move Down",
	accelerator="Ctrl+D",command=self.OnMoveDown)
moveSelectMenu.add_command(label="Move Left",
	accelerator="Ctrl+L",command=self.OnMoveLeft)
moveSelectMenu.add_command(label="Move Right",
	accelerator="Ctrl+R",command=self.OnMoveRight)
moveSelectMenu.add_command(label="Move Up",
	accelerator="Ctrl+U", command=self.OnMoveUp)
moveSelectMenu.add_separator()

moveSelectMenu.add_command(label="Promote",
	accelerator="Shift+Ctrl+[", command=self.OnPromote)
moveSelectMenu.add_command(label="Demote",
	accelerator="Shift+Ctrl+]", command=self.OnDemote)
moveSelectMenu.add_separator()

moveSelectMenu.add_command(label="Go Prev Visible",
	accelerator="Ctrl+Up",command=self.OnGoPrevVisible)
moveSelectMenu.add_command(label="Go Next Visible",
	accelerator="Ctrl+Down",command=self.OnGoNextVisible)
moveSelectMenu.add_separator()

moveSelectMenu.add_command(label="Go Back",
	accelerator="Shift+Ctrl+Up",command=self.OnGoBack)
moveSelectMenu.add_command(label="Go Next",
	accelerator="Shift+Ctrl+Down",command=self.OnGoNext)</t>
<t tx="T567">self.markGotoMenu = markGotoMenu = Tk.Menu(outlineMenu,tearoff=0)
outlineMenu.add_cascade(label="Mark/Go To...", menu=markGotoMenu)

markGotoMenu.add_command(label="Mark",
	accelerator="Ctrl-M",command=self.OnMark)
markGotoMenu.add_command(label="Mark Subheads",
	accelerator="Alt+S",command=self.OnMarkSubheads)
markGotoMenu.add_command(label="Mark Changed Items",
	accelerator="Alt+C",command=self.OnMarkChangedItems)
markGotoMenu.add_command(label="Mark Changed Roots",
	accelerator="Alt+R",command=self.OnMarkChangedRoots)
markGotoMenu.add_separator()

markGotoMenu.add_command(label="Unmark All",
	accelerator="Alt+U",command=self.OnUnmarkAll)
markGotoMenu.add_command(label="Go To Next Marked",
	accelerator="Alt+M",command=self.OnGoToNextMarked)
markGotoMenu.add_command(label="Go To Next Changed",
	accelerator="Alt+C",command=self.OnGoToNextChanged)</t>
<t tx="T568">self.windowMenu = windowMenu = Tk.Menu(menu,tearoff=0)
menu.add_cascade(label="Window", menu=windowMenu)

windowMenu.add_command(label="Equal Sized Panes",
	accelerator="Ctrl-E",command=self.OnEqualSizedPanes)
windowMenu.add_command(label="Toggle Active Pane",
	accelerator="Ctrl-T",command=self.OnToggleActivePane)
windowMenu.add_command(label="Toggle Split Direction",
	command=self.OnToggleSplitDirection, state="disabled") #
windowMenu.add_separator()

windowMenu.add_command(label="Cascade",
	command=self.OnCascade)
windowMenu.add_command(label="Minimize All",
	command=self.OnMinimizeAll,state="disabled") #
windowMenu.add_separator()

windowMenu.add_command(label="Open Python Window",
	accelerator="Alt+P",command=self.OnOpenPythonWindow)</t>
<t tx="T569">self.helpMenu = helpMenu = Tk.Menu(menu,tearoff=0)
menu.add_cascade(label="Help", menu=helpMenu)
helpMenu.add_command(label="About Leo...", command=self.OnAbout)
helpMenu.add_command(label="Leo Documentation...", command=self.OnLeoDocumentation)</t>
<t tx="T570"></t>
<t tx="T571">def canContractAllHeadlines(self):

	c = self
	v = c.tree.rootVnode
	if not v: return false
	while v:
		if v.isExpanded():
			return true
		v = v.threadNext()
	return false</t>
<t tx="T572">def canContractAllSubheads(self):

	c = self
	v = c.tree.currentVnode
	if not v: return false
	next = v.nodeAfterTree()
	v = v.threadNext()
	while v and v != next:
		if v.isExpanded():
			return true
		v = v.threadNext()
	return false</t>
<t tx="T573">def canContractParent (self):

	c = self ; v = c.currentVnode()
	return v.parent() != None</t>
<t tx="T574">def canContractSubheads(self):

	c = self ; v = c.currentVnode()
	if not v: return false
	v = v.firstChild()
	while v:
		if v.isExpanded():
			return true
		v = v.next()
	return false</t>
<t tx="T575">def canDeleteHeadline(self):

	c = self ; v = c.tree.currentVnode
	if not v: return false
	if v.parent(): # v is below the top level.
		return true
	else: # v is at the top level.  We can not delete the last node.
		return v.threadBack() or v.next()

canCutOutline = canDeleteHeadline</t>
<t tx="T576">def canDemote(self):

	c = self
	v = c.tree.currentVnode
	if not v: return false
	return v.next() != None</t>
<t tx="T577">def canExpandAllHeadlines(self):

	c = self
	v = c.tree.rootVnode
	if not v: return false
	while v:
		if not v.isExpanded():
			return true
		v = v.threadNext()
	return false</t>
<t tx="T578">def canExpandAllSubheads(self):

	c = self
	v = c.tree.currentVnode
	if not v: return false
	next = v.nodeAfterTree()
	v = v.threadNext()
	while v and v != next:
		if not v.isExpanded():
			return true
		v = v.threadNext()
	return false</t>
<t tx="T579">def canExpandSubheads(self):

	c = self
	v = c.tree.currentVnode
	if not v: return false
	v = v.firstChild()
	while v:
		if not v.isExpanded():
			return true
		v = v.next()
	return false</t>
<t tx="T580">def canGoToNextDirtyHeadline(self):

	c = self
	current = c.tree.currentVnode
	if not current: return false
	v = c.tree.rootVnode
	while v:
		if v.isDirty()and v != current:
			return true
		v = v.threadNext()
	return false</t>
<t tx="T581">def canGoToNextMarkedHeadline(self):

	c = self
	current = c.tree.currentVnode
	if not current: return false
	v = c.tree.rootVnode
	while v:
		if v.isMarked()and v != current:
			return true
		v = v.threadNext()
	return false</t>
<t tx="T582">def canMarkChangedHeadlines(self):

	c = self
	v = c.tree.rootVnode
	while v:
		if v.isDirty():
			return true
		v = v.threadNext()
	return false</t>
<t tx="T583">def canMarkChangedRoots(self):

	c = self
	v = c.tree.rootVnode
	while v:
		if v.isDirty():
			return true
		v = v.threadNext()
	return false</t>
<t tx="T584">def canMoveOutlineDown(self):

	c = self
	if 1: # The permissive way
		current = c.tree.currentVnode
		if not current: return false
		v = current.visNext()
		while v and current.isAncestorOf(v):
			v = v.visNext()
		return v != None
	else: # The MORE way.
		return c.tree.currentVnode.next() != None</t>
<t tx="T585">def canMoveOutlineLeft(self):

	c = self
	v = c.tree.currentVnode
	if 0: # Old code: assumes multiple leftmost nodes.
		return v and v.parent()
	else: # Can't move a child of the root left.
		return v and v.parent() and v.parent().parent()</t>
<t tx="T586">def canMoveOutlineRight(self):

	c = self
	v = c.tree.currentVnode
	return v and v.back()</t>
<t tx="T587">def canMoveOutlineUp(self):

	c = self
	v = c.tree.currentVnode
	if 1: # The permissive way.
		return v and v.visBack()
	else: # The MORE way.
		return v and v.back()</t>
<t tx="T588">def canPromote(self):

	c = self
	v = c.tree.currentVnode
	return v and v.hasChildren()</t>
<t tx="T589">def canShiftBodyLeft(self):

	c = self
	if c.body:
		s = c.body.GetValue()
		return len(s) &gt; 0
	else:
		return false</t>
<t tx="T590">def canShiftBodyRight(self):

	c = self
	if c.body:
		s = c.body.GetValue()
		return len(s) &gt; 0
	else:
		return false</t>
<t tx="T591">def canSortChildren(self):

	c = self ; v = c.currentVnode()
	return v and v.hasChildren()
	
def canSortSiblings(self):

	c = self ; v = c.currentVnode()
	parent = v.parent()
	return parent and parent.hasChildren()</t>
<t tx="T592"># Returns true if any node is marked.

def canUnmarkAll(self):

	c = self
	v = c.tree.rootVnode
	while v:
		if v.isMarked():
			return true
		v = v.threadNext()
	return false</t>
<t tx="T593"></t>
<t tx="T594"># This is the Tk "postcommand" callback.  It should update all menu items.

def OnMenuClick (self):

	self.updateFileMenu()
	self.updateEditMenu()
	self.updateOutlineMenu()</t>
<t tx="T595">def enable (self,menu,name,val):

	state = choose(val,"normal","disabled")
	menu.entryconfig(name,state=state)

def disable (self,menu,name):

	menu.entryconfig(name,state="disabled")

def setLabel (self,menu,name,label):

	menu.entryconfig(name,label=label)</t>
<t tx="T596"># Returns true if text in the outline or body text is selected.

def hasSelection (self):

	if self.body:
		first, last = getTextSelection(self.body)
		return first != last
	else:
		return false</t>
<t tx="T597">def updateFileMenu (self):

	c = self.commands ; menu = self.fileMenu
	if not c: return
	self.enable(menu,"Revert To Saved", c.canRevert())</t>
<t tx="T598">def updateEditMenu (self):

	c = self.commands
	if not c: return
	menu = self.editMenu
	# Top level entries.
	self.disable(menu,"Undo") ## self.enable(menu,"Undo",c.canUndo())
	self.disable(menu,"Redo") ## self.enable(menu,"Redo",c.canCopy())
	if 0: # Always on for now.
		self.enable(menu,"Cut",c.canCut())
		self.enable(menu,"Copy",c.canCut()) # delete
		self.enable(menu,"Paste",c.canPaste())
	if 0: # Always on for now.
		menu = self.findMenu
		self.enable(menu,"Find Next",c.canFind())
		flag = c.canReplace()
		self.enable(menu,"Replace",flag)
		self.enable(menu,"Replace, Then Find",flag)
	# Edit Body submenu
	menu = self.editBodyMenu
	self.enable(menu,"Extract Section",c.canExtractSection())
	self.enable(menu,"Extract Names",c.canExtractSectionNames())
	self.enable(menu,"Extract",c.canExtract())</t>
<t tx="T599">def updateOutlineMenu (self):

	c = self.commands ; v = c.currentVnode()
	if not c: return

	menu = self.outlineMenu
	self.enable(menu,"Cut Node",c.canCutOutline())
	self.enable(menu,"Delete Node",c.canDeleteHeadline())
	self.enable(menu,"Paste Node",c.canPasteOutline())
	self.enable(menu,"Sort Siblings",c.canSortSiblings())
	# Expand/Contract submenu
	menu = self.expandContractMenu
	self.enable(menu,"Contract Parent",c.canContractParent())
	# Move/Select submenu
	menu = self.moveSelectMenu
	self.enable(menu,"Move Down",c.canMoveOutlineDown())
	self.enable(menu,"Move Left",c.canMoveOutlineLeft())
	self.enable(menu,"Move Right",c.canMoveOutlineRight())
	self.enable(menu,"Move Up",c.canMoveOutlineUp())
	self.enable(menu,"Promote",c.canPromote())
	self.enable(menu,"Demote",c.canDemote())
	self.enable(menu,"Go Prev Visible",c.canSelectVisBack())
	self.enable(menu,"Go Next Visible",c.canSelectVisNext())
	self.enable(menu,"Go Back",c.canSelectThreadBack())
	self.enable(menu,"Go Next",c.canSelectThreadNext())
	# Mark/Go To submenu
	menu = self.markGotoMenu
	label = choose(v and v.isMarked(),"Unmark","Mark")
	self.setLabel(menu,0,label)
	self.enable(menu,"Mark Subheads",(v and v.hasChildren()))
	self.enable(menu,"Mark Changed Items",c.canMarkChangedHeadlines())
	self.enable(menu,"Mark Changed Roots",c.canMarkChangedRoots())
	self.enable(menu,"Go To Next Marked",c.canGoToNextMarkedHeadline())
	self.enable(menu,"Go To Next Changed",c.canGoToNextDirtyHeadline())</t>
<t tx="T600">The problem with Control-d was that event handlers did not return "break"</t>
<t tx="T601">def OnMoveDown(self,event=None):

	self.commands.moveOutlineDown()
	return "break" # inhibit further command processing</t>
<t tx="T602">def OnToggleActivePane (self,event=None):

	# trace(`event`)
	if self.getFocus() == self.body:
		self.canvas.focus_force()
	else:
		self.body.focus_force()
	return "break" # inhibit further command processing</t>
<t tx="T603"></t>
<t tx="T604"></t>
<t tx="T605"></t>
<t tx="T606">def OnNew (self,event=None):

	frame = LeoFrame() # Create another Leo window.
	c = frame.commands # Use the commander of the _new_ frame.
	c.beginUpdate()
	if 1: # within update
		t = leoNodes.tnode()
		v = leoNodes.vnode(c,t)
		v.initHeadString("NewHeadline")
		v.moveToRoot()
		c.editVnode(v)
	c.endUpdate()
	frame.body.focus_set()
	return "break" # inhibit further command processing</t>
<t tx="T607"># Called when File-Close command is chosen.

def OnClose(self,event=None):
	
	self.OnCloseLeoEvent() # Destroy the frame unless the user cancels.
	return "break" # inhibit further command processing</t>
<t tx="T608">def OnSave(self,event=None):

	c = self.commands
	
	# Make sure we never pass None to the ctor.
	if not self.mFileName:
		self.title = ""

	if self.mFileName != "":
		c.fileCommands.save(self.mFileName)
		c.setChanged(false)
		return "break" # inhibit further command processing

	self.mFileName = tkFileDialog.asksaveasfilename(
		initialfile = self.mFileName,
		title="Save",
		filetypes=[("Leo files", "*.leo")],
		defaultextension="leo")

	if len(self.mFileName) &gt; 0:
		self.mFileName = ensure_extension(self.mFileName, ".leo")
		self.title = self.mFileName
		self.top.title(self.mFileName)
		c.fileCommands.save(self.mFileName)
	return "break" # inhibit further command processing</t>
<t tx="T609">def OnSaveAs(self,event=None):

	# Make sure we never pass None to the ctor.
	if not self.mFileName:
		self.title = ""
		
	self.mFileName = tkFileDialog.asksaveasfilename(
		initialfile = self.mFileName,
		title="Save As",
		filetypes=[("Leo files", "*.leo")],
		defaultextension="leo")

	if len(self.mFileName) &gt; 0:
		self.mFileName = ensure_extension(self.mFileName, ".leo")
		self.title = self.mFileName
		self.top.title(self.mFileName)
		self.commands.fileCommands.saveAs(self.mFileName)
	return "break" # inhibit further command processing</t>
<t tx="T610">def OnSaveTo(self,event=None):

	# Make sure we never pass None to the ctor.
	if not self.mFileName:
		self.title = ""

	# set local fileName, _not_ self.mFileName
	fileName = tkFileDialog.asksaveasfilename(
		initialfile = self.mFileName,
		title="Save To",
		filetypes=[("Leo files", "*.leo")],
		defaultextension="leo")

	if len(fileName) &gt; 0:
		fileName = ensure_extension(fileName, ".leo")
		self.commands.fileCommands.saveTo(fileName)
	return "break" # inhibit further command processing</t>
<t tx="T611"></t>
<t tx="T612">def OnReadAtFileNodes (self,event=None):

	self.commands.fileCommands.readAtFileNodes()
	return "break" # inhibit further command processing</t>
<t tx="T613">def OnWriteOutlineOnly (self,event=None):

	self.commands.fileCommands.writeOutlineOnly()
	return "break" # inhibit further command processing</t>
<t tx="T614">def OnWriteAtFileNodes (self,event=None):

	self.commands.fileCommands.writeAtFileNodes()
	return "break" # inhibit further command processing</t>
<t tx="T615"></t>
<t tx="T616">def OnTangleAll(self,event=None):

	self.commands.tangleCommands.tangleAll()
	return "break" # inhibit further command processing</t>
<t tx="T617">def OnTangleMarked(self,event=None):

	self.commands.tangleCommands.tangleMarked()
	return "break" # inhibit further command processing</t>
<t tx="T618">def OnTangle (self,event=None):

	self.commands.tangleCommands.tangle()
	return "break" # inhibit further command processing</t>
<t tx="T619"></t>
<t tx="T620">def OnUntangleAll(self,event=None):

	self.commands.tangleCommands.untangleAll()
	return "break" # inhibit further command processing</t>
<t tx="T621">def OnUntangleMarked(selft):

	self.commands.tangleCommands.untangleMarked()
	return "break" # inhibit further command processing</t>
<t tx="T622">def OnUntangle(self, event):

	self.commands.tangleCommands.untangle()
	return "break" # inhibit further command processing</t>
<t tx="T623"></t>
<t tx="T624">def OnImportFiles(self,event=None):

	self.notYet("Import Files")
	return "break" # inhibit further command processing

	d = wxFileDialog (
		NULL, "Import Files",
		"", # default directory
		"", # default file
		"*.*", # wildcard
		wxOPEN | wxMULTIPLE | wxFILE_MUST_EXIST,  # style of dialog.
		wxDefaultPosition)

	if d.ShowModal() == wxID_OK:
		paths = d.GetPaths()
		self.commands.importCommands.ImportFilesCommand(paths)

	return "break" # inhibit further command processing</t>
<t tx="T625">def OnImportCWEBFiles(self,event=None):

	self.notYet("Import CWEB Files")
	return "break" # inhibit further command processing

	d = wxFileDialog (
		None, "Import CWEB Files",
		"", # default directory
		"", # default file
		"*.*", # wildcard
		wxOPEN | wxMULTIPLE | wxFILE_MUST_EXIST, wxDefaultPosition)

	if d.ShowModal() == wxID_OK:
		paths = d.GetPaths()
		self.commands.importCommands.CWEBToOutlineCommand (paths)

	return "break" # inhibit further command processing</t>
<t tx="T626">def OnImportNowebFiles(self,event=None):

	self.notYet("Import Noweb Files")
	return "break" # inhibit further command processing</t>
<t tx="T627">def OnImportMoreText(self,event=None):

	self.notYet("Import MORE Text")
	return "break" # inhibit further command processing

	d = wxFileDialog (
		None, "Import MORE Text",
		"", # default directory
		"", # default file
		"*.*", # wildcard
		wxOPEN | wxFILE_MUST_EXIST, wxDefaultPosition)

	if d.ShowModal() == wxID_OK:
		paths = d.GetPaths()
		self.commands.importCommands.importMoreText(paths)
	return "break" # inhibit further command processing</t>
<t tx="T628">def OnOutlineToCWEB(self,event=None):

	self.notYet("Outline To CWEB")
	return "break" # inhibit further command processing</t>
<t tx="T629">def OnOutlineToNoweb(self,event=None):

	self.notYet("Outline To Noweb")
	return "break" # inhibit further command processing</t>
<t tx="T630">def OnExportMoreText(self,event=None):

	self.notYet("Export MORE Text")
	return "break" # inhibit further command processing</t>
<t tx="T631">def OnFlattenOutline(self,event=None):

	self.notYet("Flatten Outline")
	return "break" # inhibit further command processing

	d = wxFileDialog (
		None, "Flatten Outline",
		"", # default directory
		"flat.txt", # default file
		"*.*", # wildcard
		wxSAVE | wxOVERWRITE_PROMPT, wxDefaultPosition)

	if d.ShowModal() == wxID_OK:
		paths = d.GetPaths()
		self.commands.importCommands.flattenOutline(paths)
	return "break" # inhibit further command processing</t>
<t tx="T632"></t>
<t tx="T633"></t>
<t tx="T634">def OnUndo(self,event=None):

	self.notYet("Undo")
	return "break" # inhibit further command processing

	w = FindFocus()
	# FindFocus seems to be a bit flakey, so use it only when absolutely needed.

	if w == self.tree:
		self.commands.undo()
	elif wxPlatform == '__WXGTK__':
		if self.body and self.body.CanUndo():
			self.body.Undo()
	return "break" # inhibit further command processing</t>
<t tx="T635">def OnRedo(self,event=None):

	self.notYet("Redo")
	return "break" # inhibit further command processing

	# The tree control does not support redo.
	if wxPlatform == '__WXGTK__':
		if self.body and self.body.CanRedo():
			self.body.Redo()
	return "break" # inhibit further command processing</t>
<t tx="T636">def OnEditHeadline(self,event=None):

	tree = self.commands.tree
	tree.editLabel(tree.currentVnode)
	return "break" # inhibit further command processing</t>
<t tx="T637">def OnFontPanel(self,event=None):

	self.notYet("Font Panel")
	return "break" # inhibit further command processing

	data = SetInitialFont(self.body.GetFont())
	data.SetColour(self.body.GetForegroundColour())

	d = wxFontDialog (self, data)
	if wxPlatform != "__WXGTK__": # Causes problems on GTK+.
		dialog.CentreOnScreen()

	if d.ShowModal() != wxID_OK:
		return "break" # inhibit further command processing
	retData = d.GetFontData()
	font = retData.GetChosenFont()
	color = retData.GetColour()

	# On Linux, SetFont apparently clears the text control's text string!
	if wxPlatform == "__WXGTK__":
		contents = self.body.GetValue()
		self.body.SetFont ( font )
		self.body.SetForegroundColour(color)
		self.body.SetValue(contents)
	else:
		self.body.SetFont ( font )
		self.body.SetForegroundColour(color)

	self.Refresh()
	return "break" # inhibit further command processing</t>
<t tx="T638">def OnSyntaxColoring(self,event=None):

	self.notYet("Syntax Coloring")
	return "break" # inhibit further command processing</t>
<t tx="T639">def OnPreferences(self,event=None):

	frame = app().prefsFrame
	frame.top.deiconify()
	frame.top.lift()
	return "break" # inhibit further command processing</t>
<t tx="T640"></t>
<t tx="T641">def OnConvertBlanks(self,event=None):

	self.commands.convertBlanks()
	return "break" # inhibit further command processing</t>
<t tx="T642">def OnDedent (self,event=None):

	self.commands.dedentBody()
	return "break" # inhibit further command processing</t>
<t tx="T643">def OnExtract(self,event=None):

	self.commands.extract()
	return "break" # inhibit further command processing</t>
<t tx="T644">def OnExtractNames(self,event=None):

	self.commands.extractSectionNames()
	return "break" # inhibit further command processing</t>
<t tx="T645">def OnExtractSection(self,event=None):

	self.commands.extractSection()
	return "break" # inhibit further command processing</t>
<t tx="T646">def OnIndent(self,event=None):

	self.commands.indentBody()
	return "break" # inhibit further command processing</t>
<t tx="T647"></t>
<t tx="T648">def OnFindPanel(self,event=None):

	find = app().findFrame
	find.top.deiconify()
	find.find_text.focus_set()
	find.commands = self
	return "break" # inhibit further command processing</t>
<t tx="T649">def OnFindNext(self,event=None):

	c = self.commands
	app().findFrame.findNextCommand(c)
	return "break" # inhibit further command processing</t>
<t tx="T650">def OnFindPrevious(self,event=None):

	c = self.commands
	app().findFrame.findPreviousCommand(c)
	return "break" # inhibit further command processing</t>
<t tx="T651">def OnReplace(self,event=None):

	c = self.commands
	app().findFrame.changeCommand(c)
	return "break" # inhibit further command processing</t>
<t tx="T652">def OnReplaceThenFind(self,event=None):

	c = self.commands
	app().findFrame.changeThenFindCommand(c)
	return "break" # inhibit further command processing</t>
<t tx="T653"></t>
<t tx="T654"></t>
<t tx="T655">def OnCutNode(self,event=None):

	self.commands.cutOutline()
	return "break" # inhibit further command processing</t>
<t tx="T656">def OnCopyNode(self,event=None):

	self.commands.copyOutline()
	return "break" # inhibit further command processing</t>
<t tx="T657">def OnPasteNode(self,event=None):

	self.commands.pasteOutline()
	return "break" # inhibit further command processing</t>
<t tx="T658">def OnDeleteNode(self,event=None):

	self.commands.deleteHeadline()
	return "break" # inhibit further command processing</t>
<t tx="T659">def OnInsertNode(self,event=None):

	self.commands.insertHeadline()
	return "break" # inhibit further command processing</t>
<t tx="T660">def OnCloneNode(self,event=None):

	self.commands.clone()
	return "break" # inhibit further command processing</t>
<t tx="T661">def OnSortChildren(self,event=None):

	self.commands.sortChildren()
	return "break" # inhibit further command processing
	
def OnSortSiblings(self,event=None):

	self.commands.sortSiblings()
	return "break" # inhibit further command processing</t>
<t tx="T662"></t>
<t tx="T663">def OnContractParent(self,event=None):

	self.commands.contractParent()
	return "break" # inhibit further command processing</t>
<t tx="T664">def OnExpandAll(self,event=None):

	self.commands.expandAllHeadlines()
	return "break" # inhibit further command processing</t>
<t tx="T665">def OnExpandAllChildren(self,event=None):

	self.commands.expandAllSubheads()
	return "break" # inhibit further command processing</t>
<t tx="T666">def OnExpandChildren(self,event=None):

	self.commands.expandSubheads()
	return "break" # inhibit further command processing</t>
<t tx="T667">def OnContractAll(self,event=None):

	self.commands.contractAllHeadlines()
	return "break" # inhibit further command processing</t>
<t tx="T668">def OnContractAllChildren(self,event=None):

	self.commands.contractAllSubheads()
	return "break" # inhibit further command processing</t>
<t tx="T669">def OnContractChildren(self,event=None):

	self.commands.contractSubheads()
	return "break" # inhibit further command processing</t>
<t tx="T670">def OnExpandNextLevel(self,event=None):

	self.commands.expandNextLevel()
	return "break" # inhibit further command processing</t>
<t tx="T671">def OnExpandToLevel1(self,event=None):

	self.commands.expandLevel1()
	return "break" # inhibit further command processing</t>
<t tx="T672">def OnExpandToLevel2(self,event=None):

	self.commands.expandLevel2()
	return "break" # inhibit further command processing</t>
<t tx="T673">def OnExpandToLevel3(self,event=None):

	self.commands.expandLevel3()
	return "break" # inhibit further command processing</t>
<t tx="T674">def OnExpandToLevel4(self,event=None):

	self.commands.expandLevel4()
	return "break" # inhibit further command processing</t>
<t tx="T675">def OnExpandToLevel5(self,event=None):

	self.commands.expandLevel5()
	return "break" # inhibit further command processing</t>
<t tx="T676">def OnExpandToLevel6(self,event=None):

	self.commands.expandLevel6()
	return "break" # inhibit further command processing</t>
<t tx="T677">def OnExpandToLevel7(self,event=None):

	self.commands.expandLevel7()
	return "break" # inhibit further command processing</t>
<t tx="T678">def OnExpandToLevel8(self,event=None):

	self.commands.expandLevel8()
	return "break" # inhibit further command processing</t>
<t tx="T679">def OnExpandToLevel9(self,event=None):

	self.commands.expandLevel9()
	return "break" # inhibit further command processing</t>
<t tx="T680"></t>
<t tx="T681">def OnMoveLeft(self,event=None):

	self.commands.moveOutlineLeft()
	return "break" # inhibit further command processing</t>
<t tx="T682">def OnMoveRight(self,event=None):

	self.commands.moveOutlineRight()
	return "break" # inhibit further command processing</t>
<t tx="T683">def OnMoveUp(self,event=None):

	self.commands.moveOutlineUp()
	return "break" # inhibit further command processing</t>
<t tx="T684">def OnPromote(self,event=None):

	self.commands.promote()
	return "break" # inhibit further command processing</t>
<t tx="T685">def OnDemote(self,event=None):

	self.commands.demote()
	return "break" # inhibit further command processing</t>
<t tx="T686">def OnGoPrevVisible(self,event=None):

	self.commands.selectVisBack()
	return "break" # inhibit further command processing</t>
<t tx="T687">def OnGoNextVisible(self,event=None):

	self.commands.selectVisNext()
	return "break" # inhibit further command processing</t>
<t tx="T688">def OnGoBack(self,event=None):

	self.commands.selectThreadBack()
	return "break" # inhibit further command processing</t>
<t tx="T689">def OnGoNext(self,event=None):

	self.commands.selectThreadNext()
	return "break" # inhibit further command processing</t>
<t tx="T690"></t>
<t tx="T691">def OnMark(self,event=None):

	self.commands.markHeadline()
	return "break" # inhibit further command processing</t>
<t tx="T692">def OnMarkSubheads(self,event=None):

	self.commands.markSubheads()
	return "break" # inhibit further command processing</t>
<t tx="T693">def OnMarkChangedItems(self,event=None):

	self.commands.markChangedHeadlines()
	return "break" # inhibit further command processing</t>
<t tx="T694">def OnMarkChangedRoots(self,event=None):

	self.commands.markChangedRoots()
	return "break" # inhibit further command processing</t>
<t tx="T695">def OnUnmarkAll(self,event=None):

	self.commands.unmarkAll()
	return "break" # inhibit further command processing</t>
<t tx="T696">def OnGoToNextMarked(self,event=None):

	self.commands.goToNextMarkedHeadline()
	return "break" # inhibit further command processing</t>
<t tx="T697">def OnGoToNextChanged(self,event=None):

	self.commands.goToNextDirtyHeadline()
	return "break" # inhibit further command processing</t>
<t tx="T698"></t>
<t tx="T699">def OnEqualSizedPanes(self,event=None):

	self.resizePanesToRatio(0.5)
	return "break" # inhibit further command processing</t>
<t tx="T700">def OnToggleSplitDirection(self,event=None):

	self.notYet("Toggle Split Direction")
	return "break" # inhibit further command processing

	self.splitVerticalFlag = not self.splitVerticalFlag
	self.resizePanesToRatio(0.5)
	self.body.focus_set()
	return "break" # inhibit further command processing</t>
<t tx="T701">def OnCascade(self,event=None):

	self.notYet("Cascade")
	return "break" # inhibit further command processing

	p = wxPoint(10,10)
	list = app().windowList
	for frame in list:
		frame.Move(p)
		p.x += 30
		p.y += 30
		if p.x &gt; 200:
			p.x = 10
			p.y = 40
	return "break" # inhibit further command processing</t>
<t tx="T702">def OnMinimizeAll(self,event=None):

	self.minimize(app().prefsFrame)
	self.minimize(app().findFrame)
	self.minimize(app().pythonFrame)
	for frame in app().windowList:
		self.minimize(frame)
	return "break" # inhibit further command processing
		
def minimize(self, frame):

	if frame and frame.top.state() == "normal":
		frame.top.iconify()</t>
<t tx="T703">def OnOpenPythonWindow(self,event=None):

	try:
		from leoApp import *
		from leoGlobals import *
		from leoUtils import *
		import idle
		if app().idle_imported:
			reload(idle)
		app().idle_imported = true
	except:
		es("Can not import idle")
		es("Please add \Python21\Tools\idle to sys.paths")
	return "break" # inhibit further command processing</t>
<t tx="T704">def OnRecentWindows(self,event=None):

	self.notYet("Recent Windows")
	return "break" # inhibit further command processing</t>
<t tx="T705"></t>
<t tx="T706">def OnAbout(self,event=None):

	import tkMessageBox

	tkMessageBox.showinfo(
		"About Leo",
		"Leo in Python/Tk\n" +
		"Version 1.0, February 10, 2002\n\n" +

		"Copyright 1999-2002 by Edward K. Ream\n" +
		"All Rights Reserved\n" +
		"Leo is distributed under the Python License")

	return "break" # inhibit further command processing</t>
<t tx="T707">def OnLeoDocumentation (self,event=None):

	dir = app().loadDir
	fileName = os.path.join(dir, "LeoDocs.leo")
	try:
		self.OpenWithFileName(fileName)
	except:
		es("LeoDocs.leo not found")
	return "break" # inhibit further command processing</t>
<t tx="T708">@ignore</t>
<t tx="T709">@ This section contains scripts and other files for creating, testing and distributing leo.py.  leo.py itself does not use any of the code in these scripts, nor do these scripts use any code in leo.py.
@c

# To convert from C to Python, do the following from Leo's Python window:
import c2py
c2py.convertCurrentTree()

# To convert from Leo1 to Leo2, do the following from Leo's Python window:
import c2py
c2py.leo1to2()

@  To create a source distribution using Python's distutils:

On windows: do the following from inside a console window:
	cd c:\prog\LeoPy
	sdist

On Linux do the following:
	cd LeoPy
	python setup.py sdist --force-manifest --formats=gztar,zip</t>
<t tx="T710">@silent

@ The following nodes use @root and @silent so that no extraneous lines get generated.

The go.bat batch loads leo.py and opens LeoPy.leo by default, so to work on leo.py I just open a Windows console window and type go.  Add LeoPy folder to your PATH environment variable, or put go.bat in c:\Windows.

The sdist.bat batch file creates a source distribution using distutils and setup.py.

The bdist.bat batch file creates a binary distribution.  It does not work yet.

The manifest.in file contains a list of files to be included in the distutils distribution.</t>
<t tx="T711">@root go.bat
cd c:\prog\LeoPy
c:\python21\python c:\prog\LeoPy\openLeo.py</t>
<t tx="T712">@root "help.bat"
rem print help message re setup.py
c:\python21\python setup.py sdist --help</t>
<t tx="T713">@root "sdist.bat"
rem creates source distribution using setup.py
rem cd c:\prog\LeoPy
rem --formats=gztar,zip
c:\python21\python setup.py sdist --force-manifest</t>
<t tx="T714">@ignore
@root "bdist.bat"
rem Create binary distribution using information in setup.py
rem cd c:\prog\LeoPy
c:\python21\python setup.py bdist --formats=wininst</t>
<t tx="T715"># The manifest template: specifies all files to be included in the distribution
@root "manifest.in"

include LeoPy.leo
include LeoDocs.leo
include leo*.py
include readme*.*
include Icons/*.*
include leo.rc
include leo.res
include sdist.bat
include manifest.in</t>
<t tx="T716">@first #! /usr/bin/env python

@ When using c2py as a script to translate entire files, use convertCFileToPython().  When using c2py within Leo, use convertCurrentTree().

Please set user data in the &lt;&lt; specifying user types &gt;&gt; section.
@c

&lt;&lt; what c2py does &gt;&gt;
&lt;&lt; theory of operation &gt;&gt;
import string
&lt;&lt; specifying user types &gt;&gt;
true = 1 ; false = None
tabWidth = 4 # how many blanks in a tab.
printFlag = false
doLeoTranslations = true ; dontDoLeoTranslations = false
&lt;&lt; define testData &gt;&gt;
@others

gClassName = "" # The class name for the present function.  Used to modify ivars.
gIvars = [] # List of ivars to be converted to self.ivar

def test():
	global printFlag ; printFlag = true
	for s in testData:
		convertCStringToPython(s, doLeoTranslations)
		
def go():
	test()

if __name__ == "__main__":
	speedTest(2)</t>
<t tx="T717">@ c2py converts C or C++ text into python text.  The conversion is not complete.  Nevertheless, c2py eliminates much of the tedious text manipulation that would otherwise be required.

The following is a list of the translations performed by c2py.  These transformations are controlled by convertCodeList().

I.  Prepass

These translations before removing all curly braces.

Suppose we are translating:

	aTypeSpec aClass::aMethod(t1 v1,...,tn vn)
	{
		body
	}

1. Translates the function prototype, i.e., translates:

	aTypeSpec aClass::aMethod(t1 v1,...,tn vn)
to:
	def aMethod(v1,...vn):

As a special case, c2py translates:

	aTypeSpec aClass::aClass(t1 v1,...,tn vn)
to:
	aClass.__init__(t1 v1,...,tn vn)

Yes, I know, aClass.__init__ isn't proper Python, but retaining the class name is useful.

2. Let t denote any member of typeList or classList.

	a) Removes all casts of the form (t) or (t*) or (t**), etc.
	b) Converts t x, t *x, t **x, etc. to x.
	c) Converts x = new t(...) to x = t(...)
	d) For all i in ivarsDict[aClass] converts this -&gt; i to self.i
	e) For all i in ivarsDict[aClass] converts i to self.i

3. Converts &lt; &lt; x &gt; &gt; = to @c.  This Leo-specific translation is not done when translating files.

II.  Main Pass

This pass does the following simple translations everywhere except in comments and strings.

Changes all -&gt; to .
Changes all this.self to self (This corrects problems during the prepass.)
Removes all curly braces
Changes all #if to if
Changes all else if to elif
Changes all #else to else:
Changes all else to else:
Removes all #endif
Changes all &amp;&amp; to and
Changes all || to or
Changes all TRUE to true
Changes all FALSE to false
Changes all NULL to None
Changes all this to self
Changes all @code to @c.  This Leo-specific translation is not done when translating files.

III.  Complex Pass

This pass attempts more complex translations.

Converts if ( x ) to if x:
Converts elif ( x ) to elif x:
Converts while ( x ) to while x:
Converts for ( x ; y ; z ) to for x SEMI y SEMI z:

remove all semicolons.

IV.  Final Pass

This pass completes the translation.

Removes all semicolons.
Removes @c if it starts the text.  This Leo-specific translation is not done when translating files.
Removes all blank lines.
Removes excess whitespace from all lines, leaving leading whitespace unchanged.
Replaces C/C++ comments by Python comments.
Removes trailing whitespace from all lines.
</t>
<t tx="T718">@ Strategy and Performance

c2py is straightforward.  The speed of c2py is unimportant.  We don't care about the memory used because we translate only small pieces of text at a time.

We can do body[i:j] = x, regardless of len(x).  We can also do del body[i:j] to delete characters.

We scan repeatedly through the text.  Using many passes greatly simplifies the code and does not slow down c2py significantly.

No scans are done within strings or comments.  The idiom to handle such scans is the following:

def someScan(body):
	i = 0
	while i &lt; body(len):
		if isStringOrComment(body,i):
			i = skipStringOrComment(body,i)
		elif &lt;&lt; found what we are looking for ? &gt;&gt; :
			&lt;&lt; convert what we are looking for, setting i &gt;&gt;
		else: i += 1

That's about all there is to it.  The code was remarkably easy to write and seems clear to me.
</t>
<t tx="T719">@ Please change the following lists so they contain the types and classes used by your program.

c2py removes all type defini
correctly; it converts
	new aType(...)
to
	aType(...)
@c

classList = [
	"vnode", "tnode", "Commands",
	"wxString", "wxTreeCtrl", "wxTextCtrl", "wxSplitterWindow" ]
	
typeList = ["char", "void", "short", "long", "int", "double", "float"]

@ Please change ivarsDict so it represents the instance variables (ivars) used by your program's classes.

ivarsDict is a dictiona
ivar i of class c to self.i.  It also translates this-&gt;i to self.i.
@c
	
ivarsDict = {
	"atFile": [ "mCommands", "mErrors", "mStructureErrors",
		"mTargetFileName", "mOutputFileName", "mOutputStream",
		"mStartSentinelComment", "mEndSentinelComment", "mRoot"],

	"vnode": ["mCommands", "mJoinList", "mIconVal", "mTreeID", "mT", "mStatusBits"],

	"tnode": ["mBodyString", "mBodyRTF", "mJoinHead", "mStatusBits", "mFileIndex",
		"mSelectionStart", "mSelectionLength", "mCloneIndex"],
		
	"LeoFrame": ["mNextFrame", "mPrevFrame", "mCommands"],

	"Commands": [
		# public
		"mCurrentVnode", "mLeoFrame", "mInhibitOnTreeChanged", "mMaxTnodeIndex",
		"mTreeCtrl", "mBodyCtrl", "mFirstWindowAndNeverSaved",
		#private
		"mTabWidth", "mChanged", "mOutlineExpansionLevel", "mUsingClipboard",
		"mFileName", "mMemoryInputStream", "mMemoryOutputStream", "mFileInputStream",
		"mInputFile", "mFileOutputStream", "mFileSize", "mTopVnode", "mTagList",
		"mMaxVnodeTag",
		"mUndoType", "mUndoVnode", "mUndoParent", "mUndoBack", "mUndoN",
		"mUndoDVnodes", "mUndoLastChild", "mUndoablyDeletedVnode" ]}</t>
<t tx="T720">testData = [ "\n@doc\n\
This is a doc part: format, whilest, {};-&gt;.\n\
&lt;&lt;\
section def&gt;&gt;=\n\
LeoFrame::LeoFrame(vnode *v, char *s, int i)\n\
{\n\
	// test ; {} /* */.\n\
	#if 0 //comment\n\
		if(gLeoFrameList)gLeoFrameList -&gt; mPrevFrame = this ;\n\
		else\n\
			this -&gt; mNextFrame = gLeoFrameList ;\n\
	#else\n\
		\n\
		vnode *v = new vnode(a,b);\n\
		Commands *commander = (Commands) NULL ; // after cast\n\
		this -&gt; mPrevFrame = NULL ;\n\
	#endif\n\
	if (a==b)\n\
		a = 2;\n\
	else if (a ==c)\n\
		a = 3;\n\
	else return; \n\
	/* Block comment test:\n\
		if(2):while(1): end.*/\n\
	for(int i = 1; i &lt; limit; ++i){\n\
		mVisible = FALSE ;\n\
		mOnTop = TRUE ;\n\
	}\n\
	// trailing ws.	 \n\
	mCommands = new Commands(this, mTreeCtrl, mTextCtrl) ;\n\
	gActiveFrame = this ;\n\
}\n\
	", "&lt;&lt;" +
"vnode methods &gt;&gt;=\n\
\n\
void vnode::OnCopyNode(wxCommandEvent&amp; WXUNUSED(event))\n\
{\n\
	mCommands -&gt; copyOutline();\n\
}\n\
\n@doc\n\
another doc part if, then, else, -&gt; \n&lt;&lt;" +
"vnode methods &gt;&gt;=\n\
void vnode::OnPasteNode(wxCommandEvent&amp; WXUNUSED(event))\n\
{\n\
	mCommands -&gt; pasteOutline();\n\
}\n" ]</t>
<t tx="T721">def speedTest(passes):

	import time
	file = r"c:\prog\LeoPy\LeoPy.leo"
	f=open(file)
	if not f:
		print "not found: ", file
		return
	s=f.read()
	f.close()
	print "file:", file, " size:", len(s), " passes:", passes
	print "speedTest start"
	time1 = time.clock()
	p = passes
	while p &gt; 0:
		n = len(s) ; i = 0 ; lines = 0
		while -1 &lt; i &lt; n:
			if s[i] == '\n':
				lines += 1 ; i += 1
			else:
				i = string.find(s,'\n',i) # _much_ faster than list-based-find.
			continue
			# match is about 9 times slower than simple test.
			if s[i]=='\n': # match(s,i,'\n'): # 
				i += 1
			else:
				i += 1
		p -= 1
	time2 = time.clock()
	print "lines:", lines
	print "speedTest done:"
	print "elapsed time:", time2-time1
	print "time/pass:", (time2-time1)/passes</t>
<t tx="T722">def leo1to2():

	import leo
	c=leo.top()
	v=c.currentVnode()
	convertLeo1to2(v,c)
</t>
<t tx="T723">def convertLeo1to2(v,c):

	after=v.nodeAfterTree()
	while v and v != after:
		s=v.bodyString()
		print "converting:", v.headString()
		s=convertStringLeo1to2(s)
		v.setBodyStringOrPane(s)
		v=v.threadNext()

	c.Repaint() # for backward compatibility
	print "end of leo1to2"</t>
<t tx="T724">def convertStringLeo1to2 (s):

	# print "convertStringLeo1to2:start\n", s
	codeList = stringToList(s) ; outputList = []
	i = 0
	while i &lt; len(codeList):
		j = skipCodePart(codeList,i)
		if j &gt; i:
			code = codeList[i:j]
			convertCodeList1to2(code)
			i = j
			#print "-----code:", listToString(code)
			for item in code:
				outputList.append(item)
		j = skipDocPart(codeList,i)
		if j &gt; i:
			doc = codeList[i:j]
			convertDocList(doc) # same as in c2py
			#print "-----doc:", listToString(doc)
			i = j
			for item in doc:
				outputList.append(item)
	
	result = listToString(outputList)
	global printFlag
	if printFlag: print "-----:\n", result
	return result</t>
<t tx="T725">@ We do _not_ replace @root by @file or insert @others as needed.  Inserting @others can be done easily enough by hand, and may take more global knowledge than we can reasonably expect to have.
@c

def convertCodeList1to2(list):

	if 0: # There isn't much reason to do this.
		removeAtRoot(list)
	safeReplace(list, "@code", "@c")
	replaceSectionDefs(list)
	removeLeadingAtCode(list)
</t>
<t tx="T726">@ We separate the processing into two parts, 1) a leo-aware driver that iterates over @file trees and 2) a text-based part that processes one or more files or strings.
</t>
<t tx="T727">def convertCurrentTree():

	import leo
	c=leo.top()
	v=c.tree.currentVnode
	c2py.convertLeoTree(v,c)</t>
<t tx="T728">def convertLeoTree(v,c):

	after=v.nodeAfterTree()
	while v and v != after:
		s=v.bodyString()
		print "converting:", v.headString()
		s=convertCStringToPython(s, doLeoTranslations )
		v.setBodyStringOrPane(s)
		v=v.threadNext()
	c.Repaint() # for backward compatibility.
	print "end of c2py"</t>
<t tx="T729">def convertCFileToPython(file):

	f=open(file, 'r')
	if not f: return
	s = f.read()
	f.close();
	f=open(file + ".py", 'w')
	if not f: return
	s = convertCStringToPython(s, dontDoLeoTranslations )
	f.write(s)
	f.close()</t>
<t tx="T730">def convertCStringToPython(s, leoFlag):

	# print "convertCStringToPython:start\n", s
	firstPart = true
	codeList = stringToList(s)
	
	if not leoFlag:
		convertCodeList(codeList, firstPart, dontDoLeoTranslations)
		return listToString(codeList)

	outputList = []
	i = 0
	while i &lt; len(codeList):
		j = skipCodePart(codeList,i)
		if j &gt; i:
			code = codeList[i:j]
			convertCodeList(code, firstPart, doLeoTranslations)
			i = j
			#print "-----code:", listToString(code)
			for item in code:
				outputList.append(item)
		firstPart = false # don't remove @c from here on.
		j = skipDocPart(codeList,i)
		if j &gt; i:
			doc = codeList[i:j]
			convertDocList(doc)
			#print "-----doc:", listToString(doc)
			i = j
			for item in doc:
				outputList.append(item)
	
	result = listToString(outputList)
	global printFlag
	if printFlag: print "-----:\n", result
	return result</t>
<t tx="T731">def convertCodeList(list, firstPart, leoFlag):
	#first
	replace(list, "\r", None)
	convertLeadingBlanks(list)
	if leoFlag:
		replaceSectionDefs(list)
	mungeAllFunctions(list)
	#next
	safeReplace(list, " -&gt; ", '.')
	safeReplace(list, "-&gt;", '.')
	safeReplace(list, " . ", '.')
	safeReplace(list, "this.self", "self")
	safeReplace(list, "{", None)
	safeReplace(list, "}", None)
	safeReplace(list, "#if", "if")
	safeReplace(list, "#else", "else")
	safeReplace(list, "#endif", None)
	safeReplace(list, "else if", "elif")
	safeReplace(list, "else", "else:")
	safeReplace(list, "&amp;&amp;", "and")
	safeReplace(list, "||", "or")
	safeReplace(list, "TRUE", "true")
	safeReplace(list, "FALSE", "false")
	safeReplace(list, "NULL", "None")
	safeReplace(list, "this", "self")
	safeReplace(list, "try", "try:")
	safeReplace(list, "catch", "except:")
	if leoFlag:
		safeReplace(list, "@code", "@c")
	#next
	handleAllKeywords(list)
	# after processing for keywords
	removeSemicolonsAtEndOfLines(list)
	#last
	if firstPart and leoFlag: removeLeadingAtCode(list)
	removeBlankLines(list)
	removeExcessWs(list)
	# your taste may vary: in Python I don't like extra whitespace
	safeReplace(list, " :", ":") 
	safeReplace(list, ", ", ",")
	safeReplace(list, " ,", ",")
	safeReplace(list, " (", "(")
	safeReplace(list, "( ", "(")
	safeReplace(list, " )", ")")
	safeReplace(list, ") ", ")")
	replaceComments(list) # should follow all calls to safeReplace
	removeTrailingWs(list)
	safeReplace(list, "\t ", "\t") # happens when deleting declarations.</t>
<t tx="T732">def convertDocList(docList):

	# print "convertDocList:", `docList`
	if matchWord(docList, 0, "@doc"):
		i = skipWs(docList, 4)
		if match(docList, i, "\n"):
			i += 1
		docList[0:i] = list("@ ")</t>
<t tx="T733">def skipDocPart(list, i):
	
	# print "skipDocPart", `i`
	while i &lt; len(list):
		if matchWord(list, i, "@code") or matchWord(list, i, "@c"):
			break
		elif isSectionDef(list,i):
			break
		else: i = skipPastLine(list, i)
	return i</t>
<t tx="T734">def skipCodePart(codeList, i):
	
	# print "skipCodePart", `i`
	if matchWord(codeList, i, "@doc") or matchWord(codeList, i, "@"):
		return i
	while i &lt; len(codeList):
		if match(codeList, i, "//"):
			i = skipPastLine(codeList,i)
		elif match(codeList, i, "/*"):
			i = skipCBlockComment(codeList,i)
		elif match(codeList, i, '"') or match(codeList, i, "'"):
			i = skipString(codeList,i)
		elif match(codeList, i, "\n"):
			i += 1
			if matchWord(codeList, i, "@doc") or matchWord(codeList, i, "@"):
				break
		else: i += 1
	return i</t>
<t tx="T735">def convertLeadingBlanks(list):

	global tabWidth
	if tabWidth &lt; 2: return
	i = 0
	while i &lt; len(list):
		n = 0
		while i &lt; len(list) and list[i] == ' ':
			n += 1 ; i += 1
			if n == tabWidth:
				list[i-tabWidth:i] = ['\t']
				i = i - tabWidth + 1
				n = 0
		i = skipPastLine(list, i)</t>
<t tx="T736">def findInList(list, i, findStringOrList):

	findList = stringToList(findStringOrList)
	
	while i &lt; len(list):
		if match(list, i, findList): return i
		else: i += 1
	return -1</t>
<t tx="T737">def findInCode(codeList, i, findStringOrList):

	findList = stringToList(findStringOrList)
	
	while i &lt; len(codeList):
		if isStringOrComment(codeList,i):
			i = skipStringOrComment(codeList,i)
		elif match(codeList, i, findList):
			return i
		else: i += 1
	return -1</t>
<t tx="T738"># We scan for a '{' at the top level that is preceeded by ')'
# @code and &lt; &lt; x &gt; &gt; = have been replaced by @c
def mungeAllFunctions(codeList):

	prevSemi = 0 # Previous semicolon: header contains all previous text
	i = 0
	firstOpen = None
	while i &lt; len(codeList):
		if isStringOrComment(codeList,i):
			i = skipStringOrComment(codeList,i)
			prevSemi = i
		elif match(codeList, i, '('):
			if not firstOpen:
				firstOpen = i
			i += 1
		elif match(codeList, i, '#'):
			i = skipPastLine(codeList, i)
			prevSemi = i
		elif match(codeList, i, ';'):
			i += 1
			prevSemi = i
		elif matchWord(codeList, i, "@code"):
			i += 5
			prevSemi = i # restart the scan
		elif matchWord(codeList, i, "@c"):
			i += 2 ; prevSemi = i # restart the scan
		elif match(codeList, i, "{"):
			i = handlePossibleFunctionHeader(codeList,i,prevSemi,firstOpen)
			prevSemi = i ; firstOpen = None # restart the scan
		else: i += 1</t>
<t tx="T739"># converts function header lines from c++ format to python format.
# That is, converts
# x1..nn w::y ( t1 z1,..tn zn) {
# to
# def y (z1,..zn): {

def handlePossibleFunctionHeader(codeList, i, prevSemi, firstOpen):

	assert(match(codeList,i,"{"))
	prevSemi = skipWsAndNl(codeList, prevSemi)
	close = prevNonWsOrNlChar(codeList, i)
	if close &lt; 0 or codeList[close] != ')':
		return 1 + skipToMatchingBracket(codeList, i)
	if not firstOpen:
		return 1 + skipToMatchingBracket(codeList, i)
	close2 = skipToMatchingBracket(codeList, firstOpen)
	if close2 != close:
		return 1 + skipToMatchingBracket(codeList, i)
	open = firstOpen
	assert(codeList[open]=='(')
	head = codeList[prevSemi:open]
	# do nothing if the head starts with "if", "for" or "while"
	k = skipWs(head,0)
	if k &gt;= len(head) or not head[k] in string.letters:
		return 1 + skipToMatchingBracket(codeList, i)
	kk = skipPastWord(head,k)
	if kk &gt; k:
		headString = listToString(head[k:kk])
		# C keywords that might be followed by '{'
		# print "headString:", headString
		if headString in [ "class", "do", "for", "if", "struct", "switch", "while"]:
			return 1 + skipToMatchingBracket(codeList, i)
	args = codeList[open:close+1]
	k = 1 + skipToMatchingBracket(codeList,i)
	body = codeList[i:k]
	#print "head:", listToString(head)
	#print "args:", listToString(args)
	#print "body:", listToString(body)
	#print "tot: ", listToString(codeList[prevSemi:k])
	head = massageFunctionHead(head)
	args = massageFunctionArgs(args)
	body = massageFunctionBody(body)
	#print "head2:", listToString(head)
	#print "args2:", listToString(args)
	#print "body2:", listToString(body)
	#print "tot2: ", listToString(codeList[prevSemi:k])
	result = []
	for item in head:
		result.append(item)
	for item in args:
		result.append(item)
	for item in body:
		result.append(item)
	codeList[prevSemi:k] = result
	return k</t>
<t tx="T740">def massageFunctionArgs(args):
	global gClassName
	assert(args[0]=='(')
	assert(args[-1]==')')

	result = ['('] ; lastWord = []
	if gClassName:
		for item in list("self,"): result.append(item) #can put extra comma

	i = 1
	while i &lt; len(args):
		i = skipWsAndNl(args, i)
		c = args[i]
		if c in string.letters:
			j = skipPastWord(args,i)
			lastWord = args[i:j]
			i = j
		elif c == ',' or c == ')':
			for item in lastWord:
				result.append(item)
			if lastWord != [] and c == ',':
				result.append(',')
			lastWord = []
			i += 1
		else: i += 1
	if result[-1] == ',':
		del result[-1]
	result.append(')')
	result.append(':')
	# print "new args:", listToString(result)
	return result</t>
<t tx="T741">def massageFunctionHead(head):

	# print "head:", listToString(head)
	result = []
	prevWord = []
	global gClassName ; gClassName = []
	i = 0
	while i &lt; len(head):
		i = skipWsAndNl(head, i)
		if i &lt; len(head) and head[i] in string.letters:
			result = []
			j = skipPastWord(head,i)
			prevWord = head[i:j]
			i = j
			# look for ::word2
			i = skipWs(head,i)
			if match(head,i,"::"):
				# Set the global to the class name.
				gClassName = listToString(prevWord)
				# print "class name:", gClassName
				i = skipWs(head, i+2)
			 	if i &lt; len(head) and (head[i]=='~' or head[i] in string.letters):
					j = skipPastWord(head,i)
					if head[i:j] == prevWord:
						for item in list("__init__"): result.append(item)
					elif head[i]=='~' and head[i+1:j] == prevWord:
						for item in list("__del__"): result.append(item)
					else:
						# for item in "::": result.append(item)
						for item in head[i:j]: result.append(item)
					i = j
			else:
				for item in prevWord:result.append(item)
		else: i += 1
		
	finalResult = list("def ")
	for item in result: finalResult.append(item)
	# print "new head:", listToString(finalResult)
	return finalResult</t>
<t tx="T742">def massageFunctionBody(body):

	body = massageIvars(body)
	body = removeCasts(body)
	body = removeTypeNames(body)
	return body</t>
<t tx="T743">def massageIvars(body):

	if gClassName and ivarsDict.has_key(gClassName):
		ivars = ivarsDict [ gClassName ]
	else:
		ivars = []
	# print "key:ivars=", gClassName, ':', `ivars`

	i = 0
	while i &lt; len(body):
		if isStringOrComment(body,i):
			i = skipStringOrComment(body,i)
		elif body[i] in string.letters:
			j = skipPastWord(body,i)
			word = listToString(body[i:j])
			# print "looking up:", word
			if word in ivars:
				# replace word by self.word
				# print "replacing", word, " by self.", word
				word = "self." + word
				word = list(word)
				body[i:j] = word
				delta = len(word)-(j-i)
				i = j + delta
			else: i = j
		else: i += 1
	return body</t>
<t tx="T744">def removeCasts(body):

	i = 0
	while i &lt; len(body):
		if isStringOrComment(body,i):
			i = skipStringOrComment(body,i)
		elif match(body, i, '('):
			start = i
			i = skipWs(body, i+1)
			if body[i] in string.letters:
				j = skipPastWord(body,i)
				word = listToString(body[i:j])
				i = j
				if word in classList or word in typeList:
					i = skipWs(body, i)
					while match(body,i,'*'):
						i += 1
					i = skipWs(body, i)
					if match(body,i,')'):
						i += 1
						# print "removing cast:", listToString(body[start:i])
						del body[start:i]
						i = start
		else: i += 1
	return body</t>
<t tx="T745"># Do _not_ remove type names when preceeded by new.

def removeTypeNames(body):

	i = 0
	while i &lt; len(body):
		if isStringOrComment(body,i):
			i = skipStringOrComment(body,i)
		elif matchWord(body, i, "new"):
			i = skipPastWord(body,i)
			i = skipWs(body,i)
			# don't remove what follows new.
			if body[i] in string.letters:
				i = skipPastWord(body,i)
		elif body[i] in string.letters:
			j = skipPastWord(body,i)
			word = listToString(body[i:j])
			if word in classList or word in typeList:
				k = skipWs(body, j)
				while match(body,k,'*'):
					k += 1 ; j = k
				# print "Deleting type name:", listToString(body[i:j])
				del body[i:j]
			else:
				i = j
		else: i += 1
	return body</t>
<t tx="T746"># converts if ( x ) to if x:
# converts while ( x ) to while x:
def handleAllKeywords(codeList):

	# print "handAllKeywords:", listToString(codeList)
	i = 0
	while i &lt; len(codeList):
		if isStringOrComment(codeList,i):
			i = skipStringOrComment(codeList,i)
		elif ( matchWord(codeList,i,"if") or
			matchWord(codeList,i,"while") or
			matchWord(codeList,i,"for") or
			matchWord(codeList,i,"elif") ):
			i = handleKeyword(codeList,i)
		else:
			i += 1
	# print "handAllKeywords2:", listToString(codeList)</t>
<t tx="T747">def handleKeyword(codeList,i):

	isFor = false
	if (matchWord(codeList,i,"if")):
		i += 2
	elif (matchWord(codeList,i,"elif")):
		i += 4
	elif (matchWord(codeList,i,"while")):
		i += 5
	elif (matchWord(codeList,i,"for")):
		i += 3
		isFor = true
	else: assert(0)
	# Make sure one space follows the keyword
	k = i
	i = skipWs(codeList,i)
	if k == i:
		c = codeList[i]
		codeList[i:i+1] = [ ' ', c ]
		i += 1
	# Remove '(' and matching ')' and add a ':'
	if codeList[i] == "(":
		j = removeMatchingBrackets(codeList,i)
		if j &gt; i and j &lt; len(codeList):
			c = codeList[j]
			codeList[j:j+1] = [":", " ", c]
			j = j + 2
		return j
	return i</t>
<t tx="T748">def isWs(c):
	return c == ' ' or c == '\t'
	
def isWsOrNl(c):
	return c == ' ' or c == '\t' or c == '\n'</t>
<t tx="T749"># returns the ending index if i points to &lt; &lt; x &gt; &gt; =
def isSectionDef(list, i):

	i = skipWs(list,i)
	if not match(list,i,"&lt;&lt;"): return false
	while i &lt; len(list) and list[i] != '\n':
		if match(list,i,"&gt;&gt;="): return i+3
		else: i += 1
	return false</t>
<t tx="T750">def isStringOrComment(list, i):

	return match(list,i,"'") or match(list,i,'"') or match(list,i,"//") or match(list,i,"/*")</t>
<t tx="T751"># returns true if findList matches starting at codeList[i]

def match (codeList, i, findStringOrList):

	findList = stringToList(findStringOrList)
	n = len(findList)
	j = 0
	while i+j &lt; len(codeList) and j &lt; len(findList):
		if codeList[i+j] != findList[j]:
			return false
		else:
			j += 1
			if j == n:
				return i+j
	return false</t>
<t tx="T752">def matchWord (codeList, i, findStringOrList):

	j = match(codeList,i,findStringOrList)
	if not j:
		return false
	elif j &gt;= len(codeList):
		return true
	else:
		c = codeList[j]
		return not (c in string.letters or c in string.digits or c == '_')</t>
<t tx="T753">def prevNonWsChar(list, i):

	i -= 1
	while i &gt;= 0 and isWs(list[i]):
		i -= 1
	return i

def prevNonWsOrNlChar(list, i):

	i -= 1
	while i &gt;= 0 and isWsOrNl(list[i]):
		i -= 1
	return i</t>
<t tx="T754">def removeAllCComments(list, delim):

	i = 0
	while i &lt; len(list):
		if match(list,i,"'") or match(list,i,'"'):
			i = skipString(list,i)
		elif match(list,i,"//"):
			j = skipPastLine(list,i)
			print "deleting single line comment:", listToString(list[i:j])
			del list[i:j]
		elif match(list,i,"/*"):
			j = skipCBlockComment(list,i)
			print "deleting block comment:", listToString(list[i:j])
			del list[i:j]
		else:
			i += 1</t>
<t tx="T755">def removeAllCSentinels(list, delim):

	i = 0
	while i &lt; len(list):
		if match(list,i,"'") or match(list,i,'"'):
			# string starts a line.
			i = skipString(list,i)
			i = skipPastLine(list,i)
		elif match(list,i,"/*"):
			# block comment starts a line
			i = skipCBlockComment(list,i)
			i = skipPastLine(line,i)
		elif match(list,i,"//@"):
			j = skipPastLine(list,i)
			print "deleting sentinel:", listToString(list[i:j])
			del list[i:j]
		else:
			i = skipPastLine(list,i)</t>
<t tx="T756">def removeAllPythonComments(list, delim):

	i = 0
	while i &lt; len(list):
		if match(list,i,"'") or match(list,i,'"'):
			i = skipString(list,i)
		elif match(list,i,"#"):
			j = skipPastLine(list,i)
			print "deleting comment:", listToString(list[i:j])
			del list[i:j]
		else:
			i += 1</t>
<t tx="T757">def removeAllPythonSentinels(list, delim):

	i = 0
	while i &lt; len(list):
		if match(list,i,"'") or match(list,i,'"'):
			# string starts a line.
			i = skipString(list,i)
			i = skipPastLine(list,i)
		elif match(list,i,"#@"):
			j = skipPastLine(list,i)
			print "deleting sentinel:", listToString(list[i:j])
			del list[i:j]
		else:
			i = skipPastLine(list,i)</t>
<t tx="T758">def removeAtRoot (codeList):

	i = skipWs(codeList, 0)
	if matchWord(codeList,i,"@root"):
		j = skipPastLine(codeList,i)
		del codeList[i:j]

	while i &lt; len(codeList):
		if isStringOrComment(codeList,i):
			i = skipStringOrComment(codeList,i)
		elif match(codeList,i,"\n"):
			i = skipWs(codeList, i+1)
			if matchWord (codeList,i,"@root"):
				j = skipPastLine(codeList,i)
				del codeList[i:j]
		else: i += 1
</t>
<t tx="T759">def removeBlankLines(codeList):

	i = 0
	while i &lt; len(codeList):
		j = i
		while j &lt; len(codeList) and (codeList[j]==" " or codeList[j]=="\t"):
			j += 1
		if j== len(codeList) or codeList[j] == '\n':
			del codeList[i:j+1]
		else:
			oldi = i
			i = skipPastLine(codeList,i)</t>
<t tx="T760">def removeExcessWs(codeList):

	i = 0
	i = removeExcessWsFromLine(codeList,i)
	while i &lt; len(codeList):
		if isStringOrComment(codeList,i):
			i = skipStringOrComment(codeList,i)
		elif match(codeList,i,'\n'):
			i += 1
			i = removeExcessWsFromLine(codeList,i)
		else: i += 1</t>
<t tx="T761">def removeExcessWsFromLine(codeList,i):

	assert(i==0 or codeList[i-1] == '\n')
	i = skipWs(codeList,i)
	while i &lt; len(codeList):
		if isStringOrComment(codeList,i): break # safe
		elif match(codeList, i, '\n'): break
		elif match(codeList, i, ' ') or match(codeList, i, '\t'):
			# Replace all whitespace by one blank.
			k = i
			i = skipWs(codeList,i)
			codeList[k:i] = [' ']
			i = k + 1 # make sure we don't go past a newline!
		else: i += 1
	return i</t>
<t tx="T762">def removeLeadingAtCode(codeList):

	i = skipWsAndNl(codeList,0)
	if matchWord(codeList,i,"@code"):
		i = skipWsAndNl(codeList,5)
		del codeList[0:i]
	elif matchWord(codeList,i,"@c"):
		i = skipWsAndNl(codeList,2)
		del codeList[0:i]</t>
<t tx="T763">def removeMatchingBrackets(codeList, i):

	j = skipToMatchingBracket(codeList, i)
	if j &gt; i and j &lt; len(codeList):
		# print "del brackets:", listToString(codeList[i:j+1])
		c = codeList[j]
		if c == ')' or c == ']' or c == '}':
			del codeList[j:j+1]
			del codeList[i:i+1]
			# print "returning:", listToString(codeList[i:j])
			return j - 1
		else: return j + 1
	else: return j</t>
<t tx="T764">def removeSemicolonsAtEndOfLines(list):

	i = 0
	while i &lt; len(list):
		if isStringOrComment(list,i):
			i = skipStringOrComment(list,i)
		elif list[i] == ';':
			j = skipWs(list,i+1)
			if j &gt;= len(list) or match(list,j,'\n') or match(list,j,'#') or match(list,j,"//"):
				del list[i]
			else: i += 1
		else: i += 1</t>
<t tx="T765">def removeTrailingWs(list):

	i = 0
	while i &lt; len(list):
		if isWs(list[i]):
			j = i
			i = skipWs(list,i)
			assert(j &lt; i)
			if i &gt;= len(list) or list[i] == '\n':
				# print "removing trailing ws:", `i-j`
				del list[j:i]
				i = j
		else: i += 1</t>
<t tx="T766"># Replaces all occurances of findString by changeString.
# Deletes all occurances if change is None
def replace(codeList, findString, changeString):

	if len(findString)==0: return
	findList = stringToList(findString)
	changeList = stringToList(changeString)

	i = 0
	while i &lt; len(codeList):
		if match(codeList, i, findList):
			codeList[i:i+len(findList)] = changeList
			i += len(changeList)
		else: i += 1</t>
<t tx="T767"># For Leo we expect few block comments; doc parts are much more common.

def replaceComments(codeList):

	i = 0
	if match(codeList, i, "//"):
		codeList[0:2] = ['#']
	while i &lt; len(codeList):
		if match(codeList, i, "//"):
			codeList[i:i+2] = ['#']
			i = skipPastLine(codeList,i)
		elif match(codeList, i, "/*"):
			j = skipCBlockComment(codeList,i)
			del codeList[j-2:j]
			codeList[i:i+2] = ['#']
			j -= 2 ; k = i ; delta = -1
			while k &lt; j + delta :
				if codeList[k]=='\n':
					codeList[k:k+1] = ['\n', '#', ' ']
					delta += 2 ; k += 3 # progress!
				else: k += 1
			i = j + delta
		elif match(codeList, i, '"') or match(codeList, i, "'"):
			i = skipString(codeList,i)
		else: i += 1</t>
<t tx="T768"># Replaces &lt; &lt; x &gt; &gt; = by @c (at the start of lines).
def replaceSectionDefs(codeList):

	i = 0
	j = isSectionDef(codeList,i)
	if j &gt; 0: codeList[i:j] = list("@c ")

	while i &lt; len(codeList):
		if isStringOrComment(codeList,i):
			i = skipStringOrComment(codeList,i)
		elif match(codeList,i,"\n"):
			i += 1
			j = isSectionDef(codeList,i)
			if j &gt; i: codeList[i:j] = list("@c ")
		else: i += 1</t>
<t tx="T769"># Replaces occurances of findString by changeString outside of C comments and strings.
# Deletes all occurances if change is None.
def safeReplace(codeList, findString, changeString):

	if len(findString)==0: return
	findList = stringToList(findString)
	changeList = stringToList(changeString)
	i = 0
	if findList[0] in string.letters: #use matchWord
		while i &lt; len(codeList):
			if isStringOrComment(codeList,i):
				i = skipStringOrComment(codeList,i)
			elif matchWord(codeList, i, findList):
				codeList[i:i+len(findList)] = changeList
				i += len(changeList)
			else: i += 1
	else: #use match
		while i &lt; len(codeList):
			if match(codeList, i, findList):
				codeList[i:i+len(findList)] = changeList
				i += len(changeList)
			else: i += 1</t>
<t tx="T770">def skipCBlockComment(codeList, i):

	assert(match(codeList, i, "/*"))
	i += 2

	while i &lt; len(codeList):
		if match(codeList, i, "*/"): return i + 2
		else: i += 1
	return i</t>
<t tx="T771">def skipPastLine(codeList, i):

	while i &lt; len(codeList) and codeList[i] != '\n':
		i += 1
	if i &lt; len(codeList) and codeList[i] == '\n':
		i += 1
	return i</t>
<t tx="T772">def skipPastWord(list, i):

	assert(list[i] in string.letters or list[i]=='~')
	
	# Kludge: this helps recognize dtors.
	if list[i]=='~':
		i += 1
	
	while i &lt; len(list) and (
		list[i] in string.letters or
		list[i] in string.digits or
		list[i]=='_'):
		i += 1
	return i</t>
<t tx="T773">def skipString(codeList, i):

	delim = codeList[i] # handle either single or double-quoted strings
	assert(delim == '"' or delim == "'")
	i += 1

	while i &lt; len(codeList):
		if codeList[i] == delim: return i + 1
		elif codeList[i] == '\\': i += 2
		else: i += 1
	return i</t>
<t tx="T774">def skipStringOrComment(list,i):

	if match(list,i,"'") or match(list,i,'"'):
		return skipString(list,i)
	if match(list, i, "//"):
		return skipPastLine(list,i)
	elif match(list, i, "/*"):
		return skipCBlockComment(list,i)
	else: assert(0)</t>
<t tx="T775">def skipToMatchingBracket(codeList, i):

	c = codeList[i]
	if   c == '(': delim = ')'
	elif c == '{': delim = '}'
	elif c == '[': delim = ']'
	else: assert(0)

	i += 1
	while i &lt; len(codeList):
		c = codeList[i]
		if isStringOrComment(codeList,i):
			i = skipStringOrComment(codeList,i)
		elif c == delim:
			return i
		elif c == '(' or c == '[' or c == '{':
			i = skipToMatchingBracket(codeList,i)
			i += 1 # skip the closing bracket.
		else: i += 1
	return i</t>
<t tx="T776">def skipWs(list, i):

	while i &lt; len(list):
		c = list[i]
		if c == ' ' or c == '\t':
			i += 1
		else: break
	return i
	
def skipWsAndNl(list, i):

	while i &lt; len(list):
		c = list[i]
		if c == ' ' or c == '\t' or c == '\n':
			i += 1
		else: break
	return i</t>
<t tx="T777"># converts a string to a list containing one item per character of the list.
# converts None to the empty string and leaves other types alone.

# list(string) does not work on none.
def stringToList(string):

	if string:
		return list(string)
	else:
		return []</t>
<t tx="T778">def listToString(list):

	return string.join(list,"")</t>
<t tx="T779">@ This file contains compare routines used for testing and I hack away as needed.  To save typing, I usually invoke the go() from the Python interpreter.
@c

import difflib, filecmp, os, string

@others</t>
<t tx="T780">def choose(cond, a, b): # warning: evaluates all arguments

	if cond: return a
	else: return b
</t>
<t tx="T781">def cmp(name1,name2):

	val = filecmp.cmp(name1,name2,0)
	if 1:
		if val: print "equal"
		else:   print "*** not equal"
	else:
		print "filecmp.cmp returns:",
		if val: print val, "(equal)"
		else:   print val, "(not equal)"

	return val</t>
<t tx="T782">def compare(f1,f2,name1,name2,verbose):

	lines = 0 ; mismatches = 0
	s1 = f1.readline() ; s2 = f2.readline() # Ignore the first line!
	while 1:
		s1 = f1.readline() ; s2 = f2.readline()
		if 1: # Ignore leading whitespace
			s1 = string.lstrip(s1)
			s2 = string.lstrip(s2)
		if 1: # LeoCB doesn't delete whitespace as well as leo.py.
			&lt;&lt; ignore blank lines &gt;&gt;
		n1 = len(s1) ; n2 = len(s2)
		if n1==0 and n2 != 0: print "eof on", name1
		if n2==0 and n1 != 0: print "eof on", name2
		if n1==0 or n2==0: break
		match = compare_lines(s1,s2)
		if not match: mismatches += 1
		lines += 1
		if verbose or not match:
			mark = choose(match,' ','*')
			dump("1.",lines,mark,s1)
			dump("2.",lines,mark,s2)
			if mismatches &gt; 9: return

	return #
	print "lines", lines, "mismatches:", mismatches
	if n1&gt;0: dumpEnd("1",f1)
	if n2&gt;0: dumpEnd("2",f2)</t>
<t tx="T783">while 1:
	s = string.rstrip(s1)
	if len(s) == 0:
		s1 = f1.readline()
		if len(s1) == 0: break
	else: break
while 1:
	s = string.rstrip(s2)
	if len(s) == 0:
		s2 = f2.readline()
		if len(s1) == 0: break
	else: break</t>
<t tx="T784">def compare_files (name1,name2,verbose):
	
	f1=doOpen(name1)
	f2=doOpen(name2)
	if f1 and f2:
		compare(f1,f2,name1,name2,verbose)
	try:
		f1.close()
		f2.close()
	except: pass</t>
<t tx="T785">def compare_lines(s1,s2):

	if 0: # ignore all whitespace
		s1 = string.replace(s1," ","")
		s1 = string.replace(s1,"\t","")
		s2 = string.replace(s2," ","")
		s2 = string.replace(s2,"\t","")
	else: # ignore leading and/or trailing whitespace
		s1 = string.strip(s1)
		s2 = string.strip(s2)
	return s1==s2</t>
<t tx="T786">def compareDirs(dir1,dir2): # make ".py" an arg.

  print "dir1:", dir1
  print "dir2:", dir2
  list1 = os.listdir(dir1)
  list2 = os.listdir(dir2)
  py1 = [] ; py2 = []
  for f in list1:
    root, ext = os.path.splitext(f)
    if ext == ".py": py1.append(f)
  for f in list2:
    root, ext = os.path.splitext(f)
    if ext == ".py": py2.append(f)
  print "comparing using filecmp.cmp"
  print
  yes = [] ; no = [] ; fail = []
  for f1 in py1:
    head,f2 = os.path.split(f1)
    if f2 in py2:
      val = filecmp.cmp(dir1+f1,dir2+f2,0)
      if val:  yes.append(f1)
      else: no.append(f1)
    else: fail.append(f1)

  print "matches:",
  for f in yes:  print f,
  print ; print "mismatches:",
  for f in no:   print f,
  print ; print "not found:",
  for f in fail: print f,</t>
<t tx="T787">def compare_directories(path1,path2,verbose):

	files = os.listdir(path1)
	files.sort()
	for f in files:
		if os.path.exists(path2 + f):
			val = filecmp.cmp(path1 + f, path2 + f)
			# print "cmp:", val, f
		else:
			print path2+f, "does not exist in both directories"
			files.remove(f)

	print "1." + path1
	print "2." + path2
	for f in files:
		name1 = path1 + f ; name2 = path2 + f
		val = filecmp.cmp(name1,name2)
		if val == 0:
			f1 = open(name1) ; f2 = open(name2)
			print f
			# note: should have param telling how to deal with whitespace.
			compare(f1,f2,name1,name2,verbose)
			f1.close() ; f2.close()
			## return ## just one</t>
<t tx="T788">def crlf(f1,f2):
	s1=f1.read() ; s2=f2.read()
	cr, lf = count_crlf(s1)
	print name1, cr, lf
	cr, lf = count_crlf(s2)
	print name2, cr, lf

def count_crlf(s):
	cr, lf = 0, 0
	for i in s:
		if i == '\n': lf += 1
		if i == '\r': cr += 1
	return cr,lf
</t>
<t tx="T789">def diff(f1,f2):

	s1=f1.read() ; s2=f2.read()
	s = difflib.Differ()
	delta = s.compare(s1,s2)
	print len(delta)</t>
<t tx="T790">def doOpen(name):

	try:
		f = open(name,'r')
		return f
	except:
		print "can not open:", `name`
		return None</t>
<t tx="T791">def dump(tag,line,mark,s):

	out = tag + `line` + mark + ':' 
	for ch in s[:-1]: # don't print the newline
		if 0: # compact
			if ch == '\t' or ch == ' ':
				out += ' '
			else:
				out += ch
		else: # more visible
			if ch=='\t':
				out += "[" ; out += "t" ; out += "]"
			elif ch==' ':
				out += "[" ; out += " " ; out += "]"
			else: out += ch
	print out
</t>
<t tx="T792">def dumpEnd(tag,f):

	lines = 0
	while 1:
		s = f.readline()
		if len(s) == 0: break
		lines += 1
		# dump(tag,s)

	print "file", tag, "has", lines, "trailing lines"</t>
<t tx="T793">def go(name=None):

	if 1: # Compare all files in Tangle test directories
		path1 = "c:\\prog\\test\\tangleTest\\"
		path2 = "c:\\prog\\test\\tangleTestCB\\"
		verbose = 0
		compare_directories(path1,path2,verbose)
	else: # Compare two files.
		name1 = "c:\\prog\\test\\compare1.txt"
		name2 = "c:\\prog\\test\\compare2.txt"
		verbose = 0
		compare_files(name1,name2,verbose)</t>
<t tx="T794">def sequence(f1,f2):

	s = difflib.SequenceMatcher()
	s1 = f1.read() ; s2 = f2.read()
	print len(s1), len(s2)
	# codes = s.get_opcodes() # hangs.
	# print len(codes)
	# print s.ratio() # hangs
</t>
<t tx="T795">@ This file contains functions for non-interactive searching.  You might find these useful while running other scripts.
@c

import leo, string, re

@others</t>
<t tx="T796">def changeAll ( commander, findPat, changePat, bodyFlag = 1 ):
	"""
	changeAll	make changes in an entire Leo outline.
	
	commander	Commands object for a Leo outline window.
	findPat		the search string.
	changePat	the replacement string.
	bodyFlag	true: change body text.  false: change headline text.
	"""
	n = len(changePat)
	v = commander.rootVnode()
	pos = 0
	while v != None:
		v, pos = changeNext(v, pos, findPat, changePat, bodyFlag)
		pos = pos + n</t>
<t tx="T797">def changeNext ( v, pos, findPat, changePat, bodyFlag = 1 ):
	"""
	changeNext:	use string.find() to change text in a Leo outline.
	
	v	 		the vnode to start the search.
	pos			the position within the body text of v to start the search.
	findPat		the search string.
	changePat	the replacement string.
	bodyFlag	true: change body text.  false: change headline text.
	
	returns a tuple (v,pos) showing where the change occured.
	returns (None,0) if no further match in the outline was found.

	Note: if (v,pos) is a tuple returned previously from changeNext,
	changeNext(v,pos+len(findPat),findPat,changePat)
	changes the next matching string.
	"""
	n = len(findPat)
	v, pos = findNext(v, pos, findPat, bodyFlag)
	if v == None:
		return None, 0
	if bodyFlag:
		s = v.bodyString()
		# s[pos:pos+n] = changePat
		s = s[:pos] + changePat + s[pos+n:]
		v.setBodyStringOrPane(s)
	else:
		s = v.headString()
		# s[pos:pos+n] = changePat
		s = s[:pos] + changePat + s[pos+n:]
		v.setHeadStringOrHeadline(s)
		print "setting head string: ", result
	return v, pos</t>
<t tx="T798">def changePrev ( v, pos, findPat, changePat, bodyFlag = 1 ):
	"""
	changePrev:	use string.rfind() to change text in a Leo outline.
	
	v	 		the vnode to start the search.
	pos			the position within the body text of v to start the search.
	findPat		the search string.
	changePat	the replacement string.
	bodyFlag	true: change body text.  false: change headline text.
	
	returns a tuple (v,pos) showing where the change occured.
	returns (None,0) if no further match in the outline was found.

	Note: if (v,pos) is a tuple returned previously from changePrev,
	changePrev(v,pos-len(findPat),findPat,changePat)
	changes the next matching string.
	"""
	n = len(findPat)
	v, pos = findPrev(v, pos, findPat, bodyFlag)
	if v == None:
		return None, 0
	if bodyFlag:
		s = v.bodyString()
		# s[pos:pos+n] = changePat
		s = s[:pos] + changePat + s[pos+n:]
		v.setBodyStringOrPane(s)
	else:
		s = v.headString()
		#s[pos:pos+n] = changePat
		s = s[:pos] + changePat + s[pos+n:]
		v.setHeadStringOrHeadline(s)
	return v, pos</t>
<t tx="T799">def findAll ( commander, pattern, bodyFlag = 1 ):
	"""
	findAll		search an entire Leo outline for a pattern.
	
	commander	Commands object for a Leo outline window.
	pattern		the search string.
	bodyFlag	true: search body text.  false: search headline text.
	
	returns a list of tuples (v,pos) showing where matches occured.
	returns [] if no match were found.
	"""
	n = len(pattern)
	result = []
	v = commander.rootVnode()
	pos = 0
	while v != None:
		v, pos = findNext(v, pos, pattern, bodyFlag)
		if v != None:
			result.append ( (v, pos) )
		pos = pos + n
	return result</t>
<t tx="T800">def findNext ( v, pos, pattern, bodyFlag = 1 ):
	"""
	findNext:	use string.find() to find a pattern in a Leo outline.
	
	v	 		the vnode to start the search.
	pos			the position within the body text of v to start the search.
	pattern		the search string.
	bodyFlag	true: search body text.  false: search headline text.
	
	returns a tuple (v,pos) showing where the match occured.
	returns (None,0) if no further match in the outline was found.

	Note: if (v,pos) is a tuple returned previously from findNext,
	findNext(v,pos+len(pattern),pattern) finds the next match.
	"""
	while v != None:
		if bodyFlag:
			s = v.bodyString()
		else:
			s = v.headString()
		pos = string.find ( s, pattern, pos )
		if pos != -1:
			return v, pos
		v = v.threadNext()
		pos = 0
	return None, 0</t>
<t tx="T801">def findPrev ( v, pos, pattern, bodyFlag = 1 ):
	"""
	findPrev:	use string.rfind() to find a pattern in a Leo outline.
	
	v	 		the vnode to start the search.
	pos			the position within the body text of v to start the search.
	pattern		the search string
	bodyFlag	true: search body text.  false: search headline text.
	
	returns a tuple (v,pos) showing where the match occured.
	returns (None,0) if no further match in the outline was found.

	Note: if (v,pos) is a tuple returned previously from findPrev,
	findPrev(v,pos-len(pattern),pattern) finds the next match.
	"""
	while v != None:
		if bodyFlag:
			s = v.bodyString()
		else:
			s = v.headString()
		pos = string.rfind ( s, pattern, 0, pos )
		if pos != -1:
			return v, pos
		v  = v.threadBack()
		pos = -1
	return None, 0</t>
<t tx="T802">def reChangeAll ( commander, findPat, changePat, bodyFlag, reFlags = None ):
	"""
	reChangeAll: make changes in an entire Leo outline using re module.
	
	commander	Commands object for a Leo outline window.
	findPat		the search string.
	changePat	the replacement string.
	bodyFlag	true: change body text.  false: change headline text.
	reFlags		flags argument to re.search().
	"""
	n = len(changePat)
	v = commander.rootVnode()
	pos = 0
	while v != None:
		v, mo, pos = reChangeNext(
			v, pos, findPat, changePat, bodyFlag, reFlags)
		pos = pos + n</t>
<t tx="T803">def reChangeNext ( v, pos, findPat, changePat, bodyFlag, reFlags = None ):
	"""
	reChangeNext: use re.search() to change text in a Leo outline.
	
	v	 		the vnode to start the search.
	pos			the position within the body text of v to start the search.
	findPat		the search string.
	changePat	the replacement string.
	bodyFlag	true: change body text.  false: change headline text.
	reFlags		flags argument to re.search().
	
	returns a tuple (v,pos) showing where the change occured.
	returns (None,0) if no further match in the outline was found.

	Note: if (v,pos) is a tuple returned previously from reChangeNext,
	reChangeNext(v,pos+len(findPat),findPat,changePat,bodyFlag)
	changes the next matching string.
	"""
	n = len(findPat)
	v, mo, pos = reFindNext(v, pos, findPat, bodyFlag, reFlags)
	if v == None:
		return None, None, 0
	if bodyFlag:
		s = v.bodyString()
		print s, findPat, changePat
		# s[pos:pos+n] = changePat
		s = s[:pos] + changePat + s[pos+n:]
		v.setBodyStringOrPane(s)
	else:
		s = v.headString()
		# s[pos:pos+n] = changePat
		s = s[:pos] + changePat + s[pos+n:]
		v.setHeadStringOrHeadline(s)
	return v, mo, pos</t>
<t tx="T804">def reChangePrev ( v, pos, findPat, changePat, bodyFlag, reFlags = None ):
	"""
	reChangePrev: use re.search() to change text in a Leo outline.
	
	v	 		the vnode to start the search.
	pos			the position within the body text of v to start the search.
	findPat		the search string.
	changePat	the replacement string.
	bodyFlag	true: change body text.  false: change headline text.
	reFlags		flags argument to re.search().
	
	returns a tuple (v,pos) showing where the change occured.
	returns (None,0) if no further match in the outline was found.

	Note: if (v,pos) is a tuple returned previously from reChangePrev,
	reChangePrev(v,pos-len(findPat),findPat,changePat,bodyFlag)
	changes the next matching string.
	"""
	n = len(findPat)
	v, mo, pos = reFindPrev(v, pos, findPat, bodyFlag, reFlags)
	if v == None:
		return None, None, 0
	if bodyFlag:
		s = v.bodyString()
		# s[pos:pos+n] = changePat
		s = s[:pos] + changePat + s[pos+n:]
		v.setBodyStringOrPane(s)
	else:
		s = v.headString()
		# s[pos:pos+n] = changePat
		s = s[:pos] + changePat + s[pos+n:]
		v.setHeadStringOrHeadline(s)
	return v, mo, pos</t>
<t tx="T805">def reFindAll ( commander, findPat, bodyFlag, reFlags = None ):
	"""
	reFindAll	search an entire Leo outline using re module.
	
	commander	Commands object for a Leo outline window.
	pattern		the search string.
	bodyFlag	true: search body text.  false: search headline text.
	reFlags		flags argument to re.search().
	
	returns a list of tuples (v,pos) showing where matches occured.
	returns [] if no match were found.
	"""
	n = len(findPat)
	result = []
	v = commander.rootVnode()
	pos = 0
	while v != None:
		v, mo, pos = reFindNext(v, pos, findPat, bodyFlag, reFlags)
		if v != None:
			result.append ( (v,mo,pos) )
		pos = pos + n
	return result</t>
<t tx="T806">def reFindNext ( v, pos, pattern, bodyFlag, reFlags = None ):
	"""
	reFindNext:	use re.search() to find pattern in a Leo outline.
	
	v	 		the vnode to start the search.
	pos			the position within the body text of v to start the search.
	pattern		the search string
	bodyFlag	true: search body text.  false: search headline text.
	reFlags		the flags argument to re.search()
	
	returns a tuple (v,mo,pos) showing where the match occured.
	returns (None,None,0) if no further match in the outline was found.

	Note: if (v,pos) is a tuple returned previously from reFindNext,
	reFindNext(v,pos+len(pattern),pattern) finds the next match.
	"""
	while v != None:
		if bodyFlag:
			s = v.bodyString()
		else:
			s = v.headString()
		if reFlags == None:
			mo = re.search ( pattern, s[pos:] )
		else:
			mo = re.search ( pattern, s[pos:], reFlags )
		if mo != None:
			return v, mo, pos + mo.start()
		v = v.threadNext()
		pos = 0
	return None, None, 0</t>
<t tx="T807">def reFindPrev ( v, pos, pattern, bodyFlag, reFlags = None ):
	"""
	reFindPrev:	use re.search() to find pattern in a Leo outline.

	v	 		the vnode to start the search.
	pos			the position within the body text of v to start the search.
	pattern		the search string
	bodyFlag	true: search body text.  false: search headline text.
	reFlags		the flags argument to re.search()
	
	returns a tuple (v,mo,pos) showing where the match occured.
	returns (None,None,0) if no further match in the outline was found.
	
	Note 1: Searches vnodes in reverse (v.threadBack) direction.
	Searches text of vnodes in _forward_ direction.
	
	Note 2: if (v,pos) is a tuple returned previously from reFindPrev,
	reFindPrev(v,pos-len(pattern),pattern) finds the next match.
	"""
	while v != None:
		if bodyFlag:
			s = v.bodyString()
		else:
			s = v.headString()
		# Forward search through text...
		if reFlags == None:
			mo = re.search ( pattern, s[pos:] )
		else:
			mo = re.search ( pattern, s[pos:], reFlags )
		if mo != None:
			return v, mo, pos+mo.start()
		# Reverse search through vnode.
		v = v.threadBack()
		pos = 0
	return None, None, 0</t>
<t tx="T808">def lineAtPos ( s, pos ):
	"""
	lineAtPos: return the line of a string containing the given index.
	s		a string
	pos		an index into s
	"""
	# find the start of the line containing the match
	if len(s) &lt; 1:
		return ""
	if pos &gt; len(s):
		pos = len(s)-1
		
	while pos &gt; 0:
		if s[pos] == '\n':
			pos = pos + 1
			break
		else:
			pos = pos - 1
	# return the line containing the match
	s = s[pos:]
	list = string.split(s,"\n")
	return list[0]</t>
<t tx="T809">def printFindList( findList, bodyFlag = 1 ):
	"""
	printFindList:	Print matching lines from the list.
	
	findList:		a list of (v,pos) tuples returned from findAll().
	Only the line containing the match is printed.
	Lines are printed once for each match found on the line.
	"""
	for v,pos in findList:
		if v != None:
			if bodyFlag:
				s = v.bodyString()
			else:
				s = v.headString()
			print lineAtPos(s, pos)</t>
<t tx="T810">@ This tiny script is intended to be called from go.bat to open LeoPy.leo.  You could change the file name to be any file you work on a lot...
@c

import leo
leo.open("c:\prog\LeoPy\LeoPy.leo")</t>
<t tx="T811">@ Script for creating and installing distributions of leo.py using Python's distutils package.  setup.py is the conventional name for such scripts.

On Windows, invoke this script using sdist.bat
On Linux do: cd LeoPy ; python setup.py sdist --force-manifest --formats=gztar,zip
@c

from distutils.core import setup
import os

print
print "Remember to update version numbers!"
print

# Generate the list of modules.
files = os.listdir(os.getcwd())
modules = []
for f in files:
	head,tail = os.path.split(f)
	root,ext = os.path.splitext(tail)
	if tail[0:3]=="leo" and ext==".py":
		modules.append(root)
		
modules.sort()
# print "modules:", `modules`

setup( name="leo",
	version="1.0",
	author="Edward K. Ream",
	author_email="edream@tds.net",
	url="http://personalpages.tds.net/~edream/front.html",
	py_modules=modules, # leo*.py also included in manifest
	description = "Leo: Literate Editor with Outlines",
	licence="Python", # [sic], not license
	platforms=["Windows, Linux, Macintosh"],
	long_description =
"""Leo is an outline-oriented editor written in 100% pure Python.
Leo works on any platform that supports Python and the Tk toolkit.
This version of Leo was developed with Python 2.1.1 and Tk 8.3.2.
You may download Python from http://python.org/ and
tcl/Tk from http://tcl.activestate.com/software/tcltk/
Leo features a multi-window outlining editor, Python colorizing,
powerful outline commands and many other things, including an
integrated Python shell(IDLE) window.""")</t>
<t tx="T812"># Example tangle_done script

def run(root_list):

	print "tangle_done roots:", `root_list`</t>
<t tx="T813"># Example untangle_done script

def run(root_list):

	print "untangle_done roots:", `root_list`</t>
<t tx="T814">@language python

@ This section contains all the source code of leo.py.

We use the following conventions throughout the code:

c: a commander
ch: a character
i, j, k: indices into a string
lst: a list
s: a string
t: a tnode
v: a vnode</t>
<t tx="T815">@ignore

@ Contains the output of c2py, partially massaged by hand.</t>
<t tx="T816">@ignore</t>
<t tx="T817">def exportMoreText(self):

	v = self.getCurrentVnode()
	if v and not wxTheClipboard.IsOpened() and wxTheClipboard.Open():
		s = v.convertTreeToString()
		wxTheClipboard.Clear()
		# The data is held by the clipboard.  Do not delete it!
		wxTheClipboard.SetData(new wxTextDataObject(s))
		wxTheClipboard.Close()
</t>
<t tx="T818">@ This code converts a vnode to noweb text as follows:

Convert @root to &lt;&lt; * &gt;&gt;
Convert @doc to @
Convert @code to &lt;&lt; name &gt;&gt;=, assuming the headline contains &lt;&lt; name &gt;&gt;
Ignore other directives
Format parts so they fit in pagewidth columns.
Output code parts as is.
@c

def convertToNoweb(v):

	if v == None: return ""
	s = v.t.bodyString
	n = len(s) ; i = 0 ; result = []
	while i &lt; n:
		i = skip_ws_and_nl(s,i)
		if match_word(s,i,"@doc") or match(s,i,"@ "):
			i = convertDocPartToNoweb(s,i,result)
		elif ( match_word(s,i,"@code") or match(s,i,"@c") or
			match_word(s,i,"@root") or match(s,i,"&lt;&lt;") ):
			i = convertCodePartToNoweb(s,i,v,result)
		elif s[i] == '@':
			i = skip_line(s,i) # Ignore all other directives.
		else: # Assume we are in a doc part.
			i = convertDocPartToNoweb(s,i,result)
	return listToString(result)</t>
<t tx="T819"># The code part should start either with @code or @root or &lt;&lt; section name &gt;&gt;=

def convertCodePartToNoweb(s,i,v,result):

	if i &gt;= len(s): return i
	if match_word(s,i,"@c"):
		&lt;&lt; handle @c &gt;&gt;
	elif match(s,i,"@root"):
		&lt;&lt; handle @root &gt;&gt;
	elif match(s,i"&lt;&lt;"):
		&lt;&lt; copy the line to result &gt;&gt;
	i = copyPart(p,limit,result)
	return i</t>
<t tx="T820">i = skip_line(s,i)
j = k = None
&lt;&lt; point j and k at section name in v's headline &gt;&gt;
if j and k:
	headline = s[j,k]
	result.append('\n')
	for item in headline:
		result.append(item)
	result.append('=')
else:
	for item in "\n\n&lt;&lt; *** ":
		result.append(item)
	for item in "no section name for @c ***&gt;&gt;":
		result.append(item)</t>
<t tx="T821">wxString hps = v.headString()
char * hp =(char *)hps.c_str()
char * hlim = hp + strlen(hp)
hp = skip_ws(hp,hlim)
if hp + 2 &lt; hlim and strn_eq(hp,"&lt;&lt;",2):
	p1 = hp
	hp += 2
	while hp + 2 &lt;= hlim:
		if strn_eq(hp,"&gt;&gt;",2):
			p2 = hp + 2
			break
		else: ++ hp</t>
<t tx="T822">wxString name("*") # Default name for empty file names.
p += 5
p = skip_ws(p,limit)
char * p2 = p
p = skip_line(p,limit)
&lt;&lt; Set name to the file name p2..p &gt;&gt;
result += "\n\n&lt;&lt;"
result += name
result += "&gt;&gt;="
</t>
<t tx="T823">if p2 &lt; p:
	char delim = ' '
	if *p2 == '&lt;':   ++ p2  delim = '&gt;'
	if *p2 == '"':   ++ p2  delim = '"'
	char * p3 = p2
	while p2 &lt; p and *p2 != delim and ! is_nl(*p2):
		++ p2
	if p3 &lt; p2:
		name = wxString(p3,p2-p3)
		name.Trim(true)
		name.Trim(false)
		if name.Length()== 0:
			name = "*"
</t>
<t tx="T824">j = i ; i = skip_line(s,i)
for item in s[j:i]:
	result.append(item)
</t>
<t tx="T825">def convertDocPartToNoweb(s,i,outerResult):

	if match_word(s,i,"@doc") or match_word(s,i,"@ "):
		i = skip_line(s,i)
	i = skip_ws_and_nl(s,i)
	result = []
	i = copyPart(s,i,result)
	if len(result) &gt; 0:
		# We could break long lines in result here.
		for item in "@ \n":
			outerResult.append(item)
		for item in result:
			outerResult.append(item)
	return i</t>
<t tx="T826"># Copies characters to result until the end of the present section is seen.

def copyPart(s,i,result):

	n = len(s)
	while i &lt; n:
		# We should be at the start of a line here.
		j = i
		i = skip_nl(s,i) ; i = skip_ws(s,i)
		if match_word(s,i,"@doc") or match_word(s,i,"@c") or match_word(s,i,"@root"):
			return i
		elif match(s,i,"&lt;&lt;"):
			k = findOnLine(s,i,"&gt;&gt;=")
			if k &gt; -1: return i
		elif match(s,i,"@ ") or match(s,i,"@@")
			return i
		elif s[i] == '@':
			i = skip_line(s,i) # Ignore all other directives.
		else:
			# Copy the entire line.
			i = skip_line(s,j)
			for item in s[j:i]:
				result.append(item)
	return i
</t>
<t tx="T827"># Almost all the time spent in this command is spent here.
def convertMoreStringsToOutlineAfter(self,strings,firstVnode):

	if not self.stringsAreValidMoreFile(strings): return None
	&lt;&lt; Declare the vars for convertMoreStringsToOutlineAfter &gt;&gt;
	self.BeginUpdate()
		while index &lt; count:
			s = strings.Item(index)
			cs = s.c_str()
			level = self.moreHeadlineLevel(cs,&amp;newFlag)- firstLevel
			if level &gt;= 0:
				&lt;&lt; Link a new vnode v into the outline &gt;&gt;
				&lt;&lt; Set the headline string,skipping over the leader &gt;&gt;
				&lt;&lt; Count the number of following body lines &gt;&gt;
				&lt;&lt; Add the lines to the body text of v &gt;&gt;
				v.setDirty()# Set the icon and the dirty bit last.
			else: ++ index
		if theRoot:
			theRoot.setDirty()
			self.setChanged(true)
	self.EndUpdate()
	return theRoot</t>
<t tx="T828">vnode * theRoot = None
vnode * lastVnode = None
vnode * v = None # The new vnode.
long index = 0
long lastLevel = -1
bool junkFlag = 0
bool newFlag = 0
long bodyLines = 0
long firstLevel = 0
long level = 0
wxString s("")
char * cs = None
long count = strings.Count()
if count &gt; 0:
	s = strings.Item(0)
	cs =(char *)s.c_str()
	firstLevel = self.moreHeadlineLevel(cs,&amp;junkFlag)
wxTreeCtrl * tree = self.treeCtrl()
</t>
<t tx="T829">assert(level &gt;= 0)
if lastVnode == None:
	theRoot = v = firstVnode.insertAfter()
elif level == lastLevel:
	v = lastVnode.insertAfter()
elif level == lastLevel + 1:
	v = lastVnode.insertAsNthChild(0)
else:
	assert(level &lt; lastLevel)
	while level &lt; lastLevel:
		lastLevel -= 1
		lastVnode = lastVnode.parent()
		assert(lastVnode)
		assert(lastLevel &gt;= 0)
	v = lastVnode.insertAfter()
lastVnode = v
lastLevel = level</t>
<t tx="T830">	char * cString = cs
	while *cString == '\t':
		++ cString
	if(*cString == '+' or *cString == '-')and *(cString+1)== ' ':
	  cString += 2
	# Set the headline string.
	wxTreeItemId id = v.treeId
	tree.SetItemText(id,wxString(cString))
</t>
<t tx="T831">bodyLines = 0
++ index # Skip the headline.
while  index &lt; count:
	s = strings.Item(index)
	cs =(char *)s.c_str()
	level = self.moreHeadlineLevel(cs,&amp;newFlag)- firstLevel
	if level &gt;= 0:
		break
	# Remove first backslash of the body line.
	if  s.Length()&gt; 0 and s [0u] == '\\':
		strings.Item(index)= s.Mid(1)
	++ bodyLines
	++ index
</t>
<t tx="T832">if bodyLines &gt; 0:
	wxString body("")
	for long n = index - bodyLines SEMI n &lt; index SEMI ++ n:
		body += strings.Item(n)
		if n != index - 1:
			body += "\n"
	v.t.setTnodeText(body)
</t>
<t tx="T833"># On entry,files contains at most one file to convert.
def importMoreText(self,files):

	current = self.getCurrentVnode()
	if current == None: return
	if files.Count()&lt; 1: return
	fileName = files.Item(0)
	wxArrayString * array = new wxArrayString()
	&lt;&lt; Read the file into array &gt;&gt;
	# Convert the string to an outline and insert it after the current node.
	newVnode = self.convertMoreStringsToOutlineAfter(array,current)
	delete array
	array = None
	if newVnode:
		self.endEditing()
		self.validateOutline()
		self.editVnode(newVnode)
		newVnode.setDirty()
		self.setChanged(true)
	else:
		alert(fileName + " is not a valid MORE file.")</t>
<t tx="T834">wxTextFile file(fileName)
bool result = file.Open()
if result:
	# put each line of the file into array.
	wxString s("")
	for s = file.GetFirstLine()SEMI !file.Eof()SEMI s = file.GetNextLine():
		array.Add(s)
else:
	alert("Not enough memory to convert: " + fileName)
</t>
<t tx="T835"># return the headline level of s,or -1 if the string is not a MORE headline.
def moreHeadlineLevel(self,s,plusFlag):

	level = 0
	while *s and *s == '\t':
		++level
		++s
	if plusFlag: *plusFlag =(*s == '+')
	if(*s == '+' or *s == '-')and *(s+1)== ' ':
		return level
	else:
		return -1
</t>
<t tx="T836">def stringsAreValidMoreFile(self,strings):

	count = strings.Count()
	if count &lt; 1: return false
	bool plusFlag = 0
	s = strings.Item(0)
	cs = s.c_str()
	level1 = self.moreHeadlineLevel(cs,&amp;plusFlag)
	if level1 == -1: return false
	lastLevel = level1
	# Check the level of all headlines.
	for   i = 1  SEMI  i &lt; count  SEMI  ++ i:
		bool newFlag = 0
		s = strings.Item(i)
		cs = s.c_str()
		level = self.moreHeadlineLevel(cs,&amp;newFlag)
		if level &gt; 0:
			if level &lt; level1 or level &gt; lastLevel + 1:
				return false # improper level.
			elif  level &gt; lastLevel and plusFlag == false:
				return false # parent of this node has no children.
			elif  level == lastLevel and plusFlag == true:
				return false # last node has missing child.
			else:
				lastLevel = level
				plusFlag = newFlag
	return true
</t>
<t tx="T837">@unit
</t>
<t tx="T838">@ignore</t>
<t tx="T839">These macros are used in several places to parse body text.
@c
#define isTex(p)(*(p)== ' ' or *(p)== '*')
#define isMacro(p)(*(p)== 'd' or *(p)== 'f')
#define isCode(p)(*(p)== 'c' or *(p)== 'p')
#define isModuleStart(p)\
	((p)+1 &lt; limit_p and *(p)== '@' and\
	(isTex(p+1)or isMacro(p+1)or isCode(p+1)))
#define isAtAt(p)((p)+1 &lt; limit_p and *(p)== '@' and *(p+1)=='@')
#define isNameStart(p)((p)+1 &lt; limit_p and *(p)== '@' and *(p+1)=='&lt;')
#define isNameEnd(p)((p)+1 &lt; limit_p and *(p)== '@' and *(p+1)=='&gt;')
#define isTeXStart(p)((p)+1 &lt; limit_p and *(p)== '@' and isTex(p+1))
#define isMacroStart(p)((p)+1 &lt; limit_p and *(p)== '@' and isMacro(p+1))
#define isCodeStart(p)((p)+1 &lt; limit_p and *(p)== '@' and isCode(p+1))
</t>
<t tx="T840">def CWEBToOutlineCommand(self,files):
	current = self.getCurrentVnode()
	if current == None: return
	count = files.Count
	if count &lt; 1: return
	self.BeginUpdate()
		for i = 0 ; i &lt; count ; ++i:
			String fileName = files.Strings [ i ]
			v = self.createOutlineFromCWEB(fileName,current)
			self.contractVnode(v)
			v.setDirty()
			self.setChanged(true)
	 	self.selectVnode(current)
	self.EndUpdate()</t>
<t tx="T841">def massageCWEBBody(self,body):

	p = body.c_str()
	p1 = p
	limit_p = p + body.Length()
	start = None,*end = None
	&lt;&lt; Remove most newlines from @space and @* sections &gt;&gt;
	p = p1
	&lt;&lt; Replace abbreviated names with full names &gt;&gt;
	&lt;&lt; Remove trailing blank lines &gt;&gt;
	return body</t>
<t tx="T842">while p &lt; limit_p:
	p = skip_ws_and_nl(p,limit_p)
	if isTeXStart(p):
		# Scan to end of the section.
		start = end = p
		p += 2
		while p &lt; limit_p:
			p = skip_ws_and_nl(p,limit_p)
			if isModuleStart(p)or isNameStart(p):
				break
			else::
				end = p
				p = skip_to_end_of_line(p,limit_p)
		# Remove newlines from start to end.
		for char *p2 = start ; p2 &lt; end ;:
			if *p2 == '\r':
				long index1 = p - p1
				long index2 = p2 - p1
				long end_index = end - p1
				body.Delete(index2 + 1,1)
				p1 = body.c_str()
				p = p1 + index1
				p2 = p1 + index2
				end = p1 + end_index
				limit_p = p1 + body.Length()
				end -= 1
			elif *p2 == '\n':
				long index2 = p2 - p1
				body.Delete(index2 + 1,1)
				body.Insert(" ",index2 + 1)
				++ p2 # Bug fix: 3/17/01: don't rescan.
			else: ++ p2
	else: p = skip_line(p,limit_p)
</t>
<t tx="T843">while p &lt; limit_p:
	if isNameStart(p):
		p += 2
		char * start = p
		while p &lt; limit_p and ! isNameEnd(p)and ! isNameStart(p):
			++ p
		if p &lt; limit_p and isNameEnd(p):
			String name(start,p - start)
			String s = cstLookup(name)
			if name != s:
				# Replace name by s.
				long index = start - p1 + 1
				long index2 = p - p1
				body.Delete(index,p - start)
				body.Insert(s,index)
				p1 = body.c_str()
				p = p1 + index2
				limit_p = p1 + body.Length()
	else:: ++p
</t>
<t tx="T844">long index = body.Length()
long ws = 0
# Scan past all trailing whitespace and newlines.
while index &gt;= 1:
	int c = body [ index ]
	if is_ws(c)or is_nl(c):
		index  -= 1 ; ws  += 1
	else:: break
# Delete the trailing whitespace.
if ws &gt; 0:
body.Delete(index + 1,ws)
body.Insert("\r\n",index + 1)
</t>
<t tx="T845">def scanCWEBFile(self,fileName,parent):

	# Read the file into FileData.
	TMemoryStream * ms = new TMemoryStream()
	ms.LoadFromFile(fileName)
	String fileData(ms.Memory,ms.Size -1)# remove the file mark.
	delete ms
	cweb_st = new TStringList()
	# Set the p and limit_p vars.
	p = fileData.c_str()
	limit_p = p + fileData.Length()
	start = None
	&lt;&lt; Create a symbol table of all section names &gt;&gt;
	&lt;&lt; Create a node for limbo text &gt;&gt;
	while p &lt; limit_p:
		&lt;&lt; Create a node for the next module &gt;&gt;
	delete cweb_st
	cweb_st = None</t>
<t tx="T846">char *p1 = p
while p &lt; limit_p:
	if isAtAt(p):
		p += 2
	elif isNameStart(p):
		p += 2
		start = p
		while p &lt; limit_p and ! isNameEnd(p)and ! isNameStart(p):
			if isAtAt(p):
				p += 2
			else::
				++ p
		if isNameEnd(p):
			self.cstEnter(start,p)
	else:: ++ p
TRACEP("cstDump",self .cstDump(); ecnl())
p = p1 # restore p
</t>
<t tx="T847">start = p
while p &lt; limit_p:
	p = skip_ws_and_nl(p,limit_p)
	if isModuleStart(p): break
	else:: p = skip_line(p,limit_p)
bool hasLimbo = false
for char *p2 = start; p2 &lt; p; ++p2:
	if *p2 != '\t' and *p2 != ' ':
		hasLimbo = true ; break
if hasLimbo:
	String body(start,p - start)
	self.createCWEBHeadline(parent,"Limbo",body)
</t>
<t tx="T848">assert(isModuleStart(p))
start = p
if isTeXStart(p):
	p += 2
	p = skip_line(p,limit_p)
	while p &lt; limit_p:
		p = skip_ws_and_nl(p,limit_p)
		if isModuleStart(p): break
		else:: p = skip_line(p,limit_p)
if isMacroStart(p):
	p += 2
	p = skip_line(p,limit_p)
	# Place all @d directives in the same node.
	while p &lt; limit_p:
		p = skip_ws_and_nl(p,limit_p)
		if isModuleStart(p)and ! isMacroStart(p): break
		else:: p = skip_line(p,limit_p)
if isCodeStart(p):
	p += 2
	p = skip_line(p,limit_p)
	while p &lt; limit_p:
		p = skip_ws_and_nl(p,limit_p)
		if isModuleStart(p): break
		else:: p = skip_line(p,limit_p)
String body(start,p - start)
body = self.massageCWEBBody(body)
String headline = self.createHeadlineFromBody(body)
self.createCWEBHeadline(parent,headline,body)
</t>
<t tx="T849">@root "CWEBToOutline.cpp"
#pragma option -w-par # suppress warning: "Parameter is never used"
&lt;&lt; CWEBToOutline includes &gt;&gt;
&lt;&lt; CWEBToOutline abbreviations &gt;&gt;
&lt;&lt; CWEBToOutline private globals &gt;&gt;
&lt;&lt; CWEBToOutline methods &gt;&gt;
</t>
<t tx="T850">#include &lt;vcl.h&gt;
#pragma hdrstop
#include "Commands.h"
#include "MainUnit.h"
#include "tnode.h"
#include "Utils.h"
#include "vnode.h"
#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
#include "Leo.h"
</t>
<t tx="T851">static TStringList * cweb_st = None
</t>
<t tx="T852">@ This method determines the proper headline text. If the body text contains a section definition the headline becomes the corresponding section reference. Otherwise,if the body text contains @c the headline becomes the function name that is presumed to follow the @c. Otherwise,if the body text contains @d name the headline becomes @d name. Otherwise,the headline is simply "code"
@c

def createHeadlineFromBody(self,body):
	String headline("")
	p = body.c_str()
	limit_p = p + body.Length()
	start = None,* end = None
	macro_start = None,* macro_end = None
	&lt;&lt; Scan for a section definition,@d or @c &gt;&gt;
	if macro_start and macro_end:
		headline = String(macro_start,macro_end - macro_start)
	else:
		headline = "code"
	return headline</t>
<t tx="T853">while p &lt; limit_p:
	start = None
	p = skip_ws_and_nl(p,limit_p)
	# Allow constructs such as @ @c
	if  isTeXStart(p):
		p += 2
	if macro_start == None and isMacroStart(p):
		&lt;&lt; set macro_start and macro_end &gt;&gt;
	elif isCodeStart(p):
		&lt;&lt; Return the function name &gt;&gt;
	elif isNameStart(p):
		start = p
		p += 2
		while p &lt; limit_p and ! isNameEnd(p)and ! is_nl(*p):
			++ p
		if isNameEnd(p):
			p += 2
			end = p
			p = skip_ws(p,limit_p)
			if
				p+1 &lt; limit_p and *p == '+' and *p == '=' or
				p &lt; limit_p and *p == '='
			:
				# Set the headline to the section reference.
				headline = String(start,end - start)
				return headline
	else: p = skip_line(p,limit_p)
</t>
<t tx="T854">macro_start = p # Remember the @d or @f
p += 2
# Scan past the first identifier.
p = skip_ws(p,limit_p)
while p &lt; limit_p and(*p == '_' or isalnum(*p)):
	++ p
macro_end = p
</t>
<t tx="T855">p += 2 # Skip the @c or @p
while  p &lt; limit_p:
	p = skip_ws_and_nl(p,limit_p)
	if p &lt; limit_p and(*p == '_' or isalpha(*p)):
		start = p
		while p &lt; limit_p and(*p == '_' or isalnum(*p)):
			++p
		end = p
	elif *p == '(' and start:
		headline = String(start,end - start)
		return headline
	else: ++ p
return "outer function"
</t>
<t tx="T856">def createOutlineFromCWEB(self,fileName,parent):

	String shortFileName("")
	&lt;&lt; Set shortFileName &gt;&gt;
	# Create the top-level headline.
	v = parent.insertAsLastChild()
	v.initHeadString(shortFileName)
	# Scan the file,creating one section for each function definition.
	self.scanCWEBFile(fileName,v)
	return v</t>
<t tx="T857">shortFileName is everything after the last backslash.
@c
long len = fileName.Length()
long bslash_index = fileName.LastDelimiter("\\")
shortFileName = fileName.SubString
	(bslash_index + 1,len - bslash_index)
</t>
<t tx="T858">def createCWEBHeadline(self,parent,headline,body):

	# Create the vnode.
	v = parent.insertAsLastChild()
	v.initHeadString(headline)
	# Attach the body text.
	t = v.t
	t.setTnodeText(body)
	t.setSelection(0,0)
	v.setIcon()</t>
<t tx="T859">@ We canonicalize strings before looking them up,but strings are entered in the form they are first encountered.
@c

def cstCanonicalize(self,s):
	TReplaceFlags flags
	flags &lt;&lt; rfReplaceAll
	s = s.LowerCase()
	s = StringReplace(s,"\t"," ",flags)
	s = StringReplace(s,"\r"," ",flags)
	s = StringReplace(s,"\n"," ",flags)
	s = StringReplace(s,"  "," ",flags)
	s = s.Trim()
	return s</t>
<t tx="T860">def cstDump(self,void):

	cweb_st.Sort()
	ecnl(); es("Dump of cwt..."); ecnls(2)
	len = cweb_st.Count
	for i = 0 ; i &lt; len ; ++ i:
		String s = cweb_st.Strings [i]
		ecnl(); es(s.c_str()); ecnl()
	ecnls(2)
</t>
<t tx="T861"># We only enter the section name into the symbol table if the ... convention is not used.

def cstEnter(self,start,end):
	TReplaceFlags flags
	flags &lt;&lt; rfReplaceAll
	p = end
	# Don't enter names that end in "..."
	while p &gt; start and is_nl(*p):
		p -= 1
	if p-3 &gt; start and strncmp(p-3,"...",3)== 0:
		return
	# We partially canonicalize s,retaining capitalization.
	String s(start,end-start)
	s = StringReplace(s,"\t"," ",flags)
	s = StringReplace(s,"\r"," ",flags)
	s = StringReplace(s,"\n"," ",flags)
	s = StringReplace(s,"  "," ",flags)
	s = s.Trim()
	String s2 = self.cstCanonicalize(s)
	# Put the section name in the symbol table.
	if  cweb_st.IndexOf(s2)== -1:
		cweb_st.Add(s)</t>
<t tx="T862"># This method returns a String if the indicated string is a prefix of an entry in the cweb_st

def cstLookup(self,target):
	# Do nothing if the ... convention is not used.
	if  target.AnsiPos("...")== 0:
		return target
	# Canonicalize the target name,and remove the trailing "..."
	String ctarget = self.cstCanonicalize(target)
	ctarget = ctarget.SubString(0,ctarget.Length()- 3)
	ctarget = ctarget.Trim()
	len = ctarget.Length()
	count = cweb_st.Count
	for i = 0 ; i &lt; count ; ++ i:
		String s = cweb_st.Strings [i]
		String cs = self.cstCanonicalize(s)
		cs = cs.SubString(0,len)
		if ctarget == cs:
			&lt;&lt; Tell about the substitution &gt;&gt;
			&lt;&lt; Warn if there are other matches &gt;&gt;
			return s
	return target</t>
<t tx="T863">ecnl()
es("replacing: "); es(target.c_str())
es(" with: "); es(s.c_str())
enl()
</t>
<t tx="T864">for long j = i + 1 ; j &lt; count ; ++ j:
	String s = cweb_st.Strings [j]
	String cs = self.cstCanonicalize(s)
	cs = cs.SubString(0,len)
	if ctarget == cs:
			String m = "****** "
		m += target
		m += ": is also a prefix of: "
		m += s
		ecnl(); es(m.c_str())
</t>
<t tx="T865"># Dummy file to make this a potential package.</t>
<t tx="T866"># Top level of leo.py

import leoGlobals # Can't import * here: app() is not defined yet!
import leoApp, leoFrame, leoUtils, Tkinter
import os, sys

app = leoGlobals.app
	
@others

if __name__ == "__main__":
	run()</t>
<t tx="T867">def windows():
	return app().windowList
	
def getCommands():
	c = []
	for w in windows():
		c.append(w.commands)
		
def topCommands():
	return top() # defined in leoGlobals.</t>
<t tx="T868"># This is useful for reloading after a file has been changed.

def go(*args):

	reload_all()
	if len(args) &gt; 0 and type(args[0]) == type(("a","b")):
		args = args[0] # Strip the outer tuple.
	run(args)</t>
<t tx="T869">def open(fileName="c:\prog\LeoPy\LeoPy.leo",*args):

	reload_all()

	# Create a hidden main window: this window never becomes visible!
	root = Tkinter.Tk()
	&lt;&lt; set the icon image &gt;&gt;
	root.title("Leo Main Window")
	root.withdraw()
	# Initialize application globals
	app = leoApp.LeoApp(root)
	leoGlobals.setApp(app)
	app.finishCreate() # do this after gApp exists.
	# Create the first Leo window
	frame1 = leoFrame.LeoFrame()
	frame1.top.withdraw()
	# Now open the second Leo window
	fileName = os.path.join(os.getcwd(), fileName)
	fileName = os.path.normpath(fileName)
	if os.path.exists(fileName):
		ok, frame = frame1.OpenWithFileName(fileName)
	else: ok = 0
	if ok:
		app.windowList.remove(frame1)
		frame1.destroy() # force the window to go away now.
		app.log = frame # Sets the log stream for es()
	else:
		frame1.top.deiconify()
		app.log = frame1
		leoGlobals.es("File not found: " + fileName)

	# Initialize "Sherlock"
	leoUtils.init_trace(args)
	# leoUtils.trace("argv", "sys.argv: " + `sys.argv`)
	root.mainloop()</t>
<t tx="T870">def reload_all ():

	mods = [ "", "App", "AtFile", "Color", "Commands", "Compare",
		"Dialog", "FileCommands", "Frame", "Find", "Globals",
		"Nodes", "Prefs", "Tangle", "Tree", "Utils" ]
	
	print "reloading all modules"
	for m in mods:
		exec("import leo%s" % m)
		exec("reload(leo%s)" % m)

	from leoGlobals import *
	from leoUtils import *</t>
<t tx="T871">from leoGlobals import *
from leoUtils import *
import leo, leoFind, leoFrame, leoPrefs
import os

class LeoApp:
	@others</t>
<t tx="T872">def destroyAllGlobalWindows (self):

	if self.findFrame:
		self.findFrame.top.destroy()

	if self.prefsFrame:
		self.prefsFrame.top.destroy()</t>
<t tx="T873">@ Class to read and write @file nodes.

This code uses readline() to get each line rather than reading the entire file into a buffer.  This is more memory efficient and saves us from having to scan for the end of each line.  The result is cleaner and faster code.  This code also accumulates body text line-by-line rather than character-by-character, a much faster way.
@c

from leoGlobals import *
from leoUtils import *
import leoNodes
import filecmp, os, os.path, time

class atFile:
	&lt;&lt; atFile constants &gt;&gt;
	@others</t>
<t tx="T874"># The kind of at_directives.

noDirective		=  1 # not an at-directive.
delimsDirective =  2 # @delims
docDirective	=  3 # @doc.
atDirective		=  4 # @&lt;space&gt; or @&lt;newline&gt;
codeDirective	=  5 # @code
cDirective		=  6 # @c&lt;space&gt; or @c&lt;newline&gt;
othersDirective	=  7 # at-others
miscDirective	=  8 # All other directive

# The kind of sentinel line.
noSentinel		=  9 # Not a sentinel
endAt			= 10 # @-at
endBody			= 11 # @-body
endDoc			= 12 # @-doc
endLeo			= 13 # @-leo
endNode			= 14 # @-node
endOthers		= 15 # @-others
startAt			= 16 # @+at
startBody		= 17 # @+body
startDelims		= 18 # @delis
startDoc		= 19 # @+doc
startLeo		= 20 # @+leo
startNode		= 21 # @+node
startOthers		= 22 # @+others
startRef		= 23 # @&lt; &lt; ... &gt; &gt;
startVerbatim	= 24 # @verbatim
startDirective	= 25 # @@</t>
<t tx="T875">def nodeSentinelText(self,v):

	# A hack: zero indicates the root node so scanText won't create a child.
	if v != self.root and v.parent():
		index = v.childIndex() + 1
	else:
		index = 0
	cloneIndex = v.t.cloneIndex
	s = choose(cloneIndex &gt; 0, "C=" + `cloneIndex`, "")
	return `index` + ':' + s + ':' + v.headString()</t>
<t tx="T876">def putCloseNodeSentinel(self,v):

	s = self.nodeSentinelText(v)
	self.putSentinel("@-node:" + s)</t>
<t tx="T877">@ root is an ancestor of v, or root == v.  We call putCloseSentinel for v up to, but not including, root.
@c
def putCloseSentinels(self,root,v):

	self.putCloseNodeSentinel(v)
	while 1:
		v = v.parent()
		assert(v) # root must be an ancestor of v.
		if  v == root: break
		self.putCloseNodeSentinel(v)</t>
<t tx="T878">@ This method is the same as putSentinel except we don't put an opening newline and leading whitespace.
@c
def putOpenLeoSentinel(self,s):

	self.os(self.startSentinelComment)
	self.os(s)
	self.os(self.endSentinelComment)
	self.onl() # Ends of sentinel.</t>
<t tx="T879">@ This method puts an open node sentinel for node v.
@c
def putOpenNodeSentinel(self,v):

	if v.isAtFileNode() and v != self.root:
		self.writeError("@file not valid in: " + v.headString())
	else:
		s = self.nodeSentinelText(v)
		self.putSentinel("@+node:" + s)</t>
<t tx="T880">@ root is an ancestor of v, or root == v.  We call putOpenNodeSentinel on all the descendents of root which are the ancestors of v.
@c
def putOpenSentinels(self,root,v):

	last = root
	while last != v:
		# Set node to v or the ancestor of v that is a child of last.
		node = v
		while node and node.parent() != last:
			node = node.parent()
		assert(node)
		self.putOpenNodeSentinel(node)
		last = node</t>
<t tx="T881">@ All sentinels are eventually output by this method.

Sentinels include both the preceding and following newlines. This rule greatly simplies the code and has several important benefits:

1. Callers never have to generate newlines before or after sentinels.  Similarly, routines that expand code and doc parts never have to add "extra" newlines.
2. There is no need for a "no-newline" directive.  If text follows a section reference, it will appear just after the newline that ends sentinel at the end of the expansion of the reference.  If no significant text follows a reference, there will be two newlines following the ending sentinel.

The only exception is that no newline is required before the opening "leo" sentinel. The putLeoSentinel and isLeoSentinel routines handle this minor exception.
@c
def putSentinel(self,s):

	self.onl() ; self.putIndent(self.indent) # Start of sentinel.
	self.os(self.startSentinelComment)
	self.os(s)
	self.os(self.endSentinelComment)
	self.onl() # End of sentinel.</t>
<t tx="T882">@ This method tells what kind of sentinel appears in line s.  Typically s will be an empty line before the actual sentinel, but it is also valid for s to be an actual sentinel line.

Returns (kind, s, emptyFlag), where emptyFlag is true if kind == noSentinel and s was an empty line on entry.
@c

sentinelDict = {
	"@verbatim": startVerbatim,
	"@+at": startAt, "@-at": endAt,
	"@+body": startBody, "@-body": endBody,
	"@+doc": startDoc, "@-doc": endDoc,
	"@+leo": startLeo, "@-leo": endLeo,
	"@+node": startNode, "@-node": endNode,
	"@+others": startOthers, "@-others": endOthers }

def sentinelKind(self,s):

	i = skip_ws(s,0)
	if match(s,i,self.startSentinelComment): 
		i += len(self.startSentinelComment)
	else:
		return atFile.noSentinel
	# Do not skip whitespace here!
	if match(s,i,"@&lt;&lt;"): return atFile.startRef
	if match(s,i,"@@"): return atFile.startDirective
	if not match(s,i,'@'): return atFile.noSentinel
	j = i # start of lookup
	i += 1 # skip the at sign.
	if match(s,i,'+') or match(s,i,'-'):
		i += 1
	i = skip_c_id(s,i)
	# trace(`s[j:i]`)
	key = s[j:i]
	if len(key) &gt; 0 and atFile.sentinelDict.has_key(key):
		return atFile.sentinelDict[key]
	else:
		return atFile.noSentinel</t>
<t tx="T883"># Returns the name of the sentinel for warnings.

sentinelNameDict = {
	endAt: "@-at", endBody: "@-body",
	endDoc: "@-body", endLeo: "@-leo",
	endNode: "@-node", endOthers: "@-others",
	noSentinel: "&lt;no sentinel&gt;",
	startAt: "@+at", startBody: "@+body",
	startDirective: "@@", startDoc: "@+doc",
	startLeo: "@+leo", startNode: "@+node",
 	startOthers: "@+others", startVerbatim: "@verbatim" }

def sentinelName(self, kind):
	if atFile.sentinelNameDict.has_key(kind):
		return atFile.sentinelNameDict[kind]
	else:
		return "&lt;unknown sentinel!&gt;"</t>
<t tx="T884">def skipSentinelStart(self,s,i):

	if is_nl(s,i): i = skip_nl(s,i)
	i = skip_ws(s,i)
	assert(match(s,i,self.startSentinelComment))
	i += len(self.startSentinelComment)
	assert(i &lt; len(s) and s[i] == '@')
	return i + 1</t>
<t tx="T885"># Returns the kind of at-directive or noDirective.

def directiveKind(self,s,i):

	n = len(s)
	if i &gt;= n or s[i] != '@':
		return atFile.noDirective
	# This code rarely gets executed, so simple code suffices.
	if i+1 &gt;= n or match(s,i,"@ ") or match(s,i,"@\t") or match(s,i,"@\n"):
		return atFile.atDirective
	if match_word(s,i,"@c"):
		return atFile.cDirective
	elif match_word(s,i,"@code"):
		return atFile.codeDirective
	elif match_word(s,i,"@doc"):
		return atFile.docDirective
	elif match_word(s,i,"@others"):
		return atFile.othersDirective
	else:
		return atFile.miscDirective</t>
<t tx="T886">def error(self,message):

	es(message)
	self.errors += 1</t>
<t tx="T887"># Skip past whitespace equivalent to width spaces.

def skipIndent(self,s,i,width):

	c = self.commands
	ws = 0 ; n = len(s)
	while i &lt; n and ws &lt; width:
		if   s[i] == '\t': ws += (c.tab_width - (ws % c.tab_width))
		elif s[i] == ' ':  ws += 1
		else: break
		i += 1
	return i</t>
<t tx="T888">def readError(self,message):

	if self.errors == 0:
		es("----- Error reading @file " + self.targetFileName)
	self.error(message)
	self.root.setOrphan()
	self.root.setDirty()</t>
<t tx="T889">@ The new Leo2 computes clone indices differently from the old Leo2:

1. The new Leo2 recomputes clone indices for every write.
2. The new Leo2 forces the clone index of the @file node to be zero.

Also, the read logic ignores the clone index of @file nodes, thereby ensuring that we don't mistakenly join an @file node to another node.
@c
def updateCloneIndices(self,root,next):

	if root.isCloned():
		self.error("Ignoring clone mark for " + root.headString())
		root.t.setCloneIndex(0)
	index = 0
	# 12/17/01: increment each cloneIndex at most once.
	v = root
	while v and v != next:
		v.t.cloneIndex = 0
		v = v.threadNext()
	v = root
	while v and v != next:
		vIs = v.isCloned()
		vShould = v.shouldBeClone() #verbose
		if 0: # vIs or vShould:
			es("update:"+`index`+" is:"+`vIs`+" should:"+`vShould`+`v`) ; enl()
		if v.t.cloneIndex == 0 and vIs and vShould:
			index += 1
			v.t.cloneIndex = index
		v = v.threadNext()
	# Make sure the root's clone index is zero.
	root.t.setCloneIndex(0)</t>
<t tx="T890">def writeError(self,message):

	if self.errors == 0:
		es("Errors writing: " + self.targetFileName)
	self.error(message)
	self.root.setOrphan()
	self.root.setDirty()</t>
<t tx="T891">@ Sections appear in the derived file in reference order, not tree order.  Therefore, when we insert the nth child of the parent there is no guarantee that the previous n-1 children have already been inserted. And it won't work just to insert the nth child as the last child if there aren't n-1 previous siblings.  For example, if we insert the third child followed by the second child followed by the first child the second and third children will be out of order.

To ensure that nodes are placed in the correct location we create "dummy" children as needed as placeholders.  In the example above, we would insert two dummy children when inserting the third child.  When inserting the other two children we replace the previously inserted dummy child with the actual children.

vnode child indices are zero-based.  Here we use 1-based indices.

With the "mirroring" scheme it is a structure error if we ever have to create dummy vnodes.  Such structure errors cause a second pass to be made, with an empty root.  This second pass will generate other structure errors, which are ignored.
@c
def createNthChild(self,n,parent,headline):

	assert(n &gt; 0)

	# Create any needed dummy children.
	dummies = n - parent.numberOfChildren() - 1
	if dummies &gt; 0:
		es("dummy created")
		self.structureErrors += 1
	while dummies &gt; 0:
		dummies -= 1
		dummy = parent.insertAsLastChild(leoNodes.tnode())
		# The user should never see this headline.
		dummy.initHeadString("Dummy")

	if n &lt;= parent.numberOfChildren():
		result = parent.nthChild(n-1)
		resulthead = result.headString()
		if string.strip(headline) != string.strip(resulthead):
			es("headline mismatch:")
			es("head1:" + `string.strip(headline)`)
			es("head2:" + `string.strip(resulthead)`)
			self.structureErrors += 1
	else:
		# This is using a dummy; we should already have bumped structureErrors.
		result = parent.insertAsLastChild(leoNodes.tnode())
	result.initHeadString(headline)
	
	result.setVisited() # Suppress all other errors for this node.
	return result</t>
<t tx="T892">@ This function joins all nodes in the two trees which should have the same topology. This code makes no other assumptions about the two trees; some or all of the nodes may already have been joined.

There are several differences between this method and the similar vnode:joinTreeTo method.  First, we can not assert that the two trees have the same topology because the derived file could have been edited outside of Leo.  Second, this method also merges the tnodes of all joined nodes.
@c
def joinTrees(self,tree1,tree2):

	assert(tree1 and tree2)
	# Use a common tnode for both nodes.
	if tree1.t != tree2.t:
		tree1.setT(tree2.t)
	# Join the roots using the vnode class.
	tree1.joinNodeTo(tree2)
	# Recursively join all subtrees.
	child1 = tree1.firstChild()
	child2 = tree2.firstChild()
	while child1 and child2:
		self.joinTrees(child1, child2)
		child1 = child1.next()
		child2 = child2.next()
	if child1 or child2:
		self.readError("cloned nodes have different topologies")</t>
<t tx="T893">@ This method scans all vnodes, calling read for every @file node found.  v should point to the root of the entire tree on entry.

Bug fix: 9/19/01 This routine clears all orphan status bits, so we must set the dirty bit of orphan @file nodes to force the writing of those nodes on saves.  If we didn't do this, a _second_ save of the .leo file would effectively wipe out bad @file nodes!

10/19/01: With the "new" Leo2 there are no such problems, and setting the dirty bit here is still correct.
@c

def readAll(self,root,partialFlag):

	c = self.commands
	c.endEditing() # Capture the current headline.
	anyRead = false
	self.initIvars()
	v = root
	if partialFlag: after = v.nodeAfterTree()
	else: after = None
	while v and v != after:
		if v.isAtIgnoreNode():
			v = v.nodeAfterTree()
		elif v.isAtFileNode():
			anyRead = true
			if partialFlag:
				# We are forcing the read.
				self.read(v,true) # do error recovery
			else:
				# f v is an orphan, we don't expect to see a derived file,
				# and we shall read a derived file if it exists.
				wasOrphan = v.isOrphan()
				ok = self.read(v,true) # do error recovery
				if wasOrphan and not ok:
					# Remind the user to fix the problem.
					v.setDirty()
					c.setChanged(true)
			v = v.nodeAfterTree()
		else: v = v.threadNext()
	# Clear all orphan bits.
	v = root
	while v:
		v.clearOrphan()
		v = v.threadNext()
		
	if partialFlag and not anyRead:
		es("No @file nodes in the selected tree.")</t>
<t tx="T894"># Scans the doc part and appends the text out.
# s,i point to the present line on entry.

def scanDoc(self,file,s,i,out,kind):

	endKind = choose(kind == atFile.startDoc, atFile.endDoc, atFile.endAt)
	single = len(self.endSentinelComment) == 0
	&lt;&lt; Skip the opening sentinel &gt;&gt;
	&lt;&lt; Skip an opening block delim &gt;&gt;
	nextLine = None ; kind = atFile.noSentinel
	while len(s) &gt; 0:
		&lt;&lt; set kind, nextLine &gt;&gt;
		if kind == endKind: break
		&lt;&lt; Skip the leading stuff &gt;&gt;
		&lt;&lt; Append s to out &gt;&gt;
		if nextLine:
			s = nextLine ; nextLine = None
		else: s = file.readline()
	if kind != endKind:
		self.readError("Missing " + self.sentinelName(endKind) + " sentinel")
	&lt;&lt; Remove a closing block delim from out &gt;&gt;</t>
<t tx="T895">assert(match(s,i,choose(kind == atFile.startDoc, "+doc", "+at")))

out.append(choose(kind == atFile.startDoc, "@doc", "@"))
s = file.readline()
</t>
<t tx="T896">if not single:
	j = skip_ws(s,0)
	if match(s,j,self.startSentinelComment):
		s = file.readline()</t>
<t tx="T897">@ For non-sentinel lines we look ahead to see whether the next line is a sentinel.
@c

assert(nextLine==None)

kind = self.sentinelKind(s)

if kind == atFile.noSentinel:
	j = skip_ws(s,0)
	blankLine = s[j] == '\n'
	nextLine = file.readline()
	nextKind = self.sentinelKind(nextLine)
	if blankLine and nextKind == endKind:
		kind = endKind # stop the scan now
</t>
<t tx="T898"># Point i to the start of the real line.

if single: # Skip the opening comment delim and a blank.
	i = skip_ws(s,0)
	if match(s,i,self.startSentinelComment):
		i += len(self.startSentinelComment)
		if match(s,i," "): i += 1
else:
	i = self.skipIndent(s,0, self.indent)
</t>
<t tx="T899"># Append the line with a newline if it is real

line = s[i:-1] # remove newline for rstrip.

if line == string.rstrip(line):
	# no trailing whitespace: the newline is real.
	out.append(line + '\n')
else:
	# trailing whitespace: the newline is not real.
	out.append(line)
</t>
<t tx="T900"># This code will typically only be executed for HTML files.

if 0: ## must be rewritten
	if not single:
		# Remove the ending block delimiter.
		delim = list('\n' + self.endSentinelComment + '\n')
		if out[-len(delim):] == delim:
			# Rewrite the stream.
			out = out[:-len(delim)]</t>
<t tx="T901">@ This method sets mStartSentinelComment and mEndSentinelComment based on the first @+leo sentinel line of the file.  We can not call sentinelKind here because that depends on the comment delimiters we set here.  @first lines are written "verbatim", so nothing more needs to be done!
@c
def scanHeader(self,file):

	valid = true ; tag = "@+leo"
	# Skip any non @+leo lines.
	s = file.readline()
	while len(s) &gt; 0:
		j = string.find(s,tag)
		if j != -1: break
		s = file.readline()
	n = len(s)
	valid = n &gt; 0
	# s contains the tag
	i = j = skip_ws(s,0)
	# The opening comment delim is the initial non-whitespace.
	while i &lt; n and not match(s,i,tag) and not is_ws(s[i]) and not is_nl(s,i):
		i += 1
	if j &lt; i:
		self.startSentinelComment = s[j:i]
	else: valid = false
	# Make sure we have @+leo
	i = skip_ws(s, i)
	if match(s, i, tag):
		i += len(tag)
	else: valid = false
	# The closing comment delim is the trailing non-whitespace.
	i = j = skip_ws(s,i)
	while i &lt; n and not is_ws(s[i]) and not is_nl(s,i):
		i += 1
	self.endSentinelComment = s[j:i]
	if not valid:
		self.readError("Bad @+leo sentinel in " + self.targetFileName)</t>
<t tx="T902">@ This method is the heart of the new read code.  It reads lines from the file until the given ending sentinel is found, and warns if any other ending sentinel is found instead.  It calls itself recursively to handle most nested sentinels.

@c
def scanText (self,file,v,out,endSentinelKind):

	c = self.commands
	lineIndent = 0 ; linep = 0 # Changed only for sentinels.
	s = file.readline() ; nextLine = None
	while len(s) &gt; 0:
		# es("scanText:" + `s`)
		&lt;&lt; set kind, nextKind &gt;&gt;
		if kind != atFile.noSentinel:
			&lt;&lt; set lineIndent, linep and leading_ws &gt;&gt;
			i = self.skipSentinelStart(s,0)
		# All cases must appear here so we can set the next line properly below.
		if kind == atFile.noSentinel:
			&lt;&lt; append non-sentinel line &gt;&gt;
		elif kind == atFile.startAt:
			&lt;&lt; scan @+at &gt;&gt;
		elif kind == atFile.startBody:
			&lt;&lt; scan @+body &gt;&gt;
		elif kind == atFile.startDelims:
			&lt;&lt; scan @delims &gt;&gt;
		elif kind == atFile.startDirective:
			&lt;&lt; scan @@ &gt;&gt;
		elif kind == atFile.startDoc:
			&lt;&lt; scan @+doc &gt;&gt;
		elif kind == atFile.startLeo:
			&lt;&lt; scan @+leo &gt;&gt;
		elif kind == atFile.startNode:
			&lt;&lt; scan @+node &gt;&gt;
		elif kind == atFile.startOthers:
			&lt;&lt; scan @+others &gt;&gt;
		elif kind == atFile.startRef:
			&lt;&lt; scan @ref &gt;&gt;
		elif kind == atFile.startVerbatim:
			&lt;&lt; scan @verbatim &gt;&gt;
		elif ( kind == atFile.endAt or kind == atFile.endBody or
			kind == atFile.endDoc or kind == atFile.endLeo or
			kind == atFile.endNode or kind == atFile.endOthers ):
			&lt;&lt; handle an ending sentinel &gt;&gt;
		else:
			&lt;&lt; warn about unknown sentinel &gt;&gt;
		if nextLine:
			s = nextLine ; nextLine = None
		else: s = file.readline()
	&lt;&lt; handle unexpected end of text &gt;&gt;
</t>
<t tx="T903">@ For non-sentinel lines we look ahead to see whether the next line is a sentinel.  If so, the newline that ends a non-sentinel line belongs to the next sentinel.
@c

assert(nextLine==None)

kind = self.sentinelKind(s)

if kind == atFile.noSentinel:
	nextLine = file.readline()
	nextKind = self.sentinelKind(nextLine)
else:
	nextLine = nextKind = None
</t>
<t tx="T904">@ lineIndent is the total indentation on a sentinel line.  The first "self.indent" portion of that must be removed when recreating text.  leading_ws is the remainder of the leading whitespace.  linep points to the first "real" character of a line, the character following the "indent" whitespace.
@c

# Point linep past the first self.indent whitespace characters.
linep = self.skipIndent(s,0,self.indent)

# Set lineIndent to the total indentation on the line.
lineIndent = 0 ; i = 0
while i &lt; len(s):
	if s[i] == '\t': lineIndent += (c.tab_width - (lineIndent % c.tab_width))
	elif s[i] == ' ': lineIndent += 1
	else: break
	i += 1
# trace("lineIndent:" +`lineIndent` + ", " + `s`)

# Set leading_ws to the additional indentation on the line.
leading_ws = s[linep:i]</t>
<t tx="T905"># We don't output the trailing newline if the next line is a sentinel.

i = self.skipIndent(s,0,self.indent)

assert(nextLine != None)

if nextKind == atFile.noSentinel:
	line = s[i:]
else:
	line = s[i:-1] # don't output the newline

out.append(line)
</t>
<t tx="T906">if kind == endSentinelKind:
	if kind == atFile.endLeo:
		s = file.readline()
		if len(s) &gt; 0:
			self.readError("Ignoring text after @-leo")
	return
else:
	# Tell of the structure error.
	name = self.sentinelName(kind)
	expect = self.sentinelName(endSentinelKind)
	self.readError("Ignoring " + name + " sentinel.  Expecting " + expect)</t>
<t tx="T907"># Issue the error.
name = self.sentinelName(endSentinelKind)
self.readError("Unexpected end of file. Expecting " + name + "sentinel" )
</t>
<t tx="T908">assert(match(s,i,"+at"))
self.scanDoc(file,s,i,out,kind)</t>
<t tx="T909">assert(match(s,i,"+body"))
self.scanText(file,v,out,atFile.endBody)</t>
<t tx="T910">assert(match(s,i,"+doc"))
self.scanDoc(file,s,i,out,kind)</t>
<t tx="T911">assert(match(s,i,"+leo"))
self.readError("Ignoring unexpected @+leo sentinel")</t>
<t tx="T912">assert(match(s,i,"+node:"))
i += 6

childIndex = 0 ; cloneIndex = 0
&lt;&lt; Set childIndex &gt;&gt;
&lt;&lt; Set cloneIndex &gt;&gt;
headline = "" ; ref = "" ;
&lt;&lt; Set headline and ref &gt;&gt;
oldIndent = self.indent ; self.indent = lineIndent

if childIndex == 0: # The root node.
	&lt;&lt; Check the filename in the sentinel &gt;&gt;
	# Put the text of the root node in the current node.
	self.scanText(file,v,out,atFile.endNode)
	v.t.setCloneIndex(cloneIndex)
	# if cloneIndex &gt; 0: trace("clone index:" + `cloneIndex` + ", " + `v`)
	self.indent = oldIndent
else:
	# NB: this call to createNthChild is the bottleneck!
	child = self.createNthChild(childIndex,v,headline)
	child.t.setCloneIndex(cloneIndex)
	# if cloneIndex &gt; 0: trace("clone index:" + `cloneIndex` + ", " + `child`)
	child_out = []
	self.scanText(file,child,child_out,atFile.endNode)
	# If text followed the section reference in the outline,
	# that text will immediately follow the @-node sentinel.
	s = file.readline()
	# es("scanText after ref:" + `s`)
	if len(s) &gt; 1:
		out.append(s)
	if child.isOrphan():
		self.readError("Replacing body text of orphan: " + child.headString())
	body = string.join(child_out, "")
	child.t.setTnodeText(body)
	self.indent = oldIndent
	if len(s) == 1: # don't discard newline
		continue</t>
<t tx="T913">i = skip_ws(s,i) ; j = i
while i &lt; len(s) and s[i] in string.digits:
	i += 1

if j == i or not match(s,i,':'):
	self.readError("Bad child index in @+node")
else:
	childIndex = int(s[j:i])
	i += 1 # Skip the ":".</t>
<t tx="T914">while i &lt; len(s) and s[i] != ':' and not is_nl(s,i):
	if match(s,i,"C="):
		# set cloneIndex from the C=nnn, field
		i += 2 ; j = i
		while i &lt; len(s) and s[i] in string.digits:
			i += 1
		if j &lt; i:
			cloneIndex = int(s[j:i])
	else: i += 1 # Ignore unknown status bits.

if match(s,i,":"):
	i += 1
else:
	self.readError("Bad attribute field in @+node")</t>
<t tx="T915"># Set headline to the rest of the line.
if len(self.endSentinelComment) == 0:
	headline = string.strip(s[i:-1])
else:
	k = string.find(s,self.endSentinelComment,i)
	headline = string.strip(s[i:k]) # works if k == -1

# Set reference if it exists.
i = skip_ws(s,i)
if match(s,i,"&lt;&lt;"):
	k = string.find(s,"&gt;&gt;",i)
	if k != -1: ref = s[i:k+2]</t>
<t tx="T916">fileName = string.strip(headline)

if fileName[:5] == "@file":
	fileName = string.strip(fileName[5:])
	if fileName != self.targetFileName:
		self.readError("File name in @node sentinel does not match file's name")
else:
	self.readError("Missing @file in root @node sentinel")</t>
<t tx="T917">assert(match(s,i,"+others"))

# Make sure that the generated at-others is properly indented.
out.append(leading_ws + "@others")
self.scanText(file,v,out,atFile.endOthers )</t>
<t tx="T918">assert(match(s,i,"@delims"));

# Skip the keyword and whitespace.
i0 = i
i = skip_ws(s,i+7)
	
# Get the first delim.
i1 = i
while i &lt; len(s) and is_ws(s[i]) and not is_nl(s,i):
	i += 1
if i1 &lt; i:
	mStartSentinelComment = s[i1,i]

	# Get the optional second delim.
	i1 = i = skip_ws(s,i)
	while i &lt; len(s) and not is_ws(*i) and not is_nl(*i):
		i += 1
	end = choose(i &gt; i1, s[i1:i], "")
	i2 = skip_ws(s,i)
	if end == mEndSentinelComment and (i2 &gt;= len(s) or is_nl(s,i2)):
		mEndSentinelComment = "" # Not really two params.
		line = s[i0:i1]
		line = string.rstrip(line)
		out.append(line)
	else:
		mEndSentinelComment = end
		line = s[i0:i]
		line = string.rstrip(line)
		out.append(line)
else:
	self.readError("Bad @delims")
	# Append the bad @delims line to the body text.
	out.append("@delims")

</t>
<t tx="T919">@ The sentinel contains an @ followed by a section name in angle brackets.  This code is different from the code for the @@ sentinel: the expansion of the reference does not include a trailing newline.
@c

assert(match(s,i,"&lt;&lt;"))

if len(self.endSentinelComment) == 0:
	line = s[i:-1] # No trailing newline
else:
	k = string.find(s,self.endSentinelComment,i)
	line = s[i:k] # No trailing newline, whatever k is.
	
out.append(line)
</t>
<t tx="T920">assert(match(s,i,"verbatim"))

# Skip the sentinel.
s = file.readline() 

# Append the next line to the text.
i = self.skipIndent(s,0,self.indent)
out.append(s[i:])
</t>
<t tx="T921">assert(match(s,i,"@"))

# The first '@' has already been eaten.
if len(self.endSentinelComment) == 0:
	out.append(s[i:])
else:
	k = string.find(s,self.endSentinelComment,i)
	if k == -1:
		out.append(s[i:])
	else:
		out.append(s[i:k] + '\n')
</t>
<t tx="T922">j = i
i = skip_line(s,i)
line = s[j:i]
self.readError("Unknown sentinel: " + line)</t>
<t tx="T923">def oblank(self):
	self.os(' ')

def oblanks(self,n):
	self.os(' ' * n)

def onl(self):
	self.os("\n")

def os(self,s):
	if self.outputFile:
		self.outputFile.write(s)

def otabs(self,n):
	self.os('\t' * n)</t>
<t tx="T924">@ root is an ancestor of v, or root == v.  This puts the entire expansion of v's body text enclosed in sentinel lines.
@c

def putBody(self,root,v,delta):

	self.indent += delta
	self.putOpenSentinels(root, v)
	self.putBodyPart(v)
	v.setVisited()
	self.putCloseSentinels(root, v)
	self.indent -= delta
</t>
<t tx="T925">@ We generate the body part only if it contains something besides whitespace. The check for at-ignore is made in atFile::write.
@c
def putBodyPart(self,v):

	s = v.t.bodyString
	i = skip_ws_and_nl(s, 0)
	if i &gt;= len(s): return
	s = removeTrailingWs(s) # don't use string.rstrip!
	self.putSentinel("@+body")
	&lt;&lt; put code/doc parts and sentinels &gt;&gt;
	self.putSentinel("@-body")</t>
<t tx="T926">i = 0 ; n = len(s)
while i &lt; n:
	kind = self.directiveKind(s,i)
	j = i
	if kind == atFile.docDirective or kind == atFile.atDirective:
		i = self.putDoc(s,i,v,kind)
	elif kind == atFile.miscDirective:
		i = self.putDirective(s,i)
	elif kind == atFile.noDirective or kind == atFile.othersDirective:
		i = self.putCodePart(s,i,v)
	elif kind == atFile.cDirective or kind == atFile.codeDirective:
		i = self.putDirective(s,i)
		i = self.putCodePart(s,i,v)
	else: assert(0) # We must handle everything that directiveKind returns
	assert(n == len(s))
	assert(j &lt; i) # We must make progress.</t>
<t tx="T927">@ This method expands a code part, terminated by any at-directive except at-others.  It expands references and at-others and outputs @verbatim sentinels as needed.
@c
def putCodePart(self,s,i,v):

	c = self.commands
	atOthersSeen = false # true: at-others has been expanded.
	n = len(s)
	while i &lt; n:
		delta = 0 # How much indent should change.
		&lt;&lt; handle the start of a line &gt;&gt;
		&lt;&lt; put the line &gt;&gt;
	assert(n == len(s))
	return i</t>
<t tx="T928">@ The at-others directive is the only directive that is recognized following leading whitespace, so it is just a little tricky to recognize it.
@c

&lt;&lt; compute delta, the width of the whitespace &gt;&gt;
kind1 = self.directiveKind(s, i)
kind2 = self.directiveKind(s, skip_ws(s,i))
if kind1 == atFile.othersDirective or kind2 == atFile.othersDirective:
	&lt;&lt; handle @others &gt;&gt;
elif kind1 == atFile.noDirective:
	&lt;&lt; put @verbatim sentinel if necessary &gt;&gt;
else:
	return i</t>
<t tx="T929">j = i ; delta = 0
while j &lt; len(s):
	if s[j] == ' ':
		j += 1 ; delta += 1
	elif s[j] == '\t':
		j += 1 ; delta += (c.tab_width - (delta % c.tab_width))
	else: break</t>
<t tx="T930"># This skips all indent and delta whitespace, so putAtOthers must generate it all.
i = skip_to_end_of_line(s, i)
if atOthersSeen:
	self.writeError("@others already expanded in: " + v.headString())
else:
	atOthersSeen = true
	self.putAtOthers(v, delta)</t>
<t tx="T931">if match (s, i, self.startSentinelComment + '@'):
	self.putSentinel("verbatim")</t>
<t tx="T932">self.putIndent(self.indent)

while i &lt; len(s):
	ch = s[i]
	if ch == body_newline:
		self.onl()
		i = skip_nl(s, i)
		break
	elif ch == body_ignored_newline:
		i += 1
	# at-others is recognized _only_ at the start of a line.
	elif ch == '&lt;':
		&lt;&lt; put possible section reference &gt;&gt;
	else:
		self.os(ch)
		i += 1</t>
<t tx="T933">(isSection, j) = self.isSectionName(s, i)

if isSection:
	# Create a reference sentinel.
	name = s[i:j]
	self.putSentinel("@" + name)
	# Output the expansion.
	ref = findReference(name, v)
	if ref:
		self.putBody(v, ref, delta)
	else:
		self.writeError("undefined section: " + name +
			"\n\treferenced from: " + v.headString())
	assert(j &gt; i) # isSectionName must make progress
	i = j
else:
	self.os(s[i]) # This is _not_ an error.
	i += 1</t>
<t tx="T934"># returns (flag, end). end is the index of the character after the section name.

def isSectionName(self,s,i):

	j = i # for traces
	if not match(s,i,"&lt;&lt;"):
		return false, -1
	i = find_on_line(s,i,"&gt;&gt;")
	if i:
		return true, i + 2
	else:
		return false, -1</t>
<t tx="T935">@ Returns true if v should be included in the expansion of the at-others directive in the body text of v's parent. v will not be included if it is a definition node or if its body text contains another at-others or @ignore directive.
@c
def inAtOthers(self,v):

	# Return false if this has been expanded previously.
	if  v.isVisited(): return false
	# Return false if this is a definition node.
	h = v.headString()
	i = skip_ws(h,0)
	isSection, j = self.isSectionName(h,i)
	if isSection: return false
	# Return false if v's body contains an @ignore or at-others directive.
	return not v.isAtIgnoreNode() and not v.isAtOthersNode()</t>
<t tx="T936">@ The at-others directive is recognized only at the start of the line.  This code must generate all leading whitespace for the opening sentinel.
@c
def putAtOthers(self,v,delta):

	self.indent += delta
	self.putSentinel("@+others")
	child = v.firstChild()
	while child:
		if self.inAtOthers( child ):
			self.putAtOthersChild( child )
		child = child.next()
	self.putSentinel("@-others")
	self.indent -= delta</t>
<t tx="T937">def putAtOthersChild(self,v):

	self.putOpenNodeSentinel(v)
	
	# Insert the expansion of v.
	v.setVisited() # Make sure it is never expanded again.
	self.putBodyPart(v)

	# Insert expansions of all children.
	child = v.firstChild()
	while child:
		if self.inAtOthers( child ):
			self.putAtOthersChild( child )
		child = child.next()

	self.putCloseNodeSentinel(v)</t>
<t tx="T938"># This method outputs s, a directive or reference, in a sentinel.

def putDirective(self,s,i):

	tag = "@delims"
	assert(i &lt; len(s) and s[i] == '@')
	k = i
	j = skip_to_end_of_line(s,i)
	directive = s[i:j]

	if match_word(s,k,tag):
		&lt;&lt; handle @delims &gt;&gt;
	else:
		self.putSentinel("@" + directive)

	i = skip_line(s,k)
	return i</t>
<t tx="T939"># Put a space to protect the last delim.
self.putSentinel("@" + directive + " ")

# Skip the keyword and whitespace.
j = i = skip_ws(s,k+len(tag))

# Get the first delim.
while i &lt; len(s) and not is_ws(s[i]) and not is_nl(s,i):
	i += 1
if j &lt; i:
	self.startSentinelComment = s[j:i]
	# Get the optional second delim.
	j = i = skip_ws(s,i)
	while i &lt; len(s) and not is_ws(s[i]) and not is_nl(s,i):
		i += 1
	self.endSentinelComment = choose(j&lt;i, s[j:i], "")
else:
	writeError("Bad @delims directive")</t>
<t tx="T940">@ This method outputs a doc section terminated by @code or end-of-text.  All other interior directives become part of the doc part.
@c
def putDoc(self,s,i,v,kind):

	if kind == atFile.atDirective:
		i += 1 ; tag = "at"
	elif kind == atFile.docDirective:
		i += 4 ; tag = "doc"
	else: assert(0)
	# Set j to the end of the doc part.
	n = len(s) ; j = i
	while j &lt; n:
		j = skip_line(s, j)
		kind = self.directiveKind(s, j)
		if kind == atFile.codeDirective or kind == atFile.cDirective:
			break
	self.putSentinel("@+" + tag)
	self.putDocPart(s[i:j])
	self.putSentinel("@-" + tag)
	return j</t>
<t tx="T941"># Puts a comment part in comments.

def putDocPart(self,s):

	# j = skip_line(s,0) ; trace(`s[:j]`)
	c = self.commands
	single = len(self.endSentinelComment) == 0
	if not single:
		self.putIndent(self.indent)
		self.os(self.startSentinelComment) ; self.onl()
	# Put all lines.
	i = 0 ; n = len(s)
	while i &lt; n:
		self.putIndent(self.indent)
		leading = self.indent
		if single:
			self.os(self.startSentinelComment) ; self.oblank()
			leading += len(self.startSentinelComment) + 1
		&lt;&lt; copy words, splitting the line if needed &gt;&gt;
	if not single:
		# This comment is like a sentinel.
		self.onl() ; self.putIndent(self.indent)
		self.os(self.endSentinelComment)
		self.onl() # Note: no trailing whitespace.</t>
<t tx="T942">@ We remove trailing whitespace from lines that have _not_ been split so that a newline has been inserted by this routine if and only if it is preceded by whitespace.
@c

line = i # Start of the current line.
while i &lt; n:
	word = i # Start of the current word.
	# Skip the next word and trailing whitespace.
	i = skip_ws(s, i)
	while i &lt; n and not is_nl(s,i) and not is_ws(s[i]):
		i += 1
	i = skip_ws(s,i)
	# Output the line if no more is left.
	if i &lt; n and is_nl(s,i):
		break
	# Split the line before the current word if needed.
	lineLen = i - line
	if line == word or leading + lineLen &lt; c.page_width:
		word = i # Advance to the next word.
	else:
		# Write the line before the current word and insert a newline.
		theLine = s[line:word]
		self.os(theLine)
		self.onl() # This line must contain trailing whitespace.
		line = i = word  # Put word on the next line.
		break
# Remove trailing whitespace and output the remainder of the line.
theLine = string.rstrip(s[line:i]) # from right.
self.os(theLine)
if i &lt; n and is_nl(s,i):
	i = skip_nl(s,i)
	self.onl() # No inserted newline and no trailing whitespace.</t>
<t tx="T943"># Puts tabs and spaces corresponding to n spaces, assuming that we are at the start of a line.

def putIndent(self,n):

	c = self.commands
	if c.tab_width &gt; 1:
		self.otabs  (n / c.tab_width)
		self.oblanks(n % c.tab_width)
	else:
		self.oblanks(n)</t>
<t tx="T944">@ This method scans all vnodes, calling write for every @file node found.  If partialFlag is true we write all @file nodes in the selected outline.  Otherwise we write @file nodes in the entire outline.
@c
def writeAll(self,v,partialFlag):

	self.initIvars()
	# Kludge: look at whole tree if forceFlag is false;
	if partialFlag: after = v.nodeAfterTree()
	else: after = None
	&lt;&lt; Clear all orphan bits &gt;&gt;
	written = false
	while v and v != after:
		if v.isAtIgnoreNode():
			v = v.nodeAfterTree()
		elif v.isAtFileNode():
			if v.isDirty() or partialFlag:
				self.write(v)
				written = true
			v = v.nodeAfterTree()
		else: v = v.threadNext()
	if partialFlag and not written:
		es("No @file nodes in the selected tree.")</t>
<t tx="T945">@ We must clear these bits because they may have been set on a previous write.  Calls to atFile::write may set the orphan bits in @file nodes.  If so, write_LEO_file will write the entire @file tree.
@c

v2 = v
while v2 and v2 != after:
	v2.clearOrphan()
	v2 = v2.threadNext()</t>
<t tx="T946">def scanAll(self):

	c = self.commands
	v = c.tree.rootVnode
	while v:
		if v.isAtIgnoreNode():
			v = v.nodeAfterTree()
		elif v.isAtFileNode():
			self.scanFile(v)
			v = v.nodeAfterTree()
		else: v = v.threadNext()
</t>
<t tx="T947">def scanFile(self,root):

	c = self.commands
	es("scanning: " + root.headString())
	self.targetFileName = root.atFileNodeName()
	self.root = root
	self.errors = self.structureErrors = 0
	&lt;&lt; open file &gt;&gt;
	if self.errors &gt; 0: return 0
	&lt;&lt; Scan the file buffer &gt;&gt;
	next = root.nodeAfterTree()
	if self.structureErrors &gt; 0:
		self.readError(`self.structureErrors` + " errors scanning file")
	return self.errors == 0
</t>
<t tx="T948">if len(self.targetFileName) == 0:
	self.readError("Missing file name")
else:
	try:
		file = open(self.targetFileName,'r')
	except:
		self.readError("Error reading file")
</t>
<t tx="T949">self.indent = 0
out = []
self.scanHeader(file)
self.scanText(file,root,out,atFile.endLeo)
s = string.join(out, "")
root.setBodyStringOrPane(s)</t>
<t tx="T950"># Syntax coloring routines for Leo.py

from leoGlobals import *
from leoUtils import *
import string, Tkinter

&lt;&lt; define colorizer constants &gt;&gt;
&lt;&lt; define colorizer keywords &gt;&gt;
&lt;&lt; define colorizer functions &gt;&gt;

class colorizer:
	@others</t>
<t tx="T951"># We only define states that can continue across lines.
normalState, docState, nocolorState, string3State = 1,2,3,4</t>
<t tx="T952">pythonKeywords = (
	"and",       "del",       "for",       "is",        "raise",    
	"assert",    "elif",      "from",      "lambda",    "return",   
	"break",     "else",      "global",    "not",       "try",      
	"class",     "except",    "if",        "or",        "yield",   
	"continue",  "exec",      "import",    "pass",      "while",
	"def",       "finally",   "in",        "print")

leoKeywords = (
	# Leo 2 directives
	"@",		"@c", 		"@code",	"@doc",
	"@color",	"@comment",	"@delims",	"@first",
	"@language","@nocolor",	"@others",	"@pagewidth",
	"@path", 	"@tabwidth",
	
	# Leo 1 directives
	"@cweb",	"@ignore", "@noweb",	"@root",	"@unit",
	"@silent",	"@terse",	"@verbose")</t>
<t tx="T953">def index(i,j):

	if type(i) != type("end"):
		i = `i`
	if type(j) != type("end"):
		j = `j`
	return i + '.' + j
</t>
<t tx="T954">def OnHyperLinkControlClick (self,v):

	pass</t>
<t tx="T955">def OnHyperLinkEnter (self,v):

	pass # trace(`v` + ", " + `v.tagName`)</t>
<t tx="T956">def OnHyperLinkLeave (self,v):

	pass # trace(`v`)</t>
<t tx="T957">def colorize(self,v,body):

	if self.enabled:
		type = self.updateSyntaxColorer(v)

		if type == python_language:
			self.colorizePython(v,body)
		else:
			self.colorizePlain(v,body)</t>
<t tx="T958">def colorizePlain(self,v,body):

	# Remove all tags from body.
	body.tag_delete(
		"comment", "docPart", "keyword", "leoKeyword",
		"name", "nameBrackets", "string")</t>
<t tx="T959">def schedule(self,v,body):

	if self.enabled:
		body.after_idle(self.idle_colorize,v,body)
		
def idle_colorize(self,v,body):

	# trace(`v` + ", " + `body`)
	if v and body and self.enabled:
		self.colorize(v,body)</t>
<t tx="T960"># Returns the language to be used for syntax coloring of v.

def updateSyntaxColorer (self,v):

	if self.useSyntaxColoring(v):
		return self.scanColorDirectives(v)
	else:
		return plain_text_language</t>
<t tx="T961"># Return true if v is unambiguously under the control of @nocolor or @owncolor.

def useSyntaxColoring (self,v):

	first = v ; val = true
	while v:
		s = v.t.bodyString
		bits, dict = is_special_bits(s,dont_set_root_from_headline)
		no_color = ( bits &amp; nocolor_bits ) != 0
		color = ( bits &amp; color_bits ) != 0
		# trace(`bits` + ", " + `v`)
		# A color anywhere in the target enables coloring.
		if color and v == first:
			val = true ; break
		# Otherwise, the specification must be unambiguous.
		elif no_color and not color:
			val = false ; break
		elif color and not no_color:
			val = true ; break
		else:
			v = v.parent()
	trace("-useSyntaxColoring",`val`)
	return val</t>
<t tx="T962">@ These methods are like the corresponding functions in leoUtils.py except they issue no error messages.
</t>
<t tx="T963">def skip_id(self,s,i):

	n = len(s)
	while i &lt; n:
		ch = s[i]
		if ch in string.letters or ch in string.digits or ch == '_':
			i += 1
		else: break
	return i
</t>
<t tx="T964">def skip_python_string(self,s,i):

	delim = s[i:i+3]
	if delim == "'''" or delim == '"""':
		k = string.find(s,delim,i+3)
		if k == -1:
			return len(s), string3State
		else:
			return k+3, normalState
	else:
		return self.skip_string(s,i), normalState
</t>
<t tx="T965">def skip_string(self,s,i):
	
	j = i ; delim = s[i] ; i += 1
	assert(delim == '"' or delim == '\'')
	n = len(s)
	while i &lt; n and s[i] != delim:
		if s[i] == '\\' : i += 2
		else: i += 1

	if i &gt;= n:
		return n
	elif s[i] == delim:
		i += 1
	return i</t>
<t tx="T966">@ This class implements the most basic commands.  All other commanders contain an commands ivar that points to an instance of this class.
@c

from leoGlobals import *
from leoUtils import *

import leoAtFile
import leoFileCommands
import leoTangle

class Commands:
	&lt;&lt; Commands constants &gt;&gt;
	@others</t>
<t tx="T967"># The code assumes that the "redo" constants are one more than the corresponding "undo" constants.

CANT_UNDO = 0
UNDO_CLONE = 1 ; REDO_CLONE = 2
UNDO_DELETE_OUTLINE = 3 ; REDO_DELETE_OUTLINE = 4
UNDO_DEMOTE = 5 ; REDO_DEMOTE = 6
UNDO_DRAG = 7 ; REDO_DRAG = 8
UNDO_INSERT_OUTLINE = 9 ; REDO_INSERT_OUTLINE = 10
UNDO_MOVE = 11 ; REDO_MOVE = 12
UNDO_PROMOTE = 13 ; REDO_PROMOTE = 14</t>
<t tx="T968">def __init__(self,frame):

	# trace("__init__", "c.__init__")
	self.frame = frame
	self.initIvars(frame)

	# initialize the sub-commanders
	self.fileCommands = leoFileCommands.fileCommands(self)
	self.atFileCommands = leoAtFile.atFile(self)
	# self.importCommands = leoImportCommands.importCommands(self)
	self.tangleCommands = leoTangle.tangleCommands(self)

def initIvars(self, frame):
	&lt;&lt; initialize ivars &gt;&gt;</t>
<t tx="T969"># per-document info...
self.expansionLevel = 0  # The expansion level of this outline.
self.changed = false # true if any data has been changed since the last save.
self.loading = false # true if we are loading a file: disables c.setChanged()

# undo info...
self.undoDVnodes = None  # Undo info for delete.
self.undoLastChild = None  # Undo info for promote &amp; demote.
self.undoType = 0  # Set by Commands::setUndoParams...
self.undoVnode = self.undoParent = self.undoBack = None
self.undoN = 0

# copies of frame info
self.body = frame.body
self.log = frame.log
self.tree = frame.tree
self.canvas = frame.canvas

# For tangle/untangle
self.tangle_errrors = 0

self.setIvarsFromPrefs()
self.setIvarsFromFind()</t>
<t tx="T970">def __del__ (self):

	# Can't trace while destroying.
	# print "c.__del__"
	pass</t>
<t tx="T971">def __repr__ (self):

	return "Commander: " + self.frame.title
</t>
<t tx="T972"># This should be called whenever we need to use preference:
# i.e., before reading, writing, tangling, untangling.

def setIvarsFromPrefs (self):

	c = self ; prefs = app().prefsFrame
	if prefs:
		prefs.set_ivars(c)</t>
<t tx="T973"># This should be called whenever we need to use find values:
# i.e., before reading or writing

def setIvarsFromFind (self):

	c = self ; find = app().findFrame
	if find:
		find.set_ivars(c)
</t>
<t tx="T974">def beginUpdate(self):

	self.tree.beginUpdate()
	
BeginUpdate = beginUpdate # Compatibility with old scripts</t>
<t tx="T975">def bringToFront(self):

	self.frame.top.deiconify()

BringToFront = bringToFront # Compatibility with old scripts</t>
<t tx="T976">def endUpdate(self, flag=true):
	
	self.tree.endUpdate(flag)
	
EndUpdate = endUpdate # Compatibility with old scripts</t>
<t tx="T977">def recolor(self):

	tree = self.tree
	tree.recolor(tree.currentVnode)</t>
<t tx="T978">def redraw(self):

	self.tree.redraw()
	
# Compatibility with old scripts
Redraw = redraw 
repaint = redraw
Repaint = redraw</t>
<t tx="T979">def contractAllHeadlines(self):

	c = self
	current = c.tree.currentVnode
	v = c.tree.rootVnode
	c.beginUpdate()
	while v:
		c.contractSubtree(v)
		v = v.next()
	if not current.isVisible():
		c.selectVnode(c.tree.rootVnode)
	c.endUpdate()
	c.expansionLevel = 1 # Reset expansion level.</t>
<t tx="T980"># Contracts all offspring of the current node.

def contractAllSubheads(self):

	c = self
	v = c.tree.currentVnode
	if not v: return
	child = v.firstChild()
	c.beginUpdate()
	while child:
		c.contractSubtree(child)
		child = child.next()
	c.endUpdate()
	c.selectVnode(v) # Needed?
	c.expansionLevel = 0</t>
<t tx="T981">def contractParent (self):
	
	c = self ; v = c.currentVnode()
	parent = v.parent()
	if not parent: return
	
	c.beginUpdate()
	c.selectVnode(parent)
	parent.contract()
	c.endUpdate()</t>
<t tx="T982"># Contracts the children of the current node.

def contractSubheads(self):

	c = self
	v = c.tree.currentVnode
	if not v: return
	child = v.firstChild()
	c.beginUpdate()
	while child:
		c.contractVnode(child)
		child = child.next()
	c.endUpdate()
	c.selectVnode(v) # Needed?
	c.expansionLevel = 0</t>
<t tx="T983">def expandLevel1(self):

	self.expandToLevel(1)</t>
<t tx="T984">def expandLevel2(self):

	self.expandToLevel(2)</t>
<t tx="T985">def expandLevel3(self):

	self.expandToLevel(3)</t>
<t tx="T986">def expandLevel4(self):

	self.expandToLevel(4)</t>
<t tx="T987">def expandLevel5(self):

	self.expandToLevel(5)</t>
<t tx="T988">def expandLevel6(self):

	self.expandToLevel(6)</t>
<t tx="T989">def expandLevel7(self):

	self.expandToLevel(7)</t>
<t tx="T990">def expandLevel8(self):

	self.expandToLevel(8)</t>
<t tx="T991">def expandLevel9(self):

	self.expandToLevel(9)</t>
<t tx="T992">def expandNextLevel(self):

	c = self
	self.expandToLevel(c.expansionLevel + 1)</t>
<t tx="T993">def expandAllHeadlines(self):

	c = self
	v = root = c.tree.rootVnode
	c.beginUpdate()
	while v:
		c.expandSubtree(v)
		v = v.next()
	c.selectVnode(root)
	c.endUpdate()
	c.expansionLevel = 0 # Reset expansion level.</t>
<t tx="T994">def expandAllSubheads(self):

	c = self
	v = c.tree.currentVnode
	if not v: return
	child = v.firstChild()
	c.beginUpdate()
	c.expandSubtree(v)
	while child:
		c.expandSubtree(child)
		child = child.next()
	c.selectVnode(v)
	c.endUpdate()</t>
<t tx="T995">def expandSubheads(self):

	c = self
	v = c.tree.currentVnode
	if not v: return
	child = v.firstChild()
	c.beginUpdate()
	c.expandVnode(v)
	while child:
		c.expandVnode(child)
		child = child.next()
	c.selectVnode(v)
	c.endUpdate()</t>
<t tx="T996">def contractSubtree(self,v):

	c = self
	last = v.lastNode()
	while v and v != last:
		v.contract()
		v = v.threadNext()</t>
<t tx="T997">def contractVnode(self,v):

	v.contract()
	self.tree.redraw()</t>
<t tx="T998">def expandSubtree(self,v):

	c = self
	last = v.lastNode()
	while v and v != last:
		v.expand()
		v = v.threadNext()
	c.tree.redraw()</t>
<t tx="T999">def expandToLevel(self,level):

	c = self
	c.beginUpdate()
	# First contract everything.
	c.contractAllHeadlines()
	# Start the recursion.
	v = c.tree.rootVnode
	while v:
		c.expandTreeToLevelFromLevel(v,level,1)
		v = v.next()
	c.expansionLevel = level
	c.endUpdate()</t>
<t tx="T1000">def expandVnode(self,v):

	c = self
	v.expand()</t>
<t tx="T1001">def expandTreeToLevelFromLevel(self,v,toLevel,fromLevel):

	if toLevel &lt;= fromLevel: return
	c = self
	while v:
		# Expand this node.
		c.expandVnode(v)
		# Recursively expand lower levels.
		c.expandTreeToLevelFromLevel(v.firstChild(),toLevel,fromLevel + 1)
		v = v.next()</t>
<t tx="T1002"># Compatibility with scripts

def currentVnode (self):

	return self.tree.currentVnode
</t>
<t tx="T1003">def clearAllMarked(self):

	c = self
	v = c.tree.rootVnode
	while v:
		v.clearMarked()
		v = v.threadNext()</t>
<t tx="T1004">def clearAllVisited(self):

	c = self
	v = c.tree.rootVnode
	
	c.beginUpdate()
	while v:
		v.clearVisited()
		if v.t:
			v.t.clearVisited()
		v = v.threadNext()
	c.endUpdate(false) # never redraw the tree.
</t>
<t tx="T1005"># Compatibility with scripts

def fileName (self):

	return self.frame.mFileName
</t>
<t tx="T1006">def isChanged (self):

	return self.changed</t>
<t tx="T1007"># Compatibility with scripts

def rootVnode (self):

	return self.tree.rootVnode
</t>
<t tx="T1008">def setChanged(self,changedFlag):

	c = self
	if not c.frame: return
	# Clear all dirty bits _before_ setting the caption.
	# 9/15/01 Clear all dirty bits except orphaned @file nodes
	if not changedFlag:
		v = c.tree.rootVnode
		while v:
			if v.isDirty() and not v.isAtFileNode():
				v.clearDirtyJoined()
			v = v.threadNext()
	# Update all derived changed markers.
	c.changed = changedFlag
	s = c.frame.top.title()
	if len(s) &gt; 2 and not c.loading: # don't update while loading.
		if changedFlag:
			if s [0] != '*': c.frame.top.title("* " + s)
		else:
			if s[0:2]=="* ": c.frame.top.title(s[2:])</t>
<t tx="T1009"># Returns false if any node of tree is a clone of parent or any of parents ancestors.

def checkMoveWithParentWithWarning(self,tree,parent,warningFlag):

	c = self
	next = tree.nodeAfterTree()
	message = "Illegal move or drag: no clone may contain a clone of itself"
	while parent:
		if parent.isCloned():
			v = tree
			while v and v != next:
				if v.t== parent.t:
					if warningFlag:
						alert(message)
					return false
				v = v.threadNext()
		parent = parent.parent()
	return true</t>
<t tx="T1010">def clone(self):

	c = self ; v = c.tree.currentVnode
	if not v: return
	c.beginUpdate()
	clone = v.clone(v)
	if clone:
		clone.setDirty() # essential in Leo2
		c.setChanged(true)
		if c.validateOutline():
			c.selectVnode(clone)
			c.setUndoParams(Commands.UNDO_CLONE,clone)
	c.endUpdate() # updates all icons</t>
<t tx="T1011"># Deletes the current vnode and dependent nodes. Does nothing if the outline would become empty.

def deleteHeadline(self):

	c = self
	v = c.tree.currentVnode
	if not v: return
	vBack = v.visBack()
	# Bug fix: 1/18/00: if vBack is NULL we are at the top level,
	# the next node should be v.next(), _not_ v.visNext();
	if vBack: newNode = vBack
	else: newNode = v.next()
	if not newNode: return
	c.setUndoParams(Commands.UNDO_DELETE_OUTLINE,v)
	c.endEditing()# Make sure we capture the headline for Undo.
	c.beginUpdate()
	v.setDirty() # 1/30/02: Mark @file nodes dirty!
	c.undoDVnodes = v.doDelete(newNode) # doDelete destroys dependents.
	c.setChanged(true)
	c.endUpdate()
	c.validateOutline()</t>
<t tx="T1012">@ This function initializes all clone bits in the entire outline's tree.
@c

def initAllCloneBits(self):

	c=self
	c.clearAllVisited()
	v = self.tree.rootVnode
	c.beginUpdate()
	while v:
		if v.isVisited():
			v = v.threadNext()
			continue
		mark = v.shouldBeClone()
		# Mark all nodes joined to v.
		v2 = v.getJoinList()
		while v2 and v2 != v:
			v2.setVisited()
			# Important speedup: only change the bit if it needs changing.
			if not mark and v2.isCloned():
				v2.clearClonedBit()
			elif mark and not v2.isCloned():
				v2.setClonedBit()
			v2 = v2.getJoinList()
		# Mark v.
		v.setVisited()
		if not mark and v.isCloned():
			v.clearClonedBit()
		elif mark and not v.isCloned():
			v.setClonedBit()
		v = v.threadNext()
	c.endUpdate()</t>
<t tx="T1013"># Inserts a vnode after the current vnode.  All details are handled by the vnode class.

def insertHeadline(self):

	c = self ; current = c.tree.currentVnode
	if not current: return
	c.beginUpdate()
	if 1: # inside update...
		if current.hasChildren() and current.isExpanded():
			v = current.insertAsNthChild(0)
		else:
			v = current.insertAfter()
		v.createDependents() # To handle effects of clones.
		c.setUndoParams(Commands.UNDO_INSERT_OUTLINE,v)
		c.selectVnode(v)
		v.setDirty() # Essential in Leo2.
		c.setChanged(true)
	c.endUpdate()
	c.editVnode(v)</t>
<t tx="T1014"># Makes sure all nodes are valid.

def validateOutline(self):

	c = self
	root = c.tree.rootVnode
	if root:
		return root.validateOutlineWithParent(None)
	else:
		return true</t>
<t tx="T1015">def goToNextDirtyHeadline(self):

	c = self
	current = c.tree.currentVnode
	if not current: return
	v = current.threadNext()
	while v and not v.isDirty():
		v = v.threadNext()
	if not v:
		v = c.tree.rootVnode
		while v and not v.isDirty():
			v = v.threadNext()
	if v:
		c.selectVnode(v)</t>
<t tx="T1016">def goToNextMarkedHeadline(self):

	c = self
	current = c.tree.currentVnode
	if not current: return
	v = current.threadNext()
	while v and not v.isMarked():
		v = v.threadNext()
	if v:
		c.beginUpdate()
		c.endEditing()
		c.selectVnode(v)
		c.endUpdate()</t>
<t tx="T1017">def markChangedHeadlines(self):

	c = self
	v = c.tree.rootVnode
	c.beginUpdate()
	while v:
		if v.isDirty()and not v.isMarked():
			v.setMarked()
			c.setChanged(true)
		v = v.threadNext()
	c.endUpdate()</t>
<t tx="T1018">def markChangedRoots(self):

	c = self
	v = c.tree.rootVnode
	c.beginUpdate()
	while v:
		if v.isDirty()and not v.isMarked():
			s = v.t.bodyString
			flag, i = is_special(s,"@root")
			if flag:
				v.setMarked()
				c.setChanged(true)
		v = v.threadNext()
	c.endUpdate()</t>
<t tx="T1019">def markAllAtFileNodesDirty(self):

	c = self
	v = c.tree.rootVnode
	c.beginUpdate()
	while v:
		if v.isAtFileNode()and not v.isDirty():
			v.setDirty()
			v = v.nodeAfterTree()
		else: v = v.threadNext()
	c.endUpdate()</t>
<t tx="T1020">def markAtFileNodesDirty(self):

	c = self
	v = c.tree.currentVnode
	if not v: return
	after = v.nodeAfterTree()
	c.beginUpdate()
	while v and v != after:
		if v.isAtFileNode() and not v.isDirty():
			v.setDirty()
			v = v.nodeAfterTree()
		else: v = v.threadNext()
	c.endUpdate()</t>
<t tx="T1021">def markHeadline(self):

	c = self ; v = c.tree.currentVnode
	if not v: return
	c.beginUpdate()
	if v.isMarked():
		v.clearMarked()
	else:
		v.setMarked()
		v.setDirty()
		c.setChanged(true)
	c.endUpdate()</t>
<t tx="T1022">def markSubheads(self):

	c = self ; v = c.tree.currentVnode
	if not v: return
	child = v.firstChild()
	c.beginUpdate()
	while child:
		if not child.isMarked():
			child.setMarked()
			child.setDirty()
			c.setChanged(true)
		child = child.next()
	c.endUpdate()</t>
<t tx="T1023">def unmarkAll(self):

	c = self ; v = c.tree.rootVnode
	c.beginUpdate()
	while v:
		if v.isMarked():
			v.clearMarked()
			v.setDirty()
			c.setChanged(true)
		v = v.threadNext()
	c.endUpdate()</t>
<t tx="T1024">def demote(self):

	c = self ; v = c.tree.currentVnode
	if not v or not v.next(): return
	# Make sure all the moves will be valid.
	child = v.next()
	while child:
		if not c.checkMoveWithParentWithWarning(child,v,true):
			return
		child = child.next()
	c.setUndoParams(Commands.UNDO_DEMOTE,v)
	c.beginUpdate()
	c.mInhibitOnTreeChanged = true
	c.endEditing()
	while v.next():
		child = v.next()
		child.moveToNthChildOf(v,v.numberOfChildren())
		c.undoLastChild = child # For undo.
	c.expandVnode(v)
	c.selectVnode(v)
	v.setDirty()
	c.setChanged(true)
	c.mInhibitOnTreeChanged = false
	c.endUpdate()
	c.updateSyntaxColorer(v) # Moving can change syntax coloring.</t>
<t tx="T1025">@ Moving down is more tricky than moving up; we can't move v to be a child of itself.  An important optimization:  we don't have to call checkMoveWithParentWithWarning() if the parent of the moved node remains the same.
@c

def moveOutlineDown(self):

	c = self
	v = c.tree.currentVnode
	if not v: return
	# Set next to the node after which v will be moved.
	next = v.visNext()
	while next and v.isAncestorOf(next):
		next = next.visNext()
	if not next: return
	c.beginUpdate()
	if 1: # inside update...
		c.endEditing()
		v.setDirty()
		&lt;&lt; Move v down &gt;&gt;
		v.setDirty() # This second call is essential.
		c.selectVnode(v)# 4/23/01
		c.setChanged(true)
	c.endUpdate()
	c.updateSyntaxColorer(v) # Moving can change syntax coloring.</t>
<t tx="T1026">if next.hasChildren() and next.isExpanded():
	# Attempt to move v to the first child of next.
	if c.checkMoveWithParentWithWarning(v,next,true):
		c.setUndoParams(Commands.UNDO_MOVE,v)
		v.moveToNthChildOf(next,0)
else:
	# Attempt to move v after next.
	if c.checkMoveWithParentWithWarning(v,next.parent(),true):
		c.setUndoParams(Commands.UNDO_MOVE,v)
		v.moveAfter(next)</t>
<t tx="T1027">def moveOutlineLeft(self):

	c = self
	v = c.tree.currentVnode
	if not v: return
	parent = v.parent()
	if not parent: return
	c.beginUpdate()
	if 1: # inside update...
		c.endEditing()
		c.setUndoParams(Commands.UNDO_MOVE,v)
		v.setDirty()
		v.moveAfter(parent)
		v.setDirty()
		c.selectVnode(v)
		c.setChanged(true)
	c.endUpdate()
	c.updateSyntaxColorer(v) # Moving can change syntax coloring.</t>
<t tx="T1028">def moveOutlineRight(self):

	c = self
	v = c.tree.currentVnode
	if not v: return
	back = v.back()
	if not back: return
	if not c.checkMoveWithParentWithWarning(v,back,true): return
	c.beginUpdate()
	if 1: # inside update...
		c.endEditing()
		c.setUndoParams(Commands.UNDO_MOVE,v)
		v.setDirty()
		n = back.numberOfChildren()
		v.moveToNthChildOf(back,n)
		v.setDirty()
		c.selectVnode(v)
		c.setChanged(true)
	c.endUpdate()
	c.updateSyntaxColorer(v) # Moving can change syntax coloring.</t>
<t tx="T1029">def moveOutlineUp(self):

	c = self
	v = c.tree.currentVnode
	if not v: return
	back = v.visBack()
	if not back: return
	back2 = back.visBack()
	c = self
	c.beginUpdate()
	if 1: # inside update...
		c.endEditing()
		v.setDirty()
		&lt;&lt; Move v up &gt;&gt;
		v.setDirty()
		c.selectVnode(v)
		c.setChanged(true)
	c.endUpdate()
	c.updateSyntaxColorer(v) # Moving can change syntax coloring.</t>
<t tx="T1030">if not back2:
	# v will be the new root node
	c.setUndoParams(Commands.UNDO_MOVE,v)
	back.moveAfter(v)
elif back2.hasChildren() and back2.isExpanded():
	if c.checkMoveWithParentWithWarning(v,back2,true):
		c.setUndoParams(Commands.UNDO_MOVE,v)
		v.moveToNthChildOf(back2,0)
elif c.checkMoveWithParentWithWarning(v,back2.parent(),true):
	# Insert after back2.
	c.setUndoParams(Commands.UNDO_MOVE,v)
	v.moveAfter(back2)</t>
<t tx="T1031">def promote(self):

	c = self
	v = c.tree.currentVnode
	if not v or not v.hasChildren(): return
	c.beginUpdate()
	if 1: # inside update...
		c.endEditing()
		after = v
		c.setUndoParams(Commands.UNDO_PROMOTE,v)
		while v.hasChildren():
			child = v.firstChild()
			child.moveAfter(after)
			after = child
			c.undoLastChild = child # for undo.
		v.setDirty()
		c.setChanged(true)
		c.selectVnode(v)
	c.endUpdate()
	c.updateSyntaxColorer(v) # Moving can change syntax coloring.</t>
<t tx="T1032"># Selects v: sets the focus to v and edits v.

def editVnode(self,v):

	c = self
	if v:
		c.selectVnode(v)
		c.tree.editLabel(v)</t>
<t tx="T1033"># Ends the editing in the outline.

def endEditing(self):

	self.tree.endEditLabel()
</t>
<t tx="T1034"># This is called inside commands to select a new vnode.

def selectVnode(self,v):

	# All updating and "synching" of nodes are now done in the event handlers!
	c = self
	c.tree.endEditLabel()
	c.tree.select(v)
	c.body.mark_set("insert","1.0")
	# c.body.see("1.0")
	c.body.focus_force()
	self.editing = false</t>
<t tx="T1035"># Selects the given node and enables editing of the headline if editFlag is true.

def selectVnodeWithEditing(self,v,editFlag):

	c = self
	if editFlag:
		c.editVnode(v)
	else:
		c.selectVnode(v)
</t>
<t tx="T1036">@ These routines provide a convenient interface to the syntax colorer.
</t>
<t tx="T1037">def updateSyntaxColorer(self,v):

	self.tree.colorizer.updateSyntaxColorer(v)
</t>
<t tx="T1038">@ The following routines handle the many details associated with undoing an outline operation. All operations that may be undone call setUndoParams()to remember enough information to undo the operation.
</t>
<t tx="T1039">def canUndo(self):

	c = self
	return c.undoType != Commands.CANT_UNDO</t>
<t tx="T1040">def undoCaption(self):

	captionDict = {} ## not ready yet
	c = self
	if captionDict.has_key(c.undoType):
		return captionDict[c.undoType]
	else:
		return "Undo"</t>
<t tx="T1041">def findSharedVnode(self,target):

	c = self
	v = c.tree.rootVnode
	t = target.t
	while v:
		if v != target and v.t== t:
			return v
		v = v.threadNext()
	return None</t>
<t tx="T1042">@ This routine saves enough information so an operation can be undone.  This routine should be called before performing the operation so that the previous state is saved.
@c

def setUndoParams(self,undo_type,v):

	# Remember the undo parameters
	c = self
	c.undoType = undo_type
	c.undoVnode = v
	c.undoParent = v.parent()
	c.undoBack = v.back()
	c.undoN = choose(c.undoParent, v.childIndex(), 0)</t>
<t tx="T1043">@ This function and its allies, undoPromote() and undoDenote(), undo the operation described by the undo parmaters.
@c

def undo(self):

	c = self
	if c.undoType == Commands.CANT_UNDO: return
	current = c.tree.currentVnode
	if current:
		vBack = vNext = shared = None
		&lt;&lt; save the undo vars in local vars &gt;&gt;
		c.beginUpdate()
		&lt;&lt; clone cases &gt;&gt;
		&lt;&lt; insert cases &gt;&gt;
		&lt;&lt; delete cases &gt;&gt;
		&lt;&lt; move cases &gt;&gt;
		&lt;&lt; promote and demote cases &gt;&gt;
		c.setChanged(true)
		if v: v.setDirty()
		c.endUpdate()</t>
<t tx="T1044">@ setUndoParams will alter the undo variables, so we preserve these variables by copying them to local vars.
@c

old_type = c.undoType
v = c.undoVnode
parent = c.undoParent
back = c.undoBack
dv = c.undoDVnodes
undoN = c.undoN</t>
<t tx="T1045"># We can immediately delete c because clone() can recreate it using only v.
if c.undoType == Commands.UNDO_CLONE:

	c.selectVnode(v)
	c.deleteHeadline()
	c.undoType = Commands.REDO_CLONE

elif c.undoType == Commands.REDO_CLONE:
	v = current.restoreOutlineFromDVnodes(dv,parent,back)
	shared = c.findSharedVnode(v)
	if shared: v.joinTreeTo(shared)
	v.createDependents()
	if v.shouldBeClone():
		# Optimizations make setting the icon a bit tricky.
		v.iconVal = -1 ; v.setClonedBit()
	c.initAllCloneBits()
	c.undoDVnodes = None
	c.setUndoParams(Commands.UNDO_CLONE,v)
	c.selectVnode(v)</t>
<t tx="T1046">@ Deleting a clone is _not_ the same as undoing a clone: the clone may have been moved, so there is no necessary relationship between the two nodes.

parent,back and n indicate where the new node is to be placed.
@c

elif c.undoType == Commands.UNDO_DELETE_OUTLINE:

	v = current.restoreOutlineFromDVnodes(dv,parent,back)
	shared = c.findSharedVnode(v)
	if shared: v.joinTreeTo(shared)
	v.createDependents()
	if v.shouldBeClone():
		# Optimizations make setting the icon a bit tricky.
		v.iconVal = 1 ; v.setClonedBit()
	c.initAllCloneBits()
	c.undoDVnodes = None
	c.setUndoParams(Commands.REDO_DELETE_OUTLINE,v)
	c.selectVnode(v)

elif c.undoType == Commands.REDO_DELETE_OUTLINE:

	c.selectVnode(v)
	c.deleteHeadline()</t>
<t tx="T1047">elif c.undoType == Commands.UNDO_INSERT_OUTLINE:

	vBack = v.visBack() ; vNext = v.visNext()
	c.endEditing()# Make sure we capture the headline for a redo.
	if vBack or vNext: # new logic: 1/18/00
		newVnode = choose(vBack,vBack,vNext)
		c.undoDVnodes = v.doDelete(newVnode)
		c.undoType = Commands.REDO_INSERT_OUTLINE
		c.selectVnode(choose(vBack,vBack,vNext))

elif c.undoType == Commands.REDO_INSERT_OUTLINE:

	v = current.restoreOutlineFromDVnodes(dv,parent,back)
	c.undoDVnodes = None
	c.setUndoParams(Commands.UNDO_INSERT_OUTLINE,v)
	if v: c.selectVnode(v)</t>
<t tx="T1048">elif (
	c.undoType == Commands.UNDO_MOVE or
	c.undoType == Commands.REDO_MOVE):

	c.setUndoParams(
		choose(old_type==Commands.UNDO_MOVE,
			Commands.REDO_MOVE,Commands.UNDO_MOVE), v)
	if parent:
		v.moveToNthChildOf(parent,n)
	elif back:
		v.moveAfter(back)
	else:
		v.moveToRoot()
	c.selectVnode(v)

elif (
	c.undoType == Commands.UNDO_DRAG or
	c.undoType == Commands.REDO_DRAG):

	c.setUndoParams(
		choose(old_type==Commands.UNDO_DRAG,
			Commands.REDO_DRAG, Commands.UNDO_DRAG), v)
	v.moveToNthChildOf(parent,n)
	c.selectVnode(v)</t>
<t tx="T1049">@ Promote and demote operations are the hardest to undo, because they involve relinking a list of nodes. We pass the work off to routines dedicated to the task.
@c

elif c.undoType == Commands.UNDO_DEMOTE:
	c.undoDemote()
	assert(c.undoType == Commands.REDO_DEMOTE)

elif c.undoType == Commands.REDO_DEMOTE:
	c.selectVnode(v)
	c.demote()
	assert(c.undoType == Commands.UNDO_DEMOTE)

elif c.undoType == Commands.UNDO_PROMOTE:
	c.undoPromote()
	assert(c.undoType == Commands.REDO_PROMOTE)

elif c.undoType == Commands.REDO_PROMOTE:
	c.selectVnode(v)
	c.promote()
	assert(c.undoType == Commands.UNDO_PROMOTE)</t>
<t tx="T1050"># undoes the previous demote operation.
def undoDemote(self):

	c = self
	ins = v = c.undoVnode
	last = c.undoLastChild
	child = v.firstChild()
	assert(child and last)
	c.setUndoParams(Commands.REDO_DEMOTE,v)
	c.beginUpdate()
	while 1:
		save_next = child.next()
		child.moveAfter(ins)
		ins = child
		c.undoLastChild = child
		child = save_next
		assert(ins == last or child)
		if ins == last: break
	c.selectVnode(v)
	c.endUpdate()</t>
<t tx="T1051"># Undoes the previous promote operation.
def undoPromote(self):

	v = v1 = c.undoVnode
	assert(v1)
	last = c.undoLastChild
	next = v.next()
	assert(next and last)
	c.setUndoParams(Commands.REDO_PROMOTE,v1)
	c.beginUpdate()
	while 1:
		v = next
		ASSERT(v)
		next = v.next()
		n = v1.numberOfChildren()
		v.moveToNthChildOf(v1,n)
		c.undoLastChild = v
		if v == last: break
	c.selectVnode(v1)
	c.endUpdate()</t>
<t tx="T1052">from leoGlobals import *
import string, Tkinter

class leoDialog:
	@others</t>
<t tx="T1053">def __init__(self):

	self.answer = ""
	self.top = None
</t>
<t tx="T1054">def askYesNoCancel(self, title, message):

	Tk = Tkinter ; root = app().root
	self.answer="cancel"
	self.top = top = Tk.Toplevel(root)
	top.title(title)
	top.resizable(0,0) # neither height or width is resizable.
	frame = Tk.Frame(top)
	self.top.bind("&lt;Key&gt;", self.OnKey)
	frame.pack()
	label = Tk.Label(frame, text=message)
	label.pack(pady=10)
	center = Tk.Frame(frame)
	center.pack()
	yes = Tk.Button(center,width=6,text="Yes",bd=4,
		underline=0,command=self.yesButton)
	no = Tk.Button(center,width=6,text="No",
		underline=0,command=self.noButton)
	cancel = Tk.Button(center,width=6,text="Cancel",
		underline=0,command=self.cancelButton)
	yes.pack(side="left",padx=5,pady=10)
	no.pack(side="left",padx=5,pady=10)
	cancel.pack(side="left",padx=5,pady=10)
	self.center() # Do this after packing.
	top.grab_set() # Make the dialog a modal dialog.
	top.focus_force() # Get all keystrokes.
	root.wait_window(top)
	return self.answer</t>
<t tx="T1055">def askYesNo(self, title, message):

	Tk = Tkinter ; root = app().root
	self.answer="No"
	self.top = top = Tk.Toplevel(root)
	top.title(title)
	top.resizable(0,0) # neither height or width is resizable.
	frame = Tk.Frame(top)
	self.top.bind("&lt;Key&gt;", self.OnKey)
	frame.pack()
	label = Tk.Label(frame, text=message)
	label.pack(pady=10)
	center = Tk.Frame(frame)
	center.pack()
	yes = Tk.Button(center,width=6,text="Yes",bd=4,
		underline=0,command=self.yesButton)
	no = Tk.Button(center,width=6,text="No",
		underline=0,command=self.noButton)
	yes.pack(side="left",padx=5,pady=10)
	no.pack(side="left",padx=5,pady=10)
	self.center() # Do this after packing.
	top.grab_set() # Make the dialog a modal dialog.
	top.focus_force() # Get all keystrokes.
	root.wait_window(top)
	return self.answer</t>
<t tx="T1056">def cancelButton(self):

	self.answer="cancel"
	self.top.destroy() # terminates wait_window
	
def noButton(self):

	self.answer="no"
	self.top.destroy() # terminates wait_window
	
def yesButton(self):

	self.answer="yes"
	self.top.destroy() # terminates wait_window</t>
<t tx="T1057"># Center the dialog on the screen.

def center(self):

	top = self.top
	top.update_idletasks() # Required to get proper info.

	# Get the information about top and the screen.
	sw = top.winfo_screenwidth()
	sh = top.winfo_screenheight()
	g = top.geometry() # g = "WidthxHeight+XOffset+YOffset"
	dim,x,y = string.split(g,'+')
	w,h = string.split(dim,'x')
	w,h,x,y = int(w),int(h),int(x),int(y)
	
	# Set the new window coordinates, leaving w and h unchanged.
	x = (sw - w)/2
	y = (sh - h)/2
	top.geometry("%dx%d%+d%+d" % (w,h,x,y))
</t>
<t tx="T1058">def OnKey(self,event):

	ch=event.char
	ch=string.lower(ch)
	if ch=='\n' or ch=='\r': self.yesButton() # The default
	elif ch=='y': self.yesButton()
	elif ch=='n': self.noButton()
	elif ch=='c': self.cancelButton()</t>
<t tx="T1059">from leoGlobals import *
from leoUtils import *

# import Tkinter

import leoNodes
import os
import os.path
import time

class BadLeoFile:
	def __init__(self, message):
		self.message = message
	def __str__(self):
		return "Bad Leo File:" + message

class fileCommands:
	@others</t>
<t tx="T1060">def __init__(self,commands):

	# trace("__init__", "fileCommands.__init__")
	self.commands = commands
	self.frame = commands.frame
	self.initIvars()

def initIvars(self):

	# General
	self.maxTnodeIndex = 0
	self.numberOfTnodes = 0
	self.topVnode = None
	self.mFileName = ""
	self.fileDate = -1
	# For reading
	self.fileFormatNumber = 0
	self.ratio = 0.5
	self.tnodesDict = {}
	self.fileBuffer = None ; self.fileIndex = 0
	self.dummy_v = None
	self.dummy_t = None
	# For writing
	self.outputFile = None # File for normal writing
	self.outputString = None # String for pasting
	self.openDirectory = None
	self.usingClipboard = false</t>
<t tx="T1061">def checkAllFileDates ( self ):

	return # disable all this: disabling is very dangerous!

	c=self.commands
	at = c.atFileCommands
	# es("Checking @file dates...")
	changed = FALSE
	v = c.tree.rootVnode
	while v:
		if v.isAtIgnoreNode():
			v = v.nodeAfterTree()
		elif v.isAtFileNode():
			&lt;&lt; update v if it has changed since last load &gt;&gt;
			v = v.nodeAfterTree();
		else: v = v.threadNext();
	
	if changed and c.tree.currentVnode:
		v = c.tree.currentVnode
		t = v.t
		if t.bodyString() != c.body.GetValue():
			# This will mark _always_ mark the current node as dirty.
			t.loadBodyPaneFromTnode(c.body)</t>
<t tx="T1062">if not v.isOrphan() and v.fileDate != -1:
	fileName = v.atFileNodeName()
	if FileExists(fileName):
		fileDate = FileAge(fileName)
		if fileDate &gt; v.fileDate:
			es("Updating " + fileName)
			ok = at.read(v,0) # no error recovery
			if ok:
				v .setDirty()
				changed = true</t>
<t tx="T1063">def createVnode(self,parent,back,tref,headline):

	# trace(`headline` + ", parent:" + `parent` + ", back:" + `back`)
	v = None ; c = self.commands
	# Shared tnodes are placed in the file even if empty.
	if tref == -1:
		t = leoNodes.tnode()
	else:
		t = self.getT(tref)
		if not t:
			t = self.newTnode(tref)
	if back: # create v after back.
		v = back.insertAfter(t)
	elif parent: # create v as the parent's first child.
		v = parent.insertAsNthChild(0,t)
	else: # create a root vnode
		v = leoNodes.vnode(c, t)
		v.moveToRoot()
		c.tree.rootVnode = v
	v.initHeadString(headline)
	return v</t>
<t tx="T1064"># This method finishes pasting the outline from the clipboard.
def finishPaste(self):

	c=self.commands
	current = c.tree.currentVnode
	after = current.nodeAfterTree()
	c.beginUpdate()
	if 1: # inside update...
		if 0: # Warning: this will only join pasted clones, and is very dangerous.
			&lt;&lt; Create join lists of all pasted vnodes &gt;&gt;
		&lt;&lt; Recompute clone bits for pasted vnodes &gt;&gt;
		self.compactFileIndices()
		c.selectVnode(current)
	c.endUpdate()
	return current</t>
<t tx="T1065"># Pass 1: create all join lists using tnode::joinHead
v = c.tree.currentVnode
while v and v != after:
	# Put v at the head of t's list of joined vnodes.
	v.setJoinList(v.t.joinHead)
	v.t.setJoinHead(v)
	v = v.threadNext()
	
# Pass 2: circularize each join list.
v = c.tree.currentVnode
while v and v != after:
	head = v.t.joinHead
	if not head:
		v = v.threadNext() ;continue
	# Make sure we don't handle this list again.
	v.t.setJoinHead(None)
	# Clear the join list if it has only one member.
	if head == v and not v.getJoinList():
		v.setJoinList(None)
		v = v.threadNext() ; continue
	# Point last at the last vnode of the list.
	last = head
	while last and last.getJoinList():
		last = last.getJoinList()
	assert(last)
	# Link last to head.
	last.setJoinList(head)
	v = v.threadNext()
</t>
<t tx="T1066">@ This must be done after the join lists have been created.  The saved clone bit is unreliable for pasted nodes.
@c

v = c.tree.currentVnode
while v and v != after:
	v.initClonedBit(v.shouldBeClone())
	v.clearDirty()
	v = v.threadNext()</t>
<t tx="T1067">def getBool(self):
	self.skipWs() # guarantees at least one more character.
	ch = self.fileBuffer[self.fileIndex]
	if ch == '0':
		self.fileIndex += 1 ; return false
	elif ch == '1':
		self.fileIndex += 1 ; return true
	else:
		raise BadLeoFile("expecting bool constant")
		
def getDqBool (self):
	self.getDquote() ; val = self.getBool() ; self.getDquote()
	return val

def getDouble(self):
	self.skipWs()
	i = self.fileIndex ; buf = self.fileBuffer
	floatChars = string.digits + 'e' + 'E' + '.' + '+' + '-'
	n = len(buf)
	while i &lt; n and buf[i] in floatChars:
		i += 1
	if i == self.fileIndex:
		raise BadLeoFile("expecting float constant")
	val = float(buf[self.fileIndex:i])
	self.fileIndex = i
	return val

def getDquote(self):
	self.getTag('"')
	
def getIndex(self):
	val = self.getLong()
	if val &lt; 0: raise BadLeoFile("expecting index")
	return val
	
def getLong(self):
	self.skipWs() # guarantees at least one more character.
	i = self.fileIndex
	if self.fileBuffer[i] == '-':
		i += 1
	n = len(self.fileBuffer)
	while i &lt; n and self.fileBuffer[i] in string.digits:
		i += 1
	if i == self.fileIndex:
		raise BadLeoFile("expecting int constant")
	val = int(self.fileBuffer[self.fileIndex:i])
	self.fileIndex = i
	return val

def getTag(self,tag):
	if not self.matchTag(tag):
		print "getTag(", tag, ") failed:"
		raise BadLeoFile("expecting" + tag)
		
def matchChar(self,ch):
	self.skipWs() # guarantees at least one more character.
	if ch == self.fileBuffer[self.fileIndex]:
		self.fileIndex += 1 ; return true
	else: return false

# Warning: does not check for end-of-word,
# so caller must match prefixes first.
def matchTag(self,tag):
	self.skipWsAndNl() # guarantees at least one more character.
	i = self.fileIndex
	# if string.find(self.fileBuffer,tag,i,i+len(tag)) == i:
	if tag == self.fileBuffer[i:i+len(tag)]:
		self.fileIndex += len(tag)
		return true
	else:
		return false</t>
<t tx="T1068">def getClipboardHeader(self):

	self.getTag("&lt;leo_header")
	# New in version 1.7: fields may appear in any order.
	while 1:
		if self.matchTag("file_format="):
			self.getDquote() ; self.fileFormatNumber = self.getLong() ; self.getDquote()
		elif self.matchTag("tnodes="):
			self.getDquote() ; self.getLong() ; self.getDquote() # no longer used
		elif self.matchTag("max_tnode_index="):
			self.getDquote() ; self.getLong() ; self.getDquote() # no longer used
		else:
			self.getTag("/&gt;")
			break</t>
<t tx="T1069"># For compatibility with old file formats.

def getCloneWindows(self):

	if self.matchTag("&lt;clone_windows&gt;"):
		while self.matchTag("&lt;clone_window vtag=\"V"):
			self.getLong() ; self.getDquote() ; self.getTag("&gt;")
			self.getTag("&lt;global_window_position")
			self.getPosition()
			self.getTag("/&gt;")
			self.getTag("&lt;/clone_window&gt;")
		self.getTag("&lt;/clone_windows&gt;")</t>
<t tx="T1070">def getEscapedString(self):

	# The next '&lt;' begins the ending tag.
	i = self.fileIndex
	self.fileIndex = j = string.find(self.fileBuffer,'&lt;',i)
	if j == -1:
		raise BadLeoFile("unterminated escaped string")
	else:
		# Allocates memory
		return self.xmlUnescape(self.fileBuffer[i:j])</t>
<t tx="T1071">def getFindPanelSettings(self):

	c = self.commands
	&lt;&lt; Set defaults of all flags &gt;&gt;
	self.getTag("&lt;find_panel_settings")
	while 1:
		if   self.matchTag("batch="): c.batch_flag = self.getDqBool()
		elif self.matchTag("wrap="): c.wrap_flag = self.getDqBool()
		elif self.matchTag("whole_word="): c.whole_word_flag = self.getDqBool()
		elif self.matchTag("ignore_case="): c.ignore_case_flag = self.getDqBool()
		elif self.matchTag("pattern_match="): c.pattern_match_flag = self.getDqBool()
		elif self.matchTag("search_headline="): c.search_headline_flag = self.getDqBool()
		elif self.matchTag("search_body="): c.search_body_flag = self.getDqBool()
		elif self.matchTag("suboutline_only="): c.suboutline_only_flag = self.getDqBool()
		elif self.matchTag("mark_changes="): c.mark_changes_flag = self.getDqBool()
		elif self.matchTag("mark_finds="): c.mark_finds_flag = self.getDqBool()
		elif self.matchTag("reverse="): c.reverse_flag = self.getDqBool()
		else: break
	self.getTag("&gt;")
	#
	self.getTag("&lt;find_string&gt;")
	c.find_text = self.getEscapedString()
	self.getTag("&lt;/find_string&gt;")
	#
	self.getTag("&lt;change_string&gt;")
	c.change_text = self.getEscapedString()
	self.getTag("&lt;/change_string&gt;")
	#
	self.getTag("&lt;/find_panel_settings&gt;")
	# Update the settings immediately.
	app().findFrame.init(c)</t>
<t tx="T1072">import leoFind

for var in leoFind.ivars:
	exec("c.%s_flag = false" % var)
</t>
<t tx="T1073">def getGlobals(self):

	self.getTag("&lt;globals")
	#
	self.getTag("body_outline_ratio=\"")
	self.ratio = self.getDouble() ; self.getDquote() ; self.getTag("&gt;")
	#
	self.getTag("&lt;global_window_position")
	top,left,height,width = self.getPosition() ; self.getTag("/&gt;")
	# trace("t,l,h,w:" + `top` + ":" + `left` + ":" + `height` + ":" + `width`)
	top = min(top,50) ; left = min(left,50)
	# Setting the heigth and width doesn't work properly.
	if 1:
		g = "+%d%+d" % (left, top)
	else:
		g = "%dx%d%+d%+d" % (width, height, left, top)
	self.frame.top.geometry(g)
	#
	self.getTag("&lt;global_log_window_position")
	self.getPosition() ; self.getTag("/&gt;") # no longer used.
	#
	self.getTag("&lt;/globals&gt;")</t>
<t tx="T1074">def getLeoFile(self,frame,atFileNodesFlag):

	c=self.commands
	self.mFileName = frame.mFileName
	self.tnodesDict = {} ; ok = true
	c.beginUpdate()
	try:
		c.tree.initing = true # inhibit endEditLabel from marking the file changed.
		self.getTag(prolog_string)
		self.getTag("&lt;leo_file&gt;")
		self.getLeoHeader()
		self.getGlobals()
		self.getPrefs()
		self.getFindPanelSettings()
		self.getVnodes()
		self.getTnodes()
		self.getCloneWindows()
		self.getTag("&lt;/leo_file&gt;")
		&lt;&lt; Create join lists of all vnodes &gt;&gt;
	except BadLeoFile, message: # All other exceptions are Leo bugs
		alert(self.mFileName + " is not a valid Leo file: " + `message`)
		ok = false
	# Leo2: read all @file nodes and reset orphan bits.
	if ok and atFileNodesFlag:
		at = c.atFileCommands
		at.readAll(c.tree.rootVnode, false) # partialFlag
	if not c.tree.currentVnode:
		c.tree.currentVnode = c.tree.rootVnode
	c.selectVnode(c.tree.currentVnode) # load body pane
	c.endUpdate() # redraw recomputes all icons.
	c.tree.initing = false # Enable changes in endEditLabel
	self.tnodesDict = {}
	return ok, self.ratio</t>
<t tx="T1075"># Pass 1: create all join lists using the joinHead field in each tnode
v = c.tree.rootVnode
while v:
	v.setJoinList(v.t.joinHead)
	v.t.setJoinHead(v)
	v = v.threadNext()

# Pass 2: Circularize each join list.
v = c.tree.rootVnode
while v:
	head = v.t.joinHead
	if not head:
		v = v.threadNext() ; continue
	# Make sure we don't handle this list again.
	v.t.setJoinHead(None)
	# Clear the join list if it has only one member.
	if head == v and not v.getJoinList():
		v.setJoinList(None)
		v = v.threadNext() ; continue
	# Point last at the last vnode of the list.
	last = head
	while last and last.getJoinList():
		assert(last != last.getJoinList())
		last = last.getJoinList()
	assert(last)
	# Link last to head.
	last.setJoinList(head)
	v = v.threadNext()</t>
<t tx="T1076">def getLeoHeader(self):

	c=self.commands
	# Set defaults.
	self.maxTnodeIndex = 0
	self.numberOfTnodes = 0
	self.getTag("&lt;leo_header")
	# New in version 1.7: attributes may appear in any order.
	while 1:
		if self.matchTag("file_format="):
			self.getDquote() ; self.fileFormatNumber = self.getLong() ; self.getDquote()
		elif self.matchTag("tnodes="):
			self.getDquote() ; self.numberOfTnodes = self.getLong() ; self.getDquote()
		elif self.matchTag("max_tnode_index="):
			self.getDquote() ; self.maxTnodeIndex = self.getLong() ; self.getDquote()
		elif self.matchTag("clone_windows="):
			self.getDquote() ; self.getLong() ; self.getDquote() # no longer used.
		else:
			self.getTag("/&gt;")
			break</t>
<t tx="T1077"># This method reads a Leo outline from string s in clipboard format.
def getLeoOutline(self,s):

	self.usingClipboard = true
	self.fileBuffer = s ; self.fileIndex = 0
	self.tnodesDict = {}
	try:
		self.getTag(prolog_string)
		self.getTag("&lt;leo_file&gt;")
		self.getClipboardHeader()
		self.getVnodes()
		self.getTnodes()
		self.getTag("&lt;/leo_file&gt;")
		v = self.finishPaste()
	except BadLeoFile:
		v = None
	# Clean up.
	self.fileBuffer = None ; self.fileIndex = 0
	self.tnodesDict = {}
	self.usingClipboard = false
	return v</t>
<t tx="T1078">def getPosition(self):

	top = left = height = width = 0
	# New in version 1.7: attributes may appear in any order.
	while 1:
		if self.matchTag("top=\""):
			top = self.getLong() ; self.getDquote()
		elif self.matchTag("left=\""):
			left = self.getLong() ; self.getDquote()
		elif self.matchTag("height=\""):
			height = self.getLong() ; self.getDquote()
		elif self.matchTag("width=\""):
			width = self.getLong() ; self.getDquote()
		else: break
	return top, left, height, width</t>
<t tx="T1079">def getSize(self):

	# New in version 1.7: attributes may appear in any order.
	height = 0 ; width = 0
	while 1:
		if self.matchTag("height=\""):
			height = self.getLong() ; self.getDquote()
		elif self.matchTag("width=\""):
			width = self.getLong() ; self.getDquote()
		else: break
	return height, width</t>
<t tx="T1080">def getT(self,index):

	if self.tnodesDict.has_key(index):
		return self.tnodesDict[index]
	else:
		return None</t>
<t tx="T1081">def getTnode(self):

	# we have already matched &lt;t.
	index = -1
	# New in version 1.7: attributes may appear in any order.
	while 1:
		if self.matchTag("tx=\"T"):
			index = self.getIndex() ; self.getDquote()
		elif self.matchTag("rtf=\"1\""): rtf = true # ignored
		elif self.matchTag("rtf=\"0\""): rtf = false # ignored
		else: break
	self.getTag("&gt;")
	t = self.getT(index)
	if t:
		s = self.getEscapedString()
		t.setTnodeText(s)
	else: # No vnode refers to this tnode.
		es("No tnode with index: ", `index`, ".  The text will be discarded")
		self.getEscapedString()
	self.getTag("&lt;/t&gt;")</t>
<t tx="T1082">def getTnodes(self):

	if self.matchTag("&lt;tnodes&gt;"):
		while self.matchTag("&lt;t"):
			self.getTnode()
		self.getTag("&lt;/tnodes&gt;")</t>
<t tx="T1083">def getVnode(self,parent,back):

	# trace("parent:" + `parent` + ", back:" + `back`)
	c=self.commands
	# Create a single dummy vnode to carry status bits.
	if not self.dummy_v:
		self.dummy_t = leoNodes.tnode(0,"")
		self.dummy_v = leoNodes.vnode(c, self.dummy_t)
		self.dummy_v.initHeadString("dummy")
	self.dummy_v.statusBits=0
	currentVnodeFlag = false # true if the 'V' attribute seen.
	topVnodeFlag = false # true if 'T' attribute seen.
	tref = -1 ; headline = ""
	# we have already matched &lt;v.
	while 1:
		if self.matchTag("t=\"T"):
			tref = self.getIndex() ; self.getDquote()
		elif self.matchTag("vtag=\"V"):
			vtag = self.getIndex() ; self.getDquote()
		elif self.matchTag("a=\""):
			&lt;&lt; Handle vnode attribute bits &gt;&gt;
		else: break
	self.getTag("&gt;")
	# Leo2: headlines are optional.
	if self.matchTag("&lt;vh&gt;"):
		headline = self.getEscapedString() ; self.getTag("&lt;/vh&gt;")
	# Link v into the outline using parent and back.
	v = self.createVnode(parent,back,tref,headline)
	v.statusBits = self.dummy_v.statusBits
	# Remember various info that may have been specified.
	if currentVnodeFlag:
		c.tree.currentVnode = v
	if topVnodeFlag: c.mTopVnode = v
	# Recursively create all nested nodes.
	parent = v ; back = None
	while self.matchTag("&lt;v"):
		back = self.getVnode(parent,back)
	# End this vnode.
	self.getTag("&lt;/v&gt;")
	return v</t>
<t tx="T1084"># The a=" has already been seen.
while 1:
	if   self.matchChar('C'): self.dummy_v.initClonedBit(true)
	elif self.matchChar('D'): pass # no longer used.
	elif self.matchChar('E'): self.dummy_v.initExpandedBit()
	elif self.matchChar('M'): self.dummy_v.initMarkedBit()
	elif self.matchChar('O'): self.dummy_v.setOrphan()
	elif self.matchChar('T'): topVnodeFlag = true
	elif self.matchChar('V'): currentVnodeFlag = true
	else: break
self.getDquote()</t>
<t tx="T1085">def getVnodes(self):

	c=self.commands
	if  self.usingClipboard:
		# Paste after the current vnode.
		back = c.tree.currentVnode ; parent = back.parent()
	else:
		back = None ; parent = None

	self.getTag("&lt;vnodes&gt;")
	while self.matchTag("&lt;v"):
		back = self.getVnode(parent,back)
	self.getTag("&lt;/vnodes&gt;")</t>
<t tx="T1086">def skipWs(self):

	while self.fileIndex &lt; len(self.fileBuffer):
		ch = self.fileBuffer[self.fileIndex]
		if ch == ' ' or ch == '\t':
			self.fileIndex += 1
		else: break

	# The caller is entitled to get the next character.
	if  self.fileIndex &gt;= len(self.fileBuffer):
		raise BadLeoFile("")</t>
<t tx="T1087">def skipWsAndNl(self):

	while self.fileIndex &lt; len(self.fileBuffer):
		ch = self.fileBuffer[self.fileIndex]
		if ch == ' ' or ch == '\t' or ch == '\r' or ch == '\n':
			self.fileIndex += 1
		else: break

	# The caller is entitled to get the next character.
	if  self.fileIndex &gt;= len(self.fileBuffer):
		raise BadLeoFile("")</t>
<t tx="T1088">def newTnode(self,index):

	if self.tnodesDict.has_key(index):
		es("bad tnode index: " + `index` + ". Using empty text.")
		return leoNodes.tnode()
	else:
		t = leoNodes.tnode()
		t.setFileIndex(index)
		self.tnodesDict[index] = t
		return t</t>
<t tx="T1089">def readAtFileNodes (self):

	c = self.commands
	c.atFileCommands.readAll(c.tree.currentVnode, true) # partialFlag</t>
<t tx="T1090">def xmlUnescape(self,s):

	if s:
		s = string.replace(s, '\r', '')
		s = string.replace(s, "&amp;lt;", '&lt;')
		s = string.replace(s, "&amp;gt;", '&gt;')
		s = string.replace(s, "&amp;amp;", '&amp;')
	return s</t>
<t tx="T1091">def assignFileIndices(self):

	c=self.commands
	v = c.tree.rootVnode
	while v:
		t = v.t
		# 8/28/99.  Write shared tnodes even if they are empty.
		if t.hasBody() or v.getJoinList():
			if t.fileIndex == 0:
				self.maxTnodeIndex += 1
				t.setFileIndex(self.maxTnodeIndex)
		else:
			t.setFileIndex(0)
		v = v.threadNext()</t>
<t tx="T1092">def compactFileIndices(self):

	c=self.commands
	self.maxTnodeIndex = 0
	v = c.tree.rootVnode
	while v: # Clear all indices.
		v.t.setFileIndex(0)
		v = v.threadNext()
	v = c.tree.rootVnode
	while v: # Set indices for all tnodes that will be written.
		t = v.t
		if t.hasBody() or v.getJoinList(): # 8/28/99. Write shared tnodes even if they are empty.
			if t.fileIndex == 0:
				self.maxTnodeIndex += 1
				t.setFileIndex(self.maxTnodeIndex)
		v = v.threadNext()</t>
<t tx="T1093">@ This method sets policy for when we should compact a file before doing a Save Command.
@c

def shouldCompactOnSave(self):

	c=self.commands
	# Count the number of tnodes used
	c.clearAllVisited()
	v = c.tree.rootVnode ; tnodesUsed = 0
	while v:
		t = v.t
		if t and not t.isVisited():
			tnodesUsed += 1
			t.setVisited()
		v = v.threadNext()
	tnodesUnused = self.maxTnodeIndex - tnodesUsed
	return tnodesUnused &gt; 100</t>
<t tx="T1094">def putClipboardHeader(self):

	tnodes = 0
	&lt;&lt; count the number of tnodes &gt;&gt;
	self.put('&lt;leo_header file_format="1" tnodes=')
	self.put_in_dquotes(`tnodes`)
	self.put(" max_tnode_index=")
	self.put_in_dquotes(`tnodes`)
	self.put("/&gt;") ; self.put_nl()
</t>
<t tx="T1095">c=self.commands
c.clearAllVisited()

# Count the vnode and tnodes.
v = c.tree.currentVnode
after = v.nodeAfterTree()
while v and v != after:
	t = v.t
	if t and not t.isVisited() and (t.hasBody() or v.getJoinList()):
		t.setVisited()
		tnodes += 1
	v = v.threadNext()</t>
<t tx="T1096"># All output eventually comes here
def put(self,s):
	if s and len(s) &gt; 0:
		if self.outputFile: # Write to a file
			self.outputFile.write(s) 
		elif self.outputString != None: # Write to a string
			self.outputString += s
					
def put_dquote(self):
	self.put('"')
		
def put_dquoted_bool(self,b):
	if b: self.put('"1"')
	else: self.put('"0"')
		
def put_flag(self,a,b):
	if a:
		self.put(" ") ; self.put(b) ; self.put('="1"')
		
def put_in_dquotes(self,a):
	self.put('"')
	if a: self.put(a) # will always be true if we use backquotes.
	else: self.put('0')
	self.put('"')

def put_nl(self):
	self.put("\n")
	
def put_tab(self):
	self.put("\t")
	
def put_tabs(self,n):
	while n &gt; 0:
		self.put("\t")
		n -= 1</t>
<t tx="T1097">@ Surprisingly, the call to xmlEscape here is _much_ faster than calling put for each characters of s.
@c

def putEscapedString(self,s):

	if s and len(s) &gt; 0:
		self.put(self.xmlEscape(s))</t>
<t tx="T1098">def putFindSettings(self):

	c = self.commands
	c.setIvarsFromFind()
	self.put("&lt;find_panel_settings")
	self.put_flag(c.batch_flag,"batch")
	self.put_flag(c.wrap_flag,"wrap")
	self.put_flag(c.whole_word_flag,"whole_word")
	self.put_flag(c.ignore_case_flag,"ignore_case")
	self.put_flag(c.pattern_match_flag,"pattern_match")
	self.put_flag(c.search_headline_flag,"search_headline")
	self.put_flag(c.search_body_flag,"search_body")
	self.put_flag(c.suboutline_only_flag,"suboutline_only")
	self.put_flag(c.mark_changes_flag,"mark_changes")
	self.put_flag(c.mark_finds_flag,"mark_finds")
	self.put_flag(c.reverse_flag,"reverse")
	self.put("&gt;") ; self.put_nl()
	#
	self.put_tab()
	self.put("&lt;find_string&gt;") ; self.putEscapedString(c.find_text)
	self.put("&lt;/find_string&gt;") ; self.put_nl()
	#
	self.put_tab()
	self.put("&lt;change_string&gt;") ; self.putEscapedString(c.change_text)
	self.put("&lt;/change_string&gt;") ; self.put_nl()
	#
	self.put("&lt;/find_panel_settings&gt;") ; self.put_nl()
</t>
<t tx="T1099">def putGlobals(self):

	c=self.commands
	self.put("&lt;globals")
	&lt;&lt; put the body/outline ratio &gt;&gt;
	self.put("&gt;") ; self.put_nl()
	&lt;&lt; put the position of this frame &gt;&gt;
	&lt;&lt; put the position of the log window &gt;&gt;
	self.put("&lt;/globals&gt;") ; self.put_nl()</t>
<t tx="T1100"># Puts an innumerate number of digits

self.put(" body_outline_ratio=") ; self.put_in_dquotes(`c.frame.ratio`)</t>
<t tx="T1101">width = self.frame.top.winfo_width()
height = self.frame.top.winfo_height()
left, top = 10, 10 ##

self.put_tab()
self.put("&lt;global_window_position")
self.put(" top=") ; self.put_in_dquotes(`top`)
self.put(" left=") ; self.put_in_dquotes(`left`)
self.put(" height=") ; self.put_in_dquotes(`height`)
self.put(" width=") ; self.put_in_dquotes(`width`)
self.put("/&gt;") ; self.put_nl()</t>
<t tx="T1102">top = left = height = width = 0 # no longer used
self.put_tab()
self.put("&lt;global_log_window_position")
self.put(" top=") ; self.put_in_dquotes(`top`)
self.put(" left=") ; self.put_in_dquotes(`left`)
self.put(" height=") ; self.put_in_dquotes(`height`)
self.put(" width=") ; self.put_in_dquotes(`width`)
self.put("/&gt;") ; self.put_nl()</t>
<t tx="T1103">def putHeader(self):

	c=self.commands
	tnodes = 0 ; clone_windows = 0
	if 0: # not used in Leo2.
		&lt;&lt; count the number of tnodes and clone windows &gt;&gt;
	self.put("&lt;leo_header")
	self.put(" file_format=") ; self.put_in_dquotes("2")
	self.put(" tnodes=") ; self.put_in_dquotes(`tnodes`)
	self.put(" max_tnode_index=") ; self.put_in_dquotes(`self.maxTnodeIndex`)
	self.put(" clone_windows=") ; self.put_in_dquotes(`clone_windows`)
	self.put("/&gt;") ; self.put_nl()</t>
<t tx="T1104">c.clearAllVisited()
v = c.tree.rootVnode
while v:
	t = v.t
	# 8/28/99: we write all shared tnodes, even if empty.
	if t and not t.isVisited() and (t.hasBody() or v.getJoinList()):
		t.setVisited()
		tnodes += 1
		v = v.threadNext()</t>
<t tx="T1105"># Writes a Leo outline to s in a format suitable for pasting to the clipboard.

def putLeoOutline(self):

	self.outputString = "" ; self.outputFile = None
	self.usingClipboard = true
	# self.assignFileIndices() // The caller does this.
	self.putProlog()
	self.putClipboardHeader()
	self.putVnodes()
	self.putTnodes()
	self.putPostlog()
	s = self.outputString
	self.outputString = None
	self.usingClipboard = false
	return s</t>
<t tx="T1106">def putPrefs(self):

	c = self.commands
	c.setIvarsFromPrefs()
	self.put("&lt;preferences")
	self.put(" allow_rich_text=") ; self.put_dquoted_bool(0) # no longer used
	self.put(" tab_width=") ; self.put_in_dquotes(`c.tab_width`)
	self.put(" page_width=") ; self.put_in_dquotes(`c.page_width`)
	self.put(" tangle_bat=") ; self.put_dquoted_bool(c.tangle_batch_flag)
	self.put(" untangle_bat=") ; self.put_dquoted_bool(c.untangle_batch_flag)
	# New in version 0.10
	self.put(" output_doc_chunks=") ; self.put_dquoted_bool(c.output_doc_flag)
	# New in version 0.15
	&lt;&lt; put syntax coloring prefs &gt;&gt;
	# New in version 0.18
	self.put(" use_header_flag=") ; self.put_dquoted_bool(c.use_header_flag)
	if 0: # USE_CWEB: Removed in version 0.19
		self.put(" noweb_flag=") ; self.put_dquoted_bool(c.use_noweb_flag)
		self.put(" extended_noweb_flag=") ; self.put_dquoted_bool(c.extended_noweb_flag)
	self.put("&gt;") ; self.put_nl()
	#
	self.put_tab()
	# New in version 0.16
	&lt;&lt; put default directory &gt;&gt;
	self.put_nl()
	#
	self.put("&lt;/preferences&gt;") ; self.put_nl()</t>
<t tx="T1107">languageNameDict = {
	c_language: "C", cweb_language: "CWEB",
	html_language: "HTML", java_language: "Java",
	pascal_language: "Pascal", perl_language: "Perl",
	perlpod_language: "PerlPod", plain_text_language: "Plain",
	python_language: "Python" }

if c.target_language and languageNameDict.has_key(c.target_language):
	self.put(" defaultTargetLanguage=")
	self.put_in_dquotes(languageNameDict[c.target_language])
else:
	self.put(" defaultTargetLanguage=") ; self.put_in_dquotes("Plain")</t>
<t tx="T1108">if len(c.tangle_directory) &gt; 0:
	self.put("&lt;defaultDirectory&gt;")
	self.putEscapedString(c.tangle_directory)
	self.put("&lt;/defaultDirectory&gt;")</t>
<t tx="T1109">def putProlog(self):

	self.put(prolog_string) ; self.put_nl()
	# internal or external DTD goes here
	self.put("&lt;leo_file&gt;") ; self.put_nl()</t>
<t tx="T1110">def putPostlog(self):

	self.put("&lt;/leo_file&gt;") ; self.put_nl()</t>
<t tx="T1111">@ This method puts all tnodes in index order.  All tnode indices must have been assigned at this point.
@c
def putTnodes(self):

	c=self.commands
	tnodes = {}
	if self.usingClipboard: # write the current tree.
		v = c.tree.currentVnode ; after = v.nodeAfterTree()
	else: # write everything
		v = c.tree.rootVnode ; after = None
	# Populate tnodes
	while v and v != after:
		index = v.t.fileIndex
		if index &gt; 0 and not tnodes.has_key(index):
			tnodes[index] = v.t
		v = v.threadNext()
	# Put all tnodes in index order.
	self.put("&lt;tnodes&gt;") ; self.put_nl()
	#
	keys = tnodes.keys() ; keys.sort()
	for index in keys:
		t = tnodes[index]
		assert(t)
		# New for Leo2: write only those tnodes whose vnodes were written.
		if t.isVisited(): self.putTnode(t)
	#
	self.put("&lt;/tnodes&gt;") ; self.put_nl()</t>
<t tx="T1112">def putTnode(self,t):

	self.put("&lt;t tx=") ; self.put_in_dquotes("T" + `t.fileIndex`)
	self.put("&gt;")
	if t and t.bodyString and len(t.bodyString) &gt; 0:
		self.putEscapedString(t.bodyString)
	self.put("&lt;/t&gt;") ; self.put_nl()</t>
<t tx="T1113">@ This method puts all vnodes by starting the recursion.  putVnode will write all vnodes in the order in which they appear in the outline.
@c
def putVnodes(self):

	c=self.commands
	c.clearAllVisited()

	self.put("&lt;vnodes&gt;") ; self.put_nl()
	if self.usingClipboard:
		self.putVnode(
			c.tree.currentVnode, # Write only current tree.
			None) # Don't write top vnode status bit.
	else: 
		v = c.tree.rootVnode
		while v:
			self.putVnode(
				v, # Write the next top-level node.
				c.tree.topVnode) # Write the top-vnode status bit.
			v = v.next()
	self.put("&lt;/vnodes&gt;") ; self.put_nl()</t>
<t tx="T1114">@ This writes full headline and body text for all vnodes, even orphan and @ignored nodes.  This allows all Leo outlines to be used as backup files.
@c

def putVnode(self,v,topVnode):

	c = self.commands
	at = c.atFileCommands
	self.put("&lt;v")
	&lt;&lt; Put tnode index if this vnode has body text &gt;&gt;
	&lt;&lt; Put attribute bits &gt;&gt;
	self.put("&gt;")
	&lt;&lt; write the head text &gt;&gt;
	child = v.firstChild()
	if child:
		self.put_nl()
		while child:
			self.putVnode(child,topVnode)
			child = child.next()
	self.put("&lt;/v&gt;") ; self.put_nl()</t>
<t tx="T1115">t = v.t
if t and (t.hasBody() or v.getJoinList()):
	if t.fileIndex &gt; 0:
		self.put(" t=") ; self.put_in_dquotes("T" + `t.fileIndex`)
		v.t.setVisited() # Indicate we wrote the body text.
	else:
		es("error writing file(bad vnode)!")
		es("Try using the Save To command")</t>
<t tx="T1116"># Dummy vnodes carry all attributes.
current = c.tree.currentVnode
top = topVnode
if ( v.isCloned() or v.isExpanded() or v.isMarked() or
	v == current or v == top ):
	self.put(" a=") ; self.put_dquote()
	if v.isCloned(): self.put("C")
	if v.isExpanded(): self.put("E")
	if v.isMarked(): self.put("M")
	if v.isOrphan(): self.put("O")
	if v == top: self.put("T")
	if v == current: self.put("V")
	self.put_dquote()</t>
<t tx="T1117">headString = v.headString()
if len(headString) &gt; 0:
	self.put("&lt;vh&gt;")
	self.putEscapedString(headString)
	self.put("&lt;/vh&gt;")</t>
<t tx="T1118">def save(self,fileName):

	c=self.commands
	c.beginUpdate()
	if 1: # within update...
		c.endEditing()# Set the current headline text.
		self.compactFileIndices() # 1/14/02: always recompute file indices
		if self.write_LEO_file(fileName,false): # outlineOnlyFlag
			c.setChanged(false) # Clears all dirty bits.
			es("saved: " + fileName)
	c.endUpdate()</t>
<t tx="T1119">def saveAs(self,fileName):

	c=self.commands
	c.beginUpdate()
	if 1: # within update...
		c.endEditing() # Set the current headline text.
		self.compactFileIndices()
		if self.write_LEO_file(fileName,false): # outlineOnlyFlag
			c.setChanged(false) # Clears all dirty bits.
			es("saved: " + fileName)
	c.endUpdate()</t>
<t tx="T1120">def saveTo (self,fileName):

	c=self.commands
	c.beginUpdate()
	if 1: # within update...
		c.endEditing()# Set the current headline text.
		self.compactFileIndices()
		if self.write_LEO_file(fileName,false): # outlineOnlyFlag
			es("saved: " + fileName)
	c.endUpdate()</t>
<t tx="T1121"># Surprisingly, this is a time critical routine.

def xmlEscape(self,s):

	assert(s and len(s) &gt; 0) # check is made in putEscapedString
	s = string.replace(s, '\r', '')
	s = string.replace(s, '&amp;', "&amp;amp;")
	s = string.replace(s, '&lt;', "&amp;lt;")
	s = string.replace(s, '&gt;', "&amp;gt;")
	return s</t>
<t tx="T1122">def writeAtFileNodes (self):

	c=self.commands
	v = c.tree.currentVnode
	if v:
		at = c.atFileCommands
		at.writeAll(v,true) # partialFlag</t>
<t tx="T1123">def writeOutlineOnly (self):

	c=self.commands
	c.endEditing()
	self.compactFileIndices()
	self.write_LEO_file(self.mFileName,true) # outlineOnlyFlag</t>
<t tx="T1124">&lt;&lt; Theory of operation &gt;&gt;

from leoGlobals import *
from leoUtils import *
import Tkinter

# Abbreviations
set_undo_params = true ; dont_set_undo_params = false
all = true

#define is_word(c)(isalnum(c)or(c)== '_')

# The names of the actual ivars have "_flag" appended to these.
# Note: batch_flag now records the "context" checkbox.
ivars = [ "batch", "wrap", "whole_word", "ignore_case",
	"pattern_match", "search_headline", "search_body",
	"suboutline_only", "mark_changes", "mark_finds", "reverse" ]

class LeoFind:
	@others</t>
<t tx="T1125">def set_ivars (self,c):

	for var in ivars:
		exec("c.%s_flag = self.%s_flag.get()" % (var,var))

	c.find_text = self.find_text.get("1.0","end - 1c") # Remove trailing newline
	c.change_text = self.change_text.get("1.0","end - 1c") # Remove trailing newline</t>
<t tx="T1126">def OnCloseFindEvent(self):

	self.top.withdraw()</t>
<t tx="T1127">from leoGlobals import *
from leoUtils import *
import leoDialog, leoNodes
import Tkinter, tkFileDialog, tkFont, tkMessageBox

# Needed for menu commands
import leoCommands, leoFileCommands, leoFind, leoNodes, leoPrefs, leoTree
import os, sys

class LeoFrame:
	@others</t>
<t tx="T1128">def __repr__ (self):

	return "leoFrame: " + self.title
</t>
<t tx="T1129"># Returns the frame that has focus, or body if None.

def getFocus(self):

	f = self.top.focus_displayof()
	if f:
		return f
	else:
		return self.body</t>
<t tx="T1130">def notYet(self,name):

	es(name + " not ready yet")
</t>
<t tx="T1131">def resizePanesToRatio(self,ratio):

	self.divideSplitter(self.splitVerticalFlag, 0.5)
</t>
<t tx="T1132">def OnActivateLog (self,event=None):

	app().log = self
	self.tree.OnDeactivate()</t>
<t tx="T1133">def OnActivateTree (self,event=None):

	app().log = self
	self.tree.undimEditLabel()
	self.tree.canvas.focus_set()</t>
<t tx="T1134"># Create a splitter window and panes into which the caller packs widgets.
# Returns (bar, pane1, pane2)

# To do:
#	height, width could be params
#	constrain the minimum size of each pane

def createSplitter (self, parent, verticalFlag):

	Tk = Tkinter
	f = Tk.Frame(parent,width="8i",height="6.5i",bd=0,bg="white",relief="flat")
	f.pack(expand=1,fill="both")

	pane1 = Tk.Frame(f)
	pane2 = Tk.Frame(f)
	pane1.configure(bd=0,bg="white",relief="flat")
	pane2.configure(bd=0,bg="white",relief="flat")

	if verticalFlag:
		# Panes arranged vertically; horizontal splitter bar
		bar = Tk.Frame(f,height=7,bd=2,relief="raised",bg="LightSteelBlue2")

		pane1.place(relx=0.5, rely =   0, anchor="n", relwidth=1.0, relheight=0.5)
		pane2.place(relx=0.5, rely = 1.0, anchor="s", relwidth=1.0, relheight=0.5)
		bar.place  (relx=0.5, rely = 0.5, anchor="c", relwidth=1.0)

		bar.bind("&lt;ButtonPress-1&gt;",   self.onGrabVSplitBar)
		bar.bind("&lt;B1-Motion&gt;",	      self.onDragVSplitBar)
		bar.bind("&lt;ButtonRelease-1&gt;", self.onDropVSplitBar)
	else:
		# Panes arranged horizontally; vertical splitter bar
		bar = Tk.Frame(f,width=7,bd=2,relief="raised",bg="LightSteelBlue2")
		
		f = 0.65 # give tree pane more room
		pane1.place(rely=0.5, relx =   0, anchor="w", relheight=1.0, relwidth=f)
		pane2.place(rely=0.5, relx = 1.0, anchor="e", relheight=1.0, relwidth=1.0-f)
		bar.place  (rely=0.5, relx = f, anchor="c", relheight=1.0)
	
		bar.bind("&lt;ButtonPress-1&gt;",		self.onGrabHSplitBar)
		bar.bind("&lt;ButtonRelease-1&gt;",	self.onDropHSplitBar)
		bar.bind("&lt;B1-Motion&gt;",			self.onDragHSplitBar)

	return bar, pane1, pane2</t>
<t tx="T1135">def divideSplitter (self, verticalFlag, frac):

	if verticalFlag:
		self.ratio = frac # Ratio of body pane to tree pane.
		# Panes arranged vertically; horizontal splitter bar
		self.bar1.place(rely=frac)
		self.split1Pane1.place(relheight=frac)
		self.split1Pane2.place(relheight=1-frac)
	else:
		# Panes arranged horizontally; vertical splitter bar
		self.bar2.place(relx=frac)
		self.split2Pane1.place(relwidth=frac)
		self.split2Pane2.place(relwidth=1-frac)</t>
<t tx="T1136">def onGrabHSplitBar (self, event):
	self.onGrabSplitterBar(event, 0)
	
def onGrabVSplitBar (self, event):
	self.onGrabSplitterBar(event, 1)
	
def onGrabSplitterBar (self, event, verticalFlag):
	pass</t>
<t tx="T1137">def onDragHSplitBar (self, event):
	self.onDragSplitterBar(event, 0)
	
def onDragVSplitBar (self, event):
	self.onDragSplitterBar(event, 1)

def onDragSplitterBar (self, event, verticalFlag):

	if not self.splitVerticalFlag:
		return ## disable for now...

	# x and y are the coordinates of the cursor relative to the bar, not the main window.
	bar = event.widget
	x = event.x
	y = event.y
	top = bar.winfo_toplevel()

	if verticalFlag:
		# Panes arranged vertically; horizontal splitter bar
		wRoot	= top.winfo_rooty()
		barRoot = bar.winfo_rooty()
		wMax	= top.winfo_height()
		offset = float(barRoot) + y - wRoot
	else:
		# Panes arranged horizontally; vertical splitter bar
		wRoot	= top.winfo_rootx()
		barRoot = bar.winfo_rootx()
		wMax	= top.winfo_width()
		offset = float(barRoot) + x - wRoot

	# Adjust the pixels, not the frac.
	if offset &lt; 3: offset = 3
	if offset &gt; wMax - 2: offset = wMax - 2
	# Redraw the splitter as the drag is occuring.
	frac = float(offset) / wMax
	# trace(`frac`)
	self.divideSplitter(verticalFlag, frac)</t>
<t tx="T1138">def onDropHSplitBar (self, event):
	self.onDropSplitterBar(event, 0)
	
def onDropVSplitBar (self, event):
	self.onDropSplitterBar(event, 1)
	
# We could call divideSplitter here (instead of On DragSplitterBar) for non-dynamic updates.
def onDropSplitterBar (self, event, verticalFlag):
	pass</t>
<t tx="T1139">@ Global constants and variables used throughout Leo2.
Most modules should do from leoGlobals import *
NB: Use app().ivar instead of using global variables
@c
	
&lt;&lt; define global constants &gt;&gt;

@others</t>
<t tx="T1140"># General constants...
true = 1
false = 0 # Better than None
body_newline = '\n'
body_ignored_newline = '\r'
prolog_string = "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;"

# These are set by the @langauge directive.
# Used by Tangle, Untangle and syntax coloring.
ada_language =		 1
c_language =		 2  # C, C++ or objective C.
cweb_language =		 3  # CWEB syntax coloring
cobol_language =	 4  # literate cobol??
fortran_language =	 5  # Comments start with C
fortran90_language =	 6  # Comments start with !
html_language =		 7
java_language =		 8
lisp_language =		 9
pascal_language =	10
plain_text_language =	11
perl_language =		12  # just ##
perlpod_language =	13  # ## and =pod and =cut
python_language =	14
shell_language =	15  # shell scripts
unknown_language =	16  # Set when @comment is seen.

# Synonyms for the bits returned by is_special_bits...
color_bits =    0x00001
comment_bits =	 0x00002
cweb_bits =     0x00004
header_bits =   0x00008
ignore_bits =   0x00010
language_bits = 0x00020
nocolor_bits =	 0x00040
noheader_bits = 0x00080
noweb_bits =    0x00100
#               0x00200 #unused
page_width_bits=0x00400
path_bits =	    0x00800
root_bits =	    0x01000 # Also represents &lt; &lt; * &gt; &gt; =
silent_bits =	  0x02000
tab_width_bits =0x04000
terse_bits = 	  0x08000
unit_bits = 	   0x10000
verbose_bits =	 0x20000</t>
<t tx="T1141">def alert(message):

	es(message)

	import tkMessageBox
	tkMessageBox.showwarning("Alert", message)
</t>
<t tx="T1142"># gApp is the only global in the application, and gApp is accessed only via app().

def app():
	global gApp
	return gApp
	
def setApp(app):
	global gApp
	gApp = app</t>
<t tx="T1143">def appendToList(out, s):

	for i in s:
		out.append(i)</t>
<t tx="T1144">def choose(cond, a, b): # warning: evaluates all arguments

	if cond: return a
	else: return b</t>
<t tx="T1145">def listToString(list):

	if list:
		return string.join(list,"")
	else:
		return ""</t>
<t tx="T1146">def ecnl():
	ecnls(1)

def ecnls(n):
	log = app().log
	if log:
		while log.es_newlines &lt; n:
			enl()

def enl():
	log = app().log
	if log:
		log.es_newlines += 1
		log.putnl()

def es(s):
	if s == None or len(s) == 0: return
	log = app().log
	if log:
		log.put(s)
	else:
		print "Null log:", s
	for ch in s:
		if ch == '\n': log.es_newlines += 1
		else: log.es_newlines = 0
	ecnl() # only valid here
</t>
<t tx="T1147">def print_stack():

	import traceback
	traceback.print_stack()</t>
<t tx="T1148">def top():

	frame = app().log # the current frame
	return frame.commands</t>
<t tx="T1149">from leoGlobals import *
from leoUtils import *

&lt;&lt; constants and synonyms &gt;&gt;

class importFiles:
	@others</t>
<t tx="T1150">indent_refs = true ; dont_indent_refs = false</t>
<t tx="T1151">def error(s): es(s)</t>
<t tx="T1152">def __init__ (self,commands):

	self.commands = commands
	&lt;&lt; initialize importFiles ivars &gt;&gt;</t>
<t tx="T1153">self.fileName = None # The original file name, say x.cpp
self.methodName = None # x, as in &lt; &lt; x methods &gt; &gt; =
self.fileType = None

# These mark the points in the present function.
self.scan_start = 0 # The start of the unscanned text.
self.function_start = None
self.function_end = None
self.name_start = None
self.name_end = None</t>
<t tx="T1154">def ImportFilesCommand (self,files):

	c = self.commands
	current = c.getCurrentVnode()
	if not current: return
	if len(files) &lt; 1: return
	c.beginUpdate()
	if 1: # range of update...
	  	c.selectVnode(current)
		if len(files) == 2:
			&lt;&lt; Create a parent for two files having a common prefix &gt;&gt;
		i = 0
		while i &lt; count:
			fileName = files[0]
			v = self.createOutline(fileName,current)
			c.contractVnode(v)
			v.setDirty()
			c.setChanged(true)
			i += 1
		c.validateOutline()
	  	c.selectVnode(current)
	c.endUpdate()</t>
<t tx="T1155">@ The two filenames have a common prefix everything before the last period is the same.  For example, x.h and x.cpp.
@c

name0 = files[0]
name1 = files[1]
prefix0 = name0.BeforeLast('.')
prefix1 = name1.BeforeLast('.')
if len(prefix0) &gt; 0 and prefix0 == prefix1:
	current = current.insertAsLastChild()
	current.initHeadString(prefix0.AfterLast('\\'))</t>
<t tx="T1156">def createOutline (self,fileName,parent):

	c = self.commands
	junk, self.fileName = os.path.split(fileName) # junk/fileName
	self.methodName, self.fileType = os.path.splitext(self.fileName) # methodName.fileType
	trace(`self.fileName`)
	# All file types except the following just get copied to the parent node.
	appendFileFlag = type in ["c", "cpp", "cxx", "java", "pas", "py"]
	&lt;&lt; Read file into buf &gt;&gt;
	# Create the top-level headline.
	v = parent.insertAsLastChild()
	v.initHeadString(self.fileName)
	if appendFileFlag:
		# Set the body text of the root.
		v.t.setTnodeText(buf)
		v.t.setSelection(0,0)
	else:
		if type == "c" or type == "cpp" or type == "cxx":
			self.scanCText(buf,v)
		elif type == "java":
			self.scanJavaText(buf,v,true) #outer level
		elif type == "pas":
			self.scanPascalText(buf,v)
		elif type == "py":
			self.scanPythonText(buf,v)
	return v</t>
<t tx="T1157">try:
	file = open(fileName)
	buf = file.read()
	file.close()
except: buf = None</t>
<t tx="T1158">def createHeadline (self,parent,body,headline):

	# Create the vnode.
	v = parent.insertAsLastChild()
	v.initHeadString(headline)
	# Set the body.
	if len(body) &gt; 0: 
		v.t.setTnodeText(body)
		v.t.setSelection(0,0)
	return v</t>
<t tx="T1159">@ This code takes care not to use blank lines or comment lines in the computation.

This routine can be called at, or just after, a newline character.
@c

def getPythonIndent(self,s,i):

	indent = 0
	while i &lt; len(s):
		if s[i] == ' ':
			indent += 1
			i += 1
		elif s[i] == '\t':
			indent += c.tab_width
			i += 1
		elif is_nl(s,i):
			# Blank lines do not affect indentation.
			indent = 0
			i = skip_nl(s,i)
		elif s[i] == '#':
			indent = 0
			# Comment lines do not affect indentation.
			i = skip_line(s,i)
		else: break
	return indent</t>
<t tx="T1160"># Inserts &lt; &lt; path methods &gt; &gt; = at the start of the body text and after leading comments.

def massageBody(self,s,methodKind):
	
	# methods = choose(self.fileType == "c","functions","methods")
	cweb = (self.fileType == "c" and not c.use_noweb_flag)
	lb = choose(cweb,"@&lt;","&lt;&lt;")
	rb = choose(cweb,"@&gt;=","&gt;&gt;=")
	intro = lb + " " + self.methodName + " " + methodKind + " " + rb
	if self.fileType == "py":
		&lt;&lt; massage python text &gt;&gt;
	else:
		&lt;&lt; massage other text &gt;&gt;</t>
<t tx="T1161"># For Python, we want to delete all but one tab from the text.

newBody = self.undentPythonBody(s)
# newBody = self.massageAngleBrackets(newBody)
newLine = choose(is_nl(newBody,0),"","\n")
return intro + newLine + newBody</t>
<t tx="T1162">newBody, comment = self.skipLeadingComments(s)
# newBody = self.massageAngleBrackets(newBody)
newLine = choose(is_nl(newBody,0),"","\n")
if len(comment) &gt; 0:
	return comment + "\n" + intro + newLine + newBody
else:
	return intro + newLine + newBody</t>
<t tx="T1163"># Converts &lt; &lt; to @ &lt; &lt; and &gt; &gt; to @ &gt; &gt; everywhere.

def massageAngleBrackets(self,s):

	# Do not use @ &lt; &lt; inside strings.
	lb = "@" ; lb += "&lt;&lt;"
	rb = "@" ; rb += "&gt;&gt;"
	s = string.replace(s,"&lt;&lt;",lb)
	s = string.replace(s,"&gt;&gt;",rb)
	return s</t>
<t tx="T1164">@ Returns s with all runs of whitespace and newlines converted to a single blank.  It also removes leading and trailing whitespace.
@c

def massageComment(self,s):

	s = string.strip(s)
	s = string.replace(s,"\n"," ")
	s = string.replace(s,"\r"," ")
	s = string.replace(s,"\t"," ")
	s = string.replace(s,"  "," ")
	s = string.strip(s)
	return s</t>
<t tx="T1165">@ This skips all leading comments in s, returning the remaining body text and the massaged comment text. Comment text is massaged as follows:

. Leading // on a line is deleted.
. A line starting with /// &lt;&lt; or /// -- end -- &lt;&lt; is deleted.
. The / * and * / characters surrounding a block comment are removed.
. Any sequence of whitespace and newlines is replaced by a single blank.
. Leading and trailing whitespace is deleted.

Returns (body, comment)
@c

def skipLeadingComments(self,s2):

	s = s2
	comment = "" ; newComment = ""
	s = string.lstrip(s)
	i = 0
	while i + 2 &lt; len(s):
		# Skip lines starting with /// &lt;&lt;
		if  i + 6 &lt; len and s.Mid(i,6) == "/// &lt;&lt;":
			while i &lt; len and s[i] != '\n':
				i += 1
			while i &lt; len and is_ws_or_nl(s,i):
				i += 1
		elif i + 16 &lt; len and s.Mid(i,16) == "/// -- end -- &lt;&lt;":
			while i &lt; len and s[i] != '\n':
				i += 1
			while i &lt; len and is_ws_or_nl(s,i):
				i += 1
		elif match(s,i,"//"): # Handle a C++ comment.
			i += 2
			while i &lt; len and s[i] == '/':
				i += 1
			commentStart = i
			while i &lt; len and not is_nl(s,i):
				i += 1
			newComment = self.massageComment(s[commentStart:i-1])
			comment = comment + newComment + "\n"
			while is_ws_or_nl(s,i):
				i += 1
		elif match(s,i,"/*"): # Handle a block C comment.
			i += 2 ; commentStart = i
			while i &lt; len and not match(s,i,"*/"):
				i += 1
			if match(s,i,"*/"):
				i += 2
			newComment = self.massageComment(s[commentStart:i-2])
			comment = comment + newComment + "\n"
			while is_ws_or_nl(s,i):
				i += 1
		else: break
	return s[i:], comment</t>
<t tx="T1166">@ Removes extra leading indentation from all lines.  We look at the first line to determine how much leading whitespace to delete.
@c

def undentPythonBody(self,body):
	
	s = body ; undent = 0
	result = ""
	# Copy an @code line as is.
	if match(s,i,"@code"):
		j = i ; i = skip_past_line(s,i)
		result += s[j:i]
	# Calculate the amount to be removed from each line.
	undent = getPythonIndent(s,i)
	if undent == 0: return body
	while i &lt; len(s):
		ws = 0
		j = skip_past_line(s,i)
		# Skip undent whitespace
		while  i &lt; len(s) and ws &lt; undent:
			if s[i] == ' ':
				ws += 1
				i += 1
			elif s[i] == '\t':
				ws += c.tab_width
				i += 1
			else: break
		result += s[i:j-1]
		i = j
	return result</t>
<t tx="T1167">@ This code creates a child of parent for each Java function definition seen.  See the comments for scanCText for what the text
looks like.
@c

def scanJavaText (self,s,parent,outerFlag): # TRUE if at outer level.

	method_seen = false
	class_seen = false # TRUE is class keyword seen at outer level.
	lparen = None   # Non-null if '(' seen at outer level.
	&lt;&lt; Initialize the ImportFiles private globals &gt;&gt;
	while i &lt; len(s): 
		ch = s[i]
		# These cases skip tokens.
		if ch == '/':
			&lt;&lt; handle possible C comments &gt;&gt;
		elif ch == '"' or ch == '\'':
			i = skip_string(s,i)
		# These cases help determine where functions start.
		elif ch == '=':
			&lt;&lt; handle equal sign in C or Java &gt;&gt;
		elif ch == '(':
			&lt;&lt; handle open paren in C or Java &gt;&gt;
		elif ch == ';':
			&lt;&lt; handle semicolon in C or Java &gt;&gt;
			class_seen = false
		# This cases and the default case can create child nodes.
		elif ch == '{':
			&lt;&lt; handle open curly bracket in Java &gt;&gt;
		elif is_c_id(s[i]):
			&lt;&lt; skip and remember the Java id &gt;&gt;
		else: i += 1
	&lt;&lt; Append any unused text to the parent's body text &gt;&gt;</t>
<t tx="T1168"># Shared by several routines...
scan_start = i
function_start = i
function_end = None
name_start = name_end = None</t>
<t tx="T1169">brace_ip1 = i
i = skip_braces(s,i) # Skip all inner blocks.
brace_ip2 = i
if (i &lt; len(s) and s[i] == '}' and
	(not outerFlag and lparen or outerFlag and class_seen) and
	name_start and name_end and function_start):
	# Point i _after_ the last character of the method.
	i += 1
	if is_nl(s,i):
		i = skip_nl(s,i)
	function_end = i
	headline = s[name_start,name_end]
	if outerFlag:
		leader = "" ; decl_leader = ""
		headline = "class " + headline
		methodKind = "classes"
	else:
		leader = "\t" # Indent only inner references.
		decl_leader = "\n"  # Declaration leader for inner references.
		methodKind = "methods"
	if method_seen:
		# Include everything after the last fucntion.
		function_start = scan_start
	else:
		&lt;&lt; create a Java declaration node &gt;&gt;
		&lt;&lt; append Java method reference to parent node &gt;&gt;
	if outerFlag:
		# Create a headline for the class.
		body = s[function_start:brace_ip1+1]
		body = self.massageBody(body,methodKind)
		v = self.createHeadline(parent,body,headline)
		&lt;&lt; recursively scan the text &gt;&gt;
	else:
		# Create a single headline for the method.
		body = s[function_start:function_end]
		body = self.massageBody(body,methodKind)
		self.createHeadline(parent,body,headline)
	method_seen = true
	scan_start = i
	function_start = i # Set the start of the _next_ function.
	lparen = None
	class_seen = false
else: i += 1</t>
<t tx="T1170">save_ip = i
i = scan_start
while i &lt; function_start and is_ws_or_nl(s,i):
	i += 1
if i &lt; function_start:
	headline = angleBrackets(self.methodName + " declarations ")
	# Append the headline to the parent's body.
	parent.appendStringToBody(decl_leader + leader + headline + "\n")
	decls = s[scan_start:function_start]
	body = "@code\n\n" + decls
	self.createHeadline(parent,body,headline)
i = save_ip
scan_start = i</t>
<t tx="T1171">kind = choose(outerFlag,"classes","methods")
name = angleBrackets(self.methodName + " " + kind)
parent.appendStringToBody(leader + name + "\n")</t>
<t tx="T1172"># These mark the points in the present function.
oldMethodName = self.methodName
self.methodName = headline
scanJavaText(s[brace_ip1+1,brace_ip2], # Don't include either brace.
	v,false) # inner level
self.methodName = oldMethodName
# Append the brace to the parent.
v.appendStringToBody("}")
i = brace_ip2 + 1 # Start after the closing brace.</t>
<t tx="T1173">if is_c_word(s,i,"class"):
	class_seen = true
	i = skip_c_id(s,i)
	i = skip_ws_and_nl(s,i)
	if i &lt; len(s) and is_c_id(s[i]):
		# Remember the class name.
		name_start = i
		i = skip_c_id(s,i)
		name_end = i - 1
elif class_seen:
	# Remember a possible method name.
	name_start = i
	i = skip_c_id(s,i)
	name_end = i - 1
else: i = skip_c_id(s,i)</t>
<t tx="T1174"></t>
<t tx="T1175">i += 1 # skip the opening '/'
if i &lt; len(s) and s[i] == '/':
	i = skip_line(s,i)
elif i &lt; len(s) and s[i] == '*':
	i += 1
	i = skip_block_comment(s,i)</t>
<t tx="T1176">@ We can not be seeing a function definition when we find an equal sign at the top level. Equal signs inside parentheses are handled by the open paren logic.
@c

i += 1 # skip the '='
function_start = None # We can't be in a function.
lparen = None   # We have not seen an argument list yet.
if  i &lt; len(s) and s[i] == '=':
	i = skip_braces(s,i)</t>
<t tx="T1177">lparen = i
# This will skip any equal signs inside the paren.
i = skip_parens(s,i)
if i &lt; len(s) and s[i] == ')':
	i += 1
	i = skip_ws_and_nl(s,i)
	if i &lt; len(s) and s[i] == ';':
		lparen = None # not a function definition.
else: lparen = None</t>
<t tx="T1178">@ A semicolon signals the end of a declaration, thereby potentially starting the _next_ function defintion.   Declarations end a function definition unless we have already seen a parenthesis, in which case we are seeing an old-style function definition.
@c

i += 1 # skip the semicolon.
if lparen == None:
	function_start = i + 1 # The semicolon ends the declaration.</t>
<t tx="T1179"># Used by C, Java and Pascal parsers.
# Do nothing if only whitespace is left.

i = skip_ws_or_nl(s,scan_start)
if i &lt; len(s):
	parent.appendStringToBody(s[scan_start:])</t>
<t tx="T1180">@ This code creates a child of parent for each C function definition seen.

After calling this function the body text of the parent node will look like this:
	..whatever was in the parent node before the call..
	..all text before the first method found..
	&lt;&lt; gModuleName methods &gt;&gt;
	..all text after the last method found..

Each new child node will have the form
	..the text of the method
Namesspaces change the gModuleName global and recursively call self function with a text covering only the range of the
namespace. This effectively changes the definition line of any created child nodes. The namespace is written to the top level.
@c

def scanCText(self,s,parent):

	include_seen = false ; method_seen = false
	first_ip = i # To terminate backwards scans.
	lparen = None   # Non-null if '(' seen at outer level.
	methodKind = choose(self.fileType == "c","functions","methods")
	&lt;&lt; Initialize the ImportFiles private globals &gt;&gt;
	while i &lt; len(s): 
		ch = s[i]
		# These cases skip tokens.
		if ch == '/':
			&lt;&lt; handle possible C comments &gt;&gt;
		elif ch == '"' or ch == '\'':
			i = skip_string(s,i)
		# These cases help determine where functions start.
		elif ch == '=':
			&lt;&lt; handle equal sign in C or Java &gt;&gt;
		elif ch == '(':
			&lt;&lt; handle open paren in C or Java &gt;&gt;
		elif ch == ';':
			&lt;&lt; handle semicolon in C or Java &gt;&gt;
		# These cases and the default case can create child nodes.
		elif ch == '#':
			&lt;&lt; handle # sign &gt;&gt;
		elif ch == '{':
			&lt;&lt; handle open curly bracket in C &gt;&gt;
		elif is_c_id(s,i):
			&lt;&lt; skip c identif ier, typedef, struct, union, namespace &gt;&gt;
		else: i += 1
	&lt;&lt; Append any unused text to the parent's body text &gt;&gt;</t>
<t tx="T1181"># if statements may contain function definitions.
i += 1  # Skip the '#'
if not include_seen and is_c_word(s,i,"include"):
	include_seen = true
	&lt;&lt; create a child node for all #include statements &gt;&gt;
else: i = skip_pp_directive(s,i)</t>
<t tx="T1182"># Scan back to the start of the line.
include_start = i
while include_start &gt; first_ip and not is_nl(s,include_start):
	include_start -= 1
if is_nl(s,include_start):
	include_start = skip_nl(s,include_start)
# Scan to the next line that is neither blank nor and #include.
i = include_start
i = skip_pp_directive(s,i)
i = skip_nl(s,i)
include_end = i
while i &lt; len(s):
	i = skip_ws_and_nl(s,i)
	if is_c_word(s,i,"#include"):
		i = skip_pp_directive(s,i)
		i = skip_nl(s,i)
		include_end = i
	elif i + 2 &lt; len(s) and s[i] == '\\':
		# Handle possible comment.
		if s[i+1] == '\\':
			i = skip_to_end_of_line(s,i)
		elif s[i+1] == '*':
			i = skip_block_comment(s,i + 2)
		else:
			i = include_end ; break
	else:
		i = include_end ; break
headline = angleBracket(" " + self.methodName + " #includes ")
body = "@code\n\n" + s[include_start:include_end]
self.createHeadline(parent,body,headline)
# Append any previous text to the parent's body.
save_ip = i
#
i = scan_start
while i &lt; include_start and is_ws_or_nl(s,i):
	i += 1
if i &lt; include_start:
	parent.appendStringToBody(s[i:include_start])
#
i = save_ip
scan_start = i
function_start = i
# Append the headline to the parent's body.
parent.appendStringToBody(headline + "\n")</t>
<t tx="T1183">i = skip_braces(s,i) # Skip all inner blocks.
if (i &lt; len(s) and s[i] == '}' and  # This may fail if #if's contain unmathed curly braces.
	lparen and name_start and name_end and function_start):
	# Point i _after_ the last character of the function.
	i += 1
	if i &lt; len(s) and(s[i] == '\r' or s[i] == '\n'):
		i = skip_nl(s,i)
	function_end = i
	if method_seen:
		function_start = scan_start # Include everything after the last fucntion.
	else:
		&lt;&lt; create a declaration node &gt;&gt;
		&lt;&lt; append C function/method reference to parent node &gt;&gt;
	length = name_end - name_start + 1
	headline = (name_start,length)
	body = s[function_start:function_end]
	body = self.massageBody(body,"functions")
	self.createHeadline(parent,body,headline)
	method_seen = true
	scan_start = i
	function_start = i # Set the start of the _next_ function.
	lparen = 0
else: i += 1</t>
<t tx="T1184">save_ip = i
i = scan_start
while i &lt; function_start and is_ws_or_nl(s,i):
	i += 1
if i &lt; function_start:
	headline = angleBrackets(self.methodName + " declarations ")
	# Append the headline to the parent's body.
	parent.appendStringToBody(headline + "\n")
	decls = s[scan_start:function_start]
	body = "@code\n\n" + decls
	self.createHeadline(parent,body,headline)
i = save_ip
scan_start = i</t>
<t tx="T1185">cweb = not c.use_noweb_flag
lb = choose(cweb,"@&lt;","&lt;&lt;")
rb = choose(cweb,"@&gt;","&gt;&gt;")
s = lb + self.methodName + " " + methodKind + rb
parent.appendStringToBody(s + "\n")</t>
<t tx="T1186">if is_c_word(s,i,"typedef"):
	i = skip_typedef(s,i)
	lparen = None
elif is_c_word(s,i,"struct"):
	i = skip_typedef(s,i)
	# lparen = NULL ;  # This can appear in an argument list.
elif is_c_word(s,i,"union"):
	i = skip_typedef(s,i)
	# lparen = NULL ;  # This can appear in an argument list.
elif is_c_word(s,i,"namespace"):
	&lt;&lt; Create children for the namespace &gt;&gt;
else:
	# Remember the last name before an open parenthesis.
	if lparen == None:
		name_start = i
	i = skip_c_id(s,i)
	if lparen == None:
		name_end = i - 1
	&lt;&lt; test for operator keyword &gt;&gt;</t>
<t tx="T1187"># We treat a C++ a construct such as operator + as a function name.
if match(s[name_start:name_end],"operator"):
	i = skip_ws(s,i) # Don't allow newline in headline.
	if  i &lt; len(s) and not is_c_id(s[i]) and s[i] != ' ' and s[i] != '\n' and s[i] != '\r':
		while i &lt; len(s) and not is_c_id(s[i]) and s[i] != ' ' and s[i] != '\n' and s[i] != '\r':
			i += 1
		name_end = i - 1</t>
<t tx="T1188"># skip the "namespace" keyword.
i += 9
i = skip_ws_and_nl(s,i)
# Skip the namespace name.
namespace_name_start = i
namespace_name_end = None
if i &lt; len(s) and is_c_id(s[i]):
	i = skip_c_id(s,i)
	namespace_name_end = i - 1
else: namespace_name_start = None
# Skip the '{'
i = skip_ws_and_nl(s,i)
if i &lt; len(s) and s[i] == '{' and namespace_name_start:
	inner_ip = i + 1
	i = skip_braces(s,i)
	if i &lt; len(s) and s[i] == '}':
		# Append everything so far to the body.
		len = inner_ip - scan_start
		if len &gt; 0:
			parent.appendStringToBody(s[scan_start:inner_ip])
		# Save and change gModuleName to namespaceName
		savedMethodName = self.methodName
		len = namespace_name_end - namespace_name_start + 1
		namespaceName(namespace_name_start,len)
		self.methodName = "namespace " + namespaceName
		# Recursively call this function .
		self.scanCText(s[inner_ip:],parent)
		# Restore gModuleName and continue scanning.
		savedMethodName = savedMethodName
		scan_start = i
		function_start = i</t>
<t tx="T1189">@ Creates a child of parent for each Pascal function definition seen.  See the comments for scanCText for what the text looks like.
@c

def scanPascalText(self,s,parent):

	method_seen = false
	methodKind("methods")
	&lt;&lt; Initialize the ImportFiles private globals &gt;&gt;
	while i &lt; len(s):
		ch = s[i]
		if ch == '{':
			i = skip_pascal_braces(s,i)
		elif ch == '/':
			&lt;&lt; handle possible Pascal single-line comment &gt;&gt;
		elif ch == '(':
			&lt;&lt; handle possible Pascal block comment &gt;&gt;
		elif ch == '"' or ch == '\'':
			i = skip_pascal_string(s,i)
		elif is_c_id(s[i]):
			&lt;&lt; handle possible Pascal function &gt;&gt;
		else: i += 1
	&lt;&lt; Append any unused text to the parent's body text &gt;&gt;</t>
<t tx="T1190">if is_c_word(s,i,"begin"):
	i = skip_pascal_begin_end(s,i)
	if is_c_word(s,i,"end"):
		i = skip_c_id(s,i)
elif (is_c_word(s,i,"function")  or is_c_word(s,i,"procedure") or
	is_c_word(s,i,"constructor") or is_c_word(s,i,"destructor")):
	start = i
	i = skip_c_id(s,i)
	i = skip_ws_and_nl(s,i)
	&lt;&lt; remember the function name, or continue &gt;&gt;
	&lt;&lt; skip the function definition, or continue &gt;&gt;
	if method_seen == false:
		method_seen = true
		&lt;&lt; create a child node for leading declarations &gt;&gt;
		&lt;&lt; append noweb method reference to the parent node &gt;&gt;
		function_start = start
	else: function_start = scan_start
	&lt;&lt; create a child node for the function &gt;&gt;
else: i = skip_c_id(s,i)</t>
<t tx="T1191">save_ip = i
i = scan_start
while i &lt; start and is_ws_or_nl(s,i):
	i += 1
if i &lt; start:
	headline = angleBrackets(self.methodName + " declarations ")
	# Append the headline to the parent's body.
	parent.appendStringToBody(headline + "\n")
	body = "@code\n\n" + s[scan_start:start]
	self.createHeadline(parent,body,headline)
i = save_ip
scan_start = i</t>
<t tx="T1192"># Point i _after_ the last character of the function.
i = skip_ws(s,i)
if i &lt; len(s) and(s[i] == '\r' or s[i] == '\n'):
	i = skip_nl(s,i)
function_end = i
length = name_end - name_start + 1
headline = (name_start,length)
body = s[function_start:function_end]
body = self.massageBody(body,methodKind)
self.createHeadline(parent,body,headline)
scan_start = i</t>
<t tx="T1193">if i &lt; len(s) and is_c_id(s[i]):
	name_start = i
	i = skip_c_id(s,i)
	while i + 1 &lt; len(s) and s[i] == '.' and is_c_id(s[i+1]):
		i += 1
		name_start = i
		i = skip_c_id(s,i)
	name_end = i - 1
else: continue</t>
<t tx="T1194">&lt;&lt; skip past the semicolon &gt;&gt;
if not is_c_word(s,i,"begin"):
	continue
# Skip to the matching end.
i = skip_pascal_begin_end(s,i)
if is_c_word(s,i,"end"):
	i = skip_c_id(s,i)
	i = skip_ws_and_nl(s,i)
	if i &lt; len(s) and s[i] == ';':
		i += 1
	i = skip_ws(s,i)
	if i &lt; len(s) and(s[i] == '\n' or s[i] == '\r'):
		i = skip_nl(s,i)
else: continue</t>
<t tx="T1195">while i &lt; len(s) and s[i] != ';':
	# The paremeter list may contain "inner" semicolons.
	if s[i] == '(':
		i = skip_parens(s,i)
		if i &lt; len(s) and s[i] == ')':
			i += 1
		else: break
	else: i += 1
if i &lt; len(s) and s[i] == ';':
	i += 1
i = skip_ws_and_nl(s,i)
if is_c_word(s,i,"var"):
	# Skip to the next begin.
	i = skip_c_id(s,i)
	done = false
	while i &lt; len(s) and not done:
		ch = s[i]
		if ch == '{':
			i = skip_pascal_braces(s,i)
		elif ch == '/':
			&lt;&lt; handle possible Pascal single-line comment &gt;&gt;
		elif ch == '(':
			&lt;&lt; handle possible Pascal block comment &gt;&gt;
		elif ch == '"' or ch == '\'':
			i = skip_pascal_string(s,i)
		elif is_c_word(s,i,"begin"):
			done = true
		else: i += 1</t>
<t tx="T1196">i += 1 # skip the opening '/'
if  i &lt; len(s) and s[i] == '/':
	i = skip_to_end_of_line(s,i)</t>
<t tx="T1197">i += 1 # skip the '('
if  i &lt; len(s) and s[i] == '*':
	i += 1 # skip the '*'
	i = skip_pascal_block_comment(s,i)</t>
<t tx="T1198"># Append the headline to the parent's body.
ref = angleBrackets(" " + self.methodName + " methods ")
parent.appendStringToBody(ref + "\n")</t>
<t tx="T1199">@ Creates a child node c of parent for the class, and children of c for each def in the class.
@c

def scanPythonClass(self,s,parent):

	&lt;&lt; set classname and headline, or return i &gt;&gt;
	i = skip_line(s,0) # Skip the class line.
	&lt;&lt; create class_vnode &gt;&gt;
	savedMethodName = self.methodName
	self.methodName = headline
	# Create a node for leading declarations of the class.
	i = scanPythonDecls(s,class_vnode,indent_refs)
	&lt;&lt; append a reference to class_vnode's methods &gt;&gt;
	&lt;&lt; create nodes for all defs of the class &gt;&gt;
	self.methodName = savedMethodName
	return i</t>
<t tx="T1200"># Skip to the class name.
i = skip_ws(s,i)
i = skip_c_id(s,i) # skip "class"
i = skip_ws_and_nl(s,i)
if i &lt; len(s) and is_c_id(s[i]):
	j = i ; i = skip_c_id(s,i)
	classname = s[j:i]
	headline = "class " + classname
else: return i</t>
<t tx="T1201"># Create the section name using the old value of self.methodName.
body = angleBrakets(" " + self.methodName + " methods ") + "=\n\n"
# i points just after the class line.
body2 = s[start:i]
body2 = undentPythonBody(body2)
body += body2
class_vnode = self.createHeadline(parent,body,headline)</t>
<t tx="T1202"># This must be done after the declaration reference is generated.
ref = "\t" + angleBrakets(" class " + classname + " methods ")
class_vnode.appendStringToBody(ref + "\n\n")</t>
<t tx="T1203">line_start = find_line_start(s,i)
indent1 = getPythonIndent(s[line_start:])
# Skip past blank lines.
i = skip_blank_lines(s,i)
start = i
indent = indent1
while i &lt; len(s) and indent &gt;= indent1:
	if is_nl(s[i]):
		j = skip_nl(s,i)
		indent = getPythonIndent(s,j)
		if indent &gt;= indent1: i = j
	elif is_c_word(s,i,"def"):
		start = i = scanPythonDef(start,s,i,class_vnode)
		indent = getPythonIndent(s,i)
	elif is_c_word(s,i,"class"):
		start = i = scanPythonClass(start,s,i,class_vnode)
		indent = getPythonIndent(s,i)
	elif s[i] == '#':
		i = skip_to_end_of_line(s,i)
	elif s[i] == '"' or s[i] == '\'':
		i = skip_python_string(s,i)
	else: i += 1</t>
<t tx="T1204">@ Creates a node of parent for the def.  i points to "def".

start is only used to scan for the start of the def line; it's exact value doesn't matter much.
@c

def scanPythonDef(self,start,s,parent):

	&lt;&lt; set headline or return i &gt;&gt;
	&lt;&lt; skip the Python def &gt;&gt;
	# Create the def node.
	save = self.methodName
	self.methodName = headline
	&lt;&lt; Create def node &gt;&gt;
	self.methodName = save
	return i</t>
<t tx="T1205">i = skip_ws(s,i)
i = skip_c_id(s,i) # Skip the "def"
i = skip_ws_and_nl(s,i)
if i &lt; len(s) and is_c_id(s[i]):
	j = i ; i = skip_c_id(s,i)
	headline = s[j:i]
else: return i</t>
<t tx="T1206"># This doesn't handle nested defs or classes.  It should.
# Set indent1 to the indentation of the def line.

line_start = find_line_start(s,i)
indent1 = getPythonIndent(s[line_start:])
i = skip_line(s,i) # Skip the def line.
indent = getPythonIndent(s,i)
while i &lt; len(s) and indent &gt;= indent1:
	ch = s[i]
	if is_nl(s,i):
		i = skip_nl(s,i)
		indent = getPythonIndent(s,i)
		if indent &lt;= indent1: break
	elif ch == '#': i = skip_line(s,i)
	elif ch == '"' or ch == '\'': i = skip_python_string(s,i)
	else: i += 1</t>
<t tx="T1207"># Create the header line.
body = angleBrackets(" " + savedMethodName + " methods ") + "=\n\n"
# Create body.
start = skip_blank_lines(s,start)
body2= s[:i]
body2 = undentPythonBody(body2)
body += body2
# Create the node.
self.createHeadline(parent,body,headline)</t>
<t tx="T1208">def scanPythonDecls(self,s,parent,indent_parent_ref_flag):
	
	i = 0 ; done = false
	while not done and i &lt; len(s):
		ch = s[i]
		if ch == '\n': i = skip_nl(s,i)
		elif ch == '#': i = skip_to_end_of_line(s,i)
		elif ch == '"' or ch == '\'': i = skip_python_string(s,i)
		elif is_c_id(s[i]):
			&lt;&lt; break on def or class &gt;&gt;
		else: i += 1
	j = skip_blank_lines(s,0)
	if is_nl(s,j):
		j = skip_nl(s,j)
	if j &lt; i:
		&lt;&lt; Create a child node for declarations &gt;&gt;
	return i</t>
<t tx="T1209">if is_c_word(s,i,"def") or is_c_word(s,i,"class"):
	i = find_line_start(s,i)
	done = true
	break
else:
	i = skip_c_id(s,i)</t>
<t tx="T1210"># Create the body.
body = "@code\n\n" + s[j:i]
body = undentPythonBody(body)
# Create the headline.
headline = angleBrackets(" " + self.methodName + " declarations ")
# Append the headline to the parent's body.
ctab = choose(indent_parent_ref_flag,"\t","")
parent.appendStringToBody(ctab + headline + "\n")
# Create the node for the decls
self.createHeadline(parent,body,headline)</t>
<t tx="T1211">@ This code creates a child of parent for each Python function definition seen.  See the comments for scanCText for what the text looks like.
@c

def scanPythonText(self,s,parent):
	
	decls_seen = false ; methodKind = "methods"
	start = i = 0
	while i &lt; len(s):
		ch = s[i]
		if ch == '\n': i = skip_nl(s,i)
		elif ch == '#': i = skip_to_end_of_line(s,i)
		elif ch == '"' or ch == '\'': i = skip_python_string(s,i)
		elif is_c_id(ch):
			&lt;&lt; handle possible Python function or class &gt;&gt;
		else: i += 1
	&lt;&lt; Append a reference to the methods of this file &gt;&gt;
	&lt;&lt; Append any unused python text to the parent's body text &gt;&gt;</t>
<t tx="T1212">if is_c_word(s,i,"def"):
	if not decls_seen:
		start = i = scanPythonDecls(s[i:],parent,dont_indent_refs)
		decls_seen = true
	start = i = scanPythonDef(start,s[i:],parent)
elif is_c_word(s,i,"class"):
	if not decls_seen:
		start = i = scanPythonDecls(s[start:],parent,dont_indent_refs)
		decls_seen = true
	start = i = scanPythonClass(s[start:],parent)
else:
	i = skip_c_id(s,i)</t>
<t tx="T1213">ref = angleBrackets(" " + self.methodName + " methods ")
parent.appendStringToBody(ref + "\n\n")</t>
<t tx="T1214"># Do nothing if only whitespace is left.
i = start ; i = skip_ws_and_nl(s,i)
if i &lt; len(s):
	parent.appendStringToBody(s[start:])</t>
<t tx="T1215">&lt;&lt; About the vnode and tnode classes &gt;&gt;
&lt;&lt; About clones &gt;&gt;

from leoGlobals import *
from leoUtils import *
import leoTree

class vnode:
	&lt;&lt; vnode members &gt;&gt;

class tnode:
	&lt;&lt; tnode members &gt;&gt;</t>
<t tx="T1216">@ The vnodes and tnodes classes form the heart of the "model" classes (using the Smalltalk model/view/controller terminology).  That is, the vnode and tnode classes represent nearly all the data contained in the outline.  These two classes also provide a way of hiding the underlying implementation.  For instance, the Delphi classes used to implement outlines (TTreeView, TTreeNode and TTreeNodes) appear only in the implementation of the vodes and tnodes class.

The developer documentation contains an extended discussion of these two classes.  To summarize:  a vnode (visual nodes) represents a headlines _at a particular location on the screen_.  When a headline is cloned, vnodes must be copied.  tnodes, (text nodes) on the other hand, represent body text: a tnode is shared by all vnodes that are clones of each other.  In other words, tnodes are the "unit of sharing" of body text.
</t>
<t tx="T1217">@ This is the design document for clones in Leo. It covers all important aspects of clones. Clones are inherently complex, and this paper will include several different definitions of clones and related concepts.

The user's view of clones

Leo's documentation describes clones as follows:

Definition 1:

"A clone node is a copy of a node that changes when the original changes. Changes to the children, grandchildren, etc. of a node are simultaneously made to the corresponding nodes contained in all cloned nodes. Clones are marked by a small clone arrow by its leader character."

As we shall see, this definition glosses over a number of important complications.

Clone bits

Internally, the clone arrow is represented by a clone bit in the status field of the vnode. The "Clone" command sets the clone bits of the "orignal" and "cloned" vnodes when it creates the clone.

Joined nodes

Two vnodes are joined if a) they share the same tnode (body text) and b) changes to any subtree of either joined vnodes are made to the corresponding nodes in all joined nodes. For example, Definition 1 defines clones as joined nodes that are marked with a clone arrow.

Leo links all vnodes joined to each other in a circular list. For any vnode n, let J(n) denote the set of all vnodes joined to n.

Structurally similar nodes

The concept of "structurally similar" nodes provides an effective way of determining when two joined nodes should have their cloned bit set.  Two joined nodes are structurally similar if a) their parents are distinct but joined and b) they are both the nth child of their (distinct) parents.

Let us consider the following alternative definition of cloned and non-cloned nodes.

Definition 2:

A node n is a clone if and only if there exist two vnodes in J(n) that are not structurally similar to each other.  Thus, non-cloned vnodes are vnodes such that all of the vnodes of J(n) are structually similar. In particular, n is a non-cloned vnode if J(n) is empty.

How do we know that Definitions 1 and 2 are consistent? Informally, these definitions are consistent because Leo makes them consistent. Definition 1 says that:

changes to the children, grandchildren, etc. of a node are simultaneously made to the corresponding nodes contained in all cloned nodes.

Making "corresponding changes" to the descendents of all cloned nodes insures that the non-cloned joined nodes will be structurally similar. On the other hand, cloned nodes are never structurally similar. They are created as siblings, so they have the same parent with different "child indices."  We shall consider the cases of moving and deleting cloned ndoes later.

We could prove consistency by induction: The definitions are (trivially) consistent for an outline containing one root node, they remain consistent when a) cloned nodes are created, moved or deleted or b) when descendents of cloned nodes are moved, inserted or deleted.

In any event, let's accept these definitions as consistent. Let's look at some examples.  In these examples, an apostrophe signifies the clone bit and the corresponding clone mark on the screen.

Example 1

root
  a' (1)
  a' (2)

This example shows the simplest possible clone. Node a in position (1) has just been cloned to produce a' in position (2). These two cloned nodes are not structurally similar because their parents are not distinct and because they occupy different positions relative to their common parent.

Example 2

If we add a node b as the first child of either a' node we get the following tree:

root
  a'
    b
  a'
    b

The b nodes are struturally similar because the a' nodes are joined and each b node is the first child of its parent.

Example 3

If we now clone either b, we will get:

root
  a'
    b' (1)
    b' (2)
  a'
    b' (1)
    b' (2)

All b' nodes must be clones because the nodes marked (1) are not structurally similar to the nodes marked (2).

Dependent nodes

Dependent nodes are nodes created or destroyed when corresponding linked nodes are created or destroyed in another tree. For example, going from example 1 to example 2 above, adding node b to either node a' causes another (dependent) node to be created as the descendent of the other node a'. Similary, going from example 2 to example 1, deleting node b from either node a' causes the other (dependent) node b to be deleted from the other node a'.

Cloned nodes may also be dependent nodes.  This will happen if the cloned nodes are descendents of other cloned nodes.  In Example 3, the b' nodes in position (1) are dependent on the other b' node in position (1).  Similarly, the b' nodes in position (2) depend on each other.

Inserting, Deleting and Moving nodes

We can now give simple rules for inserting and deleting dependent vnodes when other vnodes are created, moved or destroyed. For the purposes of this discussion, moving a node is handled exactly like deleting the node followed by inserting the node; we need not consider moving nodes further.

It is easy to insert a new node n as the nth child of a parent node p. We insert n, then for every node pi linked to p, we insert a dependent node ni as the nth child of pi. Each ni is joined to n. Clearly, each ni is structurally similar to n.

Similarly, it is easy to delete a node n that is the nth child of a parent node p. We delete each dependent node ni that is the nth child of any node pi linked to p. We then delete n.

As we have seen, when inserting or deleting any vnode n we must update its join list, J(n). Updating the join list is made easier because the list is circular: the entire list is accessible from any of its members.

Propagating clone bits: the shouldBeClone function

Inserting or deleting nodes can cause the clone bits of all joined nodes to change in non-trivial ways. We could examine a number of special cases, but there is an easier way. Because of Definition 2, we can define a shouldBeClone function that checks J(n) to see whether all nodes of J(n) are stucturally similar or not.  We set the clone bits if not, otherwise we clear the clone bits.

To see why shouldBeClone is necessary, consider deleting any of the b' nodes from Example 3. We would be left with the tree in Example 2. There are two remaining b nodes, each with the clone bit set.  The nodes are still joined but should no longer be cloned.  Checking for structural similarity is the only way to clear these clone bits.

Omitting Join lists from Files

The XML file format does not save join lists. This makes it much safer to change a Leo file "by hand." If join lists were part of the file, as they are in the Mac version of Leo, it would be too easy to corrupt the entire file by screwing up a join list.

It is easy to recreate the join lists when reading a file, provided that we allocate one extra field in each tnode. This field is the head of a list of all vnodes that point to the tnode. We create this list with one pass through the vnodes, then convert each list to a circular list in one additional pass through the tnodes.

Conclusion

Redefining clones in terms of structural simularity solves all major problems involving clones. Earlier schemes that did not use the shouldBeClone functions maintained "clone lists" of all clones that were, in fact, structurally similar! The Mac version complicated matters further by storing the join and clone lists in the file format. It's much easier and safer to call shouldBeClone as needed. The shouldBeClone function is very fast, provided that the join lists have already been computed. Moving cloned nodes is slow in the YB version of Leo because join lists are recomputed whenever needed.
</t>
<t tx="T1218">&lt;&lt; tnode constants &gt;&gt;

@others</t>
<t tx="T1219">dirtyBit =		0x01
richTextBit =	0x02 # Determines whether we use &lt;bt&gt; or &lt;btr&gt; tags.
visitedBit =	0x04</t>
<t tx="T1220"># All params have defaults, so t = tnode() is valid.

def __init__ (self, index = 0, bodyString = None):

	self.bodyString = choose(bodyString, bodyString, "")
	self.joinHead = None # The head of the join list while a file is being read.
	self.statusBits = 0 # status bits
	self.fileIndex = index # The immutable file index for self tnode.
	self.selectionStart = 0 # The start of the selected body text.
	self.selectionLength = 0 # The length of the selected body text.
	self.cloneIndex = 0 # Zero for @file nodes</t>
<t tx="T1221">def __del__ (self):

	# Can't trace while destroying.
	# print "t.__del__"
	pass</t>
<t tx="T1222">def destroy (self):

	self.joinHead = None</t>
<t tx="T1223">def hasBody (self):

	return self.bodyString and len(self.bodyString) &gt; 0</t>
<t tx="T1224">def loadBodyPaneFromTnode(self, body):

	s = self.bodyString
	if s and len(s) &gt; 0:
		body.delete(1,"end")
		body.insert(1,s)
		#body.SetSelection(
			#self.selectionStart,
			#self.selectionStart + self.selectionLength)
	else:
		body.delete(1,"end")
		#self.selectionStart = self.selectionLength = 0</t>
<t tx="T1225">def isDirty (self):

	return (self.statusBits &amp; self.dirtyBit) != 0</t>
<t tx="T1226">def isRichTextBit (self):

	return (self.statusBits &amp; self.richTextBit) != 0</t>
<t tx="T1227">def isVisited (self):

	return (self.statusBits &amp; self.visitedBit) != 0</t>
<t tx="T1228">def saveBodyPaneToTnode (self, body):

	self.bodyString = body.GetValue()
	# Set the selection.
	i, j = body.GetSelection()
	if i &gt; j:
		temp = i
		i = j
		j = temp
	self.selectionStart = i
	self.selectionLength = j - i</t>
<t tx="T1229"># This sets the text in the tnode from the given string.

def setTnodeText (self, s):

	assert(type(s)==type(""))
	self.bodyString = s</t>
<t tx="T1230">def setSelection (self, start, length):

	self.selectionStart = start
	self.selectionLength = length</t>
<t tx="T1231">def clearDirty (self):

	self.statusBits &amp;= ~ self.dirtyBit</t>
<t tx="T1232">def clearRichTextBit (self):

	self.statusBits &amp;= ~ self.richTextBit</t>
<t tx="T1233">def clearVisited (self):

	self.statusBits &amp;= ~ self.visitedBit</t>
<t tx="T1234">def setDirty (self):

	self.statusBits |= self.dirtyBit</t>
<t tx="T1235">def setRichTextBit (self):

	self.statusBits |= self.richTextBit</t>
<t tx="T1236">def setVisited (self):

	self.statusBits |= self.visitedBit</t>
<t tx="T1237">def setCloneIndex (self, index):

	self.cloneIndex = index</t>
<t tx="T1238">def setFileIndex (self, index):

	self.fileIndex = index</t>
<t tx="T1239">def setJoinHead (self, v):

	self.joinHead = v</t>
<t tx="T1240">&lt;&lt; vnode constants &gt;&gt;

@others</t>
<t tx="T1241"># Define the meaning of vnode status bits.

# Archived...
clonedBit	 = 0x01 # true: vnode has clone mark.
# not used	 = 0x02
expandedBit  = 0x04 # true: vnode is expanded.
markedBit	 = 0x08 # true: vnode is marked
orphanBit	 = 0x10 # true: vnode saved in .leo file, not derived file.
selectedBit  = 0x20 # true: vnode is current vnode.
topBit		 = 0x40 # true: vnode was top vnode when saved.

# Not archived
visitedBit	 = 0x80</t>
<t tx="T1242">def __del__ (self):

	# Can't trace while destroying.
	# print "v.__del__" + `self`
	pass</t>
<t tx="T1243">def __repr__ (self):

	return "v: " + self.mHeadString</t>
<t tx="T1244">if 0: # Unlike the SWIG code, this is not needed.
	def __cmp__(self,other):
		return not (self is other) # Must return 0, 1 or -1</t>
<t tx="T1245">@ Returns the filename following @file in the receivers's headline, or the empty string if the receiver is not an @file node.
@c

def atFileNodeName (self):

	h = self.mHeadString
	if match(h,0,"@file"):
		s = h[5:]
		return string.strip(s)
	else:
		return ""</t>
<t tx="T1246"># Returns true if the receiver's headline starts with @file.

def isAtFileNode (self):

	s = self.atFileNodeName()
	return len(s) &gt; 0</t>
<t tx="T1247">@ Returns true if the receiver contains @ignore in its body at the start of a line.
@c

def isAtIgnoreNode (self):

	flag, i = is_special(self.t.bodyString, 0, "@ignore")
	return flag</t>
<t tx="T1248">@ Returns true if the receiver contains @others in its body at the start of a line.
@c

def isAtOthersNode (self):

	flag, i = is_special(self.t.bodyString, 0, "@others")
	return flag</t>
<t tx="T1249">@ Returns true if the headline matches the pattern ignoring whitespace and case.  The headline may contain characters following the successfully matched pattern.
@c

def matchHeadline (self,pattern):

	h = string.lower(self.mHeadString)
	h = string.replace(h,' ','')
	h = string.replace(h,'\t','')

	p = string.lower(pattern)
	p = string.replace(p,' ','')
	p = string.replace(p,'\t','')

	# ignore characters in the headline following the match
	return p == h[0:len(p)]</t>
<t tx="T1250"># Converts the outline to a string in "MORE" format

def convertTreeToString (self):

	newline = "\r\n"
	v = self
	level1 = v.level()
	after = v.nodeAfterTree()
	s = ""
	while v and v != after:
		s += v.moreHead(level1)
		s += newline
		body = v.moreBody()
		if len(body) &gt; 0:
			s += body
			s += newline
		v = v.threadNext()
	return s</t>
<t tx="T1251"># Returns the headline string in MORE format.

def moreHead (self, firstLevel):

	s = ""
	level = self.level() - firstLevel
	if level &gt; 0:
		s += "\t" * level
	s += choose(self.hasChildren(), "+ ", "- ")
	s += self.mHeadString
	return s</t>
<t tx="T1252">@ Returns the body string in MORE format.  It inserts a backslash before any leading plus, minus or backslash.
@c

def moreBody (self):

	list = []
	for c in self.t.bodyString:
		if c == '+' or c == '-' or c == '\\':
			list.append('\\')
		list.append(c)
	return string.join(list,'')</t>
<t tx="T1253"># Compatibility routine for scripts

def bodyString (self):

	return self.t.bodyString</t>
<t tx="T1254"># childIndex and nthChild are zero-based.

def childIndex (self):

	parent=self.parent()
	if not parent: return 0 # This index is never used.

	child = parent.firstChild()
	n = 0
	while child:
		if child == self: return n
		n += 1 ; child = child.next()
	assert(0)</t>
<t tx="T1255"># Compatibility routine for scripts

def firstChild (self):

	return self.mFirstChild</t>
<t tx="T1256">def hasChildren (self):

	return self.firstChild() != None</t>
<t tx="T1257"># Compatibility routine for scripts

def lastChild (self):

	child = self.firstChild()
	while child and child.next():
		child = child.next()
	return child</t>
<t tx="T1258"># childIndex and nthChild are zero-based.

def nthChild (self, n):

	child = self.firstChild()
	if not child: return None
	while n &gt; 0 and child:
		n -= 1
		child = child.next()
	return child</t>
<t tx="T1259">def numberOfChildren (self):

	n = 0
	child = self.firstChild()
	while child:
		n += 1
		child = child.next()
	return n</t>
<t tx="T1260"># Compatibility routine for scripts

def currentVnode (self):

	return self.commands.tree.currentVnode</t>
<t tx="T1261"># Compatibility routine for scripts

def findRoot (self):

	return self.commands.tree.rootVnode
</t>
<t tx="T1262">def getJoinList (self):

	return self.joinList</t>
<t tx="T1263"># Compatibility routine for scripts

def headString (self):

	return self.mHeadString

</t>
<t tx="T1264">def isAncestorOf (self, v):

	if not v:
		return false
	v = v.parent()
	while v:
		if v == self:
			return true
		v = v.parent()
	return false</t>
<t tx="T1265">def isRoot (self):

	return not self.parent() and not self.back()</t>
<t tx="T1266">def isCloned (self):

	return ( self.statusBits &amp; vnode.clonedBit ) != 0</t>
<t tx="T1267">def isDirty (self):

	return self.t.isDirty()</t>
<t tx="T1268">def isExpanded (self):

	return ( self.statusBits &amp; self.expandedBit ) != 0</t>
<t tx="T1269">def isMarked (self):

	return ( self.statusBits &amp; vnode.markedBit ) != 0</t>
<t tx="T1270">def isOrphan (self):

	return ( self.statusBits &amp; vnode.orphanBit ) != 0</t>
<t tx="T1271">def isSelected (self):

	return ( self.statusBits &amp; vnode.selectedBit ) != 0</t>
<t tx="T1272">def isTopBitSet (self):

	return ( self.statusBits &amp; self.topBit ) != 0</t>
<t tx="T1273"># Returns true if all parents are expanded.

def isVisible (self):

	v = self.parent()
	while v:
		if not v.isExpanded():
			return false
		v = v.parent()
	return true</t>
<t tx="T1274">def isVisited (self):

	return ( self.statusBits &amp; vnode.visitedBit ) != 0</t>
<t tx="T1275">def status (self):

	return self.statusBits</t>
<t tx="T1276"># Compatibility routine for scripts

def back (self):

	return self.mBack</t>
<t tx="T1277">def lastNode (self):

	v = self
	level = self.level()
	result = None

	while v:
		result = v
		v = v.threadNext()
		if not v or v.level() &lt;= level:
			break

	return result</t>
<t tx="T1278">@ This function returns the indentation level of the receiver. The root nodes have level 0, their children have level 1, and so on.
@c

def level (self):

	level = 0 ; parent = self.parent()
	while parent:
		level += 1
		parent = parent.parent()
	return level</t>
<t tx="T1279"># Compatibility routine for scripts

def next (self):

	return self.mNext</t>
<t tx="T1280"># Returns the vnode following the tree whose root is the receiver.

def nodeAfterTree (self):

	next = self.next()
	p = self.parent()

	while not next and p:
		next = p.next()
		p = p.parent()

	return next</t>
<t tx="T1281"># Compatibility routine for scripts

def parent (self):

	return self.mParent</t>
<t tx="T1282"># Returns the previous element of the outline, or None if at the start of the outline.

def threadBack (self):

	back = self.back()
	if back:
		lastChild = back.lastChild()
		if lastChild:
			return lastChild.lastNode()
		else:
			return back
	else:
		return self.parent()</t>
<t tx="T1283">def threadNext (self):

	"""Returns node following the receiver in "threadNext" order.
	This should be called whenever v's links change"""
	
	v = self
	
	if v.firstChild():
		return v.firstChild()
	elif v.next():
		return v.next()
	else:
		p = v.parent()
		while p:
			if p.next():
				return p.next()
			p = p.parent()
		return None</t>
<t tx="T1284">def visBack (self):

	v = self.threadBack()
	while v and not v.isVisible():
		v = v.threadBack()
	return v</t>
<t tx="T1285">def visNext (self):

	v = self.threadNext()
	while v and not v.isVisible():
		v = v.threadNext()
	return v</t>
<t tx="T1286">def appendStringToBody (self, s):

	if len(s) == 0: return
	body = self.t.bodyString + s
	self.setBodyStringOrPane(body)</t>
<t tx="T1287">def setBodyStringOrPane (self, s):

	v = self ; c = v.commands
	if not c or not v: return
	if v == c.currentVnode():
		c.frame.body.delete("1.0","end")
		c.frame.body.insert("1.0", s) # Replace the body text with s.
		c.recolor()
	# Keep the body text in the tnode up-to-date.
	v.t.setTnodeText(s)
	v.t.setSelection(0,0)
	v.setDirty()
	if not c.isChanged():
		c.setChanged(true)

setBodyTextOrPane = setBodyStringOrPane # Compatibility with old scripts</t>
<t tx="T1288">def setHeadString(self, s):

	self.mHeadString = s
	self.setDirty()

def initHeadString (self, s):

	self.mHeadString = s</t>
<t tx="T1289"># Compatibility routine for scripts

def setHeadStringOrHeadline (self, s):

	c = self.commands
	c.endEditing()
	self.setHeadString(s)</t>
<t tx="T1290">def computeIcon (self):

	val = 0 ; v = self
	if v.t.hasBody(): val += 1
	if v.isMarked(): val += 2
	if v.isCloned(): val += 4
	if v.isDirty(): val += 8
	return val
	
def setIcon (self):

	pass # Compatibility routine for old scripts</t>
<t tx="T1291"># Compatibility routine for scripts

def clearAllVisited (self):
	
	c = self.commands.clearAllVisited()
</t>
<t tx="T1292">def clearAllVisitedInTree (self):

	v = self ; c = v.commands
	after = v.nodeAfterTree()
	
	c.beginUpdate()
	while v and v != after:
		v.clearVisited()
		v.t.clearVisited()
		v = v.threadNext()
	c.endUpdate()
</t>
<t tx="T1293">def clearClonedBit (self):

	self.statusBits &amp;= ~ self.clonedBit</t>
<t tx="T1294">def clearDirty (self):

	v = self
	v.t.clearDirty()

def clearDirtyJoined (self):

	v = self ; c = v.commands
	c.beginUpdate()
	if 1: # update range
		v.t.clearDirty()
		v2 = v.getJoinList()
		while v2 and v2 != self:
			v2.t.clearDirty()
			v2 = v2.getJoinList()
	c.endUpdate() # recomputes all icons</t>
<t tx="T1295">def clearMarked (self):

	self.statusBits &amp;= ~ self.markedBit</t>
<t tx="T1296">def clearOrphan (self):

	self.statusBits &amp;= ~ self.orphanBit</t>
<t tx="T1297">def clearVisited (self):

	self.statusBits &amp;= ~ self.visitedBit</t>
<t tx="T1298">def clearVisitedInTree (self):

	after = self.nodeAfterTree()
	v = self
	while v and v != after:
		v.clearVisited()
		v = v.threadNext()</t>
<t tx="T1299">def contract(self):

	self.statusBits &amp;= ~ self.expandedBit

def expand(self):

	self.statusBits |= self.expandedBit

def initExpandedBit (self):

    self.statusBits |= self.expandedBit</t>
<t tx="T1300">def initStatus (self, status):

	self.statusBits = status</t>
<t tx="T1301">def setClonedBit (self):

	self.statusBits |= self.clonedBit

def initClonedBit (self, val):

	if val:
		self.statusBits |= self.clonedBit
	else:
		self.statusBits &amp;= ~ self.clonedBit</t>
<t tx="T1302">def setMarked (self):

	self.statusBits |= self.markedBit

def initMarkedBit (self):

	self.statusBits |= self.markedBit</t>
<t tx="T1303">def setOrphan (self):

	self.statusBits |= self.orphanBit</t>
<t tx="T1304"># This only sets the selected bit.

def setSelected (self):

	self.statusBits |= self.selectedBit</t>
<t tx="T1305"># Compatibility routine for scripts

def setVisited (self):

	self.statusBits |= self.visitedBit</t>
<t tx="T1306">def setJoinList (self, v):

	assert(not self.joinList)
	self.joinList = v</t>
<t tx="T1307">def setSelection (self, start, length):

	self.t.setSelection ( start, length )</t>
<t tx="T1308">def setT (self, t):

	if t != self:
		del self.t
		self.t = t</t>
<t tx="T1309">@ This trims trailing blank lines from a node.  It is surprising difficult to do this during Untangle.
@c

def trimTrailingLines (self):

	return ## not ready yet

	s = self.t.bodyString
	newlines = 0
	ws = 0
	i = len - 1
	while i &gt;= 0:
		c = s[i]
		if is_ws(c): len += 1 ; ws += 1
		elif c == '\r': len -= 1
		elif c == '\n': len -= 1; newlines += 1
		else: break
		i -= 1

	if newlines &gt; 1 or newlines &gt; 0 and ws &gt; 0:
		s2 = s[:len]
		if newlines &gt; 0: s2.append('\n')
		self.setBodyStringOrPane (s2)
		# Don't set the dirty bit: it would just be annoying.</t>
<t tx="T1310"># Creates a clone of back and insert it as the next sibling of back.

def clone (self, back):

	clone = self.cloneTree(back)
	clone.createDependents()
	# Set the clone bit in all nodes joined to back.
	clone.setClonedBit()
	back.setClonedBit()
	v = back.joinList
	while v and v != back:
		v.setClonedBit()
		v = v.joinList
	return clone</t>
<t tx="T1311">@ This is the main delete routine.  It deletes the receiver's entire tree from the screen.  Because of the undo command we never actually delete vnodes or tnodes.
@c

def doDelete (self, newVnode):

	"""Unlinks the receiver, but does not destroy it. May be undone"""

	v = self ; c = v.commands
	v.setDirty() # 1/30/02: mark @file nodes dirty!
	v.destroyDependents()
	v.unjoinTree()
	v.unlink()
	# Bug fix: 1/18/99: we must set the currentVnode here!
	c.selectVnode(newVnode)
	# Update all clone bits.
	c.initAllCloneBits()
	return self # We no longer need dvnodes: vnodes contain all needed info.</t>
<t tx="T1312">def insertAfter (self, t = None):

	"""Inserts a new vnode after the receiver"""

	if not t: t = tnode()
	v = vnode(self.commands,t)
	v.mHeadString = "NewHeadline"
	v.iconVal = 0
	v.linkAfter(self)
	return v</t>
<t tx="T1313">def insertAsLastChild (self,t = None):

	"""Inserts a new vnode as the last child of the receiver"""

	n = self.numberOfChildren()
	if not t:
		t = tnode()
	return self.insertAsNthChild(n,t)</t>
<t tx="T1314">def insertAsNthChild (self, n, t=None):

	"""Inserts a new node as the the nth child of the receiver.
	The receiver must have at least n-1 children"""

	# trace(`n` + `self`)
	if not t: t = tnode()
	v = vnode(self.commands,t)
	v.mHeadString = "NewHeadline"
	v.iconVal = 0
	v.linkAsNthChild(self,n)
	return v</t>
<t tx="T1315"># Compatibility routine for scripts

def moveAfter (self,a):

	"""Moves the receiver after a"""

	v = self
	# trace(`v`)
	v.destroyDependents()
	v.unlink()
	v.linkAfter(a)
	v.createDependents()</t>
<t tx="T1316"># Compatibility routine for scripts

def moveToRoot (self):

	"""Moves the receiver to the root position"""

	v = self
	# trace(`v`)
	v.destroyDependents()
	v.unlink()
	v.linkAsRoot()
	v.createDependents()</t>
<t tx="T1317"># Compatibility routine for scripts

def moveToNthChildOf (self, p, n):

	"""Moves the receiver to the nth child of p"""

	v = self
	# trace(`n` + ", " + `p`)
	v.destroyDependents()
	v.unlink()
	v.linkAsNthChild(p, n)
	v.createDependents()</t>
<t tx="T1318"># Restores (relinks) the dv tree in the position described by back and parent.

def restoreOutlineFromDVnodes (self, dv, parent, back):

	if back:
		dv.linkAfter(back)
	elif parent:
		dv.linkAsNthChild(parent, 0)
	else:
		dv.linkAsRoot()
	return dv</t>
<t tx="T1319">@ This method copies all subtrees of oldRoot to the subtrees of newRoot.  The caller is responsible for copying the headline text from oldRoot to newRoot.

This method must be given the new root as well as the old:  the wxWindows classes do not allow us to create an unattached outline.
@c

def copyTree (self, oldTree, newTree):

	old_v = oldTree.firstChild()
	if not old_v: return
	# Copy the first child of oldTree to the first child of newTree.
	new_v = newTree.insertAsNthChild (0, old_v.t)
	self.copyNode(old_v, new_v)
	# Copy all other children of oldTree after the first child of newTree.
	old_v = old_v.next()
	while old_v:
		new_v = new_v.insertAfter(old_v.t)
		self.copyNode(old_v, new_v)
		old_v = old_v.next()
	# Recursively copy all descendents of oldTree.
	new_v = newTree.firstChild()
	old_v = oldTree.firstChild()
	while old_v:
		assert(new_v)
		self.copyTree(old_v, new_v)
		old_v = old_v.next()
		new_v = new_v.next()
	assert(new_v == None)</t>
<t tx="T1320">@ This function joins all nodes in the receiver and tree2.  This code makes no assumptions about the two trees, and some or all of the nodes may already have been joined.  The assert's guarantee that both trees have the same topology.
@c

def joinTreeTo (self, tree2):

	tree1 = self
	assert(tree2)
	# Join the roots.
	tree1.joinNodeTo ( tree2 )
	# Recursively join all subtrees.
	child1 = tree1.firstChild()
	child2 = tree2.firstChild()
	while child1:
		assert(child2)
		child1.joinTreeTo(child2)
		child1 = child1.next()
		child2 = child2.next()
	assert(child2 == None)</t>
<t tx="T1321">@ This function returns true if the receiver should be a clone.  This can be done quickly using the receiver's join list.

The receiver is a clone if and only it is structurally _dissimilar_ to a node joined to it.  Structurally _similar_ joined nodes have non-null, distinct and joined parents, and have the same child indices.

9/16/99 We now return the node that proves that the receiver should be a clone.  This allows us to dispense with the old "survivor" logic in commands::deleteHeadline.
@c

def shouldBeClone (self,verbose=0):

	p = self.parent()
	n = self.childIndex()
	if verbose:
		v = self.joinList
		es("shouldBeClone: self,self.parent():"+`self`+","+`self.parent()`)
		es("shouldBeClone: joinlist of self:")
		while v and v != self:
			es("v,v.parent():"+`v`+","+`v.parent()`)
			v=v.joinList

	v = self.joinList
	while v and v != self:
		vp = v.parent()
		if 0: # verbose:
			es("shouldBeClone:" + `v`)
			es("shouldBeClone: p,vp:" + `p` + "," + `vp`)
			es("shouldBeClone: join:" + `p.isJoinedTo(vp)`)
			es("shouldBeClone: indices:" + `n` + "," + `v.childIndex()`)
		if ( # self and v are sturcturally dissimilar if...
			(not p or not vp) or  # they are at the top level, or
			vp == p or  # have the same parent, or
			not p.isJoinedTo(vp) or  # have unjoined parents, or
			(v.childIndex() != n)): # have different child indices.
			if verbose: es("shouldBeClone returns true")
			return true
		v = v.joinList

	# The receiver is structurally similar to all nodes joined to it.
	if verbose: es("shouldBeClone returns false")
	return false</t>
<t tx="T1322"># This routine checks the structure of the receiver's tree.

def validateOutlineWithParent (self, p):

	result = true # optimists get only unpleasant surprises.
	parent = self.parent()
	childIndex = self.childIndex()
	&lt;&lt; validate parent ivar &gt;&gt;
	&lt;&lt; validate childIndex ivar &gt;&gt;
	&lt;&lt; validate x ivar &gt;&gt;

	# Recursively validate all the children.
	child = self.firstChild()
	while child:
		r = child.validateOutlineWithParent ( self )
		if not r: result = false
		child = child.next()
	return result</t>
<t tx="T1323">if parent != p:
	self.invalidOutline ( "Invalid parent link: " + parent.description() )</t>
<t tx="T1324">if p:
	if childIndex &lt; 0:
		self.invalidOutline ( "missing childIndex" + childIndex )
	elif childIndex &gt;= p.numberOfChildren():
		self.invalidOutline ( "missing children entry for index: " + childIndex )
elif childIndex &lt; 0:
	self.invalidOutline ( "negative childIndex" + childIndex )</t>
<t tx="T1325">if not self.t and p:
	self.invalidOutline ( "Empty t" )</t>
<t tx="T1326"># This method creates a cloned tree after oldTree.

def cloneTree (self, oldTree):
	# Create a new tree following oldTree.
	newTree = self.insertAfter(oldTree.t)
	newTree.initHeadString (oldTree.mHeadString)
	self.copyTree(oldTree, newTree)
	# Join the trees and copy clone bits.
	oldTree.joinTreeTo(newTree)
	oldTree.copyCloneBitsTo(newTree)
	return newTree</t>
<t tx="T1327"># This methods propagates clone bits from the receiver's tree to tree2.

def copyCloneBitsTo (self, tree2):

	tree1 = self
	assert(tree2)
	# Set the bit in the root.
	if tree1.isCloned():
		tree2.setClonedBit()
	else:
		tree2.clearClonedBit()
	# Recursively set the bits in all subtrees.
	child1 = tree1.firstChild()
	child2 = tree2.firstChild()
	while child1:
		assert(child2)
		if child1.isCloned():
			child2.setClonedBit()
		else:
			child2.clearClonedBit()
		child1 = child1.next()
		child2 = child2.next()
	assert(child2 == None)</t>
<t tx="T1328">def copyNode (self, old_node, new_node):

	new_node.mHeadString = old_node.mHeadString
	new_node.iconVal = old_node.iconVal</t>
<t tx="T1329"># This method creates all nodes that depend on the receiver.
def createDependents (self):

	v = self ; t = v.t ; parent = v.parent()
	if not parent: return
	# Copy v as the nth child of all nodes joined to parent.
	n = v.childIndex()
	# trace(`n` + ", " + `v`)
	p = parent.joinList
	while p and p != parent:
		copy = p.insertAsNthChild(n, t)
		copy.mHeadString = v.mHeadString
		copy.iconWithVal = v.iconVal
		self.copyTree(v, copy)
		v.joinTreeTo(copy)
		p = p.joinList</t>
<t tx="T1330"># Destroys all dependent vnodes and tree nodes associated with the receiver.

def destroyDependents (self):

	parent = self.parent()
	if not parent: return
	# Destroy the nth child of all nodes joined to the receiver's parent.
	n = self.childIndex()
	join = parent.joinList
	# trace(`n` + ", " + `self`)
	while join and join != parent:
		child = join.nthChild(n)
		if child:
			child.unjoinTree()
			child.unlink()
			child.destroyTree()
		join = join.joinList</t>
<t tx="T1331">@ This method destroys (irrevocably deletes) a vnode tree.

This code should be called only when it is no longer possible to undo a previous delete.  It is always valid to destroy dependent trees.
@c

def destroyTree (self):

	pass</t>
<t tx="T1332">def invalidOutline (self, message):

	s = "invalid outline: " + message + "\n"
	parent = self.parent()

	if parent:
		s += `parent`
	else:
		s += `self`

	alert ( s )</t>
<t tx="T1333">def isJoinedTo (self, v):

	return v and self.t == v.t</t>
<t tx="T1334"># Returns true if the nodes v1 and v2 are on the same join list.
def isOnJoinListOf (self, v2):

	v1 = self
	assert(v2 and v1.t and v2.t)
	
	# v1 and v2 must share the same tnode.
	if v1.t != v2.t: return false
	
	# v1 and v2 must have join lists.
	if not v1.joinList or not v2.joinList: return false
	
	# Return true if v2 is on v1's join list.
	v = v1.joinList
	while v and v != v1:
		if v == v2: return true
		v = v.joinList

	return false</t>
<t tx="T1335">@ This method joins the receiver to v2 if the two nodes have not already been joined. Joining involves placing each vnode on the others join list.
@c

def joinNodeTo (self, v2):

	v1 = self
	if v1.isOnJoinListOf(v2): return # 12/17/01: fix same bug as in LeoCB

	j1 = v1.joinList
	j2 = v2.joinList
	if j1 and j2:
		# Swapping pointers joins the two cycles.
		v1.joinList = j2  # Neither join list is None.
		v2.joinList = j1
	elif j1:
		v2.joinList = j1  # Link v2 after v1.
		v1.joinList = v2
	elif j2:
		v1.joinList = j2  # Link v1 after v2.
		v2.joinList = v1
	else:
		v1.joinList = v2  # point v1 and v2 at each other.
		v2.joinList = v1
	assert(v1.joinList and v2.joinList)</t>
<t tx="T1336"># Links the receiver after v

def linkAfter (self, v):

	# trace(`v`)
	self.mParent = v.mParent
	self.mBack = v
	self.mNext = v.mNext
	v.mNext = self
	if self.mNext:
		self.mNext.mBack = self</t>
<t tx="T1337">def linkAsNthChild (self, p, n):

	"""Links the receiver as the n'th child of p"""

	v = self
	# trace(`v` + ", " + `p` + ", " + `n`)
	v.mParent = p
	if n == 0:
		v.mBack = None
		v.mNext = p.mFirstChild
		if p.mFirstChild:
			p.mFirstChild.mBack = v
		p.mFirstChild = v
	else:
		prev = p.nthChild(n-1) # zero based
		assert(prev)
		v.mBack = prev
		v.mNext = prev.mNext
		prev.mNext = v
		if v.mNext:
			v.mNext.mBack = v</t>
<t tx="T1338">def linkAsRoot(self):

	v = self ; c = v.commands ; tree = c.tree
	# trace(`v`)
	# Set the links
	v.mParent = None
	v.mFirstChild = None
	v.mBack = None
	v.mNext = None
	tree.rootVnode = v</t>
<t tx="T1339">@ This method is called just before destroying a tree.  It copies the data into the dvnodes so headlines can be restored if the deleted is undone.
@c

# returns dvnode
def saveOutlineWithLevel (self, level):

	v = self
	dv = root = dvnode(level, v.mHeadString, v)
	child = self.firstChild()
	while child:
		# Recursively create a list of dvnodes for child's subtree.
		dv.next = child.saveOutlineWithLevel(level + 1)
		# Move dv to the end of the list of dvnodes.
		while dv and dv.next:
			dv = dv.next
		child = child.next()
	return root</t>
<t tx="T1340">def setThreadLinks (self,v):

	"""Sets the thread links in v and v.threadBack() after inserting v somewhere"""

	back = v.threadBack()
	if back:
		assert(v == self.threadNext(back))
		back.threadNext = v
	v.threadNext = self.threadNext(v)</t>
<t tx="T1341">def unlink (self):

	"""Unlinks the receiver from the tree before moving or deleting."""
	v = self ; c = v.commands ; tree = c.tree
	
	# trace(`v.mParent`+", child:"+`v.mFirstChild`+", back:"+`v.mBack`+", next:"+`v.mNext`)
	
	# Special case the root
	if v == tree.rootVnode:
		if not v.mNext: return # Should never happen.
		tree.rootVnode = v.mNext

	# Clear the links in other nodes
	if v.mBack:
		v.mBack.mNext = v.mNext
	if v.mNext:
		v.mNext.mBack = v.mBack
	if v.mParent and v == v.mParent.mFirstChild:
		v.mParent.mFirstChild = v.mNext

	# Clear the links in this node
	v.mParent = v.mNext = v.mBack = None</t>
<t tx="T1342">@ This code carefully unlinks the receiver from its join list.  We can not assume that all such links will eventually be cleared.
@c

def unjoinNode (self):

	next = self.joinList
	if not next: return

	if next.joinList == self:
		# The list contains only two elements.
		next.joinList = None
		self.joinList = None
	else:
		prev = None
		&lt;&lt; Set prev to the node that points to self &gt;&gt;
		# Remove self from the join list.
		prev.joinList = next
		self.joinList = None</t>
<t tx="T1343">@ We guard against any cycles in the join list, which would cause self loop to hang.  It's much better to cause an assert to fail.
@c

self.commands.clearAllVisited()

prev = next
while prev and prev.joinList != self:
	assert(not prev.isVisited())
	prev.setVisited()
	prev = prev.joinList</t>
<t tx="T1344"># This function unjoins all nodes of the receiver's tree.

def unjoinTree (self):

	v = self
	after = self.nodeAfterTree()
	while v and v != after:
		v.unjoinNode()
		v = v.threadNext()</t>
<t tx="T1345">from leoGlobals import *
from leoUtils import *
import string, Tkinter

# Private constants
default_page_width = 132
default_tab_width = 4

ivars = [
	"tangle_batch_flag", "untangle_batch_flag",
	"use_header_flag", "output_doc_flag",
	"tangle_directory", "page_width", "tab_width",
	"target_language" ]

class LeoPrefs:
	@others</t>
<t tx="T1346">def OnClosePrefsFrame(self):

	self.top.withdraw() # Just hide the window.</t>
<t tx="T1347"># Tangle and Untangle.

from leoGlobals import *
from leoUtils import *
import os,string

&lt;&lt; constants &amp; synonyms &gt;&gt;

&lt;&lt; define node classes &gt;&gt;

class tangleCommands:
	&lt;&lt; tangleCommands methods &gt;&gt;</t>
<t tx="T1348"># Synonyms for multiple_parts_flag.
allow_multiple_parts = 1
disallow_multiple_parts = 2
unused_parts_flag = 3

# Synonyms for root_flag to st_enter.
is_root_name = 1 ; not_root_name = 0

# Synonyms for scanAllDirectives
report_errors = 1 ; dont_report_errors = 0
require_path = 1 ; done_require_path = 0

# Synonyms for verbose_flag.
verbose = true ; brief = 0

# Constants...
max_errors = 20

@ All these must be defined together, because they form a single enumeration.  Some of these are used by utility functions.
@c

if 1: # A single enum...

	# Used by token_type().
	plain_line = 1 # all other lines
	at_at	     = 2 # double-at sign.
	at_chapter = 3 # @chapter
	# at_c       = 4 # @c in noweb mode
	at_code	   = 5 # @code, or @c or @p in CWEB mode.
	at_doc	    = 6 # @doc
	at_other   = 7 # all other @directives
	at_root	   = 8 # @root or noweb * sections
	at_section = 9 # @section
	# at_space   = 10 # @space
	at_web	    = 11 # any CWEB control code, except at_at.
	
	# Returned by self.skip_section_name() and allies and used by token_type.
	bad_section_name = 12  # &lt; &lt; with no matching &gt; &gt;
	section_ref	 = 13  # &lt; &lt; name &gt; &gt;
	section_def	 = 14  # &lt; &lt; name &gt; &gt; =
	
	# Returned by is_sentinal_line.
	non_sentinel_line   = 15
	start_sentinel_line = 16
	end_sentinel_line   = 17</t>
<t tx="T1349">class tst_node:
	&lt;&lt; tst_node methods &gt;&gt;
	
class part_node:
	&lt;&lt; part_node methods &gt;&gt;

class ust_node:
	&lt;&lt; ust_node methods &gt;&gt;</t>
<t tx="T1350">@others</t>
<t tx="T1351">def __init__ (self,name,root_flag):

	# trace("tst_node.__init__" + `name`)
	self.name = name
	self.is_root = root_flag
	self.referenced = false
	self.parts = []</t>
<t tx="T1352">def __repr__ (self):

	return "tst_node:" + self.name</t>
<t tx="T1353">@others</t>
<t tx="T1354">def __init__ (self,name,code,doc,is_root,is_dirty):

	# trace("part_node.__init__" + `name`)
	self.name = name # Section or file name.
	self.code = code # The code text.
	self.doc = doc # The doc text.
	self.is_dirty = is_dirty # true: vnode for body text is dirty.
	self.is_root = is_root # true: name is a root name.</t>
<t tx="T1355">def __repr__ (self):

	return "part_node:" + self.name</t>
<t tx="T1356">@others</t>
<t tx="T1357">@ The text has been masssaged so that 1) it contains no leading indentation and 2) all code arising from section references have been replaced by the reference line itself.  Text for all copies of the same part can differ only in non-critical white space.
@c

def __init__ (self,name,text,part,of,nl_flag,update_flag):

	trace("ust_node.__init__" + `name`)
	self.name = name # section name
	self.parts = [] # part list
	self.text = text # part text
	self.part = part # n in "(part n of m)" or zero.
	self.of = of  # m in "(part n of m)" or zero.
	self.nl_flag = nl_flag  # true: section starts with a newline.
	self.update_flag = update_flag # true: section corresponds to a section in the outline.</t>
<t tx="T1358">def __repr__ (self):

	return "ust_node:" + self.name</t>
<t tx="T1359">@others</t>
<t tx="T1360">def __init__ (self,commands):

	self.commands = commands
	self.init_ivars()</t>
<t tx="T1361">@ Only top-level drivers initialize ivars.
</t>
<t tx="T1362">def initTangleCommand (self):

	c = self.commands
	c.endEditing()
	
	es("Tangling...")
	c.setIvarsFromPrefs()
	self.init_ivars()
	self.tangling = true</t>
<t tx="T1363">def initUnangleCommand (self):

	c = self.commands
	c.endEditing()
	
	es("Untangling...")
	c.setIvarsFromPrefs()
	self.init_ivars()
	self.tangling = false</t>
<t tx="T1364">def tangle(self):

	c = self.commands ; v = c.currentVnode()
	self.initTangleCommand()
	self.tangleTree(v,report_errors)</t>
<t tx="T1365">@ This is the main routine of pass 1. It traverses the tree whose root is given, handling each headline and associated body text.
@c

def tanglePass1(self,v):

	c = self.commands
	next = v.nodeAfterTree()
	
	while v and v != next:
		self.v = v
		self.set_root_from_headline(v)
		bits, dict = is_special_bits(v.bodyString(),set_root_from_headline)
		is_ignore = (bits &amp; ignore_bits)!= 0
		if is_ignore:
			v = v.nodeAfterTree()
			continue
		# This must be called after root_name has been set.
		if self.tangling:
			self.scanAllDirectives(v,require_path,report_errors) # calls init_directive_ivars.
		# Scan the headline and body text.
		self.skip_headline(v)
		self.skip_body(v)
		if not self.tangling:
			v.trimTrailingLines() # Stamp out those trailing blank lines!
		v = v.threadNext()
		if self.errors &gt;= max_errors:
			es("----- Halting Tangle: too many errors")
			break

	if self.tangling:
		self.st_check()
		# trace(self.st_dump(verbose))</t>
<t tx="T1366"># At this point v is the root of the tree that has been tangled.

def tanglePass2(self,v,unitFlag):

	self.v = None # self.v is not valid in pass 2.

	if self.errors &gt; 0:
		es("----- No file written because of errors")
	elif self.root_list == None:
		es("----- The outline contains no roots")
	else:
		self.put_all_roots() # pass 2 top level function.</t>
<t tx="T1367">def untangle(self):

	c = self.commands ; v = c.currentVnode()
	self.initUntangleCommand()
	
	c.beginUpdate()
	self.untangleTree(v,report_errors)
	c.endUpdate()</t>
<t tx="T1368">def untangleAll(self):

	c = self.commands ; v = c.rootVnode()
	self.initUntangleCommand()
	has_roots = false

	c.beginUpdate()
	while v:
		ok = self.untangleTree(v,false)
		if ok: has_roots = true
		v = v.next()
	c.endUpdate()
	
	if not has_roots:
		es("----- The outline contains no roots")
	elif self.errors &gt; 0:
		es("----- Untangle command halted because of errors")</t>
<t tx="T1369">def untangleMarked(self):

	c = self.commands ; v = c.rootVnode()
	self.initUntangleCommand()
	any_root_flag = false

	c.beginUpdate()
	while v:
		if v.isMarked():
			ok = self.untangleTree(v,dont_report_errors)
			if ok: marked_flag = true
			if self.errors &gt; 0: break
			v = v.nodeAfterTree()
		else: v = v.threadNext()
	c.endUpdate()

	if not any_root_flag:
		es("----- The outline contains no marked roots")
	elif self.errors &gt; 0:
		es("----- Untangle command halted because of errors")</t>
<t tx="T1370"># This funtion is called when the user selects any "Untangle" command.

def untangleTree(self,v,report_flag):

	es(self.__name__ + " not ready yet")
	return ##

	any_root_flag = false
	afterEntireTree = v.nodeAfterTree()
	# Initialize these globals here: they can't be cleared later.
	self.head_root = None
	self.errors = 0
	self.clearAllVisited()# Used by untangle code.

	while v and v != afterEntireTree and self.errors == 0:
		self.set_root_from_headline(v)
		bits, dict = is_special_bits(v.bodyString(),set_root_from_headline)
		ignore =(bits &amp; ignore_bits)!= 0
		root =(bits &amp; root_bits)!= 0
		unit =(bits &amp; unit_bits)!= 0
		if ignore:
			v = v.nodeAfterTree()
		elif unit:
			# Expand the context to the @unit directive.
			unitNode = v   # 9/27/99
			afterUnit = v.nodeAfterTree()
			v = v.threadNext()
			while v and v != afterUnit and self.errors == 0:
				set_root_from_headline(v)
				bits, dict = is_special_bits(v.t.bodyString,set_root_from_headline)
				root =(bits &amp; root_bits)!= 0
				if root:
					any_root_flag = true
					end = None
					&lt;&lt; set end to the next root in the unit &gt;&gt;
					self.scanAllDirectives(v,require_path,report_errors)
					self.untangleRoot(v,unitNode,afterUnit)
					v = end
				else: v = v.threadNext()
			self.cleanup()
		elif root:
			# Limit the range of the @root to its own tree.
			afterRoot = v.nodeAfterTree()
			any_root_flag = true
			self.scanAllDirectives(v,require_path,dont_report_errors)
			self.untangleRoot(v,v,afterRoot) # 9/27/99
			self.cleanup()
			v = afterRoot
		else:
			v = v.threadNext()
	if report_flag:
		if not any_root_flag:
			es("----- The outline contains no roots")
		elif self.errors &gt; 0:
			es("----- Untangle command halted because of errors")
	return any_root_flag</t>
<t tx="T1371">@ The untangle_root function will untangle an entire tree by calling untangleTree,so the following code ensures that the next @root node will not be an offspring of v.
@c

end = v.threadNext()
while end and end != afterUnit:
	flag, i = is_special(end.bodyString(),0,"@root")
	if flag and not v.isAncestorOf(end):
		break
	end = end.threadNext()</t>
<t tx="T1372">@ This method untangles the derived files in a vnode known to contain at least one @root directive. The work is done in two passes. The first pass creates the UST by scanning the derived file. The second pass updates the outline using the UST and a TST that is created during the pass.

We assume that all sections from root to end are contained in the derived file, and we attempt to update all such sections. The begin/end params indicate the range of nodes to be scanned when building the TST.
@c

def untangleRoot(self,root,begin,end):

	&lt;&lt; return if @silent or unknown language &gt;&gt;
	&lt;&lt; Set path &amp; root_name to the file specified in the @root directive &gt;&gt;
	&lt;&lt; Read the file into file_buf &gt;&gt;
	es("@root " + path)
	# Pass 1: Scan the C file, creating the UST
	scan_derived_file(file_buf)
	# trace(self.ust_dump())
	if self.errors == 0:
		&lt;&lt; Pass 2: Untangle the outline using the UST and a newly-created TST &gt;&gt;</t>
<t tx="T1373">if self.language == unknown_language:
	es("**Unknown language for " + path)
	return

if self.print_bits == silent_bits:
	es("@silent inhibits untangle for " + path)
	return</t>
<t tx="T1374">s = root.bodyString()
i = 0
while i &lt; len(body):
	code, end = self.token_type(s,i,report_errors)
	if code == at_root:
		# token_type sets root_name unless there is a syntax error.
		if self.root_name: path = self.root_name
		break
	else: i = skip_line(s,i)
	
if not self.root_name:
	# A bad @root command.  token_type has already given an error.
	self.tangleCleanUp()
	return</t>
<t tx="T1375">try:
	file_buf = file.read(path)
	file_buf = string.replace(file_buf,body_ignored_newline,'')
except:
	es("error reading: " + path)
	self.tangleCleanUp()
	return</t>
<t tx="T1376">@ This code untangles the root and all its siblings. We don't call tangleTree here because we must handle all siblings.  tanglePass1 handles an entire tree.  It also handles @ignore.
@c

v = begin
while v and v != end:
	this.tanglePass1(v)
	if self.errors != 0:
		break
	v = v.nodeAfterTree()

self.ust_warn_about_orphans()
# trace(st_dump(brief))</t>
<t tx="T1377">@ This method handles newline processing while skipping a code section. It sets 'done' if the line contains an @directive or section definition that terminates the present code section. On entry: i should point to the first character of a line.  This routine scans past a line only if it could not contain a section reference.

Returns (i, done)
@c

def handle_newline(self,s,i):

	j = i ; done = false
	kind, end = self.token_type(s,i,dont_report_errors)
	# token_type will not skip whitespace in noweb mode.
	i = skip_ws(s,i)

	if kind == plain_line:
		pass
	elif (kind == at_code or kind == at_doc or
		kind == at_root or kind == section_def):
		i = j ; done = true # Terminate this code section and rescan.
	elif kind == section_ref:
		# Enter the reference.
		ref = s[i:end]
		self.st_enter_section_name(ref,None,None,unused_parts_flag)
	elif kind == at_other or kind == at_chapter or kind == at_section:
		# We expect to see only @doc,@c or @root directives
		# while scanning a code section.
		i = skip_to_end_of_line(s,i)
		self.error("SWEB directive not valid here: " + s[j:i])
	elif kind == bad_section_name:
		if self.use_cweb_flag:
			i = skip_to_end_of_line(s,i)
	elif kind == at_web or kind == at_at:
		i += 2 # Skip a CWEB control code.
	else: assert(false)

	return i, done</t>
<t tx="T1378"># This method handles all the body text.

def skip_body (self,v):

	# trace(`v`)
	s = v.bodyString()
	is_dirty_flag = v.isDirty()
	code_seen = false ; code = None ; doc = None
	i, doc = self.skip_doc(s,0) # Start in doc section by default.
	if i &gt;= len(s) and doc:
		&lt;&lt; Define a section containing only an @doc part &gt;&gt;
	while i &lt; len(s):
		progress = i # progress indicator
		kind, end = self.token_type(s,i,report_errors)
		if is_nl(s,i): i = skip_nl(s,i)
		i = skip_ws(s,i)
		if kind == section_def:
			&lt;&lt; Scan and define a section definition &gt;&gt;
		elif kind == at_code:
			if self.use_cweb_flag:
				i += 2 # Skip the at-c or at-p
			else:
				i = skip_line(s,i)
			&lt;&lt; Scan and define an @code defininition &gt;&gt;
		elif kind == at_root:
			i = skip_line(s,i)
			&lt;&lt; Scan and define a root section &gt;&gt;
		elif kind == at_doc:
			if self.use_cweb_flag:
				i += 2 # Skip the at-space
			else:
				i = skip_line(s,i)
			i, doc = self.skip_doc(s,i)
		elif kind == at_chapter or kind == at_section:
			i = skip_line(s,i)
			i, doc = self.skip_doc(s,i)
		else:
			i = skip_line(s,i)
		assert(progress &lt; i) # we must make progress!</t>
<t tx="T1379">@ The following subsections contain the interface between the Tangle and Untangle commands.  This interface is an important hack, and allows Untangle to avoid duplicating the logic in skip_tree and its allies.  The aha is as follows:

Just at the time the Tangle command would enter a section (or root) definition into the symbol table, all the information is present that Untangle needs to update that definition.

Only one modification had to be made to the original Tangle code: st_enter_section_name now returns the part number of the part that has just been entered.  This part is sent to update_def so it can know which part of a multiple-part definition must be updated.
</t>
<t tx="T1380">@ It's valid for an @doc directive to appear under a headline that does not contain a section name.  In that case, no section is defined.
@c

if self.header_name:
	# Original Tangle code.
	flag = choose(code_seen,allow_multiple_parts,disallow_multiple_parts)
	part = self.st_enter_section_name(self.header_name,code,doc,flag)

	if not self.tangling:
		s = self.update_def(s,self.header_name,part,c,code,doc,not_root_name)</t>
<t tx="T1381">@ This code skips an entire code section then enters it and any preceding doc part into the symbol table.
@c

k = i
i, kind, end_i = self.skip_section_name(s,i)
section_name = s[k:i]
assert(kind == section_def)
i = skip_to_end_of_line(s,i)
i = skip_blank_lines(s,i)
i, code = self.skip_code(s,i)
# We must enter the section name even if the code part is empty.
# Original Tangle code.
flag = choose(kind == section_def,allow_multiple_parts,disallow_multiple_parts)
part = self.st_enter_section_name(section_name,code,doc,flag)
		
if not self.tangling:
	part = 0
	s = self.update_def(s,section_name,part,code,doc,not_root_name)
# Original Tangle code,part 2.
doc = None</t>
<t tx="T1382"># All @c directives denote &lt; &lt; headline_name &gt; &gt; =

i = skip_blank_lines(s,i)
i, code = self.skip_code(s,i)
code = string.rstrip(code)
if self.header_name:
	# Original Tangle code.
	flag = choose(code_seen,allow_multiple_parts,disallow_multiple_parts)
	part = self.st_enter_section_name(self.header_name,code,doc,flag)
		
	if not self.tangling:
		s = self.update_def(self.header,ip2,part,s,code,doc,not_root_name)
else:
	self.error("@c expects the header: " + self.header + " to contain a section name")
code_seen = true
doc = None</t>
<t tx="T1383"># We save the file name in case another @root ends the code section.

old_root_name = self.root_name
i = skip_blank_lines(s,i)
i, code = self.skip_code(s,i)
# Original Tangle code.
self.st_enter_root_name(old_root_name,code,doc)
if not self.tangling:
	part = 1 # Use 1 for root part.
	s = self.update_def(s,old_root_name,part,code,doc,is_root_name)
# Original Tangle code,part 2.
doc = None</t>
<t tx="T1384">@ This method skips an entire code section. The caller is responsible for entering the completed section into the symbol table. On entry, i points at the line following the @directive or section definition that starts a code section. We skip code until we see the end of the body text or the next @ directive or section defintion that starts a code or doc part.
@c

def skip_code(self,s,i):

	# j = skip_line(s,i) ; trace(`s[i:j]`)
	code1 = i
	nl_i = i # For error messages
	done = false # TRUE when end of code part seen.
	if self.use_noweb_flag:
		&lt;&lt; skip a noweb code section &gt;&gt;
	else:
		&lt;&lt; skip a CWEB code section &gt;&gt;
	return i, s[code1:i]</t>
<t tx="T1385">@ This code handles the following escape conventions: double at-sign at the start of a line and at-&lt;&lt; and at.&gt;.
@c

i, done = self.handle_newline(s,i)
while not done and i &lt; len(s):
	ch = s[i]
	if is_nl(s,i):
		nl_i = i = skip_nl(s,i)
		i, done = self.handle_newline(s,i)
	elif ch == '@' and (match(s,i+1,"&lt;&lt;") or # must be on different lines
		match(s,i+1,"&gt;&gt;")):
		i += 3 # skip the noweb escape sequence.
	elif ch == '&lt;':
		&lt;&lt; handle possible noweb section reference &gt;&gt;
	else: i += 1</t>
<t tx="T1386">j, kind, end = self.is_section_name(s,i)
if kind == section_def:
	k = skip_to_end_of_line(s,i)
	# We are in the middle of a line.
	i += 1
	self.error("chunk definition not valid here\n" + s[nl_i:k])
elif kind == bad_section_name:
	i += 1 # This is not an error.  Just skip the '&lt;'.
else:
	assert(kind == section_ref)
	# Enter the reference into the symbol table.
	name = s[i:end]
	part = self.st_enter_section_name(name,None,None,unused_parts_flag)
	i = end</t>
<t tx="T1387"># This code is simple because CWEB control codes are valid anywhere.

while not done and i &lt; len(s):
	if s[i] == '@':
		&lt;&lt; handle CWEB control code &gt;&gt;
	else: i += 1</t>
<t tx="T1388">j, kind, end = self.is_section_name(s,i)

if kind == section_def:
	done = true
elif kind == bad_section_name:
	i += 2 # Any other control code.
else:
	assert(kind == section_ref)
	# Enter the reference into the symbol table.
	name = s[i:j]
	part = self.st_enter_section_name(name,None,None,unused_parts_flag)
	i = j</t>
<t tx="T1389">def skip_doc(self,s,i):

	# j = skip_line(s,i) ; trace(`s[i:j]`)
	# Ignore initial blank lines and @doc, @chapter and @section directives.
	doc1 = i
	while i &lt; len(s):
		doc1 = i
		if is_nl(s,i):
			doc1 = i = skip_nl(s,i)
			continue
		kind, end = self.token_type(s,i,dont_report_errors)
		if kind == at_doc:
			if self.use_cweb_flag:
				i += 2 # Skip the at-space.
			else:
				i = skip_line(s,i)
			doc1 = i
		elif kind == at_chapter or kind == at_section:
			doc1 = i = skip_line(s,i)
		else: break

	while i &lt; len(s):
		kind, end = self.token_type(s,i,dont_report_errors)
		if kind == at_code or kind == at_root or kind == section_def:
			break
		i = skip_line(s,i)

	return i, s[doc1:i]</t>
<t tx="T1390">@ This function sets ivars that keep track of the indentation level. We also remember where the next line starts because it is assumed to be the first line of a documentation section.

A headline can contain a leading section name.  If it does, we substitute the section name if we see an @c directive in the body text.
@c

def skip_headline(self,v):

	# trace(`v`)
	self.header = s = v.headString()
	# Set self.header_name.
	j = i = skip_ws(s,0)
	i, kind, end = self.is_section_name(s,i)
	if kind == bad_section_name:
		self.header_name = None
	else:
		self.header_name = s[j:end]</t>
<t tx="T1391">def oblank (self):
	self.oblanks(1)

def oblanks (self,n):
	if n &gt; 0:
		self.output_file.write(' ' * n)
		
def onl(self):
	self.os('\n')
		
def os (self,s):
	s = string.replace(s,body_ignored_newline,body_newline)
	self.output_file.write(s)

def otab (self):
	self.otabs(1)

def otabs (self,n):
	if n &gt; 0:
		self.output_file.write('\t' * n)</t>
<t tx="T1392">@ This method outputs a code section, expanding section references by their definition. We should see no @directives or section definitions that would end the code section.

Most of the differences bewteen noweb mode and CWEB mode are handled by token_type(called from put_newline). Here, the only difference is that noweb handles double-@ signs only at the start of a line.
@c

def put_code(self,s,no_first_lws_flag):

	# j = skip_line(s,0) ; trace(`s[:j]`)
	i = 0
	if i &lt; len(s):
		i = self.put_newline(s,i,no_first_lws_flag)
		# Double @ is valid in both noweb and CWEB modes here.
		if match(s,i,"@@"):
			self.os('@') ; i += 2
	while i &lt; len(s):
		progress = i
		ch = s[i]
		if (match(s,i,"&lt;&lt;") and self.use_noweb_flag or
			match(s,i,"@&lt;") and self.use_cweb_flag):
			&lt;&lt; put possible section reference &gt;&gt;
		elif ch == '@': # We are in the middle of a line.
			if self.use_cweb_flag:
				&lt;&lt; handle 2-character CWEB control codes &gt;&gt;
			else:
				&lt;&lt; handle noweb @ &lt; &lt; convention &gt;&gt;
		elif ch == body_ignored_newline:
			i += 1
		elif ch == body_newline:
			i += 1 ; self.onl()
			i = self.put_newline(s,i,false) # Put full lws
			if self.use_cweb_flag and match(s,i,"@@"):
				self.os('@') ; i += 2
		else: self.os(s[i]) ; i += 1
		assert(progress &lt; i)</t>
<t tx="T1393">j, kind, name_end = self.is_section_name(s,i)
if kind == section_def:
	# We are in the middle of a code section
	self.error(
		"Should never happen:\n" +
		"section definition while putting a section reference: " +
		s[i:j])
	i += 1
elif kind == bad_section_name:
	self.os(s[i]) ; i += 1 # This is not an error.
else:
	assert(kind == section_ref)
	name = s[i:name_end]
	self.put_section(s,i,name,name_end)
	i = j</t>
<t tx="T1394">if match(s,i,"@@"):
	# Handle double @ sign.
	self.os('@') ; i += 2
else:
	i += 1 # skip the @.
	if i+1 &gt;= len(s) or is_ws_or_nl(s,i):
		# A control code: at-backslash is not a valid CWEB control code.
		# We are in CWEB mode, so we can output C block comments.
		self.os("/*@" + s[i] + "*/") ; i += 1
	else:
		self.os("@") # The at sign is not part of a control code.</t>
<t tx="T1395">@ The user must ensure that neither @ &lt; &lt; nor @ &gt; &gt; occurs in comments or strings. However, it is valid for @ &lt; &lt; or @ &gt; &gt; to appear in the doc chunk or in a single-line comment.
@c

if match(s,i,"@&lt;&lt;"):
	self.os("/*@*/&lt;&lt;") ; i += 3

elif match(s,i,"@&gt;&gt;"):
	self.os("/*@*/&gt;&gt;") ; i += 3
	
else: self.os("@") ; i += 1</t>
<t tx="T1396"># This method outputs a doc section within a block comment.

def put_doc(self,s):

	# j = skip_line(s,0) ; trace(`s[:j]`)
	width = self.page_width
	words = 0 ; word_width = 0 ; line_width = 0
	single_w = choose(self.single_comment_string,len(self.single_comment_string),0)
	# Make sure we put at least 20 characters on a line.
	if width - max(0,self.tangle_indent) &lt; 20:
		width = max(0,self.tangle_indent) + 20
	# Skip Initial white space in the doc part.
	i = skip_ws_and_nl(s,0)
	if i &lt; len(s) and self.print_bits == verbose_bits:
		use_block_comment = self.start_comment_string and self.end_comment_string
		use_single_comment = not use_block_comment and self.single_comment_string
		if use_block_comment or use_single_comment:
			if 0: # The section name ends in an self.onl().
				self.onl()
			self.put_leading_ws(self.tangle_indent)
			if use_block_comment:
				self.os(self.start_comment_string)
			&lt;&lt; put the doc part &gt;&gt;
			self.onl()
			self.put_leading_ws(self.tangle_indent)
			if use_block_comment:
				self.os(self.end_comment_string)
			self.onl()
		else: self.onl()</t>
<t tx="T1397">@ This code fills and outputs each line of a doc part. It keeps track of whether the next word will fit on a line,and starts a new line if needed.
@c

if use_single_comment:
	# New code: 5/31/00
	self.os(self.single_comment_string) ; self.otab()
	line_width =(single_w / self.tab_width + 1) * self.tab_width
else:
	line_width = self.tab_width
	self.onl() ; self.otab()
self.put_leading_ws(self.tangle_indent)
line_width += max(0,self.tangle_indent)
words = 0 ; word_width = 0
while i &lt; len(s):
	&lt;&lt;output or skip whitespace or newlines&gt;&gt;
	if i &gt;= len(s):
		break
	&lt;&lt;compute the width of the next word&gt;&gt;
	if words == 0 or line_width + word_width &lt; width:
		words += 1
		&lt;&lt;output next word&gt;&gt;
		line_width += word_width
	else:
		self.onl() ; self.otab()
		line_width = self.tab_width
		if use_single_comment:
			self.os(self.single_comment_string) ; self.oblank()
			line_width += len(self.single_comment_string)+ 1
		words = 0
		self.put_leading_ws(self.tangle_indent)
 		# tangle_indent is in spaces.
		line_width += max(0,self.tangle_indent)</t>
<t tx="T1398">@ This outputs whitespace if it fits, and ignores it otherwise, and starts a new line if a newline is seen. The effect of self code is that we never start a line with whitespace that was originally at the end of a line.
@c

while is_ws_or_nl(s,i):
	ch = s[i]
	if ch == '\t':
		pad = self.tab_width - (line_width % self.tab_width)
		line_width += pad
		if line_width &lt; width: self.otab()
		i += 1
	elif ch == ' ':
		line_width += 1
		if line_width &lt; width: self.os(ch)
		i += 1
	else:
		assert(is_nl(s,i))
		self.onl()
		if use_single_comment:
			# New code: 5/31/00
			self.os(self.single_comment_string) ; self.otab()
			line_width = (single_w / self.tab_width + 1) * self.tab_width
		else:
			self.otab()
			line_width = self.tab_width
		i = skip_nl(s,i)
		words = 0
		self.put_leading_ws(self.tangle_indent)
 		# tangle_indent is in spaces.
		line_width += max(0,self.tangle_indent)
</t>
<t tx="T1399">j = i ; word_width = 0
while j &lt; len(s) and not is_ws_or_nl(s,j):
	word_width += 1
	j += 1</t>
<t tx="T1400">while i &lt; len(s) and not is_ws_or_nl(s,i):
	self.os(s[i])
	i += 1</t>
<t tx="T1401"># Outputs leading whitespace, converting tab_width blanks to tabs.

def put_leading_ws(self,indent):

	# trace("tab_width:" + `self.tab_width` + ", indent:" + `indent`)

	if self.tab_width &gt; 1:
		# Output tabs if possible.
		self.otabs  (indent / self.tab_width)
		self.oblanks(indent % self.tab_width)
	else:
		self.oblanks(indent)
</t>
<t tx="T1402">@ This method handles scanning when putting the start of a new line. Unlike the corresponding method in pass one, this method doesn't need to set a done flag in the caller because the caller already knows where the code section ends.
@c

def put_newline(self,s,i,no_first_lws_flag):

	kind, end = self.token_type(s,i,dont_report_errors)
	&lt;&lt; Output leading white space except for blank lines &gt;&gt;
	if i &gt;= len(s):
		return i
	elif kind == at_web or kind == at_at:
		i += 2 # Allow the line to be scanned.
	elif kind == at_doc or kind == at_code:
		if self.use_cweb_flag:
			i += 2
	else:
		# These should have set limit in pass 1.
		assert(kind != section_def and kind != at_chapter and kind != at_section)
	return i</t>
<t tx="T1403">j = i ; i = skip_ws(s,i)
if i &lt; len(s) and not is_nl(s,i):
	# Conditionally output the leading previous leading whitespace.
	if not no_first_lws_flag:
		self.put_leading_ws(self.tangle_indent)
	# Always output the leading whitespace of _this_ line.
	k, width = skip_leading_ws_with_indent(s,j,self.tab_width)
	self.put_leading_ws(width)</t>
<t tx="T1404"># This method outputs one part of a section definition.

def put_part_node(self,part,no_first_lws_flag):

	if part: name = part.name # can't use choose.
	else: name = "&lt;NULL part&gt;"
	# trace(`name`)

	if part.doc and self.output_doc_flag and self.print_bits != silent_bits and part.doc:
		self.put_doc(part.doc)

	if part.code:
		self.put_code(part.code,no_first_lws_flag)</t>
<t tx="T1405">@ This method outputs the definition of a section and all sections referenced from the section. name is the section's name. This code checks for recursive definitions by calling section_check(). We can not allow section x to expand to code containing another call to section x, either directly or indirectly.
@c

def put_section(self,s,i,name,name_end):

	j = skip_line(s,i)
	# trace("indent:" + `self.tangle_indent`  + ", " + `s[i:j]`)
	outer_old_indent = self.tangle_indent
	trailing_ws_indent = 0 # Set below.
	inner_old_indent = 0 # Set below.
	newline_flag = false  # True if the line ends with the reference.
	assert(match(name,0,"&lt;&lt;") or match(name,0,"@&lt;",2))
	&lt;&lt; Calculate the new value of tangle_indent &gt;&gt;
	&lt;&lt; Set 'newline_flag' if the line ends with the reference &gt;&gt;
	section = self.st_lookup(name,not_root_name)
	if section and section.parts:
		# Expand the section only if we are not already expanding it.
		if self.section_check(name):
			self.section_stack.append(name)
			&lt;&lt; put all parts of the section definition &gt;&gt;
			self.section_stack.pop()
	else:
		&lt;&lt; Put a comment about the undefined section &gt;&gt;
	if not newline_flag:
		self.put_leading_ws(trailing_ws_indent)
	self.tangle_indent = outer_old_indent
	return i, name_end</t>
<t tx="T1406"># Find the start of the line containing the reference.
j = i
while j &gt; 0 and not is_nl(s,j):
	j -= 1
if is_nl(s,j):
	j = skip_nl(s,j)

# Bump the indentation
j, width = skip_leading_ws_with_indent(s,j,self.tab_width)
self.tangle_indent += width
# trace("leading ws:" + `width` + " + new indent:" + `self.tangle_indent`)

# 4/27/01: Force no trailing whitespace in @silent mode.
if self.print_bits == silent_bits:
	trailing_ws_indent = 0
else:
	trailing_ws_indent = self.tangle_indent

# Increase the indentation if the section reference does not immediately follow
# the leading white space.  4/3/01: Make no adjustment in @silent mode.
if (j &lt; len(s) and self.print_bits != silent_bits and
	((self.use_noweb_flag and s[j] != '&lt;') or
	(self.use_cweb_flag and s[j] != '@'))):
	self.tangle_indent += self.tab_width</t>
<t tx="T1407">if self.print_bits != silent_bits:
	i = name_end
	i = skip_ws(s,i)
	newline_flag = (i &gt;= len(s) or is_nl(s,i))</t>
<t tx="T1408">@ This section outputs each part of a section definition. We first count how many parts there are so that the code can output a comment saying 'part x of y'.
@c

# Output each part of the section.
sections = len(section.parts)
count = 0
for part in section.parts:
	count += 1
	# In @silent mode, there is no sentinel line to "use up" the previously output
	# leading whitespace.  We set the flag to tell put_part_node and put_code
	# not to call put_newline at the start of the first code part of the definition.
	no_first_leading_ws_flag = (count == 1 and self.print_bits == silent_bits)
	inner_old_indent = self.tangle_indent
	# 4/3/01: @silent inhibits newlines after section expansion.
	if self.print_bits != silent_bits:
		&lt;&lt; Put the section name in a comment &gt;&gt;
	self.put_part_node(part,no_first_leading_ws_flag)
	# 4/3/01: @silent inhibits newlines after section expansion.
	if count == sections and self.print_bits != silent_bits:
		&lt;&lt; Put the ending comment &gt;&gt;
	# Restore the old indent.
	self.tangle_indent = inner_old_indent</t>
<t tx="T1409">if count &gt; 1:
	self.onl()
	self.put_leading_ws(self.tangle_indent)
	
# Don't print trailing whitespace
name = string.rstrip(name)
if self.single_comment_string:
	self.os(self.single_comment_string) ; self.oblank() ; self.os(name)
	&lt;&lt; put (n of m) &gt;&gt;
else:
	assert(
		self.start_comment_string and len(self.start_comment_string) &gt; 0 and
		self.end_comment_string and len(self.end_comment_string)&gt; 0)
	self.os(self.start_comment_string) ; self.oblank() ; self.os(name)
	&lt;&lt; put (n of m) &gt;&gt;
	self.oblank() ; self.os(self.end_comment_string)

self.onl() # Always output a newline.</t>
<t tx="T1410">if sections &gt; 1:
	self.oblank()
	self.os("(" + `count` + " of " + `sections` + ")")</t>
<t tx="T1411">@ We do not produce an ending comment unless we are ending the last part of the section,and the comment is clearer if we don't say(n of m).
@c

self.onl() ; self.put_leading_ws(self.tangle_indent)
#  Don't print trailing whitespace
name_end -= 1
while name_end &gt; 0 and is_ws(s[name_end]):
	name_end -= 1

if self.single_comment_string:
	self.os(self.single_comment_string) ; self.oblank()
	self.os("-- end -- ") ; self.os(name)
else:
	self.os(self.start_comment_string) ; self.oblank()
	self.os("-- end -- ") ; self.os(name)
	self.oblank() ; self.os(self.end_comment_string)
	
@ The following code sets a flag for untangle.

If something follows the section reference we must add a newline, otherwise the "something" would become part of the comment.  Any whitespace following the (!newline) should follow the section defintion when Untangled.
@c

if not newline_flag:
	self.os(" (!newline)") # LeoCB puts the leading blank, so we must do so too.
	# Put the whitespace following the reference.
	while name_end &lt; len(s) and is_ws(s[name_end]):
		self.os(s[name_end])
		name_end += 1
	self.onl() # We must supply the newline!</t>
<t tx="T1412">self.onl() ; self.put_leading_ws(self.tangle_indent)

if self.print_bits != silent_bits:
	if self.single_comment_string:
		self.os(self.single_comment_string)
		self.os(" undefined section: ") ; self.os(name) ; self.onl()
	else:
		self.os(self.start_comment_string)
		self.os(" undefined section: ") ; self.os(name)
		self.oblank() ; self.os(self.end_comment_string) ; self.onl()

self.error("Undefined section: " + name)</t>
<t tx="T1413">@ We can not allow a section to be defined in terms of itself, either directly or indirectly.

We push an entry on the section stack whenever beginning to expand a section and pop the section stack at the end of each section.  This method checks whether the given name appears in the stack. If so, the section is defined in terms of itself.
@c

def section_check (self,name):

	if name in self.section_stack:
		s = "Invalid recursive reference of " + name + "\n"
		for n in self.section_stack:
			s += "called from: " + n + "\n"
		self.error(s)
		return false
	return true</t>
<t tx="T1414">@ This function checks the given symbol table for defined but never referenced sections.
@c

def st_check(self):

	keys = self.tst.keys()
	keys.sort()
	# trace(`keys`)
	for name in keys:
		section = self.tst[name]
		if not section.referenced:
			es(	' ' * 4 + "Warning: " +
				choose(self.use_noweb_flag,"&lt;&lt; ","@&lt; ") +
				section.name +
				choose(self.use_noweb_flag," &gt;&gt;"," @&gt;") +
				" has been defined but not used.")</t>
<t tx="T1415"># Dumps the given symbol table in a readable format.

def st_dump(self,verbose_flag):
	
	s = "\ndump of symbol table...\n"
	keys = self.tst.keys()
	keys.sort()
	for name in keys:
		section = self.tst[name]
		if verbose_flag:
			s += self.st_dump_node(section)
		else:
			type = choose(len(section.parts)&gt;0,"  ","un")
			s += ("\n" + type + "defined:[" + section.name + "]")
	return s</t>
<t tx="T1416"># Dumps each part of a section's definition.

def st_dump_node(self,section):

	s = ("\nsection: " + section.name +
		", referenced:" + `section.referenced` +
		", is root:" + `section.is_root`)
	
	if len(section.parts) &gt; 0:
		s += "\n----- parts of " + angleBrackets(section.name)
		n = 1 # part list is in numeric order
		for part in section.parts:
			s += "\n----- Part " + `n`
			n += 1
			s += "\ndoc:  [" + `part.doc`  + "]"
			s += "\ncode: [" + `part.code` + "]"
		s += "\n----- end of partList\n"
	return s</t>
<t tx="T1417">@ Enters names and their associated code and doc parts into the given symbol table.
`is_dirty` is used only when entering root names.
@c

def st_enter(self,name,code,doc,multiple_parts_flag,is_root_flag):
	
	# trace(`name`)
	v = self.v ; is_dirty = v.isDirty()
	section = self.st_lookup(name,is_root_flag)
	assert(section)
	if doc:
		doc = string.rstrip(doc) # remove trailing lines.
	if code:
		if self.print_bits != silent_bits: # @silent supresses newline processing.
			i = skip_blank_lines(code,0) # remove leading lines.
			if i &gt; 0: code = code[i:]
		if len(code) == 0: code = None
	if code:
		&lt;&lt; check for duplicate code definitions &gt;&gt;
	if code or doc:
		part = part_node(name,code,doc,is_root_flag,false) # not dirty
		section.parts.append(part)
	else: # A reference
		section.referenced = true
	if is_root_flag:
		self.root_list.append(section)
		section.referenced = true # Mark the root as referenced.
	return len(section.parts) # part number</t>
<t tx="T1418">for part in section.parts:

	if part.code and multiple_parts_flag == disallow_multiple_parts:
		# Give the message only for non-empty parts.
		self.error("Multiple parts not allowed for " + name)
	  	return 0 # part number

	if self.tangling and code and code == part.code:
		es("Warning: possible duplicate definition of: &lt;&lt;" +
			section.name + "&gt;&gt;")</t>
<t tx="T1419">@ This function enters a section name into the given symbol table.
The code and doc pointers are None for references.
@c

def st_enter_section_name(self,name,code,doc,multiple_parts_flag):
	
	return self.st_enter(name,code,doc,multiple_parts_flag,not_root_name)</t>
<t tx="T1420"># Enters a root name into the given symbol table.

def st_enter_root_name(self,name,code,doc):
	
	assert(code)
	if name: # User errors can result in an empty @root name.
		self.st_enter(name,code,doc,disallow_multiple_parts,is_root_name)</t>
<t tx="T1421">@ This function looks up name in the symbol table and creates a tst_node for it if it does not exist.
@c

def st_lookup(self,name,is_root_flag):

	if is_root_flag:
		key = name
	else:
		key = self.standardize(name)

	if key in self.tst.keys():
		section = self.tst[key]
		# trace("found:" + key)
		return section
	else:
		# trace("not found:" + key)
		section = tst_node(key,is_root_flag)
		self.tst [key] = section
		return section</t>
<t tx="T1422">@ This function compares the interior of comments and returns true if they are identical except for whitespace or newlines. It is up to the caller to eliminate the opening and closing delimiters from the text to be compared.
@c

def compare_comments(self,s1,s2):

	comment = self.comment ; comment_end = self.comment_end
	tot_len = len(comment) + len(comment_end)
	CWEB_flag = (self.language == c_language and not self.use_noweb_flag)
	
	p1, p2 = 0, 0
	while p1 &lt; len(s1) and p2 &lt; len(s2):
		p1 = skip_ws_and_nl(s1,p1)
		p2 = skip_ws_and_nl(s2,p2)
		if comment and comment_end:
			&lt;&lt; Check both parts for @ comment conventions &gt;&gt;
		if p1 &gt;= len(s1) or p2 &gt;= len(s2):
			break
		if s1[p1] != s2[p2]:
			return false
		p1 += 1 ; p2 += 1
	p1 = skip_ws_and_nl(s1,p1)
	p2 = skip_ws_and_nl(s2,p2)
	return p1 == len(s1) and p2 == len(s2)
</t>
<t tx="T1423">@ This code is used in forgiving_compare()and in compare_comments().
To put self code in the main switch of forgiving_compare()would require splitting the code across cases,which would greatly obscure the logic and make it impossible to share the code with compare_comments().

In noweb mode we allow / * @ * /  (without the spaces)to be equal to @.
In CWEB mode we allow / * @ ? * / (without the spaces)to be equal to @?.
at-backslash is not a valid CWEB control code so,we don't have to equate
/ * @ \\ * / with at-backslash.

We must be careful not to run afoul of this very convention here!
@c

if s1[p1] == '@':
	if s2[p2:p2+tot_len+1] == comment + '@' + end_comment:
		p1 += 1
		p2 += tot_len + 1
		continue
	elif (CWEB_flag and s1[p1] == '@' and p1 + 1 &lt; len(s1) and
		s2[p2:p2+tot_len+2] == comment + '@' + s1[p1+1] ):
		p1 += 2
		p2 += tot_len + 2
		continue
	
elif s2[p2] == '@':
	if s1[p1:p1+tot_len+1] == comment + '@' + end_comment:
		p2 += 1
		p1 += tot_len + 1
		continue
	elif (CWEB_flag and s1[p1] == '@' and p1 + 1 &lt; len(s1) and
		s1[p1:p1+tot_len+2] == comment + '@' + s2[p2+1] ):
		p2 += 2
		p1 += tot_len + 2
		continue
</t>
<t tx="T1424">def pop_def_node (self):

	data = self.def_stack.pop()
	return data
</t>
<t tx="T1425"># This function pushes a new def_node on the top of the section stack.

def push_new_def_node (self,indent,name,part,of,nl_flag):

	trace("name: " + name + ", part: " + `part` +
		", of: " + `of` + ", indent: " + `indent`)
	
	data = (name,indent,part,of,nl_flag,None) # text buffer
	self.def_stack.push(data)</t>
<t tx="T1426">@ This is the "forgiving compare" function.  It compares two texts and returns true if they are identical except for comments or non-critical whitespace.  Whitespace inside strings or preprocessor directives must match exactly.
@c

def forgiving_compare(name,part,s1,s2):

	&lt;&lt; Define forgiving_compare vars &gt;&gt;
	p1 = 0 ; p2 = skip_ws_and_nl(s2,0) # Allow leading ws in s2 as well.
	result = true
	while result and p1 &lt; len(s1) and p2 &lt; len(s2):
		first1 = p1 ; first2 = p2
		if comment and comment_end:
			&lt;&lt; Check both parts for @ comment conventions &gt;&gt;
		ch1 = s1[p1]
		if ch1 == '\r' or ch1 == '\n':
			&lt;&lt; Compare non-critical newlines &gt;&gt;
		elif ch1 ==  ' ' or ch1 == '\t':
			&lt;&lt; Compare non-critical whitespace &gt;&gt;
		elif ch1 == '\'' or ch1 == '"':
			&lt;&lt; Compare possible strings &gt;&gt;
		elif ch1 == '#':
			&lt;&lt; Compare possible preprocessor directives &gt;&gt;
		elif ch1 == '&lt;' or ch1 == '@':
			&lt;&lt; Compare possible section references &gt;&gt;
		else:
			&lt;&lt; Compare comments or single characters &gt;&gt;
	&lt;&lt; Make sure both parts have ended &gt;&gt;
	if not result:
		&lt;&lt; Give error message &gt;&gt;
	return result</t>
<t tx="T1427"># The private globals describing comment delims have already been set by scan_derived_file.

comment = self.comment ; comment_end = self.comment_end
tot_len = len(comment) + len(comment_end)
CWEB_flag = (self.language == c_language and not self.use_noweb_flag)
start_ref = None  # For code that handles section references.
message = None   # Error message if result is FALSE.</t>
<t tx="T1428">p1 = skip_ws_and_nl(s1,p1)
p2 = skip_ws_and_nl(s2,p2)
</t>
<t tx="T1429">p1 = skip_ws(s1,p1)
p2 = skip_ws(s2,p2)</t>
<t tx="T1430">if self.language == c_language:
	&lt;&lt; compare preprocessor directives &gt;&gt;
else:
	&lt;&lt; compare single characters &gt;&gt;
</t>
<t tx="T1431">assert(p1 &lt; len(s1) and p2 &lt; len(s2))
result = s1[p1] == s2[p2]
p1 += 1 ; p2 += 1
if not result: mismatch("Mismatched single characters")</t>
<t tx="T1432"># We cannot assume that newlines are single characters.

result = s1[p1] == s2[p2]
p1 += 1 ; p2 += 1
while result and p1 &lt; len(s1) and p2 &lt; len(s2):
	if is_nl(s1,p1):
		result = is_nl(s2,p2)
		if not result or is_end_of_directive(s1,p1):
			break
		p1 = skip_nl(s1,p1)
		p2 = skip_nl(s2,p2)
	else:
		result = s1[p1] == s2[p2]
		p1 += 1 ; p2 += 1
if not result:
	mismatch("Mismatched preprocessor directives")</t>
<t tx="T1433"># This code implicitly assumes that string1_len == string2_len == 1.
# The match test ensures that the language actually supports strings.

if (match1(string1,string1_len) or match1(string2,string2_len)) and s1[p1] == s2[p2]:

	if self.language == pascal_language:
		&lt;&lt; Compare Pascal strings &gt;&gt;
	else:
		&lt;&lt; Compare C strings &gt;&gt;
	if not result:
		mismatch("Mismatched strings")
else:
	&lt;&lt; Compare single characters &gt;&gt;</t>
<t tx="T1434">delim = s1[p1]
result = s1[p1] == s2[p2]
p1 += 1 ; p2 += 1
while result and p1 &lt; len(s1) and p2 &lt; len(s2):
	if s1[p1] == delim and is_end_of_string(s1,p1,delim):
		result =(s2[p2] == delim and is_end_of_string(s1,p2,delim))
		p1 += 1 ; p2 += 1
		break
	elif is_nl(s1,p1)and is_nl(s2,p2):
		p1 = skip_nl(s1,p1)
		p2 = skip_nl(s2,p2)
	else:
		result = s1[p1] == s2[p2]
		p1 += 1 ; p2 += 1
</t>
<t tx="T1435">@ We assume the Pascal string is on a single line so the problems with cr/lf do not concern us.
@c

first1 = p1 ; first2 = p2
p1 = skip_pascal_string(s1,p1)
p2 = skip_pascal_string(s2,p2)
resutl = s1[first1,p1] == s2[first2,p2]
</t>
<t tx="T1436">if s1[p1] == '@' and CWEB_flag:  start_ref = "@&lt;"
elif s1[p1] == '&lt;' and not CWEB_flag:  start_ref = "&lt;&lt;"
else: start_ref = None

# Tangling may insert newlines.
p2 = skip_ws_and_nl(s2,p2)

junk, kind1, junk2 = self.is_section_name(s1,p1)
junk, kind2, junk2 = self.is_section_name(s2,p2)

if start_ref and (kind1 != bad_section_name or kind2 != bad_section_name):
	result = compare_section_names(s1[p1:],s2[p2:])
	if result:
		p1, junk1, junk2 = self.skip_section_name(s1,p1)
		p2, junk1, junk2 = self.skip_section_name(s2,p2)
	else: mismatch("Mismatched section names")
else:
	# Neither p1 nor p2 points at a section name.
	result = s1[p1] == s2[p2]
	p1 += 1 ; p2 += 1
	if not result:
		mismatch("Mismatch at '@' or '&lt;'")</t>
<t tx="T1437">if match_both(sentinel,sentinel_len):
	first1 = p1, first2 = p2
	p1 = skip_to_end_of_line(s1,p1)
	p2 = skip_to_end_of_line(s2,p2)
	result = self.compare_comments(s1[first1:p1],s2[first2:p2])
	if not result:
		mismatch("Mismatched sentinel comments")
elif match_both(line_comment,line_comment_len):
	first1 = p1, first2 = p2
	p1 = skip_to_end_of_line(s1,p1)
	p2 = skip_to_end_of_line(s2,p2)
	result = compare_comments(s1[first1:p1],s2[first2:p2])
	if not result:
		mismatch("Mismatched single-line comments")
elif match_both(comment,len(comment)):
	while (p1 &lt; len(s1) and p2 &lt; len(s2) and
		not match_either(comment_end,len(comment_end))):
		# ws doesn't have to match exactly either!
		if is_nl(s1,p1)or is_ws(s1[p1]):
			p1 = skip_ws_and_nl(s1,p1)
		else: p1 += 1
		if is_nl(s2,p2)or is_ws(s2[p2]):
			p2 = skip_ws_and_nl(s2,p2)
		else: p2 += 1
	p1 = skip_ws_and_nl(s1,p1)
	p2 = skip_ws_and_nl(s2,p2)
	if match_both(comment_end,len(comment_end)):
		first1 = p1, first2 = p2
		p1 += len(comment_end)
		p2 += len(comment_end)
		result = compare_comments(s1[first1:p1],s2[first2:p2])
	else: result = false
	if not result:
		mismatch("Mismatched block comments")
elif match_both(comment2,comment2_len):
	while (p1 &lt; len(s1) and p2 &lt; len(s2) and
		not match_either(comment2_end,comment2_end_len)):
		# ws doesn't have to match exactly either!
		if  is_nl(s1,p1)or is_ws(s1[p1]):
			p1 = skip_ws_and_nl(s1,p1)
		else: p1 += 1
		if is_nl(s2,p2)or is_ws(s2[p2]):
			p2 = skip_ws_and_nl(s2,p2)
		else: p2 += 1
	p1 = skip_ws_and_nl(s1,p1)
	p2 = skip_ws_and_nl(s2,p2)
	if match_both(comment2_end,comment2_end_len):
		first1 = p1, first2 = p2
		p1 += comment2_end_len
		p2 += comment2_end_len
		result = compare_comments(s1[first1:p1],s2[first2:p2])
	else: result = false
	if not result:
		mismatch("Mismatched alternalte block comments")
else:
	&lt;&lt; Compare single characters &gt;&gt;</t>
<t tx="T1438">if result:
	p1 = skip_ws_and_nl(s1,p1)
	p2 = skip_ws_and_nl(s2,p2)
	result = p1 == len(s1) and p2 == len(s2)
	if not result:
		# Show the ends of both parts.
		p1 = len(s1)
		p2 = len(s2)
		mismatch("One part ends before the other.")</t>
<t tx="T1439">pp1 = max(entry_p1,first1-10)
pp2 = max(entry_p2,first2-10)
lim1 = min(len(s1),p1+10)
lim2 = min(len(s2),p2+10)
	
trace("Warning: " + message +
	"\nAt part " + `part` + " of section " + name +
	"\np1..." + s1[pp1,lim1] + "\np2..." + s2[pp2,lim2] )</t>
<t tx="T1440">@ This function is called to massage an @doc part in the UST. We call self routine only after a mismatch in @doc parts is found between the UST and TST. On entry:,the parameters point to the inside of a block C comment: the opening and closing delimiters are not part of the text handled by self routine.

This code removes newlines that may have been inserted by the Tangle command in a block comment. Tangle may break lines differently in different expansions, but line breaks are ignored by forgiving_compare() and doc_compare() within block C comments.

We count the leading whitespace from the first non-blank line and remove this much whitespace from all lines. We also remove singleton newlines and replace sequences of two or more newlines by a single newline.
@c

def massage_block_comment(self,s):

	w = self.tab_width
	newlines = 0  # Consecutive newlines seen.
	first = i = skip_blank_lines(s,0)
	# Copy the first line and set n
	i, n = skip_leading_ws_with_indent(s,i,w)
	j = i ; i = skip_to_end_of_line(s,i)
	result = s[j:i]
	while i &lt; len(s):
		assert(is_nl(s,i))
		newlines += 1
		# Replace the first newline with a blank.
		result += ' ' ; i += 1
		while i &lt; len(s) and is_nl(s,i):
			i += 1 # skip the newline.
		j = i ; i = skip_ws(s,i)
		if is_nl(s,i)and newlines &gt; 1:
			# Skip blank lines.
			while is_nl(s,i):
				i += 1
		else:
			# Skip the leading whitespace.
			i = j # back track
			i = skip_leading_ws(s,i,n)
			newlines = 0
			# Copy the rest of the line.
			j = i ; i = skip_to_end_of_line(s,i)
			result += s[j:i]
	return result
</t>
<t tx="T1441">@ This function scans an entire derived file in s, discovering section or part definitions.

This is the easiest place to delete leading whitespace from each line: we simply don't copy it.  We also ignore leading blank lines and trailing blank lines.  The resulting definition must compare equal using the "forgiving" compare to any other definitions of that section or part.

We use a stack to handle nested expansions.  The outermost level of expansion corresponds to the @root directive that created the file.  When the stack is popped, the indent variable is restored.
self.root_name is the name of the file mentioned in the @root directive.

The caller has deleted all body_ignored_newlines from the text.
@c
	
def scan_derived_file(s,i):

	&lt;&lt; define scan_derived_file vars &gt;&gt;
	&lt;&lt; set the private global matching vars &gt;&gt;
	# Set indent.
	i, indent = skip_leading_ws_with_indent(s,i,self.tab_width)
	&lt;&lt; Skip the header line output by tangle &gt;&gt;
	# The top level of the stack represents the root.
	push_new_def_node(indent,self.root_name,1,1,TRUE)
	while i &lt; len(s):
		ch = s[i]
		if ch == body_ignored_newline:
			i += 1 # ignore
		elif ch == body_newline:
			&lt;&lt; handle the start of a new line &gt;&gt;
		elif match(s,i,sentinel) and test_sentinel(s,i,sentinel):
			&lt;&lt; handle a sentinel line  &gt;&gt;
		elif (match(line_comment,line_comment_len) or
			match(verbatim,verbatim_len)):
			&lt;&lt; copy the entire line &gt;&gt;
		elif match(comment,len(comment)):
			&lt;&lt; copy a multi-line comment &gt;&gt;
		elif match(comment2,comment2_len):
			&lt;&lt; copy an alternate multi-line comment &gt;&gt;
		elif (match(string1,string1_len) or
			match(string2,string2_len)):
			&lt;&lt; copy a string &gt;&gt;
		else:
			self.copy(ch) ; i += 1
	&lt;&lt; end all open sections &gt;&gt;</t>
<t tx="T1442">first_ip = i
indent = 0   # The leading whitespace to be deleted(in columns).
line_indent = 0   # The indentation to use if we see a section reference.

# These are for the call to is_sentinel_line.
nl_flag = 0 ; result = 0 ; of = 0 ; part = 0</t>
<t tx="T1443"># Set defaults from the public globals set by the @comment command.
if self.single_comment_string:
	self.sentinel = single_comment_string
	self.sentinel_end = None
elif self.end_comment_string:
	self.sentinel = self.start_comment_string
	self.sentinel_end = self.end_comment_string
else:
	self.sentinel = sentinel_end = None

# Set defaults to C
line_comment = "//" 
comment = self.start_comment_string
comment_end = self.end_comment_string
comment2 = comment2_end = None
string1 = "\""
string2 = "'"
verbatim = None

# Set all special cases.
if   self.language == c_language: verbatim = "#"
elif self.language == html_language: line_comment = None
elif self.language == java_language:
	pass
elif self.language == pascal_language:
	comment2 = "(*"
	comment2_end = "*)"
elif self.language == perl_language:
	line_comment = "##"
elif self.language == perlpod_language:
	line_comment = "##"
	comment2 = "=pod"
	comment2_end = "=cut"
elif self.language == plain_text_language:
	string1 = string2 = None # This is debatable.
	line_comment = None
elif self.language == python_language:
	pass
elif self.language == shell_language:
	line_comment = "##"

# Set the lengths of all delimiter strings.
if 0: # use len instead
	set(len(comment),     comment)
	set(comment2_len,comment2)
	set(len(comment_end),comment_end)
	set(comment2_end_len,comment2_end)
	set(sentinel_len,sentinel)
	set(sentinel_end_len,sentinel_end)
	set(line_comment_len,line_comment)
	set(string1_len,string1)
	set(string2_len,string2)
	set(verbatim_len,verbatim)</t>
<t tx="T1444">if sentinel or comment:
	line = " Created by Leo from" + choose(sentinel,sentinel,comment)
	if s[i:i+len(line)] == line:
		# Even a block comment will end on the first line.
		i = skip_to_end_of_line(s,i)</t>
<t tx="T1445">copy(ch) ; i += 1 # This works because we have one-character newlines.

# Set line_indent,for use only if we see a section reference.
junk, line_indent = skip_leading_ws_with_indent(s,i,self.tab_width)
i = skip_leading_ws(s,i,indent) # skip indent leading white space.</t>
<t tx="T1446">@ This is the place to eliminate the proper amount of whitespace from the start of each line. We do self by setting the 'indent' variable to the leading whitespace of the first _non-blank_ line following the opening sentinel.

Tangle increases the indentation by one tab if the section reference is not the first non-whitespace item on the line,so self code must do the same.
@c

if result == end_sentinel_line:
	trace("--end--" + name)
	
&lt;&lt; terminate the previous part of this section if it exists &gt;&gt;
if result == start_sentinel_line:
	indent = line_indent
	# Increase line_indent by one tab width if the
	# the section reference does not start the line.
	j = i - 1
	while j &gt;= 0:
		if is_nl(s,j):
			break
		elif not is_ws(s[j]):
			indent += self.tab_width ; break
		j -= 1
	# copy the section reference to the _present_ section,
	# but only if this is the first part of the section.
	if part &lt; 2: copy(name)
	# Skip to the first character of the new section definition.
	i = skip_to_end_of_line(s,i)
	# Start the new section.
	self.push_new_def_node(indent,name,part,of,nl_flag)
else:
	assert(result == end_sentinel_line)
	# Skip the sentinel line.
	i = skip_to_end_of_line(s,i)
	# Skip a newline only if it was added after(!newline)
	if not nl_flag:
		i = skip_ws(s,i)
		i = skip_nl(s,i)
		i = skip_ws(s,i)
		# Copy any whitespace following the(!newline)
		while end_p and is_ws(s[end_p]):
			self.copy(s[end_p])
			end_p += 1
	# Restore the old indentation level.
	if self.def_stack:
		indent = self.def_stack.indent ## ?????</t>
<t tx="T1447">@ We have just seen a sentinel line. Any kind of sentinel line will terminate a previous part of the present definition. For end sentinel lines, the present section name must match the name on the top of the stack.
@c

if len(self.def_stack) &gt; 0:
	dn = self.def_stack[0]
	if compare_section_names(name,dn.name):
		dn = pop_def_node()
		if len(dn.text) &gt; 0:
			# prev_ip = None ; prev_limit = None
			part, nl_flag = ust_lookup(name,dn.part,dn.text,false,false) # not root, not update
			# Check for incompatible previous definition.
			if found and not forgiving_compare(name,dn.part,dn.text):
				self.error("Incompatible definitions of " + name)
			elif not found:
				self.ust_enter(ust,name,dn.part,dn.of,dn.text,dn.nl_flag,false) # not root
	elif result == end_sentinel_line:
		self.error("Missing sentinel line for: " + name)</t>
<t tx="T1448">j = i ; i = skip_to_end_of_line(s,i)
self.copy(s[j:i])
</t>
<t tx="T1449">j = i
if self.language == pascal_language:
	i = skip_pascal_string(s,i)
else:
	i = skip_string(s,i)
self.copy(s[j:i])</t>
<t tx="T1450">assert(comment_end)
j = i
# Scan for the ending delimiter.
i += len(comment)
while i &lt; len(s) and not match(s,i,comment_end):
	i += 1
if match(s,i,comment_end):
	i += len(comment_end)
self.copy(s[j:i])</t>
<t tx="T1451">assert(comment2_end)
j = i
# Scan for the ending delimiter.
i += len(comment2)
while i &lt; len(s) and not match(s,i,comment2_end):
	i += 1
if match(s,i,comment2_end):
	i += len(comment2)
self.copy(s[j:i])</t>
<t tx="T1452">dn= None
while len(self.def_stack) &gt; 0:
	dn = pop_def_node()
	if len(sefl.def_stack) &gt; 0:
		self.error("Unterminated section: " + dn.name)
if dn:
	# Terminate the root setcion.
	i = len(s)
	if text and len(text) &gt; 0:
		self.ust_enter(dn.name,dn.part,dn.of,dn.text,dn.nl_flag,true) # is_root_flag
	else:
		self.error("Missing root part")
else:
	self.error("Missing root section")</t>
<t tx="T1453">def copy(self, s):

	dn = self.def_stack[0]
	dn.text += s</t>
<t tx="T1454"># This function returns true if we are at the end of preprocessor directive.

def is_end_of_directive(s,i):

	return is_nl(s,i) and not is_escaped(s,i)</t>
<t tx="T1455">def is_end_of_string(s,i,delim):

	return i &lt; len(s) and s[i] == delim and not is_escaped(s,i)</t>
<t tx="T1456"># This function returns true if the s[i] is preceded by an odd number of back slashes.

def is_escaped(s,i):

	back_slashes = 0 ; i -= 1
	while i &gt;= 0 and s[i] == '\\':
		back_slashes += 1
		i -= 1
	return (back_slashes &amp; 1) == 1
</t>
<t tx="T1457">@ This function returns true if i points to a line a sentinel line of one of the following forms:

start_sentinel &lt;&lt;section name&gt;&gt; end_sentinel
start_sentinel &lt;&lt;section name&gt;&gt; (n of m) end_sentinel
start_sentinel -- end -- &lt;&lt;section name&gt;&gt; end_sentinel
start_sentinel -- end -- &lt;&lt;section name&gt;&gt; (n of m) end_sentinel

start_sentinel: the string that signals the start of sentinel lines\
end_sentinel:   the string that signals the endof sentinel lines.

end_sentinel may be None,indicating that sentinel lines end with a newline. Any of these forms may end with (!newline), indicating that the section reference was not followed by a newline in the orignal text.

This routine sets the newline flag to false in the caller if such a string is seen. We set the name_ip1 and name_ip2 arguments in the caller to the start and end of the section name. This function sets the result param in the caller. The valid values of result are:

non_sentinel_line,   # not a sentinel line.
start_sentinel_line, #   /// &lt;section name&gt; or /// &lt;section name&gt;(n of m)
end_sentinel_line  //  /// -- end -- &lt;section name&gt; or /// -- end -- &lt;section name&gt;(n of m).
@c

def is_sentinel_line(self,s,i):

	result, i, kind, name, part, of, end, nl_flag = self.is_sentinel_line_with_data(s,i)
	return result

def is_sentinel_line_with_data(self,s,i):

	&lt;&lt; Initialize the return values &gt;&gt;
	&lt;&lt; Make sure the line starts with start_sentinel &gt;&gt;
	&lt;&lt; Set end_flag if we have -- end -- &gt;&gt;
	&lt;&lt; Make sure we have a section reference &gt;&gt;
	&lt;&lt; Set part and of if they exist &gt;&gt;
	&lt;&lt; Set nl_flag to false if !newline exists &gt;&gt;
	&lt;&lt; Make sure the line ends with end_sentinel &gt;&gt;
	kind = choose(end_flag,end_sentinel_line,start_sentinel_line)
	return true, i, kind, name, part, of, end, nl_flag</t>
<t tx="T1458">name = end = None
part = of = 1
kind = non_sentinel_line
nl_flag = true

false_data = false, i, kind, name, part, of, end, nl_flag
</t>
<t tx="T1459">if is_nl(s,i): i = skip_nl(s,i)
i = skip_ws(s,i)

# 4/18/00: We now require an exact match of the sentinel.
if match(s,i,start_sentinel):
	i += len(start_sentinel)
else:
	return false_data</t>
<t tx="T1460"># If i points to "-- end --",self code skips it and sets end_flag.

i = skip_ws(s,i)
if match(s,i,"--"):
	while i &lt; len(s) and s[i] == '-':
		i += 1
	i = skip_ws(s,i)
	if not match(s,i,"end"):
		return false_data # Not a valid sentinel line.
	i += 3 ; i = skip_ws(s,i)
	if not match(s,i,"--"):
		return false_data # Not a valid sentinel line.
	while i &lt; len(s) and s[i] == '-':
		i += 1
	end_flag = true</t>
<t tx="T1461">i = skip_ws(s,i)
if (self.use_noweb_flag and match(s,i,"&lt;&lt;") or
	self.use_cweb_flag  and match(s,i,"@&lt;") ):

	i, kind, name = self.skip_section_name(s,i)
	if result != section_ref:
		return false_data
else:
	return false_data</t>
<t tx="T1462"># This code handles(m of n),if it exists.

i = skip_ws(s,i)
if match(c,i,'('):
	j = i
	i += 1 ; i = skip_ws(s,i)
	i, part = self.scan_short_val(s,i)
	if part == -1:
		i = j # back out of the scanning for the number.
	else:
		i = skip_ws(s,i)
		if not match(s,i,"of"):
			return false_data
		i += 2 ; i = skip_ws(s,i)
		i, of = scan_short_val(s,i)
		if of == -1:
			return false_data
		i = skip_ws(s,i)
		if match(s,i,')'):
			i += 1 # Skip the paren and do _not_ return.
		else:
			return false_data</t>
<t tx="T1463">line = "(!newline)"
i = skip_ws(s,i)
if match(s,i,line):
	i += len(line)
	nl_flag = false
</t>
<t tx="T1464">i = skip_ws(s,i)
if end_sentinel:
	# Make sure the line ends with the end sentinel.
	if match(s,i,end_sentinel):
		i += end_sentinel_len
	else:
		return false_data

end = i # Show the start of the whitespace.
i = skip_ws(s,i)
if i &lt; len(s) and not is_nl(s,i):
	return false_data</t>
<t tx="T1465"># This function scans a positive integer.
# returns (i,val), where val == -1 if there is an error.

def scan_short_val(s,i):

	if i &gt;= len(s) or s[i] not in string.digits:
		return i, -1

	val = 0
	while i &lt; len(s) and s[i] in string.digits:
		val = val * 10 + (s[i] - '0')
		i += 1
	return i, val</t>
<t tx="T1466">@ This function handles the actual updating of section definitions in the web.  Only code parts are updated, never doc parts.

During pass 2 of Untangle, skip_body() call this routine when it the Tangle code discovers the definition of a section in the outline.  We look up the name in the ust. If an entry exists, we compare the code (the code part of an outline node) with the code parts in the ust. We update the code part if necessary.

We use the forgiving_compare() to compare code parts. It's not possible to change only trivial whitespace using Untangle because forgiving_compare() ignores trivial whitespace.
@c

# Major change: 2/23/01: Untangle never updates doc parts.

def update_def(self,name,part,code1,code2,is_root_flag): # Doc parts are never updated!

	v = self.v ; body = v.bodyString()
	code = body[code1:code2]
	ucode, nl_flag = ust_lookup(name,part,is_root_flag,true) # Set update
	&lt;&lt; Remove leading blank lines and block comments from ucode &gt;&gt;
	if not ucode:
		return # Not an error.
	if code and forgiving_compare(name,part,code,ucode):
		return
	# Replace code with ucode
	es("***Updating:   " + v.headString())
	# Strip leading and trailing blank lines.
	i = skip_blank_lines(ucode,0)
	ucode =ucode[i:]
	ucode = string.rstrip(ucode)
	body = body[:code1] + ucode + body[code2:] # update the body
	self.update_current_vnode(body)
	return body
</t>
<t tx="T1467">i = skip_blank_lines(ucode,0)
ucode = ucode[i:]
i = skip_ws(ucode,i)

if comment and comment_end and match(ucode,i,comment):
	
	# Skip to the end of the comment.
	i += len(comment)
	while i &lt; len(ucode):
		if match(ucode,i,end_comment):
			i += len(comment_end)
			i = skip_ws_and_nl(ucode,i)
			ucode = ucode[i:]
			break
		else: i += 1

</t>
<t tx="T1468">@ This function is called from within the Untangle logic to update the body text of the vnode indicated by the global bridge_vnode.
@c

def update_current_vnode(self,s):

	c = self.commands ; v = self.v
	assert(self.v)
	v.setBodyStringOrPane(s)
	
	c.beginUpdate()
	c.setChanged(true)
	v.setDirty()
	v.setMarked()
	c.endUpdate()</t>
<t tx="T1469">def ust_dump(table):

	s = "\n---------- Dump of Untangle Symbol Table ----------\n"
	keys = self.ust.keys()
	keys.sort()
	for name in keys:
		section = self.ust[name]
		s += "\nsection:" + section.name
		for part in section.parts:
			assert(part.of == section.of)
			s += "\n----- part " + `part.part` + " of " + `part.of` + " -----\n"
			s += `part.code`
	return s</t>
<t tx="T1470">@ This routine enters names and their code parts into the given table. The 'part' and 'of' parameters are taken from the "(part n of m)" portion of the line that introduces the section definition in the C code.

If no part numbers are given the caller should set the 'part' and 'of' parameters to zero.  The caller is reponsible for checking for duplicate parts.

This function handles names scanned from a source file; the corresponding st_enter routine handles names scanned from outlines.
@c

def ust_enter(self,name,part,of,code,nl_flag,is_root_flag):

	if not is_root_flag:
		name = self.standardize_name(name)
	&lt;&lt; remove blank lines from the start and end of the text &gt;&gt;
	u = ustNode(name,text,part,of,nl_flag,false) # update_flag
	if self.ust.has_key(name):
		section = ust[name]
		## does not check part or of.
		section.parts.append(u)
	else:
		self.ust[name] = u

	trace("section name: [" + name + "](" + `part` + " of " + `of` + ")...")</t>
<t tx="T1471">i = skip_blank_lines(text,0)
if i &gt; 0: text = text[i:]
text = string.rstrip(text)
</t>
<t tx="T1472"># This function searches the given table for a part matching the section_name and part number.

# new: it just returns the part.  nl_flag not used!  (caller can set it)

def ust_lookup(self,name,text,part_number,nl_flag,is_root_flag,update_flag):

	if not is_root_flag:
		name = self.standardize_name(name)

	if self.ust.has_key(name):
		section = self.ust[name]
		if len(section.parts) &gt;= part_number:
			part = section.parts[part_number]
		else: part = None
			
	trace(choose(part,"found","not found") +
		": " + choose(is_root_flag,"root","section") +
		" name: [" + name + "](" + `part_number` + ")...\n")
	# trace(`part.code`)
	
	if part and update_flag: part.update_flag = true
	return part</t>
<t tx="T1473">@ This function issues a warning about any sections in the derived file for which no corresponding section has been seen in the outline.
@c

def ust_warn_about_orphans(self):

	for section in self.ust:
		for part in section.parts:
			assert(part.of == bucket.of)
			if not part.update_flag:
				es("Warning: " +
 					choose(self.use_noweb_flag,"&lt;&lt; ","@&lt; ") +
					part.name +
					choose(self.use_noweb_flag," &gt;&gt;"," @&gt;") +
					" is not in the outline")
				break # One warning per section is enough.
</t>
<t tx="T1474">@ These utilities deal with tangle ivars, so they should be methods.
</t>
<t tx="T1475">def error (self,s):

	self.errors += 1
	es(s)
	
def warning (self,s):

	es(s)</t>
<t tx="T1476">def is_section_name(self,s,i):

	kind = bad_section_name ; end = -1

	if self.use_cweb_flag :
		if match(s,i,"@&lt;"):
			i, kind, end = self.skip_cweb_section_name(s,i)
	elif match(s,i,"&lt;&lt;"):
		i, kind, end = self.skip_noweb_section_name(s,i)

	return i, kind, end</t>
<t tx="T1477">def set_root_delims(self,s):

	(self.single_comment_string,
	self.start_comment_string,
	self.end_comment_string) = set_delims_from_string(s)</t>
<t tx="T1478">def set_root_from_headline (self,v):

	# trace(`v`)
	s = v.headString()

	if s[0:5] == "@root":
		i = skip_ws(s,5)
		if i &lt; len(s): # Non-empty file name.
			# self.root_name must be set later by token_type().
			self.root = s</t>
<t tx="T1479">@ This code skips the file name used in @root directives.  i points after the @root directive.

File names may be enclosed in &lt; and &gt; characters, or in double quotes.  If a file name is not enclosed be these delimiters it continues until the next newline.
@c
def set_root_from_text(self,s,err_flag):
	
	# trace(`s`)
	self.root_name = None
	i = skip_ws(s,0)
	if i &gt;= len(s): return i
	# Allow &lt;&gt; or "" as delimiters, or a bare file name.
	if s[i] == '"':
		i += 1 ; delim = '"'
	elif s[i] == '&lt;':
		i += 1 ; delim = '&gt;'
	else: delim = body_newline

	root1 = i # The name does not include the delimiter.
	while i &lt; len(s) and s[i] != delim and not is_nl(s,i):
		i += 1
	root2 = i

	if delim != body_newline and not match(s,i,delim):
		if err_flag:
			scanError("bad filename in @root " + s[:i])
	else:
		self.root_name = string.strip(s[root1:root2])
	return i</t>
<t tx="T1480">@ This function skips past a section name that starts with @&lt; and ends with @&gt;. This code also skips any = following the section name.

Returns (i, kind, end), where kind is:

	bad_section_name:  @ &lt; with no matching @ &gt;
	section_ref: @ &lt; name @ &gt;
	section_def: @ &lt; name @ &gt; =

Unlike noweb, bad section names generate errors.
@c

def skip_cweb_section_name(self,s,i):
	
	j = i # Used for error message.
	kind = bad_section_name ; end = -1
	runon = false ; empty_name = true
	assert(s[i:i+2]=="@&lt;")
	i += 2
	while i &lt; len(s):
		if match(s,i,"@&gt;="):
			i += 3 ; end = i-1 ; kind = section_def ; break
		elif match(s,i,"@&gt;"):
			i += 2 ; end = i ; kind = section_ref ; break
		elif match(s,i,"@&lt;"):
			runon = true ; break
		elif match(s,i,"@@"): i += 2
		elif is_ws_or_nl(s,i): i += 1
		else:
			i += 1 ; empty_name = false

	if empty_name:
		scanError("empty CWEB section name: " + s[j:i])
		return i, bad_section_name, -1
	elif i &gt;= len(s) or runon:
		scanError("Run on CWEB section name: " + s[j:i])
		return i, bad_section_name, -1
	else:
		return i, kind, end</t>
<t tx="T1481">@ This function skips past a section name that starts with &lt; &lt; and might end with &gt; &gt; or &gt; &gt; =. The entire section name must appear on the same line.

Note: this code no longer supports extended noweb mode.

Returns (i, kind, end),
	end indicates the end of the section name itself (not counting the =).
	kind is one of:
		bad_section_name: "no matching "&gt;&gt;" or "&gt;&gt;"  This is _not_ a user error!
		section_ref: &lt; &lt; name &gt; &gt;
		section_def: &lt; &lt; name &gt; &gt; =
		at_root:     &lt; &lt; * &gt; &gt; =
@c
def skip_noweb_section_name(self,s,i):
	
	assert(match(s,i,"&lt;&lt;"))
	i += 2
	j = i # Return this value if no section name found.
	kind = bad_section_name ; end = -1 ; empty_name = true

	# Scan for the end of the section name.
	while i &lt; len(s) and not match(s, i, body_newline):
		if match(s,i,"&gt;&gt;="):
			i += 3 ; end = i - 1 ; kind = section_def ; break
		elif match(s,i,"&gt;&gt;"):
			i += 2 ; end = i ; kind = section_ref ; break
		elif is_ws_or_nl(s,i):
			i += 1
		elif empty_name and s[i] == '*':
			empty_name = false
			i = skip_ws(s,i+1) # skip the '*'
			if match(s,i,"&gt;&gt;="):
				i += 3 ; end = i - 1 ; kind = at_root ; break
		else:
			i += 1 ; empty_name = false

	if empty_name:
		kind = bad_section_name
	if kind == bad_section_name:
		i = j
	return i, kind, end</t>
<t tx="T1482"># Returns a tuple (i, kind, end)

def skip_section_name(self,s,i):

	if self.use_noweb_flag:
		return self.skip_noweb_section_name(s,i)
	else:
		return self.skip_cweb_section_name(s,i)</t>
<t tx="T1483">@ This code removes leading and trailing brackets, converts white space to a single blank and converts to lower case.
@c

def standardize (self,name):

	# Convert to lowercase.
	name = string.lower(name)
	# Convert whitespace to a single space.
	name = string.replace(name,'\t',' ')
	name = string.replace(name,'  ',' ')
	# Remove leading '&lt;'
	i = 0 ; n = len(name)
	while i &lt; n and name[i] == '&lt;':
		i += 1
	j = i
	# Find the first '&gt;'
	while i &lt; n and name [i] != '&gt;':
		i += 1
	name = string.strip(name[j:i])
	# trace(`name`)
	return name</t>
<t tx="T1484">@ This method returns a code indicating the apparent kind of token at the position i. The caller must determine whether section definiton tokens are valid.

returns (kind, end) and sets global root_name using set_root_from_text().
@c

def token_type(self,s,i,err_flag):

	# j = skip_line(s,i) ; trace(`s[i:j]`)
	kind = plain_line ; end = -1
	if self.use_noweb_flag:
		&lt;&lt; set token_type in noweb mode &gt;&gt;
	else:
		&lt;&lt; set token_type for CWEB mode &gt;&gt;
	if kind == at_other :
		&lt;&lt; set kind for directive &gt;&gt;
	return kind, end</t>
<t tx="T1485">if match(s,i,"&lt;&lt;"):
	i, kind, end = self.skip_section_name(s,i)
	if kind == bad_section_name:
		kind = plain_line # not an error.
	elif kind == at_root:
		if head_root:
			self.set_root_from_text(head_root,err_flag)
		else:
			kind = bad_section_name # The warning has been given.
elif match(s,i,"@ ") or match(s,i,"@\n"): kind = at_doc
elif match(s,i,"@@"): kind = at_at
elif i &lt; len(s) and s[i] == '@': kind = at_other
else: kind = plain_line</t>
<t tx="T1486">i = skip_ws(s,i)
if match(s,i,"@*") or match(s,i,"@ "): kind = at_doc
elif match(s,i,"@&lt;"): i, kind, end = self.skip_section_name(s,i)
elif match(s,i,"@@"): kind = at_at
elif match_word(s,i,"@c") or match_word(s,i,"@p"): kind = at_code
elif i &lt; len(s) and s[i] == '@':
	if   i + 1 &gt;= len(s): kind = at_doc
	elif i + 1 &lt; len(s) and s[i+1] not in string.letters:
		kind = at_web
	else: kind = at_other # Set kind later
else: kind = plain_line</t>
<t tx="T1487"># This code will return at_other for any directive other than those listed.

for name, type in [ ("@chapter", at_chapter),
	("@code", at_code), ("@doc", at_doc),
	("@root", at_root), ("@section", at_section) ]:
	if match_word(s,i,name):
		kind = type ; break

if kind == at_root:
	j = i + 5
	i = self.set_root_from_text(s[i+5:],err_flag)</t>
<t tx="T1488">@ This class implements a tree control similar to Windows explorer.  The draw code is based on code found in Python's IDLE program.  Thank you Guido van Rossum!

The vnode class contains all per-node information.  The vnode class handles all tree operations except drawing, selecting and events.  Inserting, deleting and moving vnodes is done by altering the strurcture links, that is, the the v.mParent, v.mFirstChild, v.mNext, v.mBack and ivars, then redrawing the entire tree.

The tree class knows about vnodes.  The vnode class could be split into a base class (say a treeItem class) containing the ivars known to the tree class, and a derived class containing everything else, including, e.g., the bodyString ivar.  I haven't chosen to split the vnode class this way because nothing would be gained in Leo.

The Commands class is responsible for redrawing the screen.  This should be done by enclosing code that could modify the screen in c.beginUpdate()/c.endUpdate() pairs.  This is a simple and highly efficient mechanism.
@c

from leoGlobals import *
from leoUtils import *
import leoApp, leoColor, leoNodes
import os, string, traceback, Tkinter

&lt;&lt; drawing constants &gt;&gt;

class leoTree:
	@others</t>
<t tx="T1489">box_padding = 5 # extra padding between box and icon
box_width = 9 + box_padding
icon_width = 20
text_indent = 4 # extra padding between icon and tex
child_indent = 28 # was 20
hline_y = 7 # Vertical offset of horizontal line
line_height = 17 + 2 # To be replaced by Font height

root_left = 7 + box_width
root_top = 2

hiding = true # True if we don't reallocate items</t>
<t tx="T1490">def __del__ (self):

	# Can't trace while destroying.
	# print "tree.__del__"
	pass</t>
<t tx="T1491">@ About drawing and updating strategy.

This version of Leo draws the outline "by hand" using the Tk canvas widget.  Surprisingly, this is not only easy, but simplifies the vnode and Commands classes.

1.  Updating and redraw.  The tree.redraw() method is called automatically from the "outermost" call to tree.endUpdate.  Moreover, calling .tree.redraw() inside a tree.beginUpdate/tree.endUpdate pair does nothing.  c.redraw(), c.beginUpdate() and c.endUpdate() just call the corresponding tree methods.  Finally, beginUpdate()/endUpdate(false) can be used to suppress redrawing entirely.

Therefore, the Commands class never needs to worry about extra calls to tree.redraw() provided all code that draws to the tree is enclosed in a tree.beginUpdate/tree.endUpdate pair.  The tree.idle_body_key event handler manages redrawing "by hand" by maintaining a redraw_flag and then calling endUpdate(redraw_flag).

2.  The tree.redraw() method deletes all old canvas items and recomputes all data, including v.iconVal.  This means that v.doDelete need not actually delete vnodes for them to disappear from the screen.  Indeed, vnode are never actually deleted, only unlinked.  It would be valid for "dependent" vnodes to be deleted, but there really is no need to do so.
</t>
<t tx="T1492">def drawTree(self,v,x,y,h,level):

	yfirst = ylast = y
	if level==0: yfirst += 10
	while v:
		# trace(`x` + ", " + `y` + ", " + `v`)
		h = self.drawNode(v,x,y)
		y += h ; ylast = y
		if v.isExpanded() and v.firstChild():
			y = self.drawTree(v.firstChild(),x+child_indent,y,h,level+1)
		v = v.next()
	&lt;&lt; draw vertical line &gt;&gt;
	return y</t>
<t tx="T1493">id = self.canvas.create_line(
	x, yfirst-hline_y+4,
	x, ylast+hline_y-h,
	fill="gray50", # stipple="gray50"
	tag="lines")

self.canvas.tag_lower(id)</t>
<t tx="T1494">def drawNode(self,v,x,y):

	# Draw horizontal line from vertical line to icon.
	self.canvas.create_line(x, y+7, x+box_width, y+7,tag="lines",fill="gray50") # stipple="gray25")
	if v.firstChild(): self.drawBox(v,x,y)
	icon_height = self.drawIcon(v,x+box_width,y)
	text_height = self.drawText(v,x+box_width+icon_width,y)
	return max(icon_height, text_height)</t>
<t tx="T1495">@ Returns the proper width of the entry widget for the headline. This has been a problem.
@c

def headWidth(self,v):

	return max(10,len(v.headString()))</t>
<t tx="T1496">def hideAllChildren(self,v):

	child = v.firstChild()
	while child:
		self.hideTree(child)
		child = child.next()</t>
<t tx="T1497">def hideNode(self,v):

	self.canvas.delete(v.box_id)
	self.canvas.delete(v.icon_id)
	self.canvas.delete(v.edit_text)
	self.canvas.delete(v.edit_text_id)
	v.box_id = v.icon_id = None
	v.edit_text = v.edit_text_id = None</t>
<t tx="T1498">def hideTree(self,v):

	last = v.lastNode()
	while v:
		self.hideNode(v)
		if v == last: break
		v = v.threadNext()</t>
<t tx="T1499">def OnActivate (self,v):

	c=self.commands
	# trace(`v`)

	if v == self.currentVnode:
		# w = self.commands.frame.getFocus()
		if self.active:
			self.editLabel(v)
		else:
			self.undimEditLabel()
			self.canvas.focus_set()
	else:
		self.select(v)
		c.body.mark_set("insert","1.0")
		c.body.focus_force()

	self.active = true</t>
<t tx="T1500"># Called on click in box and double-click in headline.

def OnBoxClick (self,v):

	if v.isExpanded():
		v.contract()
	else:
		v.expand()

	self.active = true
	self.select(v)
	self.canvas.focus_set() # This is safe.
	self.redraw()</t>
<t tx="T1501">def OnDeactivate (self, event=None):

	self.endEditLabel()
	self.dimEditLabel()
	self.active = false</t>
<t tx="T1502"># Undo manager for leo.py

class undoer:
	pass</t>
<t tx="T1503"># Global utility functions

from leoGlobals import *
import os, string, sys, time

# Synonyms for set_root_flag of is_special_bits
set_root_from_headline = true ; dont_set_root_from_headline = false

@others</t>
<t tx="T1504"># Returns &lt; &lt; s &gt; &gt;

def angleBrackets(s):

	return ( "&lt;&lt;" + s +
		"&gt;&gt;") # must be on a separate line.

virtual_event_name = angleBrackets</t>
<t tx="T1505"># bit testing.

def btest(b1, b2):

	return (b1 &amp; b2) != 0</t>
<t tx="T1506">timeStart = 0.0

def setTime():
	global timeStart
	timeStart = time.clock()
	return timeStart
	
def esDiffTime(message, t1):
	t = time.clock()
	es(message + ("%6.3f" % (t-t1)))
	timeStart = time.clock()
	return timeStart

def esTime(message):
	global timeStart
	t = time.clock()
	es(message + ("%6.3f" % (t-timeStart)))
	timeStart = time.clock()
	return timeStart
</t>
<t tx="T1507"># Compares section names or root names.


## We should use v.matchHeadline --&gt; utils.matchSectionNames

def compare_section_names(s1,s2):

	c = self.commands # for args

	if match(s1,0,"&lt;&lt;") or match(s1,0,"@&lt;"):
		# Use a forgiving compare of the two section names.
		delim = choose(c.use_CWEB_flag,"@&gt;","&gt;&gt;")
		n1 = len(s1) ; n2 = len(s2)
		while i1 &lt; n1 and i2 &lt; n2:
			if is_ws(*ip1) and is_ws(*ip2):
				i1 = skip_ws(s1, i1)
				i2 = skip_ws(s2, i2)
			elif match(s1,i1,delim) and match(s2,i2,delim):
				return true
			elif string.lower(s1[i1]) == string.lower(s2[i2]):
				i1 += 1 ; i2 += 1
			else: return false
		return false
	else: # A root name.
		return s1 == s2</t>
<t tx="T1508"># Returns a temporary file name.

def create_temp_name (name):

	import tempfile
	temp = tempfile.mktemp()
	# trace(`temp`)
	return temp</t>
<t tx="T1509">def dump(s):

	out = ""
	for i in s:
		if i=='\n':
			out += "[" ; out += "n" ; out += "]"
		if i=='\t':
			out += "[" ; out += "t" ; out += "]"
		elif i==' ':
			out += "[" ; out += " " ; out += "]"
		else: out += i
	return out
</t>
<t tx="T1510">def ensure_extension (name, ext):

	file, old_ext = os.path.splitext(name)
	if len(name) == 0:
		return name # don't add to an empty name.
	elif old_ext and old_ext == ext:
		return name
	else:
		return file + ext</t>
<t tx="T1511"># Warning: string.rstrip also removes newlines!

def removeTrailingWs(s):

	j = len(s)-1
	while j &gt;= 0 and (s[j] == ' ' or s[j] == '\t'):
		j -= 1
	return s[:j+1]
</t>
<t tx="T1512">def print_bindings (name,window):

	bindings = window.bind()
	print
	print "Bindings for", name
	for b in bindings:
		print `b`</t>
<t tx="T1513">@ It seems dubious to bump the Tangle error count here.  OTOH, it really doesn't hurt.
@c

def scanError(s):

	# Bump the error count in the tangle command.
	c = topCommands()
	c.tangleCommands.errors += 1

	es(s)</t>
<t tx="T1514">@ This function compares two files. If they are different, we replace file_name with temp_name. Otherwise, we just delete temp_name.  Both files should be closed.
@c

def update_file_if_changed(file_name,temp_name):

	if os.path.exists(file_name):
		import filecmp
		if filecmp.cmp(temp_name, file_name):
			try: # Just delete the temp file.
				os.remove(temp_name)
			except: pass
			es("unchanged: " + file_name)
		else:
			try: # Replace file with temp file.
				os.remove(file_name)
				os.rename(temp_name, file_name)
				es("***updating: " + file_name)
			except:
				es("Rename failed: no file created! (file may be read-only)")
	else:
		try:
			os.rename(temp_name, file_name)
			es("Creating: " + file_name)
		except:
			es("Rename failed: no file created! (file may be read-only)")</t>
<t tx="T1515"># Returns true if s[i] is preceded by an odd number of backslashes.

def escaped(s,i):

	count = 0
	while i-1 &gt;= 0 and s[i-1] == '\\':
		count += 1
		i -= 1
	return (count%2) == 1</t>
<t tx="T1516">def find_line_start(s,i):

	# not tested, not used.
	i = string.rfind(s,'\n',i)
	if i == -1: return 0
	else: return i + 1</t>
<t tx="T1517">def find_on_line(s,i,pattern):

	# j = skip_line(s,i) ; trace(`s[i:j]`)
	j = string.find(s,'\n',i)
	if j == -1: j = len(s)
	k = string.find(s,pattern,i,j)
	if k &gt; -1: return k
	else: return None</t>
<t tx="T1518">def is_c_id(ch):

	return ch in string.letters or ch in string.digits or ch == '_'</t>
<t tx="T1519">def is_c_word(s,i, name):

	n = len(name)
	return ( name == s[i:i+n] and
		( i + n == len(s) or not is_c_id(s[i+n]) ) )</t>
<t tx="T1520">def is_nl(s,i):

	return i &lt; len(s) and (s[i] == '\n' or s[i] == '\r')</t>
<t tx="T1521">@ Return true if the body text contains the @ directive.

We no longer require that the directive appear befor e any @c directive or section definition.
@c

def is_special(s,i,directive):

	# j = skip_line(s,i) ; trace(`s[i:j]` + " : " + `directive`)
	assert (directive and directive [0] == '@' )
	while i &lt; len(s):
		i = skip_ws_and_nl(s,i)
		if match_word(s,i,directive):
			return true, i
		else:
			i = skip_line(s,i)
	return false, -1</t>
<t tx="T1522">@ Returns bits, dict where:
bits is a bit-set representing all the @directives of a particular body text.
dict contains various pointers into the text.
@c

def is_special_bits(s,set_root_flag):

	bits = 0 ; dict = {}
	i = 0 ; n = len(s)
	while i &lt; n:
		if s[i] == '@' and i+1 &lt; n:
			&lt;&lt; set bits for @ directives &gt;&gt;
		elif match(s,i,"&lt;&lt;") and set_root_flag:
			&lt;&lt; set root bits for noweb * chunks &gt;&gt;
		i = skip_line(s,i)
	return bits, dict</t>
<t tx="T1523">ch = s[i+1]
if ch == 'c':
	if   match_word(s,i,"@color"): bits |= color_bits
	elif match_word(s,i,"@comment"):
		bits |= comment_bits ; dict["comment"] = i
elif ch == 'h':
	if match_word(s,i,"@header"): bits |= header_bits
elif ch == 'i':
	if match_word(s,i,"@ignore"): bits |= ignore_bits
elif ch == 'l':
	if match_word(s,i,"@language"):
		# es("is_special_bits:" + s[i:])
		bits |= language_bits ; dict ["language"] = i
elif ch == 'n':
	if   match_word(s,i,"@nocolor"):  bits |= nocolor_bits
	elif match_word(s,i,"@noheader"): bits |= noheader_bits
elif ch == 'o':
	if match_word(s,i,"@owncolor"): bits |= owncolor_bits
elif ch == 'p':
	if   match_word(s,i,"@pagewidth"):
		bits |= page_width_bits ; dict["page_width"] = i
	elif match_word(s,i,"@path"):
		# es("is_special_bits:" + s[i:])
		bits |= path_bits ; dict["path"] = i
elif ch == 'r':
	if match_word(s,i,"@root"): bits |= root_bits # skip_body finds the root.
elif ch == 's':
	if match_word(s,i,"@silent"): bits |= silent_bits
elif ch == 't':
	if   match_word(s,i,"@tabwidth"):
		bits |= tab_width_bits ; dict["tab_width"] = i
	elif match_word(s,i,"@terse"):
		bits |= terse_bits
elif ch == 'u':
	if match_word(s,i,"@unit"): bits |= unit_bits
elif ch == 'v':
	if match_word(s,i,"@verbose"): bits |= verbose_bits</t>
<t tx="T1524">@ The following looks for chunk definitions of the form &lt; &lt; * &gt; &gt; =. If found, we take this to be equivalent to @root filename if the headline has the form @root filename.
@c

i = skip_ws(s,i+2)
if i &lt; n and s[i] == '*' :
	i = skip_ws(s,i+1) # Skip the '*'
	if match(s,i,"&gt;&gt;="):
		i += 3
		global head_root
		if head_root:
			bits |= root_bits
		else:
			es("&lt;&lt;" +
				"*&gt;&gt;= requires @root in the headline")</t>
<t tx="T1525">def is_ws(c):

	return c == '\t' or c == ' '
	
def is_ws_or_nl(s,i):

	return is_nl(s,i) or (i &lt; len(s) and is_ws(s[i]))</t>
<t tx="T1526"># Warning: this code makes no assumptions about what follows pattern.

def match(s,i,pattern):

	return string.find(s,pattern,i,i+len(pattern)) == i</t>
<t tx="T1527">def match_ignoring_case(s1,s2):

	return string.lower(s1) == string.lower(s2)</t>
<t tx="T1528">def match_word(s,i,pattern):

	j = len(pattern)
	if string.find(s,pattern,i,i+j) != i:
		return false
	if i+j &gt;= len(s):
		return true
	c = s[i+j]
	return not (c in string.letters or c in string.digits or c == '_')</t>
<t tx="T1529">def skip_blank_lines(s,i):

	n = len(s)
	while i &lt; n:
		if is_nl(s,i) :
			i = skip_nl(s,i)
		elif is_ws(s[i]):
			j= skip_ws(s,i)
			if is_nl(s,j):
				i = j
			else: break
		else: break
	return i</t>
<t tx="T1530">def skip_c_id(s,i):

	n = len(s)
	while i &lt; n:
		c = s[i]
		if c in string.letters or c in string.digits or c == '_':
			i += 1
		else: break
	return i</t>
<t tx="T1531">@ These methods skip to the next newline, regardless of whether the newline may be preceeded by a backslash. Consequently, this routine should be used only when we know that we are not in a preprocessor directive or string.
@c

def skip_line(s,i):

	i = string.find(s,'\n',i)
	if i == -1: return len(s)
	else: return i + 1
		
def skip_to_end_of_line(s,i):

	i = string.find(s,'\n',i)
	if i == -1: return len(s)
	else: return i</t>
<t tx="T1532"># returns (i, val) or (i, None) if s[i] does not point at a number.

def skip_long(s,i):

	val = 0
	i = skip_ws(s,i)
	n = len(s)
	if i &gt;= n or s[i] not in string.digits:
		return i, None
	while i &lt; n and s[i] in string.digits:
		val = val * 10
		val += (s[i] - '0')
		i += 1
	return i, val</t>
<t tx="T1533">@ This function skips a single "logical" end-of-line character.  We need this function because different systems have different end-of-line conventions.
@c

def skip_nl(s,i):

	if (match(s,i,"\r\n")): return i + 2
	elif match(s,i,'\n') or match(s,i,'\r'): return i + 1
	else: return i</t>
<t tx="T1534"># Skips from the opening { to the matching }.

def skip_pascal_braces(s,i):

	# No constructs are recognized inside Pascal block comments!
	k = string.find(s,'}',i)
	if i == -1: return len(s)
	else: return k</t>
<t tx="T1535">def skip_ws(s,i):

	n = len(s)
	while i &lt; n and is_ws(s[i]):
		i += 1
	return i
	
def skip_ws_and_nl(s,i):

	n = len(s)
	while i &lt; n and (is_ws(s[i]) or is_nl(s,i)):
		i += 1
	return i</t>
<t tx="T1536">@ These scanners all call scanError() directly or indirectly, so they will call es() if they find an error.  scanError() also bumps commands.tangleCommands.errors, which is harmless if we aren't tangling, and useful if we are.

These routines are called by the Import routines and the Tangle routines.
</t>
<t tx="T1537"># Scans past a block comment (an old_style C comment).

def skip_block_comment (s,i):

	assert(s[i:i+2]=="/*")
	j = i ; i += 2 ; n = len(s)
	
	k = string.find(s,"*/",i)
	if k == -1:
		scanError("Run on block comment: " + s[j:i])
		return n
	else: return k + 2</t>
<t tx="T1538"># Skips from the opening to the matching . If no matching is found i is set to len(s).

def skip_braces(s,i):

	assert(match(s,i,'{'))
	level = 0 ; n = len(s)
	while i &lt; n:
		c = s[i]
		if c == '{':
			level += 1 ; i += 1
		elif c == '}':
			level -= 1
			if level &lt;= 0: return i
			i += 1
		elif c == '\'' or c == '"': i = skip_string(s,i)
		elif match(s,i,'//'): i = skip_to_end_of_line(s,i)
		elif match(s,i,'/*'): i = skip_block_comment(s,i)
		else: i += 1
	return i</t>
<t tx="T1539">@ Skips from the opening ( to the matching ) . If no matching is found i is set to len(s)
@c

def skip_parens(s,i):
	level = 0 ; n = len(s)
	assert(match(s,i,'('))
	while i &lt; n:
		c = s[i]
		if c == '(':
			level += 1 ; i += 1
		elif c == ')':
			level -= 1
			if level &lt;= 0:  return i
			i += 1
		elif c == '\'' or c == '"': i = skip_string(s,i)
		elif match(s,i,"//"): i = skip_to_end_of_line(s,i)
		elif match(s,i,"/*"): i = skip_block_comment(s,i)
		else: i += 1
	return i</t>
<t tx="T1540">@ Skips from begin to matching end.
If found, i points to the end. Otherwise, i &gt;= len(s)
The end keyword matches begin, case, class, record, and try.
@c

def skip_pascal_begin_end(s,i):

	assert(is_c_word(s,i,"begin"))
	level = 1 ; i = skip_c_id(s,i) # Skip the opening begin.
	n = len(s)
	while i &lt; n:
		c = s[i]
		if c =='{' : i = skip_pascal_braces(s,i)
		elif c =='"' or c == '\'': i = skip_pascal_string(s,i)
		elif match(s,i,"//"): i = skip_to_end_of_line(s,i)
		elif match(s,i,"(*"): i = skip_pascal_block_comment(s,i+2)
		elif is_c_word(s,i,"end"):
			level -= 1 ;
			if level == 0: return i
		else:
			for name in ["begin", "case", "class", "record", "try"]:
				if is_c_word(s,i,name):
					level += 1 ; i += len(name) ; break
			else: i += 1
	return i</t>
<t tx="T1541"># Scans past a pascal comment delimited by (* and *).

def skip_pascal_block_comment(s,i):
	
	j = i
	assert(match(s,i,"(*"))
	i = string.find(s,"*/",i)
	if i &gt; -1: return i + 2
	else:
		scanError("Run on comment" + s[j:i])
		return len(s)

#	n = len(s)
#	while i &lt; n:
#		if match(s,i,"*)"): return i + 2
#		i += 1
#	scanError("Run on comment" + s[j:i])
#	return i</t>
<t tx="T1542">def skip_pascal_string(s,i):

	j = i ; delim = s[i] ; delim2 = delim*2 ; i += 1
	assert(delim == '"' or delim == '\'')
	
	n = len(s)
	while 1:
		i = string.find(s,delim,i)
		if i == -1 or i == n: return n
		if s[i+1] != delim: return i
		else: i += 2

	scanError("Run on string: " + s[j:])
	return i</t>
<t tx="T1543"># Now handles continuation lines and block comments.

def skip_pp_directive(s,i):

	while i &lt; len(s):
		if is_nl(s,i):
			if escaped(s,i): i = skip_nl(s,i)
			else: break
		elif match(s,i,"//"): i = skip_to_end_of_line(s,i)
		elif match(s,i,"/*"): i = skip_block_comment(s,i)
		else: i += 1
	return i</t>
<t tx="T1544"># Skips an entire if or if def statement, including any nested statements.

def skip_pp_if(s,i):

	assert(match(s,i,'#'))
	if ( not match_word(s,i,"#if") and
		not match_word(s,i,"ifdef") and
		not match_word(s,i,"#ifndef") ): return skip_to_end_of_line(s,i)

	level = 0
	while i &lt; len(s):
		c = s[i]
		if match_word(s,i,"#if") or match_word(s,i,"ifdef") or match_word(s,i,"#ifndef"):
			level += 1 ; i = skip_to_end_of_line(s,i)
		elif match_word(s,i,"#endif"):
			level -= 1 ; i = skip_to_end_of_line(s,i)
			if level &lt;= 0: return i
		elif c == '\'' or c == '"': i = skip_string(s,i)
		elif match(s,i,"//"): i = skip_to_end_of_line(s,i)
		elif match(s,i,"/*"): i = skip_block_comment(s,i)
		else: i += 1
	return i</t>
<t tx="T1545"># Skips to the next semicolon that is not in a comment or a string.

def skip_to_semicolon(s,i):

	n = len(s)
	while i &lt; n:
		c = s[i]
		if c == ';': return i
		elif c == '\'' or c == '"' : i = skip_string(s,i)
		elif match(s,i,"//"): i = skip_to_end_of_line(s,i)
		elif match(s,i,"/*"): i = skip_block_comment(s,i)
		else: i += 1
	return i</t>
<t tx="T1546">def skip_python_string(s,i):

	if match(s,i,"'''") or match(s,i,'"""'):
		j = i ; delim = s[i]*3 ; i += 3
		k = string.find(s,delim,i)
		if k &gt; -1: return k
		scanError("Run on triple quoted string: " + s[j:i])
		return len(s)
	else:
		return skip_string(s,i)</t>
<t tx="T1547">def skip_string(s,i):
	
	j = i ; delim = s[i] ; i += 1
	assert(delim == '"' or delim == '\'')
	n = len(s)
	while i &lt; n and s[i] != delim:
		if s[i] == '\\' : i += 2
		else: i += 1

	if i &gt;= n:
		scanError("Run on string: " + s[j:i])
	elif s[i] == delim:
		i += 1
	return i</t>
<t tx="T1548">def skip_typedef(s,i):

	n = len(s)
	while i &lt; n and is_c_id(s[i]):
		i = skip_c_id(s,i)
		i = skip_ws_and_nl(s,i)
	if match(s,i,'{'):
		i = skip_braces(s,i)
		i = skip_to_semicolon(s,i)
	return i</t>
<t tx="T1549"># Returns a tuple (single,start,end) of comment delims

def set_delims_from_language(language):

	for lang, val in [ (cweb_language, "// /* */"),
		(c_language, "// /* */"), (java_language, "// /* */"),
		(fortran_language, "C"), (fortran90_language, "!"),
		(html_language, "&lt;!-- --&gt;"), (pascal_language, "// { }"),
		(perl_language, "#"), (perlpod_language, "# =pod =cut"),
		(shell_language, "#"), (python_language, "#") ]:
		if lang == language:
			return set_delims_from_string(val)

	return None, None, None # Indicate that no change should be made</t>
<t tx="T1550">@ Returns (delim1, delim2, delim2), the delims following the @comment directive.

This code can be called from @languge logic, in which case s can point at @comment
@c

def set_delims_from_string(s):

	# Skip an optional @comment
	tag = "@comment"
	i = 0
	if match_word(s,i,tag):
		i += len(tag)
		
	count = 0 ; delims = [None, None, None]
	while count &lt; 3 and i &lt; len(s):
		i = j = skip_ws(s,i)
		while i &lt; len(s) and not is_ws(s[i]) and not is_nl(s,i):
			i += 1
		if j == i: break
		delims[count] = s[j:i]
		count += 1
		
	# Restore defaults if nothing specified
	if not delims[0]:
		delims[0], delims[1], delims[2] = "//", "/*", "*/"
	return delims[0], delims[1], delims[2]</t>
<t tx="T1551">@  Scans the @language directive that appears at s[i]. 'default' returns default_language.

Returns (language, delim1, delim2, delim3)
@c

def set_language(s,i,issue_errors_flag,default_language):

	tag = "@language"
	assert(i != None)
	assert(match_word(s,i,tag))
	i += len(tag) ; i = skip_ws(s, i)
	# Get the argument.
	j = i
	i = skip_c_id(s,i)
	arg = string.lower(s[j:i])
	if len(arg) &gt; 0:
		for name, language in [ ("ada", ada_language),
			("c", c_language), ("c++", c_language),
			("cweb", cweb_language), ("default", default_language),
			("fortran", fortran_language), ("fortran90", fortran90_language),
			("html", html_language), ("java", java_language),
			("lisp", lisp_language), ("objective-c", c_language),
			("pascal", pascal_language), ("perl", perl_language),
			("perlpod", perlpod_language), ("python", python_language),
			("shell", shell_language) ]:
		
			if arg == name:
				delim1, delim2, delim3 = set_delims_from_language(language)
				return language, delim1, delim2, delim3

	if issue_errors_flag:
		j = skip_to_end_of_line(s,i)
		es("ignoring: " + s[special_i:j])

	return None, None, None, None,</t>
</tnodes>
</leo_file>
